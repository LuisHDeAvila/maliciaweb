{
	"docs_id": "1",
	"name": "Una introducción a JavaScript",
	"description": "Veamos qué tiene de especial JavaScript, qué podemos lograr con este lenguaje y qué otras tecnologías se integran bien con él.",
	"content": "Veamos qué tiene de especial JavaScript, qué podemos lograr con este lenguaje y qué otras tecnologías se integran bien con él.
¿Qué es JavaScript?JavaScript fue creado para “dar vida a las páginas web”.
Los programas en este lenguaje se llaman scripts. Se pueden escribir directamente en el HTML de una página web y ejecutarse automáticamente a medida que se carga la página.
Los scripts se proporcionan y ejecutan como texto plano. No necesitan preparación especial o compilación para correr.
En este aspecto, JavaScript es muy diferente a otro lenguaje llamado Java.

            ¿Por qué se llama JavaScript?
            Cuando JavaScript fue creado, inicialmente tenía otro nombre: “LiveScript”. Pero Java era muy popular en ese momento, así que se decidió que el posicionamiento de un nuevo lenguaje como un “Hermano menor” de Java ayudaría.
Pero a medida que evolucionaba, JavaScript se convirtió en un lenguaje completamente independiente con su propia especificación llamada ECMAScript, y ahora no tiene ninguna relación con Java.

Hoy, JavaScript puede ejecutarse no solo en los navegadores, sino también en servidores o incluso en cualquier dispositivo que cuente con un programa especial llamado El motor o intérprete de JavaScript.
El navegador tiene un motor embebido a veces llamado una “Máquina virtual de JavaScript”.
Diferentes motores tienen diferentes “nombres en clave”. Por ejemplo:

V8 – en Chrome, Opera y Edge.
SpiderMonkey – en Firefox.
…Existen otros nombres en clave como “Chakra” para IE , “JavaScriptCore”, “Nitro” y “SquirrelFish” para Safari, etc.

Es bueno recordar estos términos porque son usados en artículos para desarrolladores en internet. También los usaremos. Por ejemplo, si “la característica X es soportada por V8”, entonces probablemente funciona en Chrome, Opera y Edge.

            ¿Como trabajan los motores?
            Los motores son complicados, pero los fundamentos son fáciles.

El motor (embebido si es un navegador) lee (“analiza”) el script.
Entonces convierte (“compila”) el script a lenguaje máquina.
y por último el código maquina se ejecuta muy rápido.

El motor aplica optimizaciones en cada paso del proceso. Incluso observa como el script compilado se ejecuta, analiza los datos que fluyen a través de él y aplica optimizaciones al código maquina basadas en ese conocimiento.

¿Qué puede hacer JavaScript en el navegador?JavaScript moderno es un lenguaje de programación “seguro”. No proporciona acceso de bajo nivel a la memoria o la CPU (UCP), ya que se creó inicialmente para los navegadores los cuales no lo requieren.
Las capacidades de JavaScript dependen en gran medida en el entorno en que se ejecuta. Por ejemplo, Node.JS soporta funciones que permiten a JavaScript leer y escribir archivos arbitrariamente, realizar solicitudes de red, etc.
En el navegador JavaScript puede realizar cualquier cosa relacionada con la manipulación de una página web, interacción con el usuario y el servidor web.
Por ejemplo, en el navegador JavaScript es capaz de:

Agregar nuevo HTML a la página, cambiar el contenido existente y modificar estilos.
Reaccionar a las acciones del usuario, ejecutarse con los clics del ratón, movimientos del puntero y al oprimir teclas.
Enviar solicitudes de red a servidores remotos, descargar y cargar archivos (Tecnologías llamadas AJAX y COMET).
Obtener y configurar cookies, hacer preguntas al visitante y mostrar mensajes.
Recordar datos en el lado del cliente con el almacenamiento local (“local storage”).

¿Qué NO PUEDE hacer JavaScript en el navegador?Las capacidades de JavaScript en el navegador están limitadas por el bien de la seguridad de usuario. El objetivo es prevenir que una página maliciosa acceda a información privada o dañe los datos de usuario.
Ejemplos de tales restricciones incluyen:


JavaScript en el navegador no puede leer y escribir arbitrariamente archivos en el disco duro, copiarlos o ejecutar programas. No tiene acceso directo a funciones del Sistema operativo (OS).
Los navegadores más modernos le permiten trabajar con archivos, pero el acceso es limitado y solo permitido si el usuario realiza ciertas acciones, como “arrastrar” un archivo a la ventana del navegador o seleccionarlo por medio de una etiqueta <input>.
Existen maneras de interactuar con la cámara, micrófono y otros dispositivos, pero eso requiere el permiso explícito del usuario. Por lo tanto, una página habilitada para JavaScript no puede habilitar una cámara web para observar el entorno y enviar la información a la NSA.


Diferentes pestañas y ventanas generalmente no se conocen entre sí. A veces sí lo hacen, por ejemplo, cuando una ventana usa JavaScript para abrir otra. Pero incluso en este caso, JavaScript no puede acceder a la otra si provienen de diferentes sitios (de diferente dominio, protocolo o puerto).
Esta restricción es conocida como “política del mismo origen” (“Same Origin Policy”). Es posible la comunicación, pero ambas páginas deben acordar el intercambio de datos y contener el código especial de JavaScript que permite controlarlo. Cubriremos esto en el tutorial.
Esta limitación es, de nuevo, para la seguridad del usuario. Una página de http://anysite.com la cual el usuario ha abierto no debe ser capaz de acceder a otra pestaña del navegador con la URL http://gmail.com y robar información de esta otra página.


JavaScript puede fácilmente comunicarse a través de la red con el servidor de donde la página actual proviene. Pero su capacidad para recibir información de otros sitios y dominios esta bloqueada. Aunque sea posible, esto requiere un acuerdo explícito (expresado en los encabezados HTTP) desde el sitio remoto. Una vez más, esto es una limitación de seguridad.



      
      
        
      
      Tales limitaciones no existen si JavaScript es usado fuera del navegador, por ejemplo, en un servidor. Los navegadores modernos también permiten complementos y extensiones que pueden solicitar permisos extendidos.
¿Qué hace a JavaScript único?Existen al menos tres cosas geniales sobre JavaScript:
Completa integración con HTML y CSS.
Las cosas simples se hacen de manera simple.
Soportado por la mayoría de los navegadores y habilitado de forma predeterminada.
JavaScript es la única tecnología de los navegadores que combina estas tres cosas.
Eso es lo que hace a JavaScript único. Por esto es la herramienta mas extendida para crear interfaces de navegador.
Dicho esto, JavaScript también permite crear servidores, aplicaciones móviles, etc.
Lenguajes “por arriba de” JavaScriptLa sintaxis de JavaScript no se adapta a las necesidades de todos. Personas diferentes querrán diferentes características.
Esto es algo obvio, porque los proyectos y requerimientos son diferentes para cada persona.
Así que recientemente ha aparecido una gran cantidad de nuevos lenguajes, los cuales son Convertidos/Transpilados a JavaScript antes de ser ejecutados en el navegador.
Las herramientas modernas hacen la conversión (Transpilación) muy rápida y transparente, permitiendo a los desarrolladores codificar en otros lenguajes y convertirlo automáticamente detrás de escena.
Ejemplos de tales lenguajes:

CoffeeScript Es una “sintaxis azucarada” para JavaScript. Introduce una sintaxis corta, permitiéndonos escribir un código mas claro y preciso. Usualmente desarrolladores de Ruby prefieren este lenguaje.
TypeScript se concentra en agregar “tipado estricto” (“strict data typing”) para simplificar el desarrollo y soporte de sistemas complejos. Es desarrollado por Microsoft.
FLow también agrega la escritura de datos, pero de una manera diferente. Desarrollado por Facebook.
Dart es un lenguaje independiente, tiene su propio motor que se ejecuta en entornos que no son de navegador (como aplicaciones móviles), pero que también se puede convertir/transpilar a JavaScript. Desarrollado por Google.
Brython es un transpilador de Python a JavaScript que permite escribir aplicaciones en Python puro sin JavaScript.
Kotlin es un lenguaje moderno, seguro y conciso que puede apuntar al navegador o a Node.

Hay más. Por supuesto, incluso si nosotros usamos alguno de estos lenguajes, deberíamos conocer también JavaScript para realmente entender qué estamos haciendo.
Resumen
JavaScript fue inicialmente creado como un lenguaje solamente para el navegador, pero ahora es usado también en muchos otros entornos.
Hoy en día, JavaScript tiene una posición única como el lenguaje más extendido y adoptado de navegador, con una integración completa con HTML y CSS.
Existen muchos lenguajes que se convierten o transpilan a JavaScript y aportan ciertas características. Es recomendable echarles un vistazo, al menos brevemente, después de dominar JavaScript.

",
	"url": "https://es.javascript.info/intro" 
},
{
	"docs_id": "2",
	"name": "Manuales y especificaciones",
	"description": "Este libro es un tutorial. Su objetivo es ayudarte a aprender el lenguaje gradualmente. Pero una vez que te familiarices con lo básico, necesitarás otras fuentes.",
	"content": "Este libro es un tutorial. Su objetivo es ayudarte a aprender el lenguaje gradualmente. Pero una vez que te familiarices con lo básico, necesitarás otras fuentes.
EspecificaciónLa especificación ECMA-262 contiene la información más exhaustiva, detallada, y formal sobre JavaScript. En ella se define el lenguaje.
Pero por su estilo formal, es difícil de entender a primeras. Así que si necesitas la fuente de información más fiable sobre los detalles del lenguaje, esta especificación es el lugar correcto a consultar. Es de entender entonces que no es para el uso diario.
Una nueva versión de la especificación del lenguaje es publicada anualmente. Entre publicaciones, el último borrador de la especificación se puede consultar en https://tc39.es/ecma262/.
Para leer acerca de las nuevas prestaciones de vanguardia del lenguaje, incluyendo aquellas que son “cuasi-estándar” (apodado “stage 3”), encuentra las propuestas en https://github.com/tc39/proposals.
Si estás desarrollando para navegadores web, se mencionan otras especificaciones en la segunda parte del tutorial.
Manuales

MDN (Mozilla) JavaScript Reference es el manual principal, con ejemplos y otras informaciones. Es fantástico para obtener información exhaustiva sobre funciones individuales del lenguaje, métodos, etc.
Se puede acceder en https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference.


Aunque a menudo es preferible una búsqueda en internet. Simplemente añade “MDN [término]” en la consulta, por ejemplo https://google.com/search?q=MDN+parseInt para buscar la función parseInt.
Tablas de compatibilidadJavaScript es un lenguaje en evolución, nuevas características son adicionadas regularmente.
Para ver la compatibilidad por navegador y otros motores, consultar:

https://caniuse.com – tablas de compatibilidad por característica, p.ej. para comprobar qué motores soportan funciones modernas de criptografía: https://caniuse.com/#feat=cryptography.
https://kangax.github.io/compat-table – tabla que muestra la compatibilidad o no de las prestaciones del lenguaje por motor.

Todos estos recursos son de utilidad para el desarrollo con JavaScript, ya que incluyen información valiosa sobre los detalles del lenguaje, su compatibilidad, etc.
Por favor, tenlos en cuenta (o esta página) para cuando necesites información exhaustiva sobre una característica determinada.
",
	"url": "https://es.javascript.info/manuals-specifications" 
},
{
	"docs_id": "3",
	"name": "Editores de Código",
	"description": "Un editor de código es el lugar donde los programadores pasan la mayor parte de su tiempo.",
	"content": "Un editor de código es el lugar donde los programadores pasan la mayor parte de su tiempo.
Hay dos principales tipos de editores de código: IDEs y editores livianos. Muchas personas usan una herramienta de cada tipo.
IDEEl término IDE (siglas en inglés para Integrated Development Environment, Ambiente Integrado de Desarrollo) se refiere a un poderoso editor con varias características que operan usualmente sobre un “proyecto completo”. Como el nombre sugiere, no sólo es un editor, sino un completo “ambiente de desarrollo”.
Un IDE carga el proyecto (el cual puede ser de varios archivos), permite navegar entre archivos, provee autocompletado basado en el proyecto completo (no sólo el archivo abierto), e integra un sistema de control de versiones (como git), un ambiente de pruebas, entre otras cosas a “nivel de proyecto”.
Si aún no has seleccionado un IDE, considera las siguientes opciones:

Visual Studio Code (Multiplataforma, gratuito).
WebStorm (Multiplataforma, de pago).

Para Windows, también está “Visual Studio”, no lo confundamos con “Visual Studio Code”. “Visual Studio” es un poderoso editor pagado sólo para Windows, idóneo para la plataforma .NET. Una versión gratuita es de este editor se llama Visual Studio Community.
Muchos IDEs son de paga, pero tienen un periodo de prueba. Su costo usualmente es pequeño si lo comparamos al salario de un desarrollador calificado, así que sólo escoge el mejor para ti.
Editores livianos“Editores livianos” no son tan poderosos como los IDEs, pero son rápidos, elegantes y simples.
Son usados principalmente para abrir y editar un archivo al instante.
La diferencia principal entre un “editor liviano” y un “IDE” es que un IDE trabaja a nivel de proyecto, por lo que carga mucha más información desde el inicio, analiza la estructura del proyecto si así lo requiere y continua. Un editor liviano es mucho más rápido si solo necesitamos un archivo.
En la práctica, los editores livianos pueden tener montones de plugins incluyendo analizadores de sintaxis a nivel de directorio y autocompletado, por lo que no hay un límite estricto entre un editor liviano y un IDE.
Las siguientes opciones merecen tu atención:

Atom (multiplataforma, gratuito).
Sublime Text (multiplataforma, shareware).
Notepad++ (Windows, gratuito).
Vim y Emacs son geniales también si sabes como usarlos.

No discutamosLos editores en las listas anteriores son aquellos que yo o mis amigos a quienes considero buenos programadores hemos estado usando por un largo tiempo y con los que somos felices.
Existen otros grandes editores en este gran mundo. Por favor escoge el que más te guste.
La elección de un editor, como cualquier otra herramienta, es individual y depende de tus proyectos, hábitos y preferencias personales.
",
	"url": "https://es.javascript.info/code-editors" 
},
{
	"docs_id": "4",
	"name": "Consola de desarrollador",
	"description": "El código es propenso a errores. Es muy probable que cometas errores … Oh, ¿de qué estoy hablando? Definitivamente vas a cometer errores, al menos si eres un humano, no un robot.",
	"content": "El código es propenso a errores. Es muy probable que cometas errores … Oh, ¿de qué estoy hablando? Definitivamente vas a cometer errores, al menos si eres un humano, no un robot.
Pero el navegador, de forma predeterminada, no muestra los errores al usuario. Entonces si algo sale mal en el script, no veremos lo que está roto y no podemos arreglarlo.
Para ver los errores y obtener mucha otra información útil sobre los scripts, se han incorporado “herramientas de desarrollo” en los navegadores.
La mayoría de los desarrolladores se inclinan por Chrome o Firefox para el desarrollo porque esos navegadores tienen las mejores herramientas para desarrolladores. Otros navegadores también proporcionan herramientas de desarrollo, a veces con características especiales, pero generalmente están jugando a ponerse al día con Chrome o Firefox. Por lo tanto, la mayoría de los desarrolladores tienen un navegador “favorito” y cambian a otros si un problema es específico del navegador.
Las herramientas de desarrollo son potentes; Tienen muchas características. Para comenzar, aprenderemos cómo abrirlas, observar errores y ejecutar comandos JavaScript.
Google ChromeAbre la página bug.html.
Hay un error en el código JavaScript dentro de la página. Está oculto a los ojos de un visitante regular, así que abramos las herramientas de desarrollador para verlo.
Presione F12 o, si está en Mac, entonces combine Cmd+Opt+J.
Las herramientas de desarrollador se abrirán en la pestaña Consola de forma predeterminada.
Se ve algo así:

      
      
      El aspecto exacto de las herramientas de desarrollador depende de su versión de Chrome. Cambia de vez en cuando, pero debería ser similar.

Aquí podemos ver el mensaje de error de color rojo. En este caso, el script contiene un comando desconocido “lalala”.
A la derecha, hay un enlace en el que se puede hacer clic en la fuente bug.html:12 con el número de línea donde se produjo el error.

Debajo del mensaje de error, hay un símbolo azul >. Marca una “línea de comando” donde podemos escribir comandos JavaScript. Presione Enter para ejecutarlos.
Ahora podemos ver errores, y eso es suficiente para empezar. Volveremos a las herramientas de desarrollador más adelante y cubriremos la depuración más en profundidad en el capítulo Debugging en el navegador.

            Entrada multilínea
            Por lo general, cuando colocamos una línea de código en la consola y luego presionamos Enter, se ejecuta.
Para insertar varias líneas, presione Shift+Enter. De esta forma se pueden ingresar fragmentos largos de código JavaScript.

Firefox, Edge, y otrosLa mayoría de los otros navegadores usan F12 para abrir herramientas de desarrollador.
La apariencia de ellos es bastante similar. Una vez que sepa cómo usar una de estas herramientas (puede comenzar con Chrome), puede cambiar fácilmente a otra.
SafariSafari (navegador Mac, no compatible con Windows/Linux) es un poco especial aquí. Necesitamos habilitar primero el “Menú de desarrollo”.
Abra Preferencias y vaya al panel “Avanzado”. Hay una casilla de verificación en la parte inferior:

      
      
      Ahora combine Cmd+Opt+C para alternar a consola. Además, tenga en cuenta que ha aparecido el nuevo elemento del menú superior denominado “Desarrollar”. Tiene muchos comandos y opciones.
Resumen
Las herramientas para desarrolladores nos permiten ver errores, ejecutar comandos, examinar variables y mucho más.
Se pueden abrir con F12 para la mayoría de los navegadores en Windows. Chrome para Mac necesita la combinación Cmd+Opt+J, Safari: Cmd+Opt+C (primero debe habilitarse).

Ahora tenemos el entorno listo. En la siguiente sección nos enfocaremos en JavaScript.
",
	"url": "https://es.javascript.info/devtools" 
},
{
	"docs_id": "5",
	"name": "¡Hola, mundo!",
	"description": "Esta parte del tutorial trata sobre el núcleo de JavaScript, el lenguaje en sí.",
	"content": "Esta parte del tutorial trata sobre el núcleo de JavaScript, el lenguaje en sí.
Pero necesitamos un entorno de trabajo para ejecutar nuestros scripts y, dado que este libro está en línea, el navegador es una buena opción. Mantendremos la cantidad de comandos específicos del navegador (como alert) al mínimo para que no pases tiempo en ellos si planeas concentrarte en otro entorno (como Node.js). Nos centraremos en JavaScript en el navegador en la siguiente parte del tutorial.
Primero, veamos cómo adjuntamos un script a una página web. Para entornos del lado del servidor (como Node.js), puedes ejecutar el script con un comando como "node my.js".
La etiqueta “script”Los programas de JavaScript se pueden insertar en casi cualquier parte de un documento HTML con el uso de la etiqueta <script>.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <!DOCTYPE HTML>
<html>

<body>

  <p>Antes del script...</p>

  <script>
    alert( '¡Hola, mundo!' );
  </script>

  <p>...Después del script.</p>

</body>

</html>
        
      
      
      Puedes ejecutar el ejemplo haciendo clic en el botón “Play” en la esquina superior derecha del cuadro de arriba.
La etiqueta <script> contiene código JavaScript que se ejecuta automáticamente cuando el navegador procesa la etiqueta.
Marcado modernoLa etiqueta <script> tiene algunos atributos que rara vez se usan en la actualidad, pero aún se pueden encontrar en código antiguo:

El atributo type: <script type=…>

El antiguo estándar HTML, HTML4, requería que un script tuviera un type. Por lo general, era type="text/javascript". Ya no es necesario. Además, el estándar HTML moderno cambió totalmente el significado de este atributo. Ahora, se puede utilizar para módulos de JavaScript. Pero eso es un tema avanzado, hablaremos sobre módulos en otra parte del tutorial.

El atributo language: <script language=…>

Este atributo estaba destinado a mostrar el lenguaje del script. Este atributo ya no tiene sentido porque JavaScript es el lenguaje predeterminado. No hay necesidad de usarlo.

Comentarios antes y después de los scripts.

En libros y guías muy antiguos, puedes encontrar comentarios dentro de las etiquetas <script>, como el siguiente:

      
        
        
          <script type="text/javascript"><!--
    ...
//--></script>
        
      
      
      

Este truco no se utiliza en JavaScript moderno. Estos comentarios ocultaban el código JavaScript de los navegadores antiguos que no sabían cómo procesar la etiqueta <script>. Dado que los navegadores lanzados en los últimos 15 años no tienen este problema, este tipo de comentario puede ayudarte a identificar códigos realmente antiguos.
Scripts externosSi tenemos un montón de código JavaScript, podemos ponerlo en un archivo separado.
Los archivos de script se adjuntan a HTML con el atributo src:

      
        
        
          <script src="/path/to/script.js"></script>
        
      
      
      Aquí, /path/to/script.js es una ruta absoluta al archivo de script desde la raíz del sitio. También se puede proporcionar una ruta relativa desde la página actual. Por ejemplo, src="script.js" significaría un archivo "script.js" en la carpeta actual.
También podemos dar una URL completa. Por ejemplo:

      
        
        
          <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js"></script>
        
      
      
      Para adjuntar varios scripts, usa varias etiquetas:

      
        
        
          <script src="/js/script1.js"></script>
<script src="/js/script2.js"></script>
…
        
      
      
      
            Por favor tome nota:
            Como regla general, solo los scripts más simples se colocan en el HTML. Los más complejos residen en archivos separados.
La ventaja de un archivo separado es que el navegador lo descargará y lo almacenará en caché.
Otras páginas que hacen referencia al mismo script lo tomarán del caché en lugar de descargarlo, por lo que el archivo solo se descarga una vez.
Eso reduce el tráfico y hace que las páginas sean más rápidas.


            Si se establece src, el contenido del script se ignora.
            Una sola etiqueta <script> no puede tener el atributo src y código dentro.
Esto no funcionará:

      
        
        
          <script src="file.js">
  alert(1); // el contenido se ignora porque se estableció src
</script>
        
      
      
      Debemos elegir un <script src="…"> externo o un <script> normal con código.
El ejemplo anterior se puede dividir en dos scripts para que funcione:

      
        
        
          <script src="file.js"></script>
<script>
  alert(1);
</script>
        
      
      
      
Resumen
Podemos usar una etiqueta <script> para agregar código JavaScript a una página.
Los atributos type y language no son necesarios.
Un script en un archivo externo se puede insertar con <script src="path/to/script.js"> </script>.

Hay mucho más que aprender sobre los scripts del navegador y su interacción con la página web. Pero tengamos en cuenta que esta parte del tutorial está dedicada al lenguaje JavaScript, por lo que no debemos distraernos con implementaciones específicas del navegador. Usaremos el navegador como una forma de ejecutar JavaScript, lo cual es muy conveniente para la lectura en línea, pero es solo una de muchas.
TareasMostrar una alertaimportancia: 5Crea una página que muestre el mensaje “¡Soy JavaScript!”.
Hazlo en un sandbox o en tu disco duro, no importa, solo asegúrate de que funcione.
Demo en nueva ventanasolución
      
        
        
          <!DOCTYPE html>
<html>

<body>

  <script>
    alert( "¡Soy JavaScript!" );
  </script>

</body>

</html>
        
      
      
      Abrir la solución en un entorno controlado.Mostrar una alerta con un script externoimportancia: 5Toma la solución de la tarea anterior Mostrar una alerta. Modificarla extrayendo el contenido del script a un archivo externo alert.js, ubicado en la misma carpeta.
Abrir la página, asegurarse que la alerta funcione.
soluciónEl código HTML:

      
        
        
          <!DOCTYPE html>
<html>

<body>

  <script src="alert.js"></script>

</body>

</html>
        
      
      
      Para el archivo alert.js en la misma carpeta:

      
        
        
          alert("¡Soy JavaScript!");
        
      
      
      ",
	"url": "https://es.javascript.info/hello-world" 
},
{
	"docs_id": "6",
	"name": "Estructura del código",
	"description": "Lo primero que estudiaremos son los bloques de construcción del código.",
	"content": "Lo primero que estudiaremos son los bloques de construcción del código.
SentenciasLas sentencias son construcciones sintácticas y comandos que realizan acciones.
Ya hemos visto una sentencia, alert('¡Hola mundo!'), que muestra el mensaje “¡Hola mundo!”.
Podemos tener tantas sentencias en nuestro código como queramos, las cuales se pueden separar con un punto y coma.
Por ejemplo, aquí separamos “Hello World” en dos alerts:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hola'); alert('Mundo');
        
      
      
      Generalmente, las sentencias se escriben en líneas separadas para hacer que el código sea más legible:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hola');
alert('Mundo');
        
      
      
      Punto y comaSe puede omitir un punto y coma en la mayoría de los casos cuando existe un salto de línea.
Esto también funcionaría:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hola')
alert('Mundo')
        
      
      
      Aquí, JavaScript interpreta el salto de línea como un punto y coma “implícito”. Esto se denomina inserción automática de punto y coma.
En la mayoría de los casos, una nueva línea implica un punto y coma. Pero “en la mayoría de los casos” no significa “siempre”!
Hay casos en que una nueva línea no significa un punto y coma. Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert(3 +
1
+ 2);
        
      
      
      El código da como resultado 6 porque JavaScript no inserta punto y coma aquí. Es intuitivamente obvio que si la línea termina con un signo más "+", es una “expresión incompleta”, un punto y coma aquí sería incorrecto. Y en este caso eso funciona según lo previsto.
Pero hay situaciones en las que JavaScript “falla” al asumir un punto y coma donde realmente se necesita.
Los errores que ocurren en tales casos son bastante difíciles de encontrar y corregir.

            Un ejemplo de error
            Si tienes curiosidad por ver un ejemplo concreto de tal error, mira este código:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello");

[1, 2].forEach(alert);
        
      
      
      No es necesario pensar en el significado de los corchetes [] y forEach todavía, los estudiaremos más adelante. Por ahora, solo recuerda el resultado del código: muestra Hello, luego 1, luego 2.
Quitemos el punto y coma del alert:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello")

[1, 2].forEach(alert);
        
      
      
      La diferencia, comparando con el código anterior, es de solo un carácter: falta el punto y coma al final de la primera línea.
Esta vez, si ejecutamos el código, solo se ve el primer Hello (y un error pero necesitas abrir la consola para verlo). Los números no aparecen más.
Esto ocurre porque JavaScript no asume un punto y coma antes de los corchetes [...], entonces el código del primer ejemplo se trata como una sola sentencia.
Así es como lo ve el motor:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello")[1, 2].forEach(alert);
        
      
      
      Se ve extraño, ¿verdad? Tal unión en este caso es simplemente incorrecta. Necesitamos poner un punto y coma después del alert para que el código funcione bien.
Esto puede suceder en otras situaciones también.

Recomendamos colocar puntos y coma entre las sentencias, incluso si están separadas por saltos de línea. Esta regla está ampliamente adoptada por la comunidad. Notemos una vez más que es posible omitir los puntos y coma la mayoría del tiempo. Pero es más seguro, especialmente para un principiante, usarlos.
ComentariosA medida que pasa el tiempo, los programas se vuelven cada vez más complejos. Se hace necesario agregar comentarios que describan lo que hace el código y por qué.
Los comentarios se pueden poner en cualquier lugar de un script. No afectan su ejecución porque el motor simplemente los ignora.
Los comentarios de una línea comienzan con dos caracteres de barra diagonal //.
El resto de la línea es un comentario. Puede ocupar una línea completa propia o seguir una sentencia.
Como aquí:

      
        
        
          
            
          
          
            
          
        
        
          // Este comentario ocupa una línea propia.
alert('Hello');

alert('World'); // Este comentario sigue a la sentencia.
        
      
      
      Los comentarios de varias líneas comienzan con una barra inclinada y un asterisco /* y terminan con un asterisco y una barra inclinada */.
Como aquí:

      
        
        
          
            
          
          
            
          
        
        
          /* Un ejemplo con dos mensajes.
Este es un comentario multilínea.
*/
alert('Hola');
alert('Mundo');
        
      
      
      El contenido de los comentarios se ignora, por lo que si colocamos el código dentro de /* … */, no se ejecutará.
A veces puede ser útil deshabilitar temporalmente una parte del código:

      
        
        
          
            
          
          
            
          
        
        
          /* Comentando el código
alert('Hola');
*/
alert('Mundo');
        
      
      
      
            ¡Usa accesos rápidos del teclado!
            En la mayoría de los editores, se puede comentar una línea de código presionando Ctrl+/ para un comentario de una sola línea y algo como Ctrl+Shift+/ – para comentarios de varias líneas (selecciona una parte del código y pulsa la tecla de acceso rápido). Para Mac, intenta  Cmd en lugar de  Ctrl y Option en lugar de Shift.


            ¡Los comentarios anidados no son admitidos!
            No puede haber /*...*/ dentro de otro /*...*/.
Dicho código terminará con un error:

      
        
        
          
            
          
          
            
          
        
        
          /*
  /* comentario anidado ?!? */
*/
alert( 'Mundo' );
        
      
      
      
Por favor, no dudes en comentar tu código.
Los comentarios aumentan el tamaño general del código, pero eso no es un problema en absoluto. Hay muchas herramientas que minimizan el código antes de publicarlo en un servidor de producción. Eliminan los comentarios, por lo que no aparecen en los scripts de trabajo. Por lo tanto, los comentarios no tienen ningún efecto negativo en la producción.
Más adelante, en el tutorial, habrá un capítulo Estilo de codificación que también explica cómo escribir mejores comentarios.
",
	"url": "https://es.javascript.info/structure" 
},
{
	"docs_id": "7",
	"name": "El modo moderno, "use strict"",
	"description": "Durante mucho tiempo, JavaScript evolucionó sin problemas de compatibilidad. Se añadían nuevas características al lenguaje sin que la funcionalidad existente cambiase.",
	"content": "Durante mucho tiempo, JavaScript evolucionó sin problemas de compatibilidad. Se añadían nuevas características al lenguaje sin que la funcionalidad existente cambiase.
Esto tenía el beneficio de nunca romper código existente, pero lo malo era que cualquier error o decisión incorrecta tomada por los creadores de JavaScript se quedaba para siempre en el lenguaje.
Esto fue así hasta 2009, cuando ECMAScript 5 (ES5) apareció. Esta versión añadió nuevas características al lenguaje y modificó algunas de las ya existentes. Para mantener el código antiguo funcionando, la mayor parte de las modificaciones están desactivadas por defecto. Tienes que activarlas explícitamente usando una directiva especial: "use strict".
“use strict”La directiva se asemeja a un string: "use strict". Cuando se sitúa al principio de un script, el script entero funciona de la manera “moderna”.
Por ejemplo:

      
        
        
          "use strict";

// este código funciona de la manera moderna
...
        
      
      
      Aprenderemos funciones (una manera de agrupar comandos) en breve, pero adelantemos que "use strict" se puede poner al inicio de una función. De esta manera, se activa el modo estricto únicamente en esa función. Pero normalmente se utiliza para el script entero.

            Asegúrate de que “use strict” está al inicio
            Por favor, asegúrate de que "use strict" está al principio de tus scripts. Si no, el modo estricto podría no estar activado.
El modo estricto no está activado aquí:

      
        
        
          alert("algo de código");
// la directiva "use strict" de abajo es ignorada, tiene que estar al principio

"use strict";

// el modo estricto no está activado
        
      
      
      Únicamente pueden aparecer comentarios por encima de "use strict".


            No hay manera de cancelar use strict
            No hay ninguna directiva del tipo "no use strict" que haga al motor volver al comportamiento anterior.
Una vez entramos en modo estricto, no hay vuelta atrás.

Consola del navegadorCuando utilices la consola del navegador para ejecutar código, ten en cuenta que no utiliza use strict por defecto.
En ocasiones, donde use strict cause diferencia, obtendrás resultados incorrectos.
Entonces, ¿como utilizar use strict en la consola?
Primero puedes intentar pulsando Shift+Enter para ingresar múltiples líneas y poner use strict al principio, como aquí:

      
        
        
          'use strict'; <Shift+Enter para una nueva línea>
//  ...tu código
<Intro para ejecutar>
        
      
      
      Esto funciona para la mayoría de los navegadores, específicamente Firefox y Chrome.
Si esto no funciona, como en los viejos navegadores, hay una fea pero confiable manera de asegurar use strict. Ponlo dentro de esta especie de envoltura:

      
        
        
          (function() {
  'use strict';

  // ...tu código...
})()
        
      
      
      ¿Deberíamos utilizar “use strict”?La pregunta podría parecer obvia, pero no lo es.
Uno podría recomendar que se comiencen los script con "use strict"… ¿Pero sabes lo que es interesante?
El JavaScript moderno admite “clases” y “módulos”, estructuras de lenguaje avanzadas (que seguramente llegaremos a ver), que automáticamente habilitan use strict. Entonces no necesitamos agregar la directiva "use strict" si las usamos.
Entonces, por ahora "use strict"; es un invitado bienvenido al tope de tus scripts. Luego, cuando tu código sea todo clases y módulos, puedes omitirlo.
A partir de ahora tenemos que saber acerca de use strict en general.
En los siguientes capítulos, a medida que aprendamos características del lenguaje, veremos las diferencias entre el modo estricto y el antiguo. Afortunadamente no hay muchas y realmente hacen nuestra vida mejor.
Todos los ejemplos en este tutorial asumen modo estricto salvo que (muy raramente) se especifique lo contrario.
",
	"url": "https://es.javascript.info/strict-mode" 
},
{
	"docs_id": "8",
	"name": "Variables",
	"description": "La mayoría del tiempo, una aplicación de JavaScript necesita trabajar con información. Aquí hay 2 ejemplos:",
	"content": "La mayoría del tiempo, una aplicación de JavaScript necesita trabajar con información. Aquí hay 2 ejemplos:

Una tienda en línea – La información puede incluir los bienes a la venta y un “carrito de compras”.
Una aplicación de chat – La información puede incluir los usuarios, mensajes, y mucho más.

Utilizamos las variables para almacenar esta información.
Una variableUna variable es un “almacén con un nombre” para guardar datos. Podemos usar variables para almacenar golosinas, visitantes, y otros datos.
Para generar una variable en JavaScript, se usa la palabra clave let.
La siguiente declaración genera (en otras palabras: declara o define) una variable con el nombre “message”:

      
        
        
          let message;
        
      
      
      Ahora podemos introducir datos en ella al utilizar el operador de asignación =:

      
        
        
          let message;

message = 'Hola'; // almacenar la cadena 'Hola' en la variable llamada message
        
      
      
      La cadena ahora está almacenada en el área de la memoria asociada con la variable. La podemos acceder utilizando el nombre de la variable:

      
        
        
          
            
          
          
            
          
        
        
          let message;
message = 'Hola!';

alert(message); // muestra el contenido de la variable
        
      
      
      Para ser concisos, podemos combinar la declaración de la variable y su asignación en una sola línea:

      
        
        
          
            
          
          
            
          
        
        
          let message = 'Hola!'; // define la variable y asigna un valor

alert(message); // Hola!
        
      
      
      También podemos declarar variables múltiples en una sola línea:

      
        
        
          let user = 'John', age = 25, message = 'Hola';
        
      
      
      Esto puede parecer más corto, pero no lo recomendamos. Por el bien de la legibilidad, por favor utiliza una línea por variable.
La versión de líneas múltiples es un poco más larga, pero se lee más fácil:

      
        
        
          let user = 'John';
let age = 25;
let message = 'Hola';
        
      
      
      Algunas personas también definen variables múltiples en estilo multilínea:

      
        
        
          let user = 'John',
  age = 25,
  message = 'Hola';
        
      
      
      …Incluso en este estilo “coma primero”:

      
        
        
          let user = 'John'
  , age = 25
  , message = 'Hola';
        
      
      
      Técnicamente, todas estas variantes hacen lo mismo. Así que, es cuestión de gusto personal y preferencia estética.

            var en vez de let
            En scripts más viejos, a veces se encuentra otra palabra clave: var en lugar de let:

      
        
        
          var mensaje = 'Hola';
        
      
      
      La palabra clave var es casi lo mismo que let. También hace la declaración de una variable, aunque de un modo ligeramente distinto, y más antiguo.
Existen sutiles diferencias entre let y var, pero no nos interesan en este momento. Cubriremos el tema a detalle en el capítulo La vieja "var".

Una analogía de la vida realPodemos comprender fácilmente el concepto de una “variable” si nos la imaginamos como una “caja” con una etiqueta de nombre único pegada en ella.
Por ejemplo, podemos imaginar la variable message como una caja etiquetada "message" con el valor "Hola!" adentro:

      
      
        
      
      Podemos introducir cualquier valor a la caja.
También la podemos cambiar cuantas veces queramos:

      
        
        
          
            
          
          
            
          
        
        
          let message;

message = 'Hola!';

message = 'Mundo!'; // valor alterado

alert(message);
        
      
      
      Cuando el valor ha sido alterado, los datos antiguos serán removidos de la variable:

      
      
        
      
      También podemos declarar dos variables y copiar datos de una a la otra.

      
        
        
          
            
          
          
            
          
        
        
          let hello = 'Hola mundo!';

let message;

// copia 'Hola mundo' de hello a message
message = hello;

// Ahora, ambas variables contienen los mismos datos
alert(hello); // Hola mundo!
alert(message); // Hola mundo!
        
      
      
      
            Declarar dos veces lanza un error
            Una variable debe ser declarada solamente una vez.
Una declaración repetida de la misma variable es un error:

      
        
        
          
            
          
          
            
          
        
        
          let message = "This";

// 'let' repetidos lleva a un error
let message = "That"; // SyntaxError: 'message' ya fue declarado
        
      
      
      Debemos declarar una variable una sola vez y desde entonces referirnos a ella sin let.


            Lenguajes funcionales
            Es interesante notar el hecho que lenguajes de programación funcional, como Scala o Erlang prohíben cambiar el valor de variables.
En tales lenguajes, una vez la variable ha sido almacenada “en la caja”, permanece allí por siempre. Si necesitamos almacenar algo más, el lenguaje nos obliga a crear una nueva caja (generar una nueva variable). No podemos reusar la antigua.
Aunque puede parecer un poco extraño a primera vista, estos lenguajes son muy capaces de desarrollo serio. Más aún, existen áreas como computación en paralelo en las cuales esta limitación otorga ciertos beneficios. Estudiar tales lenguajes (incluso sin la intención de usarlo en el futuro cercano) es recomendable para ampliar la mente.

Nombramiento de variablesExisten dos limitaciones de nombre de variables en JavaScript:

El nombre únicamente puede incluir letras, dígitos, o los símbolos $ y _.
El primer carácter no puede ser un dígito.

Ejemplos de nombres válidos:

      
        
        
          let userName;
let test123;
        
      
      
      Cuando el nombre contiene varias palabras, comúnmente se utiliza camelCase. Es decir: palabras van una detrás de otra, con cada palabra iniciando con letra mayúscula: miNombreMuyLargo.
Es interesante notar que el símbolo del dólar '$' y el guion bajo '_' también se utilizan en nombres. Son símbolos comunes, tal como las letras, sin ningún significado especial.
Los siguientes nombres son válidos:

      
        
        
          
            
          
          
            
          
        
        
          let $ = 1; // Declara una variable con el nombre "$"
let _ = 2; // y ahora una variable con el nombre "_"

alert($ + _); // 3
        
      
      
      Ejemplos de nombres incorrectos:

      
        
        
          let 1a; // no puede iniciar con un dígito

let my-name; // los guiones '-' no son permitidos en nombres
        
      
      
      
            La Capitalización es Importante
            Dos variables con nombres manzana y MANZANA son variables distintas.


            Letras que no son del alfabeto inglés están permitidas, pero no se recomiendan
            Es posible utilizar letras de cualquier alfabeto, incluyendo el cirílico e incluso jeroglíficos, por ejemplo:

      
        
        
          let имя = '...';
let 我 = '...';
        
      
      
      Técnicamente, no existe ningún error aquí. Tales nombres están permitidos, pero existe una tradición internacional de utilizar inglés en el nombramiento de variables. Incluso si estamos escribiendo un script pequeño, este puede tener una larga vida por delante. Puede ser necesario que gente de otros países deba leerlo en algún momento.


            Nombres reservados
            Hay una lista de palabras reservadas, las cuales no pueden ser utilizadas como nombre de variable porque el lenguaje en sí las utiliza.
Por ejemplo: let, class, return, y function están reservadas.
El siguiente código nos da un error de sintaxis:

      
        
        
          
            
          
          
            
          
        
        
          let let = 5; // no se puede le nombrar "let" a una variable  ¡Error!
let return = 5; // tampoco se le puede nombrar "return", ¡Error!
        
      
      
      

            Una asignación sin utilizar use strict
            Normalmente, debemos definir una variable antes de utilizarla. Pero, en los viejos tiempos, era técnicamente posible crear una variable simplemente asignando un valor sin utilizar ‘let’. Esto aún funciona si no ponemos ‘use strict’ en nuestros scripts para mantener la compatibilidad con scripts antiguos.

      
        
        
          
            
          
          
            
          
        
        
          // nota: no se utiliza "use strict" en este ejemplo

num = 5; // se crea la variable "num" si no existe antes

alert(num); // 5
        
      
      
      Esto es una mala práctica que causaría errores en ‘strict mode’:

      
        
        
          "use strict";

num = 5; // error: num no está definida
        
      
      
      
ConstantesPara declarar una variable constante (inmutable) use const en vez de let:

      
        
        
          const myBirthday = '18.04.1982';
        
      
      
      Las variables declaradas utilizando const se llaman “constantes”. No pueden ser alteradas. Al intentarlo causaría un error:

      
        
        
          
            
          
          
            
          
        
        
          const myBirthday = '18.04.1982';

myBirthday = '01.01.2001'; // ¡error, no se puede reasignar la constante!
        
      
      
      Cuando un programador está seguro de que una variable nunca cambiará, puede declarar la variable con const para garantizar y comunicar claramente este hecho a todos.
Constantes mayúsculasExiste una práctica utilizada ampliamente de utilizar constantes como aliases de valores difíciles-de-recordar y que se conocen previo a la ejecución.
Tales constantes se nombran utilizando letras mayúsculas y guiones bajos.
Por ejemplo, creemos constantes para los colores en el formato “web” (hexadecimal):

      
        
        
          
            
          
          
            
          
        
        
          const COLOR_RED = "#F00";
const COLOR_GREEN = "#0F0";
const COLOR_BLUE = "#00F";
const COLOR_ORANGE = "#FF7F00";

// ...cuando debemos elegir un color
let color = COLOR_ORANGE;
alert(color); // #FF7F00
        
      
      
      Ventajas:

COLOR_ORANGE es mucho más fácil de recordar que "#FF7F00".
Es mucho más fácil escribir mal "#FF7F00" que COLOR_ORANGE.
Al leer el código, COLOR_ORANGE tiene mucho más significado que #FF7F00.

¿Cuándo se deben utilizar letras mayúsculas para una constante, y cuando se debe nombrarla de manera normal? Dejémoslo claro.
Ser una “constante” solo significa que el valor de la variable nunca cambia. Pero hay constantes que son conocidas previo a la ejecución (como el valor hexadecimal del color rojo) y hay constantes que son calculadas en el tiempo de ejecución, pero no cambian después de su asignación inicial.
Por ejemplo:

      
        
        
          const pageLoadTime = /* el tiempo que tardó la página web para cargar */;
        
      
      
      El valor de pageLoadTime no se conoce antes de cargar la página, así que la nombramos normalmente. No obstante, es una constante porque no cambia después de su asignación inicial.
En otras palabras, las constantes con nombres en mayúscula son utilizadas solamente como alias para valores invariables y preestablecidos (“hard-coded”).
Nombrar cosas correctamenteEstando en el tema de las variables, existe una cosa de mucha importancia.
Una variable debe tener un nombre claro, de significado evidente, que describa el dato que almacena.
Nombrar variables es una de las habilidades más importantes y complejas en la programación. Un vistazo rápido a el nombre de las variables nos revela cuál código fue escrito por un principiante o por un desarrollador experimentado.
En un proyecto real, la mayor parte de el tiempo se pasa modificando y extendiendo una base de código en vez de empezar a escribir algo desde cero. Cuando regresamos a algún código después de hacer algo distinto por un rato, es mucho más fácil encontrar información que está bien etiquetada. O, en otras palabras, cuando las variables tienen nombres adecuados.
Por favor pasa tiempo pensando en el nombre adecuado para una variable antes de declararla. Hacer esto te da un retorno muy sustancial.
Algunas reglas buenas para seguir:

Use términos legibles para humanos como userName p shoppingCart.
Evite abreviaciones o nombres cortos a, b, c, al menos que en serio sepa lo que está haciendo.
Cree nombres que describen al máximo lo que son y sean concisos. Ejemplos que no son adecuados son data y value. Estos nombres no nos dicen nada. Estos solo está bien usarlos en el contexto de un código que deje excepcionalmente obvio cuál valor o cuales datos está referenciando la variable.
Acuerda en tu propia mente y con tu equipo cuáles términos se utilizarán. Si a un visitante se le llamara “user”, debemos llamar las variables relacionadas currentUser o newUser en vez de currentVisitor o newManInTown.

¿Suena simple? De hecho lo es, pero no es tan fácil crear nombres de variables descriptivos y concisos a la hora de practicar. Inténtelo.

            ¿Reusar o crear?
            Una última nota. Existen programadores haraganes que, en vez de declarar una variable nueva, tienden a reusar las existentes.
El resultado de esto es que sus variables son como cajas en las cuales la gente introduce cosas distintas sin cambiar sus etiquetas. ¿Que existe dentro de la caja? ¿Quién sabe? Necesitamos acercarnos y revisar.
Dichos programadores se ahorran un poco durante la declaración de la variable, pero pierden diez veces más a la hora de depuración.
Una variable extra es algo bueno, no algo malvado.
Los minificadores de JavaScript moderno, y los navegadores optimizan el código suficientemente bien para no generar cuestiones de rendimiento. Utilizar diferentes variables para distintos valores incluso puede ayudar a optimizar su código

ResumenPodemos declarar variables para almacenar datos al utilizar las palabra clave var, let, o const.

let – es la forma moderna de declaración de una variable.
var – es la declaración de variable de vieja escuela. Normalmente no lo utilizamos en absoluto. Cubriremos sus sutiles diferencias con let en el capítulo La vieja "var", por si lo necesitaras.
const – es como let, pero el valor de la variable no puede ser alterado.

Las variables deben ser nombradas de tal manera que entendamos fácilmente lo que está en su interior.
TareasTrabajando con variables.importancia: 2
Declara dos  variables: admin y name.
Asigna el valor "John" a name.
Copia el valor de name a admin.
Muestra el valor de admin usando alert (debe salir “John”).

soluciónEn el siguiente código, cada línea corresponde al elemento en la lista de tareas.

      
        
        
          
            
          
          
            
          
        
        
          let admin, name; // Puedes declarar dos variables a la vez.

name = "John";

admin = name;

alert( admin ); // "John"
        
      
      
      Dando el nombre correctoimportancia: 3
Crea una variable con el nombre de nuestro planeta. ¿Cómo nombrarías a dicha variable?
Crea una variable para almacenar el nombre del usuario actual de un sitio web. ¿Cómo nombrarías a dicha variable?

soluciónLa variable para nuestro planeta.La variable para nuestro planeta.Eso es simple:

      
        
        
          let ourPlanetName = "Tierra";
        
      
      
      Nota, podríamos usar un nombre más corto planeta, pero podría no ser obvio a qué planeta se refiere. Es una buena idea ser más detallado, siempre y cuando la variable noSeaMuyLarga.
El nombre del usuario actualEl nombre del usuario actual
      
        
        
          let currentUserName = "Juan";
        
      
      
      Una vez más, podríamos acortar eso a userName si estamos seguros que es el usuario actual (current).
Los editores modernos y el autocompletado hacen que los nombres de variables largos sean fáciles de escribir. No ahorres caracteres. Un nombre de 3 palabras está bien.
Y si tu editor no tiene un autocompletado apropiado, consigue uno nuevo.
¿const mayúsculas?importancia: 4Examina el siguiente código:

      
        
        
          const birthday = '18.04.1982';

const age = someCode(birthday);
        
      
      
      Aquí tenemos una constante birthday y age es calculada desde birthday con la ayuda de cierto código (no está provisto para abreviar y porque los detalles no importan aquí).
¿Sería correcto usar mayúsculas para birthday? ¿Para age? ¿O incluso para ambos?

      
        
        
          const BIRTHDAY = '18.04.1982'; // make uppercase?

const AGE = someCode(BIRTHDAY); // make uppercase?
        
      
      
      soluciónGeneralmente usamos mayúsculas para constantes que están “hard-codeadas”. En otras palabras, cuando el valor se conoce antes de la ejecución y se escribe directamente en el código.
En este código, birthday es exactamente así, por lo que podemos escribirla en mayúsculas.
En cambio, age es evaluada en ejecución. Hoy tenemos una edad, un año después tendremos otra. Es constante en el sentido que no cambia durante la ejecución del código, pero es un poco “menos constante” que birthday ya que se calcula, por lo que debemos mantenerla en minúscula.
",
	"url": "https://es.javascript.info/variables" 
},
{
	"docs_id": "9",
	"name": "Tipos de datos",
	"description": "Un valor en JavaScript siempre pertenece a un tipo de dato determinado. Por ejemplo, un string o un número.",
	"content": "Un valor en JavaScript siempre pertenece a un tipo de dato determinado. Por ejemplo, un string o un número.
Hay ocho tipos de datos básicos en JavaScript. En este capítulo los cubriremos en general y en los próximos hablaremos de cada uno de ellos en detalle.
Podemos almacenar un valor de cualquier tipo dentro de una variable. Por ejemplo, una variable puede contener en un momento un string y luego almacenar un número:

      
        
        
          // no hay error
let message = "hola";
message = 123456;
        
      
      
      Los lenguajes de programación que permiten estas cosas, como JavaScript, se denominan “dinámicamente tipados”, lo que significa que allí hay tipos de datos, pero las variables no están vinculadas rígidamente a ninguno de ellos.
Number
      
        
        
          let n = 123;
n = 12.345;
        
      
      
      El tipo number representa tanto números enteros como de punto flotante.
Hay muchas operaciones para números. Por ejemplo, multiplicación *, división /, suma +, resta -, y demás.
Además de los números comunes, existen los llamados “valores numéricos especiales” que también pertenecen a este tipo de datos: Infinity, -Infinity y NaN.


Infinity representa el Infinito matemático ∞. Es un valor especial que es mayor que cualquier número.
Podemos obtenerlo como resultado de la división por cero:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 / 0 ); // Infinity
        
      
      
      O simplemente hacer referencia a él directamente:

      
        
        
          
            
          
          
            
          
        
        
          alert( Infinity ); // Infinity
        
      
      
      

NaN representa un error de cálculo. Es el resultado de una operación matemática incorrecta o indefinida, por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( "no es un número" / 2 ); // NaN, tal división es errónea
        
      
      
      NaN es “pegajoso”. Cualquier otra operación sobre NaN devuelve NaN:

      
        
        
          
            
          
          
            
          
        
        
          alert( NaN + 1 ); // NaN
alert( 3 * NaN ); // NaN
alert( "not a number" / 2 - 1 ); // NaN
        
      
      
      Por lo tanto, si hay un NaN en alguna parte de una expresión matemática, se propaga a todo el resultado (con una única excepción: NaN ** 0 es 1).



            Las operaciones matemáticas son seguras
            Hacer matemáticas es “seguro” en JavaScript. Podemos hacer cualquier cosa: dividir por cero, tratar las cadenas no numéricas como números, etc.
El script nunca se detendrá con un error fatal (“morir”). En el peor de los casos, obtendremos NaN como resultado.

Los valores numéricos especiales pertenecen formalmente al tipo “número”. Por supuesto que no son números en el sentido estricto de la palabra.
Veremos más sobre el trabajo con números en el capítulo Números.
BigIntEn JavaScript, el tipo “number” no puede representar valores enteros mayores que (253-1) (eso es 9007199254740991), o menor que -(253-1) para negativos. Es una limitación técnica causada por su representación interna.
Para la mayoría de los propósitos es suficiente, pero a veces necesitamos números realmente grandes. Por ejemplo, para criptografía o marcas de tiempo de precisión de microsegundos.
BigInt se agregó recientemente al lenguaje para representar enteros de longitud arbitraria.
Un valor BigInt se crea agregando n al final de un entero:

      
        
        
          // la "n" al final significa que es un BigInt
const bigInt = 1234567890123456789012345678901234567890n;
        
      
      
      Como los números BigInt rara vez se necesitan, no los cubrimos aquí sino que les dedicamos un capítulo separado <info: bigint>. Léelo cuando necesites números tan grandes.

            Problemas de compatibilidad
            En este momento, BigInt está soportado por Firefox/Chrome/Edge/Safari, pero no por IE.

Puedes revisar la tabla de compatibilidad de BigInt en MDN para saber qué versiones de navegador tienen soporte.
StringUn string en JavaScript es una cadena de caracteres y debe colocarse entre comillas.

      
        
        
          let str = "Hola";
let str2 = 'Las comillas simples también están bien';
let phrase = `se puede incrustar otro ${str}`;
        
      
      
      En JavaScript, hay 3 tipos de comillas.

Comillas dobles: "Hola".
Comillas simples: 'Hola'.
Backticks (comillas invertidas): `Hola`.

Las comillas dobles y simples son comillas “sencillas” (es decir, funcionan igual). No hay diferencia entre ellas en JavaScript.
Los backticks son comillas de “funcionalidad extendida”. Nos permiten incrustar variables y expresiones en una cadena de caracteres encerrándolas en ${...}, por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let name = "John";

// incrustar una variable
alert( `Hola, ${name}!` ); // Hola, John!

// incrustar una expresión
alert( `el resultado es ${1 + 2}` ); //el resultado es 3
        
      
      
      La expresión dentro de ${...} se evalúa y el resultado pasa a formar parte de la cadena. Podemos poner cualquier cosa ahí dentro: una variable como name, una expresión aritmética como 1 + 2, o algo más complejo.
Toma en cuenta que esto sólo se puede hacer con los backticks. ¡Las otras comillas no tienen esta capacidad de incrustación!

      
        
        
          
            
          
          
            
          
        
        
          alert( "el resultado es ${1 + 2}" ); // el resultado es ${1 + 2} (las comillas dobles no hacen nada)
        
      
      
      En el capítulo Strings trataremos más a fondo las cadenas.

            No existe el tipo carácter
            En algunos lenguajes, hay un tipo especial “carácter” para un solo carácter. Por ejemplo, en el lenguaje C y en Java es char.
En JavaScript no existe tal tipo. Sólo hay un tipo: string. Un string puede estar formado por un solo carácter, por ninguno, o por varios de ellos.

Boolean (tipo lógico)El tipo boolean tiene sólo dos valores posibles: true y false.
Este tipo se utiliza comúnmente para almacenar valores de sí/no: true significa “sí, correcto, verdadero”, y false significa “no, incorrecto, falso”.
Por ejemplo:

      
        
        
          let nameFieldChecked = true; // sí, el campo name está marcado
let ageFieldChecked = false; // no, el campo age no está marcado
        
      
      
      Los valores booleanos también son el resultado de comparaciones:

      
        
        
          
            
          
          
            
          
        
        
          let isGreater = 4 > 1;

alert( isGreater ); // verdadero (el resultado de la comparación es "sí")
        
      
      
      En el capítulo Operadores Lógicos trataremos más a fondo el tema de los booleanos.
El valor “null” (nulo)El valor especial null no pertenece a ninguno de los tipos descritos anteriormente.
Forma un tipo propio separado que contiene sólo el valor null:

      
        
        
          let age = null;
        
      
      
      En JavaScript, null no es una “referencia a un objeto inexistente” o un “puntero nulo” como en otros lenguajes.
Es sólo un valor especial que representa “nada”, “vacío” o “valor desconocido”.
El código anterior indica que el valor de age es desconocido o está vacío por alguna razón.
El valor “undefined” (indefinido)El valor especial undefined también se distingue. Hace un tipo propio, igual que null.
El significado de undefined es “valor no asignado”.
Si una variable es declarada, pero no asignada, entonces su valor es undefined:

      
        
        
          
            
          
          
            
          
        
        
          let age;

alert(age); // muestra "undefined"
        
      
      
      Técnicamente, es posible asignar undefined a cualquier variable:

      
        
        
          
            
          
          
            
          
        
        
          let age = 100;

// cambiando el valor a undefined
age = undefined;

alert(age); // "undefined"
        
      
      
      …Pero no recomendamos hacer eso. Normalmente, usamos null para asignar un valor “vacío” o “desconocido” a una variable, mientras undefined es un valor inicial reservado para cosas que no han sido asignadas.
Object y SymbolEl tipo object (objeto) es especial.
Todos los demás tipos se llaman “primitivos” porque sus valores pueden contener una sola cosa (ya sea una cadena,  un número o lo que sea). Por el contrario, los objetos se utilizan para almacenar colecciones de datos y entidades más complejas.
Siendo así de importantes, los objetos merecen un trato especial. Nos ocuparemos de ellos más adelante en el capítulo Objetos después de aprender más sobre los primitivos.
El tipo symbol (símbolo) se utiliza para crear identificadores únicos para los objetos. Tenemos que mencionarlo aquí para una mayor integridad, pero es mejor estudiar este tipo después de los objetos.
El operador typeofEl operador typeof devuelve el tipo del argumento. Es útil cuando queremos procesar valores de diferentes tipos de forma diferente o simplemente queremos hacer una comprobación rápida.
La llamada a typeof x devuelve una cadena con el nombre del tipo:

      
        
        
          typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
        
      
      
      Las últimas tres líneas pueden necesitar una explicación adicional:

Math es un objeto incorporado que proporciona operaciones matemáticas. Lo aprenderemos en el capítulo Números. Aquí sólo sirve como ejemplo de un objeto.
El resultado de typeof null es "object". Esto está oficialmente reconocido como un error de comportamiento de typeof que proviene de los primeros días de JavaScript y se mantiene por compatibilidad. Definitivamente null no es un objeto. Es un valor especial con un tipo propio separado.
El resultado de typeof alert es "function" porque alert es una función. Estudiaremos las funciones en los próximos capítulos donde veremos que no hay ningún tipo especial “function” en JavaScript. Las funciones pertenecen al tipo objeto. Pero typeof las trata de manera diferente, devolviendo function. Además proviene de los primeros días de JavaScript. Técnicamente dicho comportamiento es incorrecto, pero puede ser conveniente en la práctica.


            Sintaxis de typeof(x)
            Se puede encontrar otra sintaxis en algún código: typeof(x). Es lo mismo que typeof x.
Para ponerlo en claro: typeof es un operador, no una función. Los paréntesis aquí no son parte del operador typeof. Son del tipo usado en agrupamiento matemático.
Usualmente, tales paréntesis contienen expresiones matemáticas tales como (2 + 2), pero aquí solo tienen un argumento (x). Sintácticamente, permiten evitar el espacio entre el operador typeof y su argumento, y a algunas personas les gusta así.
Algunos prefieren typeof(x), aunque la sintaxis typeof x es mucho más común.

ResumenHay 8 tipos básicos en JavaScript.

Siete tipos de datos primitivos

number para números de cualquier tipo: enteros o de punto flotante, los enteros están limitados por ±(253-1).
bigint para números enteros de longitud arbitraria.
string para cadenas. Una cadena puede tener cero o más caracteres, no hay un tipo especial para un único carácter.
boolean para verdadero y falso: true/false.
null para valores desconocidos – un tipo independiente que tiene un solo valor nulo: null.
undefined para valores no asignados – un tipo independiente que tiene un único valor “indefinido”: undefined.
symbol para identificadores únicos.


Y un tipo de dato no primitivo:

object para estructuras de datos complejas.



El operador typeof nos permite ver qué tipo está almacenado en una variable.

Dos formas: typeof x o typeof(x).
Devuelve una cadena con el nombre del tipo. Por ejemplo "string".
Para null devuelve "object": esto es un error en el lenguaje, en realidad no es un objeto.

TareasComillasimportancia: 5¿Cuál es la salida del script?

      
        
        
          let name = "Ilya";

alert( `Hola ${1}` ); // ?

alert( `Hola ${"name"}` ); // ?

alert( `Hola ${name}` ); // ?
        
      
      
      soluciónLos backticks incrustan la expresión dentro de ${...} en la cadena.

      
        
        
          
            
          
          
            
          
        
        
          let name = "Ilya";

// la expresión es un número 1
alert( `hola ${1}` ); // hola 1

// la expresión es una cadena "nombre"
alert( `hola ${"name"}` ); // hola name

// la expresión es una variable, incrustada
alert( `hola ${name}` ); // hola Ilya
        
      
      
      ",
	"url": "https://es.javascript.info/types" 
},
{
	"docs_id": "10",
	"name": "Interacción: alert, prompt, confirm",
	"description": "Como usaremos el navegador como nuestro entorno de demostración, veamos un par de funciones para interactuar con el usuario: alert,prompt y confirm.",
	"content": "Como usaremos el navegador como nuestro entorno de demostración, veamos un par de funciones para interactuar con el usuario: alert,prompt y confirm.
alertEste ya lo hemos visto. Muestra un mensaje y espera a que el usuario presione “Aceptar”.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello");
        
      
      
      La mini ventana con el mensaje se llama * ventana modal *. La palabra “modal” significa que el visitante no puede interactuar con el resto de la página, presionar otros botones, etc., hasta que se haya ocupado de la ventana. En este caso, hasta que presionen “OK”.
promptLa función prompt acepta dos argumentos:

      
        
        
          result = prompt(title, [default]);
        
      
      
      Muestra una ventana modal con un mensaje de texto, un campo de entrada para el visitante y los botones OK/CANCELAR.

title
El texto a mostrar al usuario.
default
Un segundo parámetro opcional, el valor inicial del campo de entrada.


            Corchetes en la sintaxis [...]
            Los corchetes alrededor de default en la sintaxis de arriba denotan que el parámetro es opcional, no requerido.

El usuario puede escribir algo en el campo de entrada de solicitud y presionar OK. Así obtenemos ese texto en result. O puede cancelar la entrada presionando Cancelar o presionando la tecla Esc obteniendo null en result.
La llamada a prompt retorna el texto del campo de entrada o null si la entrada fue cancelada.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt ('¿Cuántos años tienes?', 100);

alert(`Tienes ${age} años!`); //Tienes 100 años!
        
      
      
      
            En IE: proporciónale un predeterminado siempre
            El segundo parámetro es opcional, pero si no lo proporcionamos, Internet Explorer insertará el texto "undefined" en el prompt.
Ejecuta este código en Internet Explorer para verlo:

      
        
        
          
            
          
          
            
          
        
        
          let test = prompt("Test");
        
      
      
      Por lo tanto, para que las indicaciones se vean bien en IE, recomendamos siempre proporcionar el segundo argumento:

      
        
        
          
            
          
          
            
          
        
        
          let test = prompt("Test", ''); // <-- para IE
        
      
      
      
confirmLa sintaxis:

      
        
        
          result = confirm(pregunta);
        
      
      
      La función confirm muestra una ventana modal con una pregunta y dos botones: OK y CANCELAR.
El resultado es true si se pulsa OK y false en caso contrario.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let isBoss = confirm("¿Eres el jefe?");

alert( isBoss ); // true si se pulsa OK
        
      
      
      ResumenCubrimos 3 funciones específicas del navegador para interactuar con los usuarios:

alert
muestra un mensaje.
prompt
muestra un mensaje pidiendo al usuario que introduzca un texto. Retorna el texto o, si se hace clic en CANCELAR o Esc, retorna null.
confirm
muestra un mensaje y espera a que el usuario pulse “OK” o “CANCELAR”. Retorna true si se presiona OK y false si se presiona CANCEL/Esc.

Todos estos métodos son modales: detienen la ejecución del script y no permiten que el usuario interactúe con el resto de la página hasta que la ventana se haya cerrado.
Hay dos limitaciones comunes a todos los métodos anteriores:

La ubicación exacta de la ventana modal está determinada por el navegador. Normalmente, está en el centro.
El aspecto exacto de la ventana también depende del navegador. No podemos modificarlo.

Ese es el precio de la simplicidad. Existen otras formas de mostrar ventanas más atractivas e interactivas para el usuario, pero si la “apariencia” no importa mucho, estos métodos funcionan bien.
TareasUna página simpleimportancia: 4Crea una página web que pida un nombre y lo muestre.
Ejecutar el demosoluciónCódigo JavaScript:

      
        
        
          
            
          
          
            
          
        
        
          let name = prompt("¿Cuál es tu nombre?", "");
alert(name);
        
      
      
      La página completa:

      
        
        
          <!DOCTYPE html>
<html>
<body>

  <script>
    'use strict';

    let name = prompt("¿Cuál es tu nombre?", "");
    alert(name);
  </script>

</body>
</html>
        
      
      
      ",
	"url": "https://es.javascript.info/alert-prompt-confirm" 
},
{
	"docs_id": "11",
	"name": "Conversiones de Tipos",
	"description": "La mayoría de las veces, los operadores y funciones convierten automáticamente los valores que se les pasan al tipo correcto. Esto es llamado “conversión de tipo”.",
	"content": "La mayoría de las veces, los operadores y funciones convierten automáticamente los valores que se les pasan al tipo correcto. Esto es llamado “conversión de tipo”.
Por ejemplo, alert convierte automáticamente cualquier valor a string para mostrarlo. Las operaciones matemáticas convierten los valores a números.
También hay casos donde necesitamos convertir de manera explícita un valor al tipo esperado.

            Aún no hablamos de objetos
            En este capítulo no hablamos de objetos. Por ahora, solamente veremos los valores primitivos.
Más adelante, después de haberlos tratado, veremos en el capítulo Conversión de objeto a valor primitivo cómo funciona la conversión de objetos.

ToStringLa conversión a string ocurre cuando necesitamos la representación en forma de texto de un valor.
Por ejemplo, alert(value) lo hace para mostrar el valor como texto.
También podemos llamar a la función String(value) para convertir un valor a string:

      
        
        
          
            
          
          
            
          
        
        
          let value = true;
alert(typeof value); // boolean

value = String(value); // ahora value es el string "true"
alert(typeof value); // string
        
      
      
      La conversión a string es bastante obvia. El boolean false se convierte en "false", null en "null", etc.
ToNumberLa conversión numérica ocurre automáticamente en funciones matemáticas y expresiones.
Por ejemplo, cuando se dividen valores no numéricos usando /:

      
        
        
          
            
          
          
            
          
        
        
          alert( "6" / "2" ); // 3, los strings son convertidos a números
        
      
      
      Podemos usar la función Number(value) para convertir de forma explícita un valor a un número:

      
        
        
          
            
          
          
            
          
        
        
          let str = "123";
alert(typeof str); // string

let num = Number(str); // se convierte en 123

alert(typeof num); // number
        
      
      
      La conversión explícita es requerida usualmente cuando leemos un valor desde una fuente basada en texto, como lo son los campos de texto en los formularios, pero que esperamos que contengan un valor numérico.
Si el string no es un número válido, el resultado de la conversión será NaN. Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let age = Number("un texto arbitrario en vez de un número");

alert(age); // NaN, conversión fallida
        
      
      
      Reglas de conversión numérica:



Valor
Se convierte en…




undefined
NaN


null
0


true and false
1 y 0


string
Se eliminan los espacios al inicio y final del texto. Si el string resultante es vacío, el resultado es 0, en caso contrario el número es “leído” del string. Un error devuelve NaN.



Ejemplos:

      
        
        
          
            
          
          
            
          
        
        
          alert( Number("   123   ") ); // 123
alert( Number("123z") );      // NaN (error al leer un número en "z")
alert( Number(true) );        // 1
alert( Number(false) );       // 0
        
      
      
      Ten en cuenta que null y undefined se comportan de distinta manera aquí: null se convierte en 0 mientras que undefined se convierte en NaN.

            Adición ‘+’ concatena strings
            Casi todas las operaciones matemáticas convierten valores a números. Una excepción notable es la suma +. Si uno de los valores sumados es un string, el otro valor es convertido a string.
Luego, los concatena (une):

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 + '2' ); // '12' (string a la derecha)
alert( '1' + 2 ); // '12' (string a la izquierda)
        
      
      
      Esto ocurre solo si al menos uno de los argumentos es un string, en caso contrario los valores son convertidos a número.

ToBooleanLa conversión a boolean es la más simple.
Ocurre en operaciones lógicas (más adelante veremos test condicionales y otras cosas similares), pero también puede realizarse de forma explícita llamando a la función Boolean(value).
Las reglas de conversión:

Los valores que son intuitivamente “vacíos”, como 0, "", null, undefined, y NaN, se convierten en false.
Otros valores se convierten en true.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean(1) ); // true
alert( Boolean(0) ); // false

alert( Boolean("hola") ); // true
alert( Boolean("") ); // false
        
      
      
      
            Ten en cuenta: el string con un cero "0" es true
            Algunos lenguajes (como PHP) tratan "0" como false. Pero en JavaScript, un string no vacío es siempre true.

      
        
        
          
            
          
          
            
          
        
        
          alert( Boolean("0") ); // true
alert( Boolean(" ") ); // sólo espacios, también true (cualquier string no vacío es true)
        
      
      
      
ResumenLas tres conversiones de tipo más usadas son a string, a número y a boolean.
ToString – Ocurre cuando se muestra algo. Se puede realizar con String(value). La conversión a string es usualmente obvia para los valores primitivos.
ToNumber – Ocurre en operaciones matemáticas. Se puede realizar con Number(value).
La conversión sigue las reglas:



Valor
Se convierte en…




undefined
NaN


null
0


true / false
1 / 0


string
El string es leído “como es”, los espacios en blanco tanto al inicio como al final son ignorados. Un string vacío se convierte en 0. Un error entrega NaN.



ToBoolean – Ocurren en operaciones lógicas. Se puede realizar con Boolean(value).
Sigue las reglas:



Valor
Se convierte en…




0, null, undefined, NaN, ""
false


cualquier otro valor
true



La mayoría de estas reglas son fáciles de entender y recordar. Las excepciones más notables donde la gente suele cometer errores son:

undefined es NaN como número, no 0.
"0" y textos que solo contienen espacios como " " son true como boolean.

Los objetos no son cubiertos aquí. Volveremos a ellos más tarde en el capítulo Conversión de objeto a valor primitivo que está dedicado exclusivamente a objetos después de que aprendamos más cosas básicas sobre JavaScript.
",
	"url": "https://es.javascript.info/type-conversions" 
},
{
	"docs_id": "12",
	"name": "Operadores básicos, matemáticas",
	"description": "Conocemos varios operadores matemáticos porque nos los enseñaron en la escuela. Son cosas como la suma +, multiplicación *, resta -, etcétera.",
	"content": "Conocemos varios operadores matemáticos porque nos los enseñaron en la escuela. Son cosas como la suma +, multiplicación *, resta -, etcétera.
En este capítulo, nos vamos a concentrar en los aspectos de los operadores que no están cubiertos en la aritmética escolar.
Términos: “unario”, “binario”, “operando”Antes de continuar, comprendamos la terminología común.


Un operando – es a lo que se aplican los operadores. Por ejemplo, en la multiplicación de 5 * 2 hay dos operandos: el operando izquierdo es 5 y el operando derecho es 2. A veces, la gente los llama “argumentos” en lugar de “operandos”.


Un operador es unario si tiene un solo operando. Por ejemplo, la negación unaria - invierte el signo de un número:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

x = -x;
alert( x ); // -1, se aplicó negación unaria
        
      
      
      

Un operador es binario si tiene dos operandos. El mismo negativo también existe en forma binaria:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1, y = 3;
alert( y - x ); // 2, binario negativo resta valores
        
      
      
      Formalmente, estamos hablando de dos operadores distintos: la negación unaria (un operando: revierte el símbolo) y la resta binaria (dos operandos: resta).


MatemáticasEstán soportadas las siguientes operaciones:

Suma +,
Resta -,
Multiplicación *,
División /,
Resto %,
Exponenciación **.

Los primeros cuatro son conocidos mientras que % y ** deben ser explicados más ampliamente.
Resto %El operador resto %, a pesar de su apariencia, no está relacionado con porcentajes.
El resultado de a % b es el resto de la división entera de a por b.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( 5 % 2 ); // 1 es un resto de 5 dividido por 2
alert( 8 % 3 ); // 2 es un resto de 8 dividido por 3
        
      
      
      Exponenciación **El operador exponenciación a ** b eleva a a la potencia de b.
En matemáticas de la escuela, lo escribimos como ab.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( 2 ** 2 ); // 2² = 4
alert( 2 ** 3 ); // 2³ = 8
alert( 2 ** 4 ); // 2⁴ = 16
        
      
      
      Matemáticamente, la exponenciación es definida para números no enteros también.
Por ejemplo, la raíz cuadrada es el exponente ½:

      
        
        
          
            
          
          
            
          
        
        
          alert( 4 ** (1/2) ); // 2 (potencia de 1/2 es lo mismo que raíz cuadrada, eso es matemáticas)
alert( 8 ** (1/3) ); // 2 (potencia de 1/3 es lo mismo que raíz cúbica)
        
      
      
      Concatenación de cadenas con el binario +Ahora veamos características especiales de JavaScript que van más allá de las aritméticas escolares.
Normalmente el operador + suma números.
Pero si se aplica el + binario a una cadena, los une (concatena):

      
        
        
          let s = "my" + "string";
alert(s); // mystring
        
      
      
      Tenga presente que si uno de los operandos es una cadena, el otro es convertido a una cadena también.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( '1' + 2 ); // "12"
alert( 2 + '1' ); // "21"
        
      
      
      Vieron, no importa si el primer operando es una cadena o el segundo.
Aquí hay un ejemplo algo más complejo:

      
        
        
          
            
          
          
            
          
        
        
          alert(2 + 2 + '1' ); // "41" y no "221"
        
      
      
      Aquí, los operadores trabajan uno después de otro. El primer + suma dos números entonces devuelve 4, luego el siguiente + le agrega la cadena 1, así que se evalúa como 4 + '1' = 41.

      
        
        
          
            
          
          
            
          
        
        
          alert('1' + 2 + 2); // "122", no es "14"
        
      
      
      Aquí el primer operando es una cadena, el compilador trata los otros dos operandos como cadenas también. El 2 es concatenado a '1', entonces es como '1' + 2 = "12" y "12" + 2 = "122".
El binario + es el único operador que soporta cadenas en esa forma. Otros operadores matemáticos trabajan solamente con números y siempre convierten sus operandos a números.
Por ejemplo, resta y división:

      
        
        
          
            
          
          
            
          
        
        
          alert( 2 - '1' ); // 1
alert( '6' / '2' ); // 3
        
      
      
      Conversión numérica, unario +La suma + existe en dos formas: la forma binaria que utilizamos arriba y la forma unaria.
El unario suma o, en otras palabras, el operador suma + aplicado a un solo valor, no hace nada a los números. Pero si el operando no es un número, el unario suma lo convierte en un número.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // Sin efecto en números
let x = 1;
alert( +x ); // 1

let y = -2;
alert( +y ); // -2

// Convierte los no números
alert( +true ); // 1
alert( +"" );   // 0
        
      
      
      Realmente hace lo mismo que Number(...), pero es más corto.
La necesidad de convertir cadenas en números surge con mucha frecuencia. Por ejemplo, si estamos obteniendo valores de campos de formulario HTML, generalmente son cadenas.
El operador binario suma los agregaría como cadenas:

      
        
        
          
            
          
          
            
          
        
        
          let apples = "2";
let oranges = "3";

alert( apples + oranges ); // "23", el binario suma concatena las cadenas
        
      
      
      Si queremos tratarlos como números, necesitamos convertirlos y luego sumarlos:

      
        
        
          
            
          
          
            
          
        
        
          let apples = "2";
let oranges = "3";

// ambos valores convertidos a números antes del operador binario suma
alert( +apples + +oranges ); // 5

// la variante más larga
// alert( Number(apples) + Number(oranges) ); // 5
        
      
      
      Desde el punto de vista de un matemático, la abundancia de signos más puede parecer extraña. Pero desde el punto de vista de un programador no hay nada especial: primero se aplican los signos más unarios que convierten las cadenas en números, y luego el signo más binario los suma.
¿Por qué se aplican los signos más unarios a los valores antes que los binarios? Como veremos, eso se debe a su mayor precedencia.
Precedencia del operadorSi una expresión tiene más de un operador, el orden de ejecución se define por su precedencia o, en otras palabras, el orden de prioridad predeterminado de los operadores.
Desde la escuela, todos sabemos que la multiplicación en la expresión 1 + 2 * 2 debe calcularse antes de la suma. Eso es exactamente la precedencia. Se dice que la multiplicación tiene una mayor precedencia que la suma.
Los paréntesis anulan cualquier precedencia, por lo que si no estamos satisfechos con el orden predeterminado, podemos usarlos para cambiarlo. Por ejemplo, escriba (1 + 2) * 2.
Hay muchos operadores en JavaScript. Cada operador tiene un número de precedencia correspondiente. El que tiene el número más grande se ejecuta primero. Si la precedencia es la misma, el orden de ejecución es de izquierda a derecha.
Aquí hay un extracto de la tabla de precedencia (no necesita recordar esto, pero tenga en cuenta que los operadores unarios son más altos que el operador binario correspondiente):



Precedencia
Nombre
Signo




…
…
…


15
suma unaria
+


15
negación unaria
-


14
exponenciación
**


13
multiplicación
*


13
división
/


12
suma
+


12
resta
-


…
…
…


2
asignación
=


…
…
…



Como podemos ver, la “suma unaria” tiene una prioridad de 15, que es mayor que el 12 de “suma” (suma binaria). Es por eso que, en la expresión "+apples + +oranges", las sumas unarias se hacen antes de la adición.
AsignaciónTengamos en cuenta que una asignación = también es un operador. Está listado en la tabla de precedencia con la prioridad muy baja de 2.
Es por eso que, cuando asignamos una variable, como x = 2 * 2 + 1, los cálculos se realizan primero y luego se evalúa el =, almacenando el resultado en x.

      
        
        
          let x = 2 * 2 + 1;

alert( x ); // 5
        
      
      
      Asignación = devuelve un valorEl hecho de que = sea un operador, no una construcción “mágica” del lenguaje, tiene un implicación interesante.
Todos los operadores en JavaScript devuelven un valor. Esto es obvio para + y -, pero también es cierto para =.
La llamada x = value escribe el value en x y luego lo devuelve.
Aquí hay una demostración que usa una asignación como parte de una expresión más compleja:

      
        
        
          
            
          
          
            
          
        
        
          let a = 1;
let b = 2;

let c = 3 - (a = b + 1);

alert( a ); // 3
alert( c ); // 0
        
      
      
      En el ejemplo anterior, el resultado de la expresión (a = b + 1) es el valor asignado a a (es decir, 3). Luego se usa para evaluaciones adicionales.
Código gracioso, ¿no? Deberíamos entender cómo funciona, porque a veces lo vemos en las bibliotecas de JavaScript.
Pero no deberíamos escribir algo así. Tales trucos definitivamente no hacen que el código sea más claro o legible.
Asignaciones encadenadasOtra característica interesante es la habilidad para encadenar asignaciones:

      
        
        
          
            
          
          
            
          
        
        
          let a, b, c;

a = b = c = 2 + 2;

alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
        
      
      
      Las asignaciones encadenadas evalúan de derecha a izquierda. Primero, se evalúa la expresión más a la derecha 2 + 2 y luego se asigna a las variables de la izquierda: c, b y a. Al final, todas las variables comparten un solo valor.
Una vez más, con el propósito de la legibilidad es mejor separa tal código en unas pocas líneas:

      
        
        
          c = 2 + 2;
b = c;
a = c;
        
      
      
      Es más fácil de leer, especialmente cuando se hace de un vistazo.
Modificar en el lugarA menudo necesitamos aplicar un operador a una variable y guardar el nuevo resultado en esa misma variable.
Por ejemplo:

      
        
        
          let n = 2;
n = n + 5;
n = n * 2;
        
      
      
      Esta notación puede ser acortada utilizando los operadores += y *=:

      
        
        
          
            
          
          
            
          
        
        
          let n = 2;
n += 5; // ahora n = 7 (lo mismo que n = n + 5)
n *= 2; // ahora n = 14 (lo mismo que n = n * 2)

alert( n ); // 14
        
      
      
      Los operadores cortos “modifica y asigna” existen para todos los operadores aritméticos y de nivel bit: /=, -=, etcétera.
Tales operadores tienen la misma precedencia que la asignación normal, por lo tanto se ejecutan después de otros cálculos:

      
        
        
          
            
          
          
            
          
        
        
          let n = 2;

n *= 3 + 5;

alert( n ); // 16  (lado derecho evaluado primero, lo mismo que n *= 8)
        
      
      
      Incremento/decremento
Aumentar o disminuir un número en uno es una de las operaciones numéricas más comunes.
Entonces, hay operadores especiales para ello:


Incremento ++ incrementa una variable por 1:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 2;
counter++;      // funciona igual que counter = counter + 1, pero es más corto
alert( counter ); // 3
        
      
      
      

Decremento -- decrementa una variable por 1:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 2;
counter--;      // funciona igual que counter = counter - 1, pero es más corto
alert( counter ); // 1
        
      
      
      


            Importante:
            Incremento/decremento sólo puede ser aplicado a variables. Intentar utilizarlo en un valor como 5++ dará un error.

Los operadores ++ y -- pueden ser colocados antes o después de una variable.

Cuando el operador va después de la variable, está en “forma de sufijo”: counter++.
La “forma de prefijo” es cuando el operador va antes de la variable: ++counter.

Ambas sentencias hacen la misma cosa: aumentar counter por 1.
¿Existe alguna diferencia? Sí, pero solamente la podemos ver si utilizamos el valor devuelto de ++/--.
Aclaremos. Tal como conocemos, todos los operadores devuelven un valor. Incremento/decremento no es una excepción. La forma prefijo devuelve el nuevo valor mientras que la forma sufijo devuelve el valor anterior (antes del incremento/decremento).
Para ver la diferencia, aquí hay un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
let a = ++counter; // (*)

alert(a); // 2
        
      
      
      En la línea (*), la forma prefijo ++counter incrementa counter y devuelve el nuevo valor, 2. Por lo tanto, el alert muestra 2.
Ahora usemos la forma sufijo:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
let a = counter++; // (*) cambiado ++counter a counter++

alert(a); // 1
        
      
      
      En la línea (*), la forma sufijo counter++ también incrementa counter, pero devuelve el antiguo valor (antes de incrementar). Por lo tanto, el alert muestra 1.
Para resumir:


Si no se usa el resultado del incremento/decremento, no hay diferencia en la forma de usar:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
counter++;
++counter;
alert( counter ); // 2, las líneas de arriba realizan lo mismo
        
      
      
      

Si queremos aumentar un valor y usar inmediatamente el resultado del operador, necesitamos la forma de prefijo:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
alert( ++counter ); // 1
        
      
      
      

Si queremos incrementar un valor, pero usamos su valor anterior, necesitamos la forma sufijo:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 0;
alert( counter++ ); // 0
        
      
      
      


            Incremento/decremento entre otros operadores
            Los operadores ++/-- también pueden ser usados dentro de expresiones. Su precedencia es más alta que la mayoría de los otros operadores aritméticos.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * ++counter ); // 4
        
      
      
      Compara con:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * counter++ ); // 2, porque counter++ devuelve el valor "antiguo"
        
      
      
      Aunque técnicamente está bien, tal notación generalmente hace que el código sea menos legible. Una línea hace varias cosas, no es bueno.
Mientras lee el código, un rápido escaneo ocular “vertical” puede pasar por alto fácilmente algo como ‘counter++’ y no será obvio que la variable aumentó.
Aconsejamos un estilo de “una línea – una acción”:

      
        
        
          
            
          
          
            
          
        
        
          let counter = 1;
alert( 2 * counter );
counter++;
        
      
      
      
Operadores a nivel de bitLos operadores a nivel bit tratan los argumentos como números enteros de 32 bits y trabajan en el nivel de su representación binaria.
Estos operadores no son específicos de JavaScript. Son compatibles con la mayoría de los lenguajes de programación.
La lista de operadores:

AND ( & )
OR ( | )
XOR ( ^ )
NOT ( ~ )
LEFT SHIFT ( << )
RIGHT SHIFT ( >> )
ZERO-FILL RIGHT SHIFT ( >>> )

Estos operadores se usan muy raramente, cuando necesitamos manejar la representación de números em su más bajo nivel. No tenemos en vista usarlos pronto pues en el desarrollo web tiene poco uso; pero en ciertas áreas especiales, como la criptografía, son útiles. Puedes leer el artículo Operadores a nivel de bit en MDN cuando surja la necesidad.
ComaEl operador coma , es uno de los operadores más raros e inusuales. A veces, es utilizado para escribir código más corto, entonces tenemos que saberlo para poder entender qué está pasando.
El operador coma nos permite evaluar varias expresiones, dividiéndolas con una coma ,. Cada una de ellas es evaluada, pero sólo el resultado de la última es devuelto.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let a = (1 + 2, 3 + 4);

alert( a ); // 7 (el resultado de 3 + 4)
        
      
      
      Aquí, se evalúa la primera expresión 1 + 2 y se desecha su resultado. Luego, se evalúa 3 + 4 y se devuelve como resultado.

            Coma tiene muy baja precedencia
            Tenga en cuenta que el operador coma tiene una precedencia muy baja, inferior a =, por lo que los paréntesis son importantes en el ejemplo anterior.
Sin ellos: a = 1 + 2, 3 + 4 se evalúa primero el +, sumando los números a a = 3, 7, luego el operador de asignación = asigna a = 3, y el resto es ignorado. Es igual que (a = 1 + 2), 3 + 4.

¿Por qué necesitamos un operador que deseche todo excepto la última expresión?
A veces, las personas lo usan en construcciones más complejas para poner varias acciones en una línea.
Por ejemplo:

      
        
        
          // tres operaciones en una línea
for (a = 1, b = 3, c = a * b; a < 10; a++) {
 ...
}
        
      
      
      Tales trucos se usan en muchos frameworks de JavaScript. Por eso los estamos mencionando. Pero generalmente no mejoran la legibilidad del código, por lo que debemos pensar bien antes de usarlos.
TareasLas formas sufijo y prefijoimportancia: 5¿Cuáles son los valores finales de todas las variables a, b, c y d después del código a continuación?

      
        
        
          let a = 1, b = 1;

let c = ++a; // ?
let d = b++; // ?
        
      
      
      soluciónLa respuesta es:

a = 2
b = 2
c = 2
d = 1


      
        
        
          
            
          
          
            
          
        
        
          let a = 1, b = 1;

alert( ++a ); // 2, la forma de prefijo devuelve el nuevo valor
alert( b++ ); // 1, la forma de sufijo devuelve el antiguo valor

alert( a ); // 2, incrementado una vez
alert( b ); // 2, incrementado una vez
        
      
      
      Resultado de asignaciónimportancia: 3¿Cuáles son los valores de ‘a’ y ‘x’ después del código a continuación?

      
        
        
          let a = 2;

let x = 1 + (a *= 2);
        
      
      
      soluciónLa respuesta es:

a = 4 (multiplicado por 2)
x = 5 (calculado como 1 + 4)

Conversiones de tiposimportancia: 5¿Cuáles son los resultados de estas expresiones?

      
        
        
          "" + 1 + 0
"" - 1 + 0
true + false
6 / "3"
"2" * "3"
4 + 5 + "px"
"$" + 4 + 5
"4" - 2
"4px" - 2
"  -9  " + 5
"  -9  " - 5
null + 1
undefined + 1
" \t \n" - 2
        
      
      
      Piensa bien, anótalos y luego compara con la respuesta.
solución
      
        
        
          "" + 1 + 0 = "10" // (1)
"" - 1 + 0 = -1 // (2)
true + false = 1
6 / "3" = 2
"2" * "3" = 6
4 + 5 + "px" = "9px"
"$" + 4 + 5 = "$45"
"4" - 2 = 2
"4px" - 2 = NaN
"  -9  " + 5 = "  -9  5" // (3)
"  -9  " - 5 = -14 // (4)
null + 1 = 1 // (5)
undefined + 1 = NaN // (6)
" \t \n" - 2 = -2 // (7)
        
      
      
      
La suma con una cadena "" + 1 convierte 1 a un string: "" + 1 = "1", y luego tenemos "1" + 0, la misma regla se aplica.
La resta - (como la mayoría de las operaciones matemáticas) sólo funciona con números, convierte una cadena vacía "" a 0.
La suma con una cadena concatena el número 5 a la cadena.
La resta siempre convierte a números, por lo tanto hace de " -9 " un número -9 (ignorando los espacios que lo rodean).
null se convierte en 0 después de la conversión numérica.
undefined se convierte en NaN después de la conversión numérica.
Los caracteres de espacio se recortan al inicio y al final de la cadena cuando una cadena se convierte en un número. Aquí toda la cadena consiste en caracteres de espacio, tales como \t, \n y un espacio “común” entre ellos. Por lo tanto, pasa lo mismo que a una cadena vacía, se convierte en 0.

Corregir la adiciónimportancia: 5Aquí hay un código que le pide al usuario dos números y muestra su suma.
Funciona incorrectamente. El resultado en el ejemplo a continuación es 12 (para valores de captura predeterminados).
¿Por qué? Arreglalo. El resultado debería ser 3.

      
        
        
          
            
          
          
            
          
        
        
          let a = prompt("¿Primer número?", 1);
let b = prompt("¿Segundo número?", 2);

alert(a + b); // 12
        
      
      
      soluciónLa razón es que la captura devuelve la entrada del usuario como una cadena.
Entonces las variables tienen valores "1" y "2" respectivamente.

      
        
        
          
            
          
          
            
          
        
        
          let a = "1"; // prompt("¿Primer número?", 1);
let b = "2"; // prompt("¿Segundo número?", 2);

alert(a + b); // 12
        
      
      
      Lo que debemos hacer es convertir las cadenas de texto a números antes de +. Por ejemplo, utilizando Number() o anteponiendo +.
Por ejemplo, justo antes de prompt:

      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt("¿Primer número?", 1);
let b = +prompt("¿Segundo número?", 2);

alert(a + b); // 3
        
      
      
      O en el alert:

      
        
        
          
            
          
          
            
          
        
        
          let a = prompt("¿Primer número?", 1);
let b = prompt("¿Segundo número?", 2);

alert(+a + +b); // 3
        
      
      
      Usar ambos unario y binario + en el último ejemplo, se ve raro, ¿no?
",
	"url": "https://es.javascript.info/operators" 
},
{
	"docs_id": "13",
	"name": "Comparaciones",
	"description": "Conocemos muchos operadores de comparación de las matemáticas:",
	"content": "Conocemos muchos operadores de comparación de las matemáticas:
En Javascript se escriben así:

Mayor/menor que: a > b, a < b.
Mayor/menor o igual que: a >= b, a <= b.
Igual: a == b (ten en cuenta que el doble signo == significa comparación, mientras que un solo símbolo a = b significaría una asignación).
Distinto. En matemáticas la notación es ≠, pero en JavaScript se escribe como una asignación con un signo de exclamación delante: a != b.

En este artículo, aprenderemos más sobre los diferentes tipos de comparaciones y de cómo las realiza JavaScript, incluidas las peculiaridades importantes.
Al final, encontrará una buena receta para evitar problemas relacionadas con las “peculiaridades” de JavaScript.
Booleano es el resultadoComo todos los demás operadores, una comparación retorna un valor. En este caso, el valor es un booleano.

true – significa “sí”, “correcto” o “verdad”.
false – significa “no”, “equivocado” o " no verdad".

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( 2 > 1 ); // true (correcto)
alert( 2 == 1 ); // false (incorrecto)
alert( 2 != 1 ); // true (correcto)
        
      
      
      El resultado de una comparación puede asignarse a una variable, igual que cualquier valor:

      
        
        
          
            
          
          
            
          
        
        
          let result = 5 > 4; // asignar el resultado de la comparación
alert( result ); // true
        
      
      
      Comparación de cadenasPara ver si una cadena es “mayor” que otra, JavaScript utiliza el llamado orden “de diccionario” o “lexicográfico”.
En otras palabras, las cadenas se comparan letra por letra.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
        
      
      
      El algoritmo para comparar dos cadenas es simple:

Compare el primer carácter de ambas cadenas.
Si el primer carácter de la primera cadena es mayor (o menor) que el de la otra cadena, entonces la primera cadena es mayor (o menor) que la segunda. Hemos terminado.
De lo contrario, si los primeros caracteres de ambas cadenas son los mismos, compare los segundos caracteres de la misma manera.
Repita hasta el final de cada cadena.
Si ambas cadenas tienen la misma longitud, entonces son iguales. De lo contrario, la cadena más larga es mayor.

En los ejemplos anteriores, la comparación 'Z' > 'A' llega a un resultado en el primer paso.
La segunda comparación "Glow" y "Glee" necesitan más pasos, se comparan carácter por carácter:

G es igual que G.
l es igual que l.
o es mayor que e. Detente aquí. La primera cadena es mayor.


            No es un diccionario real, sino un orden Unicode
            El algoritmo de comparación dado arriba es aproximadamente equivalente al utilizado en los diccionarios o guías telefónicas, pero no es exactamente el mismo.
Por ejemplo, las mayúsculas importan. Una letra mayúscula "A" no es igual a la minúscula "a". ¿Cuál es mayor? La "a" minúscula. ¿Por qué? Porque el carácter en minúsculas tiene un mayor índice en la tabla de codificación interna que utiliza JavaScript (Unicode). Volveremos a los detalles específicos y las consecuencias de esto en el capítulo Strings.

Comparación de diferentes tiposAl comparar valores de diferentes tipos, JavaScript convierte los valores a números.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( '2' > 1 ); // true, la cadena '2' se convierte en el número 2
alert( '01' == 1 ); // true, la cadena '01' se convierte en el número 1
        
      
      
      Para valores booleanos, true se convierte en 1 y false en 0.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( true == 1 ); // true
alert( false == 0 ); // true
        
      
      
      
            Una consecuencia graciosa
            Es posible que al mismo tiempo:

Dos valores sean iguales.
Uno de ellos sea true como booleano y el otro sea false como booleano.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert( a == b ); // true!
        
      
      
      Desde el punto de vista de JavaScript, este resultado es bastante normal. Una comparación de igualdad convierte valores utilizando la conversión numérica (de ahí que "0" se convierta en 0), mientras que la conversión explícita Boolean utiliza otro conjunto de reglas.

Igualdad estrictaUna comparación regular de igualdad == tiene un problema. No puede diferenciar 0 de `falso’:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == false ); // true
        
      
      
      Lo mismo sucede con una cadena vacía:

      
        
        
          
            
          
          
            
          
        
        
          alert( '' == false ); // true
        
      
      
      Esto sucede porque los operandos de diferentes tipos son convertidos a números por el operador de igualdad ==. Una cadena vacía, al igual que false, se convierte en un cero.
¿Qué hacer si queremos diferenciar 0 de false?
Un operador de igualdad estricto === comprueba la igualdad sin conversión de tipo.
En otras palabras, si a y b son de diferentes tipos, entonces a === b retorna inmediatamente false sin intentar convertirlos.
Intentémoslo:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 === false ); // falso, porque los tipos son diferentes
        
      
      
      Existe también un operador de “diferencia estricta” !== análogo a !=.
El operador de igualdad estricta es un poco más largo de escribir, pero hace obvio lo que está pasando y deja menos espacio a errores.
Comparación con nulos e indefinidosVeamos más casos extremos.
Hay un comportamiento no intuitivo cuando se compara null o undefined con otros valores.

Para un control de igualdad estricto ===

Estos valores son diferentes, porque cada uno de ellos es de un tipo diferente.

      
        
        
          
            
          
          
            
          
        
        
          alert( null === undefined ); // false
        
      
      
      
Para una comparación no estricta ==

Hay una regla especial. Estos dos son una " pareja dulce ": son iguales entre sí (en el sentido de ==), pero no a ningún otro valor.

      
        
        
          
            
          
          
            
          
        
        
          alert( null == undefined ); // true
        
      
      
      
Para matemáticas y otras comparaciones < > <= >=

null/undefined se convierten en números: null se convierte en 0, mientras que undefined se convierte en NaN.


Ahora veamos algunos hechos graciosas que suceden cuando aplicamos estas reglas. Y, lo que es más importante, cómo no caer en una trampa con ellas.
Resultado extraño: null vs 0Comparemos null  con un cero:

      
        
        
          
            
          
          
            
          
        
        
          alert( null > 0 ); /// (1) false
alert( null == 0 ); /// (2) false
alert( null >= 0 ); // (3) true
        
      
      
      Matemáticamente, eso es extraño. El último resultado afirma que "null es mayor o igual a cero", así que en una de las comparaciones anteriores debe ser true, pero ambas son falsas.
La razón es que una comparación de igualdad == y las comparaciones > < >= <= funcionan de manera diferente. Las comparaciones convierten a null en un número, tratándolo como 0. Es por eso que (3) null >= 0 es verdadero y (1) null > 0 es falso.
Por otro lado, el control de igualdad == para undefined y null se define de tal manera que, sin ninguna conversión, son iguales entre sí y no son iguales a nada más. Es por eso que (2) null == 0 es falso.
Un indefinido incomparableEl valor undefined no debe compararse con otros valores:

      
        
        
          
            
          
          
            
          
        
        
          alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
        
      
      
      ¿Por qué le desagrada tanto el cero? ¡Siempre falso!
Obtenemos estos resultados porque:

Las comparaciones (1) y (2) retornan falso porque no definido se convierte en NaN y NaN es un valor numérico especial que retorna falso para todas las comparaciones.
La comparación de igualdad (3) retorna falso porque undefined sólo equivale a null y a ningún otro valor.

Evitar los problemas¿Por qué repasamos estos ejemplos? ¿Deberíamos recordar estas peculiaridades todo el tiempo? Bueno, en realidad no. De hecho, estas peculiaridades se volverán familiares con el tiempo, pero hay una manera sólida de evadir los problemas con ellas:


Trata cualquier comparación con undefined/null (excepto la igualdad estricta ===) con sumo cuidado.


No uses comparaciones >= > < <= con una variable que puede ser null/undefined, a menos que estés realmente seguro de lo que estás haciendo. Si una variable puede tener estos valores, verifícalos por separado.


Resumen
Los operadores de comparación retornan un valor booleano.
Las cadenas se comparan letra por letra en el orden del “diccionario”.
Cuando se comparan valores de diferentes tipos, se convierten en números (excepto un control de igualdad estricta).
Los valores null y undefined son iguales == entre sí y no equivalen a ningún otro valor.
Ten cuidado al usar comparaciones como > o < con variables que ocasionalmente pueden ser null/undefined. Revisar por separado si hay null/undefined es una buena idea.

TareasComparacionesimportancia: 5¿Cuál será el resultado de las siguientes expresiones?

      
        
        
          5 > 4
"apple" > "pineapple"
"2" > "12"
undefined == null
undefined === null
null == "\n0\n"
null === +"\n0\n"
        
      
      
      solución
      
        
        
          5 > 4 → true
"apple" > "pineapple" → false
"2" > "12" → true
undefined == null → true
undefined === null → false
null == "\n0\n" → false
null === +"\n0\n" → false
        
      
      
      Algunas de las razones:

Obviamente, true.
Comparación lexicográfica, por lo tanto false. "a" es menor que "p".
Una vez más, la comparación lexicográfica, el primer carácter de "2" es mayor que el primer carácter de "1".
Los valores null y undefined son iguales entre sí solamente.
La igualdad estricta es estricta. Diferentes tipos de ambos lados conducen a false.
Similar a (4), null solamente es igual a undefined.
Igualdad estricta de diferentes tipos.

",
	"url": "https://es.javascript.info/comparison" 
},
{
	"docs_id": "14",
	"name": "Ejecución condicional: if, '?'",
	"description": "Algunas veces, necesitamos ejecutar diferentes acciones basadas en diferentes condiciones.",
	"content": "Algunas veces, necesitamos ejecutar diferentes acciones basadas en diferentes condiciones.
Para esto podemos usar la sentencia if y el operador condicional ?, también llamado operador de “signo de interrogación”.
La sentencia “if”La sentencia if(...) evalúa la condición en los paréntesis, y si el resultado es true ejecuta un bloque de código.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('¿En que año fué publicada la especificación ECMAScript-2015?', '');

if (year == 2015) alert( '¡Estás en lo cierto!' );
        
      
      
      Aquí la condición es una simple igualdad (year == 2015), pero podría ser mucho mas complejo.
Si quisiéramos ejecutar más de una sentencia, debemos encerrar nuestro bloque de código entre llaves:

      
        
        
          if (year == 2015) {
  alert( "¡Es Correcto!" );
  alert( "¡Eres muy inteligente!" );
}
        
      
      
      Recomendamos siempre encerrar nuestro bloque de código entre llaves {} siempre que se utilice la sentencia if, inclusive si solo se va a ejecutar una sola sentencia en este caso. Hacer eso mejora la legibilidad.
Conversión BooleanaLa sentencia if (…) evalúa la expresión dentro de sus paréntesis y convierte el resultado en booleano.
Recordemos las reglas de conversión del capítulo Conversiones de Tipos:

El número 0, un string vacío "", null, undefined, y NaN se convierte en false. Por esto son llamados valores “falso”.
El resto de los valores se convierten en  true, entonces los llamaremos valores “verdadero”.

Entonces, el código bajo esta condición nunca se ejecutaría:

      
        
        
          if (0) { // 0 es falso
  ...
}
        
      
      
      …y dentro de esta condición siempre se ejecutará:

      
        
        
          if (1) { // 1 es verdadero
  ...
}
        
      
      
      También podemos pasar un valor booleano pre-evaluado al if, así:

      
        
        
          let cond = (year == 2015); // la igualdad evalúa y devuelve un true o false

if (cond) {
  ...
}
        
      
      
      La cláusula “else”La sentencia if quizás contenga un bloque “else” opcional. Este se ejecutará cuando la condición sea falsa.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('¿En qué año fue publicada la especificación ECMAScript-2015?', '');

if (year == 2015) {
  alert( '¡Lo adivinaste, correcto!' );
} else {
  alert( '¿Cómo puedes estar tan equivocado?' ); // cualquier valor excepto 2015
}
        
      
      
      Muchas condiciones: “else if”Algunas veces, queremos probar variantes de una condición. La clausula else if nos permite hacer esto.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let year = prompt('¿En qué año fue publicada la especificación ECMAScript-2015?', '');

if (year < 2015) {
  alert( 'Muy poco...' );
} else if (year > 2015) {
  alert( 'Muy Tarde' );
} else {
  alert( '¡Exactamente!' );
}
        
      
      
      En el código de arriba, JavaScript primero revisa si year < 2015. Si esto es falso, continúa a la siguiente condición year > 2015. Si esta también es falsa, mostrará la última alert.
Podría haber más bloques else if.  Y el último  else es opcional.
Operador ternario ‘?’A veces necesitamos asignar una variable dependiendo de alguna condición.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let accessAllowed;
let age = prompt('¿Qué edad tienes?', '');

if (age > 18) {
  accessAllowed = true;
} else {
  accessAllowed = false;
}

alert(accessAllowed);
        
      
      
      Entonces el operador “ternario” también llamado  “signo de interrogación” nos permite ejecutar esto en una forma más corta y simple.
El operador está representado por un signo de interrogación de cierre ?.  A veces es llamado “ternario” porque el operador tiene tres operandos. Es el único operador de JavaScript que tiene esta cantidad de ellos.
La Sintaxis es:

      
        
        
          let result = condition ? value1 : value2;
        
      
      
      Se evalúa condition: si es verdadera entonces devuelve value1 , de lo contrario value2.
Por ejemplo:

      
        
        
          let accessAllowed = (age > 18) ? true : false;
        
      
      
      Técnicamente, podemos omitir el paréntesis alrededor de  age > 18. El operador de signo de interrogación tiene una precedencia baja, por lo que se ejecuta después de la comparación >.
En este ejemplo realizaremos lo mismo que en el anterior:

      
        
        
          // el operador de comparación  "age > 18" se ejecuta primero de cualquier forma
// (no necesitamos agregar los paréntesis)
let accessAllowed = age > 18 ? true : false;
        
      
      
      Pero los paréntesis hacen el código mas legible, asi que recomendamos utilizarlos.

            Por favor tome nota:
            En el ejemplo de arriba, podrías evitar utilizar el operador de signo de interrogación porque esta comparación devuelve directamente true/false:

      
        
        
          // es lo mismo que
let accessAllowed = age > 18;
        
      
      
      
Múltiples ‘?’Una secuencia de operadores de signos de interrogación  ? puede devolver un valor que depende de más de una condición.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('¿edad?', 18);

let message = (age < 3) ? '¡Hola, bebé!' :
  (age < 18) ? '¡Hola!' :
  (age < 100) ? '¡Felicidades!' :
  '¡Qué edad tan inusual!';

alert( message );
        
      
      
      Puede ser difícil al principio comprender lo que está sucediendo. Pero después de una mirada más cercana, podemos ver que es solo una secuencia ordinaria de condiciones:

El primer signo de pregunta revisa si age < 3.
Si es cierto – devuelve '¡Hola, bebé!'. De lo contrario, continua a la expresión que está después de los dos puntos ‘":"’, revisando age < 18.
Si es cierto – devuelve '¡Hola!'. De lo contrario, continúa con la expresión que está después de los dos puntos siguientes ‘":"’, revisando age < 100.
Si es cierto – devuelve '¡Felicidades!'. De lo contrario, continúa a la expresión que está después de los dos puntos ‘":"’, devolviendo '¡Qué edad tan inusual!'.

Aquí lo podemos ver utilizando if..else:

      
        
        
          if (age < 3) {
  message = '¡Hola, bebé!';
} else if (age < 18) {
  message = '¡Hola!';
} else if (age < 100) {
  message = '¡Felicidades!';
} else {
  message = '¡Qué edad tan inusual!';
}
        
      
      
      Uso no tradicional de ‘?’A veces el signo de interrogación cerrado ? se utiliza para reemplazar if:

      
        
        
          
            
          
          
            
          
        
        
          let company = prompt('¿Qué compañía creó JavaScript?', '');

(company == 'Netscape') ?
   alert('¡Correcto!') : alert('Equivocado.');
        
      
      
      Dependiendo de la condición company == 'Netscape', se ejecutará la primera o la segunda expresión del operador ? y se mostrará una alerta.
Aquí no asignamos el resultado de una variable. En vez de esto, ejecutamos diferentes códigos dependiendo de la condición.
No se recomienda el uso del operador de signo de interrogación de esta forma.
La notación es más corta que la sentencia equivalente con if, lo cual seduce a algunos programadores. Pero es menos legible.
Aquí está el mismo código utilizando la sentencia if para comparar:

      
        
        
          
            
          
          
            
          
        
        
          let company = prompt('¿Cuál compañía creó JavaScript?', '');

if (company == 'Netscape') {
  alert('¡Correcto!');
} else {
  alert('Equivocado.');
}
        
      
      
      Nuestros ojos leen el código verticalmente. Los bloques de código que se expanden múltiples lineas son mas fáciles de entender que los las instrucciones largas horizontales.
El propósito del operador de signo de interrogación ? es para devolver un valor u otro dependiendo de su condición. Por favor utilízala para exactamente esto. Utiliza la sentencia if cuando necesites ejecutar código en ramas distintas.
Tareasif (un string con cero)importancia: 5Se mostrará el alert?

      
        
        
          if ("0") {
  alert( 'Hello' );
}
        
      
      
      soluciónSí lo hará.
Cualquier string excepto uno vacío (y "0" que no es vacío) se convierte en true en un contexto lógico.
Podemos ejecutar y verificar:

      
        
        
          
            
          
          
            
          
        
        
          if ("0") {
  alert( 'Hola' );
}
        
      
      
      El nombre de JavaScriptimportancia: 2Usando el constructor if..else, escribe el código que pregunta: ‘¿Cuál es el nombre “oficial” de JavaScript?’
Si el visitante escribe “ECMAScript”, entonces muestra: “¡Correcto!”, de lo contrario muestra: “¿No lo sabes? ¡ECMAScript!”

      
      
        
      
      Demo en nueva ventanasolución
      
        
        
          
            
          
          
            
          
        
        
          <!DOCTYPE html>
<html>

<body>
  <script>
    'use strict';

    let value = prompt('¿Cuál es el nombre "oficial" de JavaScript?', '');

    if (value == 'ECMAScript') {
      alert('¡Correcto!');
    } else {
      alert("¿No lo sabes? ¡ECMAScript!");
    }
  </script>


</body>

</html>
        
      
      
      Muestra el signoimportancia: 2Usando el constructor if..else, escribe un código que obtenga a través de un prompt un número y entonces muestre en un alert:

1, si el valor es mayor que cero,
-1, si es menor que cero,
0, si es igual a cero.

En la tarea asumimos que siempre el usuario introduce un número.
Demo en nueva ventanasolución
      
        
        
          
            
          
          
            
          
        
        
          let value = prompt('Escribe un número', 0);

if (value > 0) {
  alert( 1 );
} else if (value < 0) {
  alert( -1 );
} else {
  alert( 0 );
}
        
      
      
      Reescribe el 'if' como '?'importancia: 5Reescriba esta condición if usando el operador ternario '?':

      
        
        
          let result;

if (a + b < 4) {
  result = 'Debajo';
} else {
  result = 'Encima';
}
        
      
      
      solución
      
        
        
          let result = (a + b < 4) ? 'Debajo' : 'Encima';
        
      
      
      Reescriba el 'if..else' con '?'importancia: 5Reescriba el if..else utilizando operadores ternarios múltiples'?'.
Para legibilidad, es recomendad dividirlo en múltiples lineas de código.

      
        
        
          let message;

if (login == 'Empleado') {
  message = 'Hola';
} else if (login == 'Director') {
  message = 'Felicidades';
} else if (login == '') {
  message = 'Sin sesión';
} else {
  message = '';
}
        
      
      
      solución
      
        
        
          let message = (login == 'Empleado') ? 'Hola' :
  (login == 'Director') ? 'Felicidades' :
  (login == '') ? 'Sin sesión' :
  '';
        
      
      
      ",
	"url": "https://es.javascript.info/ifelse" 
},
{
	"docs_id": "15",
	"name": "Operadores Lógicos",
	"description": "Hay cuatro operadores lógicos en JavaScript: || (O), && (Y), ! (NO), ?? (Fusión de nulos). Aquí cubrimos los primeros tres, el operador  ?? se verá en el siguiente artículo.",
	"content": "Hay cuatro operadores lógicos en JavaScript: || (O), && (Y), ! (NO), ?? (Fusión de nulos). Aquí cubrimos los primeros tres, el operador  ?? se verá en el siguiente artículo.
Aunque sean llamados lógicos, pueden ser aplicados a valores de cualquier tipo, no solo booleanos. El resultado también puede ser de cualquier tipo.
Veamos los detalles.
|| (OR)El operador OR se representa con dos símbolos de linea vertical:

      
        
        
          result = a || b;
        
      
      
      En la programación clásica, el OR lógico esta pensado para manipular solo valores booleanos. Si cualquiera de sus argumentos es true, retorna true, de lo contrario retorna false.
En JavaScript, el operador es un poco más complicado y poderoso. Pero primero, veamos qué pasa con los valores booleanos.
Hay cuatro combinaciones lógicas posibles:

      
        
        
          
            
          
          
            
          
        
        
          alert(true || true); // true (verdadero)
alert(false || true); // true
alert(true || false); // true
alert(false || false); // false (falso)
        
      
      
      Como podemos ver, el resultado es siempre true excepto cuando ambos operandos son false.
Si un operando no es un booleano, se lo convierte a booleano para la evaluación.
Por ejemplo, el número 1 es tratado como true, el número 0 como false:

      
        
        
          
            
          
          
            
          
        
        
          if (1 || 0) { // Funciona como if( true || false )
  alert("valor verdadero!");
}
        
      
      
      La mayoría de las veces, OR || es usado en una declaración if para probar si alguna de las condiciones dadas es true.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 9;

if (hour < 10 || hour > 18) {
  alert( 'La oficina esta cerrada.' );
}
        
      
      
      Podemos pasar mas condiciones:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 12;
let isWeekend = true;

if (hour < 10 || hour > 18 || isWeekend) {
  alert("La oficina esta cerrada."); // Es fin de semana
}
        
      
      
      OR "||" encuentra el primer valor verdaderoLa lógica descrita arriba es algo clásica. Ahora, mostremos las características “extra” de JavaScript.
El algoritmo extendido trabaja de la siguiente forma.
Dado múltiples valores aplicados al operador OR:

      
        
        
          result = value1 || value2 || value3;
        
      
      
      El operador OR || realiza lo siguiente:

Evalúa los operandos de izquierda a derecha.
Para cada operando, convierte el valor a booleano. Si el resultado es true, se detiene y retorna el valor original de ese operando.
Si todos los operandos han sido evaluados (todos eran false), retorna el ultimo operando.

Un valor es retornado en su forma original, sin la conversión.
En otras palabras, una cadena de OR "||" devuelve el primer valor verdadero o el último si ningún verdadero es encontrado.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert(1 || 0); // 1 (1 es un valor verdadero)

alert(null || 1); // 1 (1 es el primer valor verdadero)
alert(null || 0 || 1); // 1 (el primer valor verdadero)

alert(undefined || null || 0); // 0 (todos son valores falsos, retorna el último valor)
        
      
      
      Esto brinda varios usos interesantes comparados al “OR puro, clásico, de solo booleanos”.


Obtener el primer valor verdadero de una lista de variables o expresiones.
Por ejemplo, tenemos las variables firstName, lastName y nickName, todas opcionales (pueden ser undefined o tener valores falsos).
Usemos OR || para elegir el que tiene los datos y mostrarlo (o anónimo si no hay nada configurado):

      
        
        
          
            
          
          
            
          
        
        
          let firstName = "";
let lastName = "";
let nickName = "SuperCoder";

alert( firstName || lastName || nickName || "Anonymous"); // SuperCoder
        
      
      
      Si todas las variables fueran falsas, aparecería "Anonymous".


Evaluación del camino más corto.


Otra característica de OR || operador es la evaluación de “el camino más corto”.
Esto significa que || procesa sus argumentos hasta que se alcanza el primer valor verdadero, y luego el valor se devuelve inmediatamente, sin siquiera tocar el otro argumento.
La importancia de esta característica se vuelve obvia si un operando no es solo un valor, sino una expresión con un efecto secundario, como una asignación de variable o una llamada a función.

En el siguiente ejemplo, solo se imprime el segundo mensaje:

      
        
        
          
            
          
          
            
          
        
        
          true || alert("not printed");
false || alert("printed");
        
      
      
      En la primera línea, el operador OR || detiene la evaluación inmediatamente después de ver que es verdadera, por lo que la alerta no se ejecuta.
A veces, las personas usan esta función para ejecutar comandos solo si la condición en la parte izquierda es falsa.
&& (AND)El operador AND es representado con dos ampersands &&:

      
        
        
          result = a && b;
        
      
      
      En la programación clásica, AND retorna true si ambos operandos son valores verdaderos y false en cualquier otro caso.

      
        
        
          
            
          
          
            
          
        
        
          alert(true && true); // true
alert(false && true); // false
alert(true && false); // false
alert(false && false); // false
        
      
      
      Un ejemplo con if:

      
        
        
          
            
          
          
            
          
        
        
          let hour = 12;
let minute = 30;

if (hour == 12 && minute == 30) {
  alert("La hora es 12:30");
}
        
      
      
      Al igual que con OR, cualquier valor es permitido como operando de AND:

      
        
        
          
            
          
          
            
          
        
        
          if (1 && 0) { // evaluado como true && false
  alert( "no funcionará porque el resultado es un valor falso" );
}
        
      
      
      AND “&&” encuentra el primer valor falsoDado múltiples valores aplicados al operador AND:

      
        
        
          result = value1 && value2 && value3;
        
      
      
      El operador AND && realiza lo siguiente:

Evalúa los operandos de izquierda a derecha.
Para cada operando, los convierte a un booleano. Si el resultado es false, se detiene y retorna el valor original de dicho operando.
Si todos los operandos han sido evaluados (todos fueron valores verdaderos), retorna el último operando.

En otras palabras, AND retorna el primer valor falso o el último valor si ninguno fue encontrado.
Las reglas anteriores son similares a las de OR. La diferencia es que AND retorna el primer valor falso mientras que OR retorna el primer valor verdadero.
Ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // si el primer operando es un valor verdadero,
// AND retorna el segundo operando:
alert(1 && 0); // 0
alert(1 && 5); // 5

// si el primer operando es un valor falso,
// AND lo retorna. El segundo operando es ignorado
alert(null && 5); // null
alert(0 && "cualquier valor"); // 0
        
      
      
      También podemos pasar varios valores de una vez. Observa como el primer valor falso es retornado:

      
        
        
          
            
          
          
            
          
        
        
          alert(1 && 2 && null && 3); // null
        
      
      
      Cuando todos los valores son verdaderos, el último valor es retornado:

      
        
        
          
            
          
          
            
          
        
        
          alert(1 && 2 && 3); // 3, el último.
        
      
      
      
            La precedencia de AND && es mayor que la de OR ||
            La precedencia del operador AND && es mayor que la de OR ||.
Así que el código a && b || c && d es básicamente el mismo que si la expresiones && estuvieran entre paréntesis: (a && b) || (c && d)


            No remplace if con || ni &&
            A veces, la gente usa el operador AND && como una "forma más corta de escribir if".
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

(x > 0) && alert("¡Mayor que cero!");
        
      
      
      La acción en la parte derecha de && sería ejecutada sólo si la evaluación la alcanza. Eso es, solo si (x > 0) es verdadero.
Así que básicamente tenemos un análogo para:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

if (x > 0) alert("Mayor que cero!");
        
      
      
      Aunque la variante con && parece más corta, if es más obvia y tiende a ser un poco más legible. Por lo tanto, recomendamos usar cada construcción para su propósito: use if si queremos si y use&&si queremos AND.

! (NOT)El operador booleano NOT se representa con un signo de exclamación !.
La sintaxis es bastante simple:

      
        
        
          result = !value;
        
      
      
      El operador acepta un solo argumento y realiza lo siguiente:

Convierte el operando al tipo booleano: true/false.
Retorna el valor contrario.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert(!true); // false
alert(!0); // true
        
      
      
      Un doble NOT !! es a veces usado para convertir un valor al tipo booleano:

      
        
        
          
            
          
          
            
          
        
        
          alert(!!"cadena de texto no vacía"); // true
alert(!!null); // false
        
      
      
      Eso es, el primer NOT convierte el valor a booleano y retorna el inverso, y el segundo NOT lo invierte de nuevo. Al final, tenemos una simple conversión a booleano.
Hay una manera un poco mas prolija de realizar lo mismo – una función integrada Boolean:

      
        
        
          
            
          
          
            
          
        
        
          alert(Boolean("cadena de texto no vacía")); // true
alert(Boolean(null)); // false
        
      
      
      La precedencia de NOT ! es la mayor de todos los operadores lógicos, así que siempre se ejecuta primero, antes que && o ||.
Tareas¿Cuál es el resultado de OR?importancia: 5¿Cuál será la salida del siguiente código?

      
        
        
          alert( null || 2 || undefined );
        
      
      
      soluciónLa respuesta es 2, ese es el primer valor verdadero.

      
        
        
          
            
          
          
            
          
        
        
          alert( null || 2 || undefined );
        
      
      
      ¿Cuál es el resultado de las alertas aplicadas al operador OR?importancia: 3¿Cuál será la salida del siguiente código?

      
        
        
          alert( alert(1) || 2 || alert(3) );
        
      
      
      soluciónLa repuesta: primero 1, después 2.

      
        
        
          
            
          
          
            
          
        
        
          alert( alert(1) || 2 || alert(3) );
        
      
      
      La llamada a alert no retorna un valor. O, en otras palabras, retorna undefined.

El primer OR || evalúa el operando de la izquierda alert(1). Eso muestra el primer mensaje con 1.
El alert retorna undefined, por lo que OR se dirige al segundo operando buscando un valor verdadero.
El segundo operando 2 es un valor verdadero, por lo que se detiene la ejecución, se retorna 2 y es mostrado por el alert exterior.

No habrá 3 debido a que la evaluación no alcanza a alert(3).
¿Cuál es el resultado de AND?importancia: 5¿Cuál será la salida del siguiente código?

      
        
        
          alert( 1 && null && 2 );
        
      
      
      soluciónLa respuesta: null, porque es el primer valor falso de la lista.

      
        
        
          
            
          
          
            
          
        
        
          alert(1 && null && 2);
        
      
      
      ¿Cuál es el resultado de las alertas aplicadas al operador AND?importancia: 3¿Cuál será la salida del siguiente código?

      
        
        
          alert( alert(1) && alert(2) );
        
      
      
      soluciónLa respuesta: 1 y después undefined.

      
        
        
          
            
          
          
            
          
        
        
          alert( alert(1) && alert(2) );
        
      
      
      La llamada a alert retorna undefined (solo muestra un mensaje, así que no hay un valor que retornar relevante)
Debido a ello, && evalúa el operando de la izquierda (imprime 1) e inmediatamente se detiene porque undefined es un valor falso. Como && busca un valor falso y lo retorna, terminamos.
El resultado de OR AND ORimportancia: 5¿Cuál será el resultado?

      
        
        
          alert( null || 2 && 3 || 4 );
        
      
      
      soluciónLa respuesta: 3.

      
        
        
          
            
          
          
            
          
        
        
          alert( null || 2 && 3 || 4 );
        
      
      
      La precedencia de AND && es mayor que la de ||, así que se ejecuta primero.
El resultado de 2 && 3 = 3, por lo que la expresión se convierte en:

      
        
        
          null || 3 || 4
        
      
      
      Ahora el resultado será el primer valor verdadero: 3.
Comprueba el rango por dentroimportancia: 3Escribe una condición “if” para comprobar que age(edad) está entre 14 y 90 inclusive.
“Inclusive” significa que age puede llegar a ser uno de los extremos, 14 o 90.
solución
      
        
        
          if (age >= 14 && age <= 90)
        
      
      
      Comprueba el rango por fueraimportancia: 3Escribe una condición if para comprobar que age NO está entre 14 y 90 inclusive.
Crea dos variantes: la primera usando NOT !, y la segunda sin usarlo.
soluciónLa primer variante:

      
        
        
          if (!(age >= 14 && age <= 90))
        
      
      
      La segunda variante:

      
        
        
          if (age < 14 || age > 90)
        
      
      
      Un pregunta acerca de "if"importancia: 5¿Cuáles de estos alerts va a ejecutarse?
¿Cuáles serán los resultados de las expresiones dentro de if(...)?

      
        
        
          if (-1 || 0) alert( "primero" );
if (-1 && 0) alert( "segundo" );
if (null || -1 && 1) alert( "tercero" );
        
      
      
      soluciónLa respuesta: el primero y el tercero serán ejecutados.
Detalles:

      
        
        
          
            
          
          
            
          
        
        
          // Corre.
// El resultado de -1 || 0 = -1, valor verdadero
if (-1 || 0) alert( "primero" );

// No corre.
// -1 && 0 = 0, valor falso
if (-1 && 0) alert( "segundo" );

// Se ejecuta
// El operador && tiene mayor precedencia que ||
// Así que -1 && 1 se ejecuta primero, dándonos la cadena:
// null || -1 && 1  ->  null || 1  ->  1
if (null || -1 && 1) alert( "tercero" );
        
      
      
      Comprueba el inicio de sesiónimportancia: 3Escribe un código que pregunte por el inicio de sesión con propmt.
Si el visitante ingresa "Admin", entonces prompt(pregunta) por una contraseña, si la entrada es una linea vacía o Esc – muestra “Cancelado.”, si es otra cadena de texto – entonces muestra “No te conozco”.
La contraseña se comprueba de la siguiente manera:

Si es igual a “TheMaster”, entonces muestra “Bienvenido!”,
Si es otra cadena de texto – muetra “Contraseña incorrecta”,
Para una cadena de texto vacía o una entrada cancelada, muestra “Cancelado.”

El esquema:

      
      
        
      
      Por favor usa bloques anidados de if. Piensa en la legibilidad general del código.
Pista: si se le pasa una entrada vacía a un prompt, retorna una cadena de texto vacía ''. Presionando ESC durante un prompt retorna null.
Ejecutar el demosolución
      
        
        
          
            
          
          
            
          
        
        
          let userName = prompt("Quién está ahí?", "");

if (userName == "Admin") {

    let pass = prompt("¿Contraseña?", "");

    if (pass === "TheMaster") {
  alert( "Bienvenido!" );
    } else if (pass === "" || pass === null) {
  alert( "Cancelado." );
    } else {
  alert( "Contraseña incorrecta" );
    }

} else if (userName === "" || userName === null) {
    alert( "Canceledo" );
} else {
    alert( "No te conozco" );
}
        
      
      
      Nota las sangrías verticales dentro de los bloques if. Técnicamente no son necesarias, pero facilitan la lectura del código.
",
	"url": "https://es.javascript.info/logical-operators" 
},
{
	"docs_id": "16",
	"name": "Operador Nullish Coalescing '??'",
	"description": "El operador “nullish coalescing” (fusión de null) se escribe con un doble signo de cierre de interrogación ??.",
	"content": "
            Una adición reciente
            
            Esta es una adición reciente al lenguaje.
            Los navegadores antiguos pueden necesitar polyfills.
            
El operador “nullish coalescing” (fusión de null) se escribe con un doble signo de cierre de interrogación ??.
Como este trata a null y a undefined de forma similar, usaremos un término especial para este artículo. Diremos que una expresión es “definida” cuando no es null ni undefined.
El resultado de a ?? b:

si a está “definida”, será a,
si a no está “definida”, será b.

Es decir, ?? devuelve el primer argumento cuando este no es null ni undefined. En caso contrario, devuelve el segundo.
El operador “nullish coalescing” no es algo completamente nuevo. Es solamente una sintaxis agradable para obtener el primer valor “definido” de entre dos.
Podemos reescribir result = a ?? b usando los operadores que ya conocemos:

      
        
        
          result = (a !== null && a !== undefined) ? a : b;
        
      
      
      Ahora debería estar absolutamente claro lo que ?? hace. Veamos dónde podemos utilizarlo.
El uso típico de ?? es brindar un valor predeterminado.
Por ejemplo, aquí mostramos user si su valor está “definido” (que no es null ni undefined). De otro modo, muestra Anonymous:

      
        
        
          
            
          
          
            
          
        
        
          let user;

alert(user ?? "Anonymous"); // Anonymous (user no definido)
        
      
      
      Aquí el ejemplo de user con un nombre asignado:

      
        
        
          
            
          
          
            
          
        
        
          let user = "John";

alert(user ?? "Anonymous"); // John (user definido)
        
      
      
      También podemos usar una secuencia de ?? para seleccionar el primer valor que no sea null/undefined de una lista.
Digamos que tenemos los datos de un usuario en las variables firstName, lastName y nickName. Todos ellos podrían ser indefinidos si el usuario decide no ingresar los valores correspondientes.
Queremos mostrar un nombre usando una de estas variables, o mostrar “anónimo” si todas ellas son null/undefined.
Usemos el operador ?? para ello:

      
        
        
          
            
          
          
            
          
        
        
          let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// Muestra el primer valor definido:
alert(firstName ?? lastName ?? nickName ?? "Anonymous"); // Supercoder
        
      
      
      Comparación con ||El operador OR || puede ser usado de la misma manera que ??, tal como está explicado en el capítulo previo
Por ejemplo, en el código de arriba podemos reemplazar ?? por || y obtener el mismo resultado:

      
        
        
          
            
          
          
            
          
        
        
          let firstName = null;
let lastName = null;
let nickName = "Supercoder";

// muestra el primer valor "verdadero":
alert(firstName || lastName || nickName || "Anonymous"); // Supercoder
        
      
      
      Históricamente, el operador OR || estuvo primero. Existe desde el origen de JavaScript, así que los desarrolladores lo estuvieron usando para tal propósito durante mucho tiempo.
Por otro lado, el operador “nullish coalescing” ?? fue una adición reciente, y la razón es que la gente no estaba del todo satisfecha con ||.
La gran diferencia es que:

|| devuelve el primer valor verdadero.
?? devuelve el primer valor definido.

El || no distingue entre false, 0, un string vacío "", y null/undefined.  Todos son lo mismo: valores “falsos”. Si cualquiera de ellos es el primer argumento de ||, obtendremos el segundo argumento como resultado.
Pero en la práctica podemos querer usar el valor predeterminado solamente cuando la variable es null/undefined, es decir cuando el valor realmente es desconocido o no fue establecido.
Por ejemplo considera esto:

      
        
        
          
            
          
          
            
          
        
        
          let height = 0; // altura cero

alert(height || 100); // 100
alert(height ?? 100); // 0
        
      
      
      height || 100 verifica si height es “falso”, y 0 lo es.
- así el resultado de || es el segundo argumento, 100.
height ?? 100 verifica si height es null/undefined, y no lo es.
- así el resultado es height como está, que es 0.
En la práctica, una altura cero es a menudo un valor válido que no debería ser reemplazado por un valor por defecto. En este caso ?? hace lo correcto.
PrecedenciaLa precedencia del operador ?? es la misma de ||. Ambos son iguales a 4 en la Tabla MDN.
Esto significa que ambos operadores, || y ??, son evaluados antes que = y ?, pero después de la mayoría de las demás operaciones como + y *.
Así que podemos necesitar añadir paréntesis:

      
        
        
          
            
          
          
            
          
        
        
          let height = null;
let width = null;

// Importante: usar paréntesis
let area = (height ?? 100) * (width ?? 50);

alert(area); // 5000
        
      
      
      Caso contrario, si omitimos los paréntesis, entonces * tiene una mayor precedencia y se ejecutará primero. Eso sería lo mismo que:

      
        
        
          // sin paréntesis
let area = height ?? 100 * width ?? 50;

// ...funciona de esta forma (no es lo que queremos):
let area = height ?? (100 * width) ?? 50;
        
      
      
      Uso de ?? con && y ||Por motivos de seguridad, JavaScript prohíbe el uso de ?? junto con los operadores && y ||, salvo que la precedencia sea explícitamente especificada con paréntesis.
El siguiente código desencadena un error de sintaxis:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1 && 2 ?? 3; // Syntax error
        
      
      
      La limitación es debatible. Fue agregada a la especificación del lenguaje con propósito de evitar equivocaciones cuando la gente comenzara a reemplazar || por ??.
Usa paréntesis explícitos para solucionarlo:

      
        
        
          
            
          
          
            
          
        
        
          let x = (1 && 2) ?? 3; // Funciona

alert(x); // 2
        
      
      
      Resumen

El operador “nullish coalescing” ?? brinda una manera concisa de seleccionar un valor “definido” de una lista.
Es usado para asignar valores por defecto a las variables:

      
        
        
          // Asignar height=100, si height es null o undefined
height = height ?? 100;
        
      
      
      

El operador ?? tiene una precedencia muy baja, un poco más alta que ? y =.


Está prohibido su uso con || y && sin paréntesis explícitos.


",
	"url": "https://es.javascript.info/nullish-coalescing-operator" 
},
{
	"docs_id": "17",
	"name": "Bucles: while y for",
	"description": "Usualmente necesitamos repetir acciones.",
	"content": "Usualmente necesitamos repetir acciones.
Por ejemplo, mostrar los elementos de una lista uno tras otro o simplemente ejecutar el mismo código para cada número del 1 al 10.
Los Bucles son una forma de repetir el mismo código varias veces.

            Los bucles for…of y for…in
            Un pequeño anuncio para lectores avanzados.
Este artículo cubre solamente los bucles básicos: while, do..while y for(..;..;..).
Si llegó a este artículo buscando otro tipo de bucles, aquí están los enlaces:

Vea for…in para bucles sobre propiedades de objetos.
Vea for…of e iterables para bucles sobre arrays y objetos iterables.

De otra manera, por favor continúe leyendo.

El bucle “while”El bucle while (mientras) tiene la siguiente sintaxis:

      
        
        
          while (condition) {
  // código
  // llamado "cuerpo del bucle"
}
        
      
      
      Mientras la condición condition sea verdadera, el código del cuerpo del bucle será ejecutado.
Por ejemplo, el bucle debajo imprime i mientras se cumpla i < 3:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 3) { // muestra 0, luego 1, luego 2
  alert( i );
  i++;
}
        
      
      
      Cada ejecución del cuerpo del bucle se llama iteración. El bucle en el ejemplo de arriba realiza 3 iteraciones.
Si faltara i++ en el ejemplo de arriba, el bucle sería repetido (en teoría) eternamente. En la práctica, el navegador tiene maneras de detener tales bucles desmedidos; y en el JavaScript del lado del servidor, podemos eliminar el proceso.
Cualquier expresión o variable puede usarse como condición del bucle, no solo las comparaciones: El while evaluará y transformará la condición a un booleano.
Por ejemplo, una manera más corta de escribir while (i != 0) es while (i):

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;
while (i) { // cuando i sea 0, la condición se volverá falsa y el bucle se detendrá
  alert( i );
  i--;
}
        
      
      
      
            Las llaves no son requeridas para un cuerpo de una sola línea
            Si el cuerpo del bucle tiene una sola sentencia, podemos omitir las llaves {…}:

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;
while (i) alert(i--);
        
      
      
      
El bucle “do…while”La comprobación de la condición puede ser movida debajo del cuerpo del bucle usando la sintaxis do..while:

      
        
        
          do {
  // cuerpo del bucle
} while (condition);
        
      
      
      El bucle primero ejecuta el cuerpo, luego comprueba la condición, y, mientras sea un valor verdadero, la ejecuta una y otra vez.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
        
      
      
      Esta sintaxis solo debe ser usada cuando quieres que el cuerpo del bucle sea ejecutado al menos una vez sin importar que la condición sea verdadera. Usualmente, se prefiere la otra forma: while(…) {…}.
El bucle “for”El bucle for es más complejo, pero también el más usado.
Se ve así:

      
        
        
          for (begin; condition; step) { // (comienzo, condición, paso)
  // ... cuerpo del bucle ...
}
        
      
      
      Aprendamos el significado de cada parte con un ejemplo. El bucle debajo corre alert(i) para i desde 0 hasta (pero no incluyendo) 3:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) { // muestra 0, luego 1, luego 2
  alert(i);
}
        
      
      
      Vamos a examinar la declaración for parte por parte:



parte






comienzo
let i = 0
Se ejecuta una vez al comienzo del bucle.


condición
i < 3
Comprobada antes de cada iteración del bucle. Si es falsa, el bucle finaliza.


cuerpo
alert(i)
Se ejecuta una y otra vez mientras la condición sea verdadera.


paso
i++
Se ejecuta después del cuerpo en cada iteración.



El algoritmo general del bucle funciona de esta forma:

      
        
        
          Se ejecuta comenzar
→ (si condición → ejecutar cuerpo y ejecutar paso)
→ (si condición → ejecutar cuerpo y ejecutar paso)
→ (si condición → ejecutar cuerpo y ejecutar paso)
→ ...
        
      
      
      Si eres nuevo en bucles, te podría ayudar regresar al ejemplo y reproducir cómo se ejecuta paso por paso en una pedazo de papel.
Esto es lo que sucede exactamente en nuestro caso:

      
        
        
          // for (let i = 0; i < 3; i++) alert(i)

// se ejecuta comenzar
let i = 0
// si condición → ejecutar cuerpo y ejecutar paso
if (i < 3) { alert(i); i++ }
// si condición → ejecutar cuerpo y ejecutar paso
if (i < 3) { alert(i); i++ }
// si condición → ejecutar cuerpo y ejecutar paso
if (i < 3) { alert(i); i++ }
// ...finaliza, porque ahora i == 3
        
      
      
      
            Declaración de variable en línea
            Aquí, la variable “counter” i es declarada en el bucle. Esto es llamado una declaración de variable “en línea”. Dichas variables son visibles solo dentro del bucle.

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {
  alert(i); // 0, 1, 2
}
alert(i); // error, no existe dicha variable
        
      
      
      En vez de definir una variable, podemos usar una que ya exista:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

for (i = 0; i < 3; i++) { // usa una variable existente
  alert(i); // 0, 1, 2
}

alert(i); // 3, visible, porque fue declarada fuera del bucle
        
      
      
      
Omitiendo partesCualquier parte de for puede ser omitida.
Por ejemplo, podemos quitar comienzo si no necesitamos realizar nada al inicio del bucle.
Como aquí:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0; // Ya tenemos i declarada y asignada

for (; i < 3; i++) { // no hay necesidad de "comenzar"
  alert( i ); // 0, 1, 2
}
        
      
      
      También podemos eliminar la parte paso:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

for (; i < 3;) {
  alert( i++ );
}
        
      
      
      Esto hace al bucle idéntico a while (i < 3).
En realidad podemos eliminar todo, creando un bucle infinito:

      
        
        
          for (;;) {
  // se repite sin limites
}
        
      
      
      Por favor, nota que los dos punto y coma ; del for deben estar presentes. De otra manera, habría un error de sintaxis.
Rompiendo el bucleNormalmente, se sale de un bucle cuando la condición se vuelve falsa.
Pero podemos forzar una salida en cualquier momento usando la directiva especial break.
Por ejemplo, el bucle debajo le pide al usuario por una serie de números, “rompiéndolo” cuando un número no es ingresado:

      
        
        
          let sum = 0;

while (true) {

  let value = +prompt("Ingresa un número", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Suma: ' + sum );
        
      
      
      La directiva break es activada en la línea (*) si el usuario ingresa una línea vacía o cancela la entrada. Detiene inmediatamente el bucle, pasando el control a la primera línea después de el bucle. En este caso, alert.
La combinación “bucle infinito + break según sea necesario” es ideal en situaciones donde la condición del bucle debe ser comprobada no al inicio o al final de el bucle, sino a la mitad o incluso en varias partes del cuerpo.
Continuar a la siguiente iteraciónLa directiva continue es una “versión más ligera” de break. No detiene el bucle completo. En su lugar, detiene la iteración actual y fuerza al bucle a comenzar una nueva (si la condición lo permite).
Podemos usarlo si hemos terminado con la iteración actual y nos gustaría movernos a la siguiente.
El bucle debajo usa continue para mostrar solo valores impares:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 10; i++) {

  // si es verdadero, saltar el resto del cuerpo
  if (i % 2 == 0) continue;

  alert(i); // 1, luego 3, 5, 7, 9
}
        
      
      
      Para los valores pares de i, la directiva continue deja de ejecutar el cuerpo y pasa el control a la siguiente iteración de for (con el siguiente número). Así que el alert solo es llamado para valores impares.

            La directiva continue ayuda a disminuir la anidación
            Un bucle que muestra valores impares podría verse así:

      
        
        
          for (let i = 0; i < 10; i++) {

  if (i % 2) {
    alert( i );
  }

}
        
      
      
      Desde un punto de vista técnico, esto es idéntico al ejemplo de arriba. Claro, podemos simplemente envolver el código en un bloque if en vez de usar continue.
Pero como efecto secundario, esto crearía un nivel más de anidación (la llamada a alert dentro de las llaves). Si el código dentro de if posee varias líneas, eso podría reducir la legibilidad en general.


            No break/continue a la derecha de ‘?’
            Por favor, nota que las construcciones sintácticas que no son expresiones no pueden user usadas con el operador ternario ?. En particular, directivas como break/continue no son permitidas aquí.
Por ejemplo, si tomamos este código:

      
        
        
          if (i > 5) {
  alert(i);
} else {
  continue;
}
        
      
      
      …y lo reescribimos usando un signo de interrogación:

      
        
        
          (i > 5) ? alert(i) : continue; // continue no está permitida aquí
        
      
      
      …deja de funcionar. Código como este generará un error de sintaxis:
Esta es otra razón por la cual se recomienda no usar el operador de signo de interrogación ? en lugar de if.

Etiquetas para break/continueA veces necesitamos salirnos de múltiples bucles anidados al mismo tiempo.
Por ejemplo, en el código debajo usamos un bucle sobre i y j, solicitando las coordenadas (i,j) de (0,0) a (3,3):

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Valor en las coordenadas (${i},${j})`, '');

    // ¿Y si quiero salir de aquí hacia Listo (debajo)?

  }
}

alert('Listo!');
        
      
      
      Necesitamos una manera de detener el proceso si el usuario cancela la entrada.
El break ordinario después de input solo nos sacaría del bucle interno. Eso no es suficiente. ¡Etiquetas, vengan al rescate!
Una etiqueta es un identificador con un signo de dos puntos “:” antes de un bucle:

      
        
        
          labelName: for (...) {
  ...
}
        
      
      
      La declaración break <labelName> en el bucle debajo nos saca hacia la etiqueta:

      
        
        
          
            
          
          
            
          
        
        
          outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Value at coords (${i},${j})`, '');

    // Si es una cadena de texto vacía o se canceló, entonces salir de ambos bucles
    if (!input) break outer; // (*)

    // hacer algo con el valor...
  }
}

alert('Listo!');
        
      
      
      En el código de arriba, break outer mira hacia arriba por la etiqueta llamada outer y nos saca de dicho bucle.
Así que el control va directamente de (*) a alert('Listo!').
También podemos mover la etiqueta a una línea separada:

      
        
        
          outer:
for (let i = 0; i < 3; i++) { ... }
        
      
      
      La directiva continue también puede usar usada con una etiqueta. En este caso, la ejecución del código salta a la siguiente iteración del bucle etiquetado.

            Las etiquetas no son “goto”
            Las etiquetas no nos permiten saltar a un lugar arbitrario en el código.
Por ejemplo, es imposible hacer esto:

      
        
        
          break label;  // ¿saltar a label? No funciona.

label: for (...)
        
      
      
      Una directiva break debe estar en el interior del bucle. Aunque, técnicamente, puede estar en cualquier bloque de código etiquetado:

      
        
        
          label: {
  // ...
  break label; // funciona
  // ...
}
        
      
      
      …Aunque 99.9% del tiempo break se usa dentro de bucles, como hemos visto en ejemplos previos.
Un continue es solo posible dentro de un bucle.

ResumenCubrimos 3 tipos de bucles:

while – La condición es comprobada antes de cada iteración.
do..while –  La condición es comprobada después de cada iteración.
for (;;) –  La condición es comprobada antes de cada iteración, con ajustes adicionales disponibles.

Para crear un bucle “infinito”, usualmente se usa while(true). Un bucle como este, tal y como cualquier otro, puede ser detenido con la directiva break.
Si queremos detener la iteración actual y adelantarnos a la siguiente, podemos usar la directiva continue.
break/continue soportan etiquetas antes del bucle. Una etiqueta es la única forma de usar break/continue para escapar de un bucle anidado para ir a uno exterior.
TareasÚltimo valor del bucleimportancia: 3¿Cuál es el último valor mostrado en alerta por este código? ¿Por qué?

      
        
        
          let i = 3;

while (i) {
  alert( i-- );
}
        
      
      
      soluciónLa respuesta: 1.

      
        
        
          
            
          
          
            
          
        
        
          let i = 3;

while (i) {
  alert( i-- );
}
        
      
      
      Cada iteración del bucle disminuye i en 1. La comprobación while(i) detiene el bucle cuando i = 0.
Por consiguiente, los pasos del bucle forman la siguiente secuencia (“bucle desenrollado”).

      
        
        
          let i = 3;

alert(i--); // muestra 3, disminuye i a 2

alert(i--) // muestra 2, disminuye i a 1

alert(i--) // muestra 1, disminuye i a 0

// listo, while(i) comprueba y detiene el bucle
        
      
      
      ¿Qué valores serán mostrados por el bucle while?importancia: 4Para cada iteración del bucle, escribe qué valor será impreso y luego compáralo con la solución.
Ambos bucles ¿alertan los mismos valores?


La forma de prefijo ++i:

      
        
        
          let i = 0;
while (++i < 5) alert( i );
        
      
      
      

La forma de sufijo i++

      
        
        
          let i = 0;
while (i++ < 5) alert( i );
        
      
      
      

soluciónLa tarea demuestra cómo las formas de sufijo y prefijo pueden llevar a diferentes resultados cuando son usadas en comparaciones.


Del 1 al 4

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (++i < 5) alert( i );
        
      
      
      El primer valor es i = 1, porque ++i primero incrementa i y luego retorna el valor nuevo. Así que la primera comparación es 1 < 5 y el alert muestra 1.
Entonces siguen 2, 3, 4… – los valores son mostrados uno tras otro. La comparación siempre usa el valor incrementado, porque ++ está antes de la variable.
Finalmente, i = 4 es incrementada a 5, la comparación while(5 < 5) falla, y el bucle se detiene. Así que 5 no es mostrado.


Del 1 al 5

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i++ < 5) alert( i );
        
      
      
      El primer valor es de nuevo i = 1. La forma del sufijo de i++ incrementa i y luego retorna el valor viejo, así que la comparación i++ < 5 usará i = 0 (contrario a ++i < 5).
Pero la llamada a alert está separada. Es otra declaración, la cual se ejecuta luego del incremento y la comparación. Así que obtiene el i = 1 actual.
Luego siguen 2, 3, 4…
Detengámonos en i = 4. La forma del prefijo ++i lo incrementaría y usaría 5 en la comparación. Pero aquí tenemos la forma del sufijo i++. Así que incrementa i a 5, pero retorna el valor viejo. Por lo tanto, la comparación es en realidad while(4 < 5) – verdadero, y el control sigue a alert.
El valor i = 5 es el último, porque el siguiente paso while(5 < 5) es falso.


¿Qué valores serán mostrados por el bucle "for"?importancia: 4Para cada bucle, anota qué valores mostrará y luego compara las respuestas.
Ambos bucles, ¿muestran en alert los mismos valores?


La forma del sufijo:

      
        
        
          for (let i = 0; i < 5; i++) alert( i );
        
      
      
      

La forma del prefijo:

      
        
        
          for (let i = 0; i < 5; ++i) alert( i );
        
      
      
      

soluciónLa respuesta: de 0a 4 en ambos casos.

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 5; ++i) alert( i );

for (let i = 0; i < 5; i++) alert( i );
        
      
      
      Eso puede ser fácilmente deducido del algoritmo de for:

Ejecutar i = 0 una vez antes de todo (comienzo).
Comprobar la condición i < 5.
Si true – ejecutar el cuerpo del bucle alert(i) y luego i++.

El incremento i++ es separado de la comprobación de la condición (2). Es simplemente otra declaración.
El valor retornado por el incremento no es usado aquí, así que no hay diferencia entre i++ y ++i.
Muestra números pares en el bucleimportancia: 5Usa el bucle for para mostrar números pares del 2 al 10.
Ejecutar el demosolución
      
        
        
          
            
          
          
            
          
        
        
          for (let i = 2; i <= 10; i++) {
  if (i % 2 == 0) {
    alert( i );
  }
}
        
      
      
      Usamos el operador “modulo” % para conseguir el resto y comprobar la paridad.
Reemplaza "for" por "while"importancia: 5Reescribe el código cambiando el bucle for a while sin alterar su comportamiento (la salida debería ser la misma).

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {
  alert( `número ${i}!` );
}
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 3) {
  alert( `número ${i}!` );
  i++;
}
        
      
      
      Repite hasta que la entrada sea correctaimportancia: 5Escribe un bucle que solicite un número mayor que 100. Si el usuario ingresa otro número – pídele que ingrese un valor de nuevo.
El bucle debe pedir un número hasta que el usuario ingrese un número mayor que 100 o bien cancele la entrada/ingrese una linea vacía.
Aquí podemos asumir que el usuario solo ingresará números. No hay necesidad de implementar un manejo especial para entradas no numéricas en esta tarea.
Ejecutar el demosolución
      
        
        
          
            
          
          
            
          
        
        
          let num;

do {
  num = prompt("Ingresa un número mayor a 100", 0);
} while (num <= 100 && num);
        
      
      
      El bucle do..while se repite mientras ambas condiciones sean verdaderas:

La condición num <= 100 – eso es, el valor ingresado aún no es mayor que 100.
La condición && num es falsa cuando num es null o una cadena de texto vacía. Entonces el bucle while se detiene.

PD. Si num es null entonces num <= 100 es true, así que sin la segunda condición el bucle no se detendría si el usuario hace click en CANCELAR. Ambas comprobaciones son requeridas.
Muestra números primosimportancia: 3Un número entero mayor que 1 es llamado primo si no puede ser dividido sin un resto por ningún número excepto 1 y él mismo.
En otras palabras, n > 1 es un primo si no puede ser divido exactamente por ningún número excepto 1 y n.
Por ejemplo, 5 es un primo, porque no puede ser divido exactamente por 2, 3 y 4.
Escribe el código que muestre números primos en el intervalo de 2 a n.
Para n = 10 el resultado será 2, 3, 5, 7.
PD. El código debería funcionar para cualquier n, no debe estar programado para valores fijos.
soluciónHay muchos algoritmos para esta tarea.
Usemos un bucle anidado.

      
        
        
          Por cada i en el intervalo {
  comprobar si i tiene un divisor en 1..i
  si tiene => el valor no es un primo
  si no => el valor es un primo, mostrarlo
}
        
      
      
      El código usando una etiqueta:

      
        
        
          
            
          
          
            
          
        
        
          let n = 10;

nextPrime:
for (let i = 2; i <= n; i++) { // por cada i...

  for (let j = 2; j < i; j++) { // buscar un divisor..
    if (i % j == 0) continue nextPrime; // no es primo, ir al próximo i
  }

  alert( i ); // primo
}
        
      
      
      Hay mucho lugar para la mejora. Por ejemplo, podríamos buscar por divisores desde 2 hasta la raíz cuadrada de i. Pero de todas formas, si queremos ser realmente eficientes para intervalos grandes, necesitamos cambiar el enfoque y confiar en matemáticas avanzadas y algoritmos complejos como Criba cuadrática, Criba general del cuerpo de números etc.
",
	"url": "https://es.javascript.info/while-for" 
},
{
	"docs_id": "18",
	"name": "La sentencia "switch"",
	"description": "Una sentencia switch puede reemplazar múltiples condiciones if.",
	"content": "Una sentencia switch puede reemplazar múltiples condiciones if.
Provee una mejor manera de comparar un valor con múltiples variantes.
La sintaxisswitch tiene uno o mas bloques casey un opcional default.
Se ve de esta forma:

      
        
        
          switch(x) {
  case 'valor1':  // if (x === 'valor1')
    ...
    [break]

  case 'valor2':  // if (x === 'valor2')
    ...
    [break]

  default:
    ...
    [break]
}
        
      
      
      
El valor de x es comparado contra el valor del primer case (en este caso, valor1), luego contra el segundo (valor2) y así sucesivamente, todo esto bajo una igualdad estricta.
Si la igualdad es encontrada, switch empieza a ejecutar el código iniciando por el primer case correspondiente, hasta el break más cercano (o hasta el final del switch).
Si no se cumple ningún caso entonces el código default es ejecutado (si existe).

EjemploUn ejemplo de switch (se resalta el código ejecutado):

      
        
        
          
            
          
          
            
          
        
        
          let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Muy pequeño' );
    break;
  case 4:
    alert( '¡Exacto!' );
    break;
  case 5:
    alert( 'Muy grande' );
    break;
  default:
    alert( "Desconozco estos valores" );
}
        
      
      
      Aquí el switch inicia comparando a con la primera variante case que es 3. La comparación falla.
Luego 4. La comparación es exitosa, por tanto la ejecución empieza desde case 4 hasta el break más cercano.
Si no existe break entonces la ejecución continúa con el próximo case sin ninguna revisión.
Un ejemplo sin break:

      
        
        
          
            
          
          
            
          
        
        
          let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Muy pequeño' );
  case 4:
    alert( '¡Exacto!' );
  case 5:
    alert( 'Muy grande' );
  default:
    alert( "Desconozco estos valores" );
}
        
      
      
      En el ejemplo anterior veremos ejecuciones de tres alert secuenciales:

      
        
        
          alert( '¡Exacto!' );
alert( 'Muy grande' );
alert( "Desconozco estos valores" );
        
      
      
      
            Cualquier expresión puede ser un argumento switch/case
            Ambos switch y case permiten expresiones arbitrarias.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let a = "1";
let b = 0;

switch (+a) {
  case b + 1:
    alert("esto se ejecuta, porque +a es 1, exactamente igual b+1");
    break;

  default:
    alert("esto no se ejecuta");
}
        
      
      
      Aquí +a da 1, esto es comparado con b + 1 en case, y el código correspondiente es ejecutado.

Agrupamiento de “case”Varias variantes de case los cuales comparten el mismo código pueden ser agrupadas.
Por ejemplo, si queremos que se ejecute el mismo código para case 3 y case 5:

      
        
        
          
            
          
          
            
          
        
        
          let a = 2 + 2;

switch (a) {
  case 4:
    alert('¡Correcto!');
    break;

  case 3:                    // (*) agrupando dos cases
  case 5:
    alert('¡Incorrecto!');
    alert("¿Por qué no tomas una clase de matemáticas?");
    break;

  default:
    alert('El resultado es extraño. Realmente.');
}
        
      
      
      Ahora ambos, 3 y 5, muestran el mismo mensaje.
La capacidad de “agrupar” los case es un efecto secundario de cómo trabaja switch/case sin break. Aquí la ejecución de case 3 inicia desde la línea (*) y continúa a través de case 5, porque no existe break.
El tipo importaVamos a enfatizar que la comparación de igualdad es siempre estricta. Los valores deben ser del mismo tipo para coincidir.
Por ejemplo, consideremos el código:

      
        
        
          
            
          
          
            
          
        
        
          let arg = prompt("Ingrese un valor");
switch (arg) {
  case '0':
  case '1':
    alert( 'Uno o cero' );
    break;

  case '2':
    alert( 'Dos' );
    break;

  case 3:
    alert( '¡Nunca ejecuta!' );
    break;
  default:
    alert( 'Un valor desconocido' );
}
        
      
      
      
Para 0, 1, se ejecuta el primer alert.
Para 2 se ejecuta el segundo alert.
Pero para 3, el resultado del prompt es un string "3", el cual no es estrictamente igual === al número 3. Por tanto ¡Tenemos un código muerto en case 3! La variante default se ejecutará.

TareasReescribe el "switch" en un "if"importancia: 5Escribe el código utilizando if..else que corresponda al siguiente switch:

      
        
        
          switch (navegador) {
  case 'Edge':
    alert( "¡Tienes Edge!" );
    break;

  case 'Chrome':
  case 'Firefox':
  case 'Safari':
  case 'Opera':
    alert( 'Esta bien, soportamos estos navegadores también' );
    break;

  default:
    alert( '¡Esperamos que esta página se vea bien!' );
}
        
      
      
      soluciónPara que coincida con la funcionalidad de switch exactamente, el if debe utilizar una comparación estricta '==='.
Pero para strings, un simple '==' también funciona.

      
        
        
          if(navegador == 'Edge') {
  alert("¡Tienes Edge!");
} else if (navegador == 'Chrome'
 || navegador == 'Firefox'
 || navegador == 'Safari'
 || navegador == 'Opera') {
  alert( 'Está bien, soportamos estos navegadores también' );
} else {
  alert( '¡Esperamos que la página se vea bien!' );
}
        
      
      
      Nota: la construcción navegador == 'Chrome' || navegador == 'Firefox' … fue separada en varias líneas para mejorar su lectura.
Pero la construcción switch sigue siendo más clara y descriptiva.
Reescribe "if" en "switch"importancia: 4Reescribe el código debajo utilizando solo un argumento switch:

      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt('a?', '');

if (a == 0) {
  alert( 0 );
}
if (a == 1) {
  alert( 1 );
}

if (a == 2 || a == 3) {
  alert( '2,3' );
}
        
      
      
      soluciónLas primeras dos validaciones se vuelven dos case. La tercera validación se separa en dos case:

      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt('a?', '');

switch (a) {
  case 0:
    alert( 0 );
    break;

  case 1:
    alert( 1 );
    break;

  case 2:
  case 3:
    alert( '2,3' );
    break;
}
        
      
      
      Nota: El break al final no es requerido. Pero lo agregamos por previsión, para preparar el código para el futuro.
Existe una probabilidad de que en el futuro queramos agregar un case adicional, por ejemplo case 4. Y si olvidamos agregar un break antes, al final de case 3, habrá un error. Por tanto, es una forma de auto-asegurarse.
",
	"url": "https://es.javascript.info/switch" 
},
{
	"docs_id": "19",
	"name": "Funciones",
	"description": "Muy a menudo necesitamos realizar acciones similares en muchos lugares del script.",
	"content": "Muy a menudo necesitamos realizar acciones similares en muchos lugares del script.
Por ejemplo, debemos mostrar un mensaje atractivo cuando un visitante inicia sesión, cierra sesión y tal vez en otros momentos.
Las funciones son los principales “bloques de construcción” del programa. Permiten que el código se llame muchas veces sin repetición.
Ya hemos visto ejemplos de funciones integradas, como alert(message), prompt(message, default) y confirm(question). Pero también podemos crear funciones propias.
Declaración de funcionesPara crear una función podemos usar una declaración de función.
Se ve como aquí:

      
        
        
          function showMessage() {
  alert( '¡Hola a todos!' );
}
        
      
      
      La palabra clave function va primero, luego va el nombre de función,  luego una lista de parámetros entre paréntesis (separados por comas, vacía en el ejemplo anterior) y finalmente el código de la función entre llaves, también llamado “el cuerpo de la función”.

      
        
        
          function name(parameter1, parameter2, ... parameterN) {
  ...body...
}
        
      
      
      Nuestra nueva función puede ser llamada por su nombre: showMessage().
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage() {
  alert( '¡Hola a todos!' );
}

showMessage();
showMessage();
        
      
      
      La llamada showMessage() ejecuta el código de la función. Aquí veremos el mensaje dos veces.
Este ejemplo demuestra claramente uno de los propósitos principales de las funciones: evitar la duplicación de código…
Si alguna vez necesitamos cambiar el mensaje o la forma en que se muestra, es suficiente modificar el código en un lugar: la función que lo genera.
Variables LocalesUna variable declarada dentro de una función solo es visible dentro de esa función.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage() {
  let message = "Hola, ¡Soy JavaScript!"; // variable local

  alert( message );
}

showMessage(); // Hola, ¡Soy JavaScript!

alert( message ); // <-- ¡Error! La variable es local para esta función
        
      
      
      Variables ExternasUna función también puede acceder a una variable externa, por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'Juan';

function showMessage() {
  let message = 'Hola, ' + userName;
  alert(message);
}

showMessage(); // Hola, Juan
        
      
      
      La función tiene acceso completo a la variable externa. Puede modificarlo también.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'Juan';

function showMessage() {
  userName = "Bob"; // (1) Cambió la variable externa

  let message = 'Hola, ' + userName;
  alert(message);
}

alert( userName ); // Juan antes de llamar la función

showMessage();

alert( userName ); // Bob, el valor fué modificado por la función
        
      
      
      La variable externa solo se usa si no hay una local.
Si una variable con el mismo nombre se declara dentro de la función, le hace sombra a la externa. Por ejemplo, en el siguiente código, la función usa la variable userName local. La exterior se ignora:

      
        
        
          
            
          
          
            
          
        
        
          let userName = 'John';

function showMessage() {
  let userName = "Bob"; // declara variable local

  let message = 'Hello, ' + userName; // Bob
  alert(message);
}

// la función crea y utiliza su propia variable local userName
showMessage();

alert( userName ); // John, se mantiene, la función no accedió a la variable externa
        
      
      
      
            Variables globales
            Variables declaradas fuera de cualquier función, como la variable externa userName en el código anterior, se llaman globales.
Las variables globales son visibles desde cualquier función (a menos que se les superpongan variables locales con el mismo nombre).
Es una buena práctica reducir el uso de variables globales. El código moderno tiene pocas o ninguna variable global. La mayoría de las variables residen en sus funciones. Aunque a veces puede justificarse almacenar algunos datos a nivel de proyecto.

ParámetrosPodemos pasar datos arbitrarios a funciones usando parámetros.
En el siguiente ejemplo, la función tiene dos parámetros: from y text.

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text) { // parámetros: from, text
  alert(from + ': ' + text);
}

showMessage('Ann', '¡Hola!'); // Ann: ¡Hola! (*)
showMessage('Ann', "¿Cómo estás?"); // Ann: ¿Cómo estás? (**)
        
      
      
      Cuando la función se llama (*) y (**), los valores dados se copian en variables locales from y text. Y la función las utiliza.
Aquí hay un ejemplo más: tenemos una variable from y la pasamos a la función. Tenga en cuenta: la función cambia from, pero el cambio no se ve afuera, porque una función siempre obtiene una copia del valor:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text) {

  from = '*' + from + '*'; // hace que "from" se vea mejor

  alert( from + ': ' + text );
}

let from = "Ann";

showMessage(from, "Hola"); // *Ann*: Hola

// el valor de "from" es el mismo, la función modificó una copia local
alert( from ); // Ann
        
      
      
      Cuando un valor es pasado como un parámetro de función, también se denomina argumento.
Para poner los términos claros:

Un parámetro es una variable listada dentro de los paréntesis en la declaración de función (es un término para el momento de la declaración)
Un argumento es el valor que es pasado a la función cuando esta es llamada (es el término para el momento en que se llama).

Declaramos funciones listando sus parámetros, luego las llamamos pasándoles argumentos.
En el ejemplo de arriba, se puede decir: "la función showMessage es declarada con dos parámetros, y luego llamada con dos argumentos: from y "Hola"".
Valores predeterminadosSi una función es llamada, pero no se le proporciona un argumento, su valor correspondiente se convierte en undefined.
Por ejemplo, la función mencionada anteriormente showMessage(from, text) se puede llamar con un solo argumento:

      
        
        
          showMessage("Ann");
        
      
      
      Eso no es un error. La llamada mostraría "Ann: undefined". Como no se pasa un valor de text, este se vuelve undefined.
Podemos especificar un valor llamado “predeterminado” o “default” (que se usa si el argumento fue omitido) en la declaración de función usando =:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text = "sin texto") {
  alert( from + ": " + text );
}

showMessage("Ann"); // Ann: sin texto
        
      
      
      Ahora, si no existe el parámetro text, obtendrá el valor "sin texto"
Aquí "sin texto" es un string, pero puede ser una expresión más compleja, la cual solo es evaluada y asignada si el parámetro falta. Entonces, esto también es posible:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(from, text = anotherFunction()) {
  // anotherFunction() solo se ejecuta si text no fue asignado
  // su resultado se convierte en el valor de texto
}
        
      
      
      
            Evaluación de parámetros predeterminados
            En JavaScript, se evalúa un parámetro predeterminado cada vez que se llama a la función sin el parámetro respectivo.
En el ejemplo anterior, anotherFunction() no será llamado en absoluto si se provee el parámetro text.
Por otro lado, se llamará independientemente cada vez que text se omita.


            Parámetros predeterminados en viejo código JavaScript
            Años atrás, JavaScript no soportaba la sintaxis para parámetros predeterminados. Entonces se usaban otras formas para especificarlos.
En estos días, aún podemos encontrarlos en viejos scripts.
Por ejemplo, una verificación explícita de undefined:

      
        
        
          function showMessage(from, text) {
  if (text === undefined) {
    text = 'sin texto dado';
  }

  alert( from + ": " + text );
}
        
      
      
      … O usando el operador || :

      
        
        
          function showMessage(from, text) {
  // Si el valor de "text" es falso, asignar el valor predeterminado
  // esto asume que text == "" es lo mismo que sin texto en absoluto
  text = text || 'sin texto dado';
  ...
}
        
      
      
      
Parámetros predeterminados alternativosA veces tiene sentido asignar valores predeterminados no en la declaración de función sino en una etapa posterior.
Podemos verificar si un parámetro es pasado durante la ejecución de la función comparándolo con undefined:

      
        
        
          
            
          
          
            
          
        
        
          function showMessage(text) {
  // ...

  if (text === undefined) { // si falta el parámetro
    text = 'mensaje vacío';
  }

  alert(text);
}

showMessage(); // mensaje vacío
        
      
      
      …O podemos usar el operador ||:

      
        
        
          function showMessage(text) {
  // si text es indefinida o falsa, la establece a 'vacío'
  text = text || 'vacío';
  ...
}
        
      
      
      Los intérpretes de JavaScript modernos soportan el operador nullish coalescing ??, que es mejor cuando el valor de 0 debe ser considerado “normal” en lugar de falso:

      
        
        
          
            
          
          
            
          
        
        
          function showCount(count) {
  // si count es undefined o null, muestra "desconocido"
  alert(count ?? "desconocido");
}

showCount(0); // 0
showCount(null); // desconocido
showCount(); // desconocido
        
      
      
      Devolviendo un valorUna función puede devolver un valor al código de llamada como resultado.
El ejemplo más simple sería una función que suma dos valores:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a, b) {
  return a + b;
}

let result = sum(1, 2);
alert( result ); // 3
        
      
      
      La directiva return puede estar en cualquier lugar de la función. Cuando la ejecución lo alcanza, la función se detiene y el valor se devuelve al código de llamada (asignado al result anterior).
Puede haber muchos casos de return en una sola función. Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('¿Tienes permiso de tus padres?');
  }
}

let age = prompt('¿Qué edad tienes?', 18);

if ( checkAge(age) ) {
  alert( 'Acceso otorgado' );
} else {
  alert( 'Acceso denegado' );
}
        
      
      
      Es posible utilizar return sin ningún valor. Eso hace que la función salga o termine inmediatamente.
Por ejemplo:

      
        
        
          function showMovie(age) {
  if ( !checkAge(age) ) {
    return;
  }

  alert( "Mostrándote la película" ); // (*)
  // ...
}
        
      
      
      En el código de arriba, si checkAge(age) devuelve false, entonces showMovie no mostrará la alert.

            Una función con un return vacío, o sin return, devuelve undefined
            Si una función no devuelve un valor, es lo mismo que si devolviera undefined:

      
        
        
          
            
          
          
            
          
        
        
          function doNothing() { /* empty */ }

alert( doNothing() === undefined ); // true
        
      
      
      Un return vacío también es lo mismo que return undefined:

      
        
        
          
            
          
          
            
          
        
        
          function doNothing() {
  return;
}

alert( doNothing() === undefined ); // true
        
      
      
      

            Nunca agregue una nueva línea entre return y el valor
            Para una expresión larga de return, puede ser tentador ponerlo en una línea separada, como esta:

      
        
        
          return
 (una + expresion + o + cualquier + cosa * f(a) + f(b))
        
      
      
      Eso no funciona, porque JavaScript asume un punto y coma después del return. Eso funcionará igual que:

      
        
        
          return;
 (una + expresion + o + cualquier + cosa * f(a) + f(b))
        
      
      
      Entonces, efectivamente se convierte en un return vacío. Deberíamos poner el valor en la misma línea.

Nomenclatura de funcionesLas funciones son acciones. Entonces su nombre suele ser un verbo. Debe ser breve, lo más preciso posible y describir lo que hace la función, para que alguien que lea el código obtenga una indicación de lo que hace la función.
Es una práctica generalizada comenzar una función con un prefijo verbal que describe vagamente la acción. Debe haber un acuerdo dentro del equipo sobre el significado de los prefijos.
Por ejemplo, funciones que comienzan con "show" usualmente muestran algo.
Funciones que comienza con…

"get…" – devuelven un valor,
"calc…" – calculan algo,
"create…" – crean algo,
"check…" – revisan algo y devuelven un boolean, etc.

Ejemplos de este tipo de nombres:

      
        
        
          showMessage(..)     // muestra un mensaje
getAge(..)          // devuelve la edad (la obtiene de alguna manera)
calcSum(..)         // calcula una suma y devuelve el resultado
createForm(..)      // crea un formulario (y usualmente lo devuelve)
checkPermission(..) // revisa permisos, y devuelve true/false
        
      
      
      Con los prefijos en su lugar, un vistazo al nombre de una función permite comprender qué tipo de trabajo realiza y qué tipo de valor devuelve.

            Una función – una acción
            Una función debe hacer exactamente lo que sugiere su nombre, no más.
Dos acciones independientes por lo general merecen dos funciones, incluso si generalmente se convocan juntas (en ese caso, podemos hacer una tercera función que llame a esas dos).
Algunos ejemplos de cómo se rompen estas reglas:

getAge – está mal que muestre una alert con la edad (solo debe obtenerla).
createForm – está mal que modifique el documento agregándole el form (solo debe crearlo y devolverlo).
checkPermission – está mal que muestre el mensaje acceso otorgado/denegado(solo debe realizar la verificación y devolver el resultado).

En estos ejemplos asumimos los significados comunes de los prefijos. Tú y tu equipo pueden acordar significados diferentes, aunque usualmente no muy diferente. En cualquier caso, debe haber una compromiso firme de lo que significa un prefijo, de lo que una función con prefijo puede y no puede hacer. Todas las funciones con el mismo prefijo deben obedecer las reglas. Y el equipo debe compartir ese conocimiento.


            Nombres de funciones ultracortos
            Las funciones que se utilizan muy a menudo algunas veces tienen nombres ultracortos.
Por ejemplo, el framework jQuery define una función con $. La librería LoDash tiene como nombre de función principal _.
Estas son excepciones. En general, los nombres de las funciones deben ser concisos y descriptivos.

Funciones == ComentariosLas funciones deben ser cortas y hacer exactamente una cosa. Si esa cosa es grande, tal vez valga la pena dividir la función en algunas funciones más pequeñas. A veces, seguir esta regla puede no ser tan fácil, pero definitivamente es algo bueno.
Una función separada no solo es más fácil de probar y depurar, – ¡su existencia es un gran comentario!
Por ejemplo, comparemos las dos funciones showPrimes(n) siguientes. Cada una devuelve números primos hasta n.
La primera variante usa una etiqueta:

      
        
        
          function showPrimes(n) {
  nextPrime: for (let i = 2; i < n; i++) {

    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert( i ); // un número primo
  }
}
        
      
      
      La segunda variante usa una función adicional isPrime(n) para probar la primalidad:

      
        
        
          function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);  // a prime
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if ( n % i == 0) return false;
  }
  return true;
}
        
      
      
      La segunda variante es más fácil de entender, ¿no? En lugar del código, vemos un nombre de la acción. (isPrime). A veces las personas se refieren a dicho código como autodescriptivo.
Por lo tanto, las funciones se pueden crear incluso si no tenemos la intención de reutilizarlas. Estructuran el código y lo hacen legible.
ResumenUna declaración de función se ve así:

      
        
        
          function name(parámetros, delimitados, por, coma) {
  /* code */
}
        
      
      
      
Los valores pasados a una función como parámetros se copian a sus variables locales.
Una función puede acceder a variables externas. Pero funciona solo de adentro hacia afuera. El código fuera de la función no ve sus variables locales.
Una función puede devolver un valor. Si no lo hace, entonces su resultado es undefined.

Para que el código sea limpio y fácil de entender, se recomienda utilizar principalmente variables y parámetros locales en la función, no variables externas.
Siempre es más fácil entender una función que obtiene parámetros, trabaja con ellos y devuelve un resultado que una función que no obtiene parámetros, pero modifica las variables externas como un efecto secundario.
Nomenclatura de funciones:

Un nombre debe describir claramente lo que hace la función. Cuando vemos una llamada a la función en el código, un buen nombre nos da al instante una comprensión de lo que hace y devuelve.
Una función es una acción, por lo que los nombres de las funciones suelen ser verbales.
Existen muchos prefijos de funciones bien conocidos como create…, show…, get…, check… y así. Úsalos para insinuar lo que hace una función.

Las funciones son los principales bloques de construcción de los scripts. Ahora hemos cubierto los conceptos básicos, por lo que en realidad podemos comenzar a crearlos y usarlos. Pero ese es solo el comienzo del camino. Volveremos a ellos muchas veces, profundizando en sus funciones avanzadas.
Tareas¿Es "else" requerido?importancia: 4La siguiente función devuelve true si el parámetro age es mayor a 18.
De lo contrario, solicita una confirmación y devuelve su resultado:

      
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    // ...
    return confirm('¿Tus padres te permitieron?');
  }
}
        
      
      
      ¿Funcionará la función de manera diferente si se borra else?

      
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  }
  // ...
  return confirm('¿Tus padres te permitieron?');
}
        
      
      
      ¿Hay alguna diferencia en el comportamiento de estas dos variantes?
solución¡Ninguna diferencia!
En ambos casos, return confirm('¿Tus padres te permitieron?') se ejecuta precisamente cuando la condición if es falsa.
Reescribe la función utilizando '?' o '||'importancia: 4La siguiente función devuelve true si el parámetro age es mayor que 18.
De lo contrario, solicita una confirmación y devuelve su resultado.

      
        
        
          function checkAge(age) {
  if (age > 18) {
    return true;
  } else {
    return confirm('¿Tienes permiso de tus padres?');
  }
}
        
      
      
      Reescríbela para realizar lo mismo, pero sin if, en una sola linea.
Haz dos variantes de checkAge:

Usando un operador de signo de interrogación ?
Usando OR ||

soluciónUsando un operador signo de pregunta '?':

      
        
        
          function checkAge(age) {
  return (age > 18) ? true : confirm('¿Tus padres te lo permitieron?');
}
        
      
      
      Usando Ó || (la variante más corta):

      
        
        
          function checkAge(age) {
  return (age > 18) || confirm('¿Tus padres te lo permitieron?');
}
        
      
      
      Tenga en cuenta que aquí los paréntesis alrededor de age > 18 no son requeridos. Existen para una mejor legibilidad.
Función min(a, b)importancia: 1Escriba una función min(a,b) la cual devuelva el menor de dos números a y b.
Por ejemplo:

      
        
        
          min(2, 5) == 2
min(3, -1) == -1
min(1, 1) == 1
        
      
      
      soluciónUna solución usando if:

      
        
        
          function min(a, b) {
  if (a < b) {
    return a;
  } else {
    return b;
  }
}
        
      
      
      Una solución con un operador de signo de interrogación '?':

      
        
        
          function min(a, b) {
  return a < b ? a : b;
}
        
      
      
      P.D: En el caso de una igualdad a == b No importa qué devuelva.
Función pow(x,n)importancia: 4Escriba la función pow(x,n) que devuelva x como potencia de n. O, en otras palabras, multiplique x por si mismo n veces y devuelva el resultado.

      
        
        
          pow(3, 2) = 3 * 3 = 9
pow(3, 3) = 3 * 3 * 3 = 27
pow(1, 100) = 1 * 1 * ...* 1 = 1
        
      
      
      Cree una página web que solicite x y n, y luego muestre el resultado de pow(x,n).
Ejecutar el demoPD: En esta tarea, la función solo debe admitir valores naturales de n: enteros desde 1.
solución
      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  let result = x;

  for (let i = 1; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("x?", '');
let n = prompt("n?", '');

if (n < 1) {
  alert(`Potencia ${n} no soportada,
    use un entero mayor a 0`);
} else {
  alert( pow(x, n) );
}
        
      
      
      ",
	"url": "https://es.javascript.info/function-basics" 
},
{
	"docs_id": "20",
	"name": "Expresiones de función",
	"description": "En JavaScript, una función no es una “estructura mágica del lenguaje”, sino un tipo de valor especial.",
	"content": "En JavaScript, una función no es una “estructura mágica del lenguaje”, sino un tipo de valor especial.
La sintaxis que usamos antes se llama Declaración de Función:

      
        
        
          function sayHi() {
  alert( "Hola" );
}
        
      
      
      Existe otra sintaxis para crear una función que se llama una Expresión de Función.
Esto nos permite crear una nueva función en el medio de cualquier expresión
Por ejemplo:

      
        
        
          let sayHi = function() {
  alert( "Hola" );
};
        
      
      
      Aquí podemos ver una variable sayHi obteniendo un valor —la nueva función— creada como function() { alert("Hello"); }.
Como la creación de una función ocurre en el contexto de una expresión de asignación, (el lado derecho de =), esto es una Expresión de función.
Note que no hay un nombre después de la palabra clave function. Omitir el nombre está permitido en las expresiones de función.
Aquí la asignamos directamente a la variable, así que el significado de estos ejemplos de código es el mismo: "crear una función y ponerla en la variable sayHi".
En situaciones más avanzadas, que cubriremos más adelante, una función puede ser creada e inmediatamente llamada o agendada para uso posterior, sin almacenarla en ningún lugar, permaneciendo así anónima.
La función es un valorReiteremos: no importa cómo es creada la función, una función es un valor. Ambos ejemplos arriba almacenan una función en la variable sayHi.
Incluso podemos mostrar aquel valor usando alert:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert( "Hola" );
}

alert( sayHi ); // muestra el código de la función
        
      
      
      Tenga en cuenta que la última línea no ejecuta la función, porque no hay paréntesis después de sayHi. Existen lenguajes de programación en los que cualquier mención del nombre de una función causa su ejecución, pero JavaScript no funciona así.
En JavaScript, una función es un valor, por lo tanto podemos tratarlo como un valor. El código de arriba muestra su representación de cadena, que es el código fuente.
Por supuesto que es un valor especial, en el sentido que podemos invocarlo de esta forma sayHi().
Pero sigue siendo un valor. Entonces podemos trabajar con ello como trabajamos con otro tipo de valores.
Podemos copiar una función a otra variable:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {   // (1) crear
  alert( "Hola" );
}

let func = sayHi;    // (2) copiar

func(); // Hola          // (3) ejecuta la copia (funciona)!
sayHi(); // Hola         // esto también funciona (por qué no lo haría)
        
      
      
      Esto es lo que sucede arriba en detalle:

La Declaración de la Función (1) crea la función y la coloca dentro de la variable llamada sayHi.
Línea(2) copia la función en la variable func.
Ahora la función puede ser llamada de ambas maneras, sayHi() y func().

También podríamos haber usado una expresión de función para declarar sayHi en la primera línea:

      
        
        
          let sayHi = function() { // (1) crea
  alert( "Hola" );
};

let func = sayHi;
// ...
        
      
      
      Todo funcionaría igual.

            ¿Por qué hay un punto y coma al final?
            Tal vez te preguntes por qué la Expresión de Función tiene un punto y coma ; al final, pero la Declaración de Función no lo tiene:

      
        
        
          function sayHi() {
  // ...
}

let sayHi = function() {
  // ...
};
        
      
      
      La respuesta es simple: una expresión de función se crea aquí como function(…) {…} dentro de la sentencia de asignación let sayHi = …;. El punto y coma se recomienda para finalizar la sentencia, no es parte de la sintaxis de función.
El punto y coma estaría allí para una asignación más simple tal como let sayHi = 5;, y también está allí para la asignación de función.

Funciones CallbackVeamos más ejemplos del pasaje de funciones como valores y el uso de expresiones de función.
Escribimos una función ask(question, yes, no) con tres argumentos:

question
Texto de la pregunta
yes
Función a ejecutar si la respuesta es “Yes”
no
Función a ejecutar si la respuesta es “No”

La función deberá preguntar la question y, dependiendo de la respuesta del usuario, llamar yes() o no():

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

function showOk() {
  alert( "Estás de acuerdo." );
}

function showCancel() {
  alert( "Cancelaste la ejecución." );
}

// uso: las funciones showOk, showCancel son pasadas como argumentos de ask
ask("Estás de acuerdo?", showOk, showCancel);
        
      
      
      En la práctica, tales funciones son bastante útiles. La mayor diferencia entre la función ask en la vida real y el ejemplo anterior es que las funciones de la vida real utilizan formas para interactuar con el usuario más complejas que un simple confirme. En el navegador, una función como tal normalmente dibuja una ventana de pregunta atractiva. Pero esa es otra historia.
Los argumentos de ask se llaman funciones callback o simplemente callbacks.
La idea es que pasamos una función y esperamos que se “devuelva la llamada” más tarde si es necesario. En nuestro caso, showOk se convierte en la callback para la respuesta “Yes”, y showCancel para la respuesta “No”.
Podemos usar Expresión de Función para redactar una función equivalente y más corta:

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Estás de acuerdo?",
  function() { alert("Estás de acuerdo"); },
  function() { alert("Cancelaste la ejecución."); }
);
        
      
      
      Aquí, las funciones son declaradas justo dentro del llamado ask(...). No tienen nombre, y por lo tanto se denominan anónimas. Tales funciones no se pueden acceder fuera de ask (porque no están asignadas a variables), pero eso es justo lo que queremos aquí.
Éste código aparece en nuestros scripts de manera muy natural, está en el archivo de comandos de JavaScript.

            Una función es un valor representando una “acción”
            Valores regulares tales como cadena de caracteres o números representan los datos.
Una función puede ser percibida como una acción.
La podemos pasar entre variables y ejecutarla cuando nosotros queramos.

Expresión de Función vs Declaración de FunciónFormulemos las principales diferencias entre Declaración y Expresión de Funciones.
Primero, la sintaxis: cómo diferenciarlas en el código.


Declaración de Función: una función, declarada como una instrucción separada, en el flujo de código principal.

      
        
        
          // Declaración de Función
function sum(a, b) {
  return a + b;
}
        
      
      
      

Expresión de Función: una función, creada dentro de una expresión o dentro de otra construcción sintáctica. Aquí, la función es creada en el lado derecho de la “expresión de asignación” =:

      
        
        
          // Expresión de Función
let sum = function(a, b) {
  return a + b;
};
        
      
      
      

La diferencia más sutil es cuándo la función es creada por el motor de JavaScript.
Una Expresión de Función es creada cuando la ejecución la alcance y es utilizable desde ahí en adelante.
Una vez que el flujo de ejecución pase al lado derecho de la asignación let sum = function… – aquí vamos, la función es creada y puede ser usada (asignada, llamada, etc.) de ahora en adelante.
Las Declaraciones de Función son diferente.
Una Declaración de Función puede ser llamada antes de ser definida.
Por ejemplo, una Declaración de Función global es visible en todo el script, sin importar dónde se esté.
Esto se debe a los algoritmos internos. Cuando JavaScript se prepara para ejecutar el script, primero busca Declaraciones de Funciones globales en él y crea las funciones. Podemos pensar en esto como una “etapa de inicialización”.
Y después de que se procesen todas las Declaraciones de Funciones, el código se ejecuta. Entonces tiene acceso a éstas funciones.
Por ejemplo, esto funciona:

      
        
        
          
            
          
          
            
          
        
        
          sayHi("John"); // Hola, John

function sayHi(name) {
  alert( `Hola, ${name}` );
}
        
      
      
      La Declaración de Función sayHi es creada cuando JavaScript está preparándose para iniciar el script y es visible en todas partes.
…Si fuera una Expresión de Función, entonces no funcionaría:

      
        
        
          
            
          
          
            
          
        
        
          sayHi("John"); // error!

let sayHi = function(name) {  // (*) ya no hay magia
  alert( `Hola, ${name}` );
};
        
      
      
      Las Expresiones de Función son creadas cuando la ejecución las alcance. Esto podría pasar solamente en la línea (*). Demasiado tarde.
Otra característica especial de las Declaraciones de Funciones es su alcance de bloque.
En modo estricto, cuando una Declaración de Función se encuentra dentro de un bloque de código, es visible en todas partes dentro de ese bloque. Pero no fuera de él.
Por ejemplo, imaginemos que necesitamos declarar una función welcome() dependiendo de la variable age que obtengamos durante el tiempo de ejecución. Y luego planeamos usarlo algún tiempo después.
Si utilizamos la Declaración de Funciones, no funcionará como se esperaba:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("Cuál es tu edad?", 18);

// declarar condicionalmente una función
if (age < 18) {

  function welcome() {
    alert("Hola!");
  }

} else {

  function welcome() {
    alert("Saludos!");
  }

}

// ...usarla más tarde
welcome(); // Error: welcome no está definida
        
      
      
      Esto se debe a que una Declaración de Función sólo es visible dentro del bloque de código en el que reside.
Aquí hay otro ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let age = 16; // tomemos 16 como ejemplo

if (age < 18) {
  welcome();               // \   (corre)
                           //  |
  function welcome() {     //  |
    alert("¡Hola!");       //  |  La declaración de Función está disponible
  }                        //  |  en todas partes del bloque donde está declarada
                           //  |
  welcome();               // /   (corre)

} else {

  function welcome() {
    alert("¡Saludos!");
  }
}

// Aquí estamos fuera de las llaves,
// por lo tanto no podemos ver la Declaración de Función realizada dentro de ellas.

welcome(); // Error: welcome no está definida
        
      
      
      ¿Qué podemos hacer para que welcome sea visible fuera de ‘if’?
El enfoque correcto sería utilizar una Expresión de Función y asignar welcome a la variable que se declara fuera de ‘if’ y tiene la visibilidad adecuada.
Este código funciona según lo previsto:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("Cuál es tu edad?", 18);

let welcome;

if (age < 18) {

  welcome = function() {
    alert("Hola!");
  };

} else {

  welcome = function() {
    alert("Saludos!");
  };

}

welcome(); // ahora ok
        
      
      
      O lo podemos simplificar aun más usando un operador de signo de pregunta ?:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("¿Cuál es tu edad?", 18);

let welcome = (age < 18) ?
  function() { alert("¡Hola!"); } :
  function() { alert("¡Saludos!"); };

welcome(); // ahora ok
        
      
      
      
            ¿Cuándo debo elegir la Declaración de Función frente a la Expresión de Función?
            Como regla general, cuando necesitamos declarar una función, la primera que debemos considerar es la sintaxis de la Declaración de Función. Da más libertad en cómo organizar nuestro código, porque podemos llamar a tales funciones antes de que sean declaradas.
También es un poco más fácil de buscar function f(…) {…} en el código comparado con let f = function(…) {…}. La Declaración de Función es más llamativa.
…Pero si una Declaración de Función no nos conviene por alguna razón, o necesitamos declaración condicional (hemos visto un ejemplo), entonces se debe usar la Expresión de función.

Resumen
Las funciones son valores. Se pueden asignar, copiar o declarar en cualquier lugar del código.
Si la función se declara como una declaración separada en el flujo del código principal, eso se llama “Declaración de función”.
Si la función se crea como parte de una expresión, se llama “Expresión de función”.
Las Declaraciones de Funciones se procesan antes de ejecutar el bloque de código. Son visibles en todas partes del bloque.
Las Expresiones de Función se crean cuando el flujo de ejecución las alcanza.

En la mayoría de los casos, cuando necesitamos declarar una función, es preferible una Declaración de Función, ya que es visible antes de la declaración misma. Eso nos da más flexibilidad en la organización del código, y generalmente es más legible.
Por lo tanto, deberíamos usar una Expresión de Función solo cuando una Declaración de Función no sea adecuada para la tarea. Hemos visto un par de ejemplos de eso en este capítulo, y veremos más en el futuro.
",
	"url": "https://es.javascript.info/function-expressions" 
},
{
	"docs_id": "21",
	"name": "Funciones Flecha, lo básico",
	"description": "Hay otra sintaxis muy simple y concisa para crear funciones, que a menudo es mejor que las Expresiones de funciones.",
	"content": "Hay otra sintaxis muy simple y concisa para crear funciones, que a menudo es mejor que las Expresiones de funciones.
Se llama “funciones de flecha”, porque se ve así:

      
        
        
          let func = (arg1, arg2, ..., argN) => expression;
        
      
      
      Esto crea una función func que acepta los parámetros arg1..argN, luego evalúa la expression del lado derecho mediante su uso y devuelve su resultado.
En otras palabras, es la versión más corta de:

      
        
        
          let func = function(arg1, arg2, ..., argN) {
  return expression;
};
        
      
      
      Veamos un ejemplo concreto:

      
        
        
          
            
          
          
            
          
        
        
          let sum = (a, b) => a + b;

/* Esta función de flecha es una forma más corta de:

let sum = function(a, b) {
  return a + b;
};
*/

alert( sum(1, 2) ); // 3
        
      
      
      Como puedes ver, (a, b) => a + b significa una función que acepta dos argumentos llamados a y b. Tras la ejecución, evalúa la expresión a + b y devuelve el resultado.


Si solo tenemos un argumento, se pueden omitir paréntesis alrededor de los parámetros, lo que lo hace aún más corto.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let double = n => n * 2;
// Más o menos lo mismo que: let double = function(n) { return n * 2 }

alert( double(3) ); // 6
        
      
      
      

Si no hay parámetros, los paréntesis estarán vacíos; pero deben estar presentes:

      
        
        
          
            
          
          
            
          
        
        
          let sayHi = () => alert("¡Hola!");

sayHi();
        
      
      
      

Las funciones de flecha se pueden usar de la misma manera que las expresiones de función.
Por ejemplo, para crear dinámicamente una función:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt("What is your age?", 18);

let welcome = (age < 18) ?
  () => alert('¡Hola!') :
  () => alert("¡Saludos!");

welcome();
        
      
      
      Las funciones de flecha pueden parecer desconocidas y poco legibles al principio, pero eso cambia rápidamente a medida que los ojos se acostumbran a la estructura.
Son muy convenientes para acciones simples de una línea, cuando somos demasiado flojos para escribir muchas palabras.
Funciones de flecha multilíneaLas funciones de flecha que estuvimos viendo eran muy simples. Toman los parámetros a la izquierda de =>, los evalúan y devuelven la expresión del lado derecho.
A veces necesitamos una función más compleja, con múltiples expresiones o sentencias. En ese caso debemos encerrarlos entre llaves. La diferencia principal es que las llaves necesitan usar un return para devolver un valor (tal como lo hacen las funciones comunes).
Como esto:

      
        
        
          
            
          
          
            
          
        
        
          let sum = (a, b) => {  // la llave abre una función multilínea
  let result = a + b;
  return result; // si usamos llaves, entonces necesitamos un "return" explícito
};

alert( sum(1, 2) ); // 3
        
      
      
      
            Más por venir
            Aquí elogiamos las funciones de flecha por su brevedad. ¡Pero eso no es todo!
Las funciones de flecha tienen otras características interesantes.
Para estudiarlas en profundidad, primero debemos conocer algunos otros aspectos de JavaScript, por lo que volveremos a las funciones de flecha más adelante en el capítulo Funciones de flecha revisadas.
Por ahora, ya podemos usar las funciones de flecha para acciones de una línea y devoluciones de llamada.

ResumenLas funciones de flecha son útiles para acciones simples, especialmente las de una sola línea. Vienen en dos variantes:

Sin llaves: (...args) => expression – el lado derecho es una expresión: la función la evalúa y devuelve el resultado. Pueden omitirse los paréntesis si solo hay un argumento, por ejemplo n => n*2.
Con llaves: (...args) => { body } – las llaves nos permiten escribir varias declaraciones dentro de la función, pero necesitamos un return explícito para devolver algo.

TareasReescribe con funciones de flechaReemplace las expresiones de función con funciones de flecha en el código a continuación:

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes();
  else no();
}

ask(
  "Do you agree?",
  function() { alert("You agreed."); },
  function() { alert("You canceled the execution."); }
);
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          function ask(question, yes, no) {
  if (confirm(question)) yes();
  else no();
}

ask(
  "Do you agree?",
  () => alert("You agreed."),
  () => alert("You canceled the execution.")
);
        
      
      
      Se ve corto y limpio, ¿verdad?
",
	"url": "https://es.javascript.info/arrow-functions-basics" 
},
{
	"docs_id": "22",
	"name": "Especiales JavaScript",
	"description": "Este capítulo resume brevemente las características de JavaScript que hemos aprendido hasta ahora, prestando especial atención a los detalles relevantes.",
	"content": "Este capítulo resume brevemente las características de JavaScript que hemos aprendido hasta ahora, prestando especial atención a los detalles relevantes.
Estructura de CódigoLas declaraciones se delimitan con un punto y coma:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hola'); alert('Mundo');
        
      
      
      En general, un salto de línea también se trata como un delimitador, por lo que también funciona:

      
        
        
          
            
          
          
            
          
        
        
          alert('Hola')
alert('Mundo')
        
      
      
      Esto se llama “inserción automática de punto y coma”. A veces no funciona, por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert("Habrá un error después de este mensaje.")

[1, 2].forEach(alert)
        
      
      
      La mayoría de las guías de estilo de código coinciden en que debemos poner un punto y coma después de cada declaración.
Los puntos y comas no son necesarios después de los bloques de código {...} y los constructores de sintaxis como los bucles:

      
        
        
          function f() {
  // no se necesita punto y coma después de la declaración de función
}

for(;;) {
  // no se necesita punto y coma después del bucle
}
        
      
      
      …Pero incluso si colocásemos un punto y coma “extra” en alguna parte, eso no sería un error. Solo sería ignorado.
Más en: Estructura del código.
Modo estrictoPara habilitar completamente todas las características de JavaScript moderno, debemos comenzar los scripts con "use strict".

      
        
        
          'use strict';

...
        
      
      
      La directiva debe estar en la parte superior de un script o al comienzo de una función.
Sin la directiva "use strict" todo sigue funcionando, pero algunas características se comportan de la manera antigua y “compatible”. Generalmente preferimos el comportamiento moderno.
Algunas características modernas del lenguaje (como las clases que estudiaremos en el futuro) activan el modo estricto implícitamente.
Más en: El modo moderno, "use strict".
VariablesSe pueden declarar usando:

let
const (constante, no se puede cambiar)
var (estilo antiguo, lo veremos más tarde)

Un nombre de variable puede incluir:

Letras y dígitos, pero el primer carácter no puede ser un dígito.
Los caracteres $ y _ son normales, al igual que las letras.
Los alfabetos y jeroglíficos no latinos también están permitidos, pero comúnmente no se usan.

Las variables se escriben dinámicamente. Pueden almacenar cualquier valor:

      
        
        
          let x = 5;
x = "John";
        
      
      
      Hay 8 tipos de datos:

number tanto para números de punto flotante como enteros,
bigint para números enteros de largo arbitrario,
string para textos,
boolean para valores lógicos: true/false,
null – un tipo con el valor único null, que significa “vacío” o “no existe”,
undefined – un tipo con el valor único undefined, que significa “no asignado”,
object y symbol – para estructuras de datos complejas e identificadores únicos, aún no los hemos aprendido.

El operador typeof devuelve el tipo de un valor, con dos excepciones:

      
        
        
          typeof null == "object" // error del lenguaje
typeof function(){} == "function" // las funciones son tratadas especialmente
        
      
      
      Más en: Variables y Tipos de datos.
InteracciónEstamos utilizando un navegador como entorno de trabajo, por lo que las funciones básicas de la interfaz de usuario serán:

prompt(question, [default])
Hace una pregunta question, y devuelve lo que ingresó el visitante o null si presiona “cancelar”.
confirm(question)
Hace una pregunta question, y sugiere elegir entre Aceptar y Cancelar. La elección se devuelve como booleano true/false.
alert(message)
Muestra un message.

Todas estas funciones son modales, pausan la ejecución del código y evitan que el visitante interactúe con la página hasta que responda.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let userName = prompt("¿Su nombre?", "Alice");
let isTeaWanted = confirm("¿Quiere té?");

alert( "Visitante: " + userName ); // Alice
alert( "Quiere té: " + isTeaWanted ); // true
        
      
      
      Más en: Interacción: alert, prompt, confirm.
OperadoresJavaScript soporta los siguientes operadores:

Aritméticos

Los normales: * + - /, también % para los restos y ** para aplicar potencia de un número.
El binario más + concatena textos. Si uno de los operandos es un texto, el otro también se convierte en texto:

      
        
        
          
            
          
          
            
          
        
        
          alert( '1' + 2 ); // '12', texto
alert( 1 + '2' ); // '12', texto
        
      
      
      
Asignaciones

Existen las asignaciones simples: a = b y las combinadas a *= 2.

Operador bit a bit

Los operadores bit a bit funcionan con enteros de 32 bits al más bajo nivel, el de bit: vea la documentación cuando los necesite.

Condicional

El único operador con 3 parámetros: cond ? resultA : resultB. Sí cond es verdadera, devuelve resultA, de lo contrario resultB.

Operadores Lógicos

Los operadores lógicos Y && y Ó || realizan una evaluación de circuito corto y luego devuelven el valor donde se detuvo (no necesariamente true/false). El operador lógico NOT ! convierte el operando a tipo booleano y devuelve el valor inverso.

Operador “Nullish coalescing”

El operador ?? brinda una forma de elegir el primer valor “definido” de una lista de variables. El resultado de a ?? b es a salvo que esta sea null/undefined, en cuyo caso será b.

Comparaciones

Para verificar la igualdad == de valores de diferentes tipos, estos se convierten a número (excepto null y undefined que son iguales entre sí y nada más), por lo que son iguales:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == false ); // true
alert( 0 == '' ); // true
        
      
      
      Otras comparaciones también se convierten en un número.
El operador de igualdad estricta === no realiza la conversión: diferentes tipos siempre significan diferentes valores.
Los valores null y undefined son especiales: son iguales == el uno al otro y no son iguales a nada más.
Las comparaciones mayor/menor comparan las cadenas carácter por carácter, los demás tipos de datos se convierten a número.

Otros operadores

Hay algunos otros, como un operador de coma.


Más en: Operadores básicos, matemáticas, Comparaciones, Operadores Lógicos, Operador Nullish Coalescing '??'.
Bucles

Cubrimos 3 tipos de bucles:

      
        
        
          // 1
while (condition) {
  ...
}

// 2
do {
  ...
} while (condition);

// 3
for(let i = 0; i < 10; i++) {
  ...
}
        
      
      
      

La variable declarada en el bucle for(let...) sólo es visible dentro del bucle. Pero también podemos omitir el let y reutilizar una variable existente.


Directivas break/continue permiten salir de todo el ciclo/iteración actual. Use etiquetas para romper bucles anidados.


Detalles en: Bucles: while y for.
Más adelante estudiaremos más tipos de bucles para tratar con objetos.
La construcción “switch”La construcción “switch” puede reemplazar múltiples revisiones con if. “switch” utiliza === (comparación estricta).
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let age = prompt('¿Su Edad?', 18);

switch (age) {
  case 18:

    alert("No funciona"); // el resultado de la petición es un string, no un número

  case "18":
    alert("¡Funciona!");
    break;

  default:
    alert("Todo valor que no sea igual a uno de arriba");
}
        
      
      
      Detalles en: La sentencia "switch".
FuncionesCubrimos tres formas de crear una función en JavaScript:


Declaración de función: la función en el flujo del código principal

      
        
        
          function sum(a, b) {
  let result = a + b;

  return result;
}
        
      
      
      

Expresión de función: la función en el contexto de una expresión

      
        
        
          let sum = function(a, b) {
  let result = a + b;

  return result;
};
        
      
      
      

Funciones de flecha:

      
        
        
          // la expresión en el lado derecho
let sum = (a, b) => a + b;

// o sintaxis multilínea { ... }, aquí necesita return:
let sum = (a, b) => {
  // ...
  return a + b;
}

// sin argumentos
let sayHi = () => alert("Hello");

// con un único argumento
let double = n => n * 2;
        
      
      
      


Las funciones pueden tener variables locales: son aquellas declaradas dentro de su cuerpo. Estas variables solo son visibles dentro de la función.
Los parámetros pueden tener valores predeterminados: function sum(a = 1, b = 2) {...}.
Las funciones siempre devuelven algo. Si no hay return, entonces el resultado es undefined.

Más: ver Funciones, Funciones Flecha, lo básico.
Más por venirEsa fue una breve lista de características de JavaScript. Por ahora solo hemos estudiado lo básico. Más adelante en el tutorial encontrará más características especiales y avanzadas de JavaScript.
",
	"url": "https://es.javascript.info/javascript-specials" 
},
{
	"docs_id": "23",
	"name": "",
	"description": "Aquí aprenderemos JavaScript, empezando desde cero y llegaremos hasta conceptos avanzados como POO.",
	"content": "Parte 1El lenguaje JavaScriptParte 2El navegador: Documentos, Eventos e InterfacesParte 3Artículos adicionalesEl lenguaje JavaScriptAquí aprenderemos JavaScript, empezando desde cero y llegaremos hasta conceptos avanzados como POO.
Nos concentraremos en el lenguaje mismo con el mínimo de notas específicas del entorno.
Una introducciónUna introducción a JavaScriptManuales y especificacionesEditores de CódigoConsola de desarrolladorFundamentos de JavaScript¡Hola, mundo!Estructura del códigoEl modo moderno, "use strict"VariablesTipos de datosInteracción: alert, prompt, confirmConversiones de TiposOperadores básicos, matemáticasComparacionesEjecución condicional: if, '?'Operadores LógicosOperador Nullish Coalescing '??'Bucles: while y forLa sentencia "switch"FuncionesExpresiones de funciónFunciones Flecha, lo básicoEspeciales JavaScriptMás…Calidad del códigoDebugging en el navegadorEstilo de codificaciónComentariosCódigo ninjaTest automatizados con MochaPolyfills y transpiladoresObjetos: lo básicoObjetosReferencias de objetos y copiaRecolección de basuraMétodos del objeto, "this"Constructor, operador "new"Encadenamiento opcional '?.'Tipo SymbolConversión de objeto a valor primitivoTipos de datosMétodos en tipos primitivosNúmerosStringsArraysMétodos de arraysIterablesMap y SetWeakMap y WeakSetObject.keys, values, entriesAsignación desestructuranteFecha y HoraMétodos JSON, toJSONMás…Trabajo avanzado con funcionesRecursión y pilaParámetros Rest y operador SpreadÁmbito de Variable y el concepto "closure"La vieja "var"Objeto GlobalFunción como objeto, NFELa sintaxis "new Function"Planificación: setTimeout y setIntervalDecoradores y redirecciones, call/applyFunción bind: vinculación de funcionesFunciones de flecha revisadasMás…Configuración de las propiedades de objetosIndicadores y descriptores de propiedad"Getters" y "setters" de propiedadPrototipos y herenciaHerencia prototípicaF.prototypePrototipos nativosMétodos prototipo, objetos sin __proto__ClasesSintaxis básica de `class`Herencia de clasePropiedades y métodos estáticos.Propiedades y métodos privados y protegidos.Ampliación de clases integradasComprobación de clase: "instanceof"Los MixinsManejo de erroresManejo de errores, "try...catch"Errores personalizados, extendiendo ErrorPromesas y async/awaitIntroducción: callbacksPromesaEncadenamiento de promesasManejo de errores con promesasPromise APIPromisificaciónMicrotareas (Microtasks)Async/awaitGeneradores e iteración avanzadaGeneradoresIteradores y generadores asíncronosMódulosMódulos, introducciónExport e ImportImportaciones dinámicasTemas diversosProxy y ReflectEval: ejecutando una cadena de códigoCurrificaciónTipo de ReferenciaBigIntEl navegador: Documentos, Eventos e InterfacesAprenderemos a manejar la página del navegador: agregar elementos, manipular su tamaño y posición, crear interfaces dinámicamente e interactuar con el visitante.
DocumentoEntorno del navegador, especificacionesÁrbol del Modelo de Objetos del Documento (DOM)Recorriendo el DOMBuscar: getElement*, querySelector*Propiedades del nodo: tipo, etiqueta y contenidoAtributos y propiedadesModificando el documentoEstilos y clasesTamaño de elementos y desplazamientoTamaño de ventana y desplazamientoCoordenadasMás…Introducción a los eventosIntroducción a los eventos en el navegadorPropagación y capturaDelegación de eventosAcciones predeterminadas del navegadorEnvío de eventos personalizadosEventos en la UIEventos del MouseMoviendo el mouse: mouseover/out, mouseenter/leaveArrastrar y Soltar con eventos del ratónEventos de punteroTeclado: keydown y keyupDesplazamientoFormularios y controlesPropiedades y Métodos de FormulariosEnfocado: enfoque/desenfoqueEventos: change, input, cut, copy, pasteFormularios: evento y método submitEl documento y carga de recursosPágina: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferCarga de recursos: onload y onerrorTemas diversosMutation observerSelection y RangeLoop de eventos: microtareas y macrotareasArtículos adicionalesLista de temas adicionales que supone que ha cubierto las dos primeras partes del tutorial. Aquí no hay una jerarquía clara, puede leer los artículos en el orden que desee.Marcos y ventanasVentanas emergentes y métodos de ventanaComunicación entre ventanasEl ataque de secuestro de clicsDatos binarios y archivosArrayBuffer, arrays binariosTextDecoder y TextEncoderBlobFile y FileReaderSolicitudes de redFetchFormDataFetch: Progreso de la descargaFetch: AbortFetch: Cross-Origin RequestsFetch APIObjetos URLXMLHttpRequestCarga de archivos reanudableSondeo largoWebSocketEventos enviados por el servidorMás…Almacenando datos en el navegadorCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimacionesCurva de BézierAnimaciones CSSAnimaciones JavaScriptComponentes WebDesde la altura orbitalElementos personalizadosShadow DOMElemento templateShadow DOM slots, composiciónEstilo Shadow DOMShadow DOM y eventosExpresiones RegularesPatrones y banderas (flags)Clases de caracteresUnicode: bandera "u" y clase \p{...}Anclas: inicio ^ y final $ de cadenaModo multilínea de anclas ^ $, bandera "m"Límite de palabra: \bEscapando, caracteres especialesConjuntos y rangos [...]Cuantificadores +, *, ? y {n}Cuantificadores codiciosos y perezososGrupos de capturaReferencias inversas en patrones: \N y \k<nombre>Alternancia (O) |Lookahead y lookbehind (revisar delante/detrás)Backtracking catastróficoIndicador adhesivo “y”, buscando en una posición.Métodos de RegExp y StringMás…{
  "@context": "http://schema.org",
  "@type": "WebSite",
  "url": "https://es.javascript.info/",
  "potentialAction": {
    "@type": "SearchAction",
    "target": "https://es.javascript.info/search?query={search_term_string}",
    "query-input": "required name=search_term_string"
  }
}",
	"url": "https://es.javascript.info#" 
},
{
	"docs_id": "24",
	"name": "Debugging en el navegador",
	"description": "Antes de escribir código más complejo, hablemos de debugging.",
	"content": "Antes de escribir código más complejo, hablemos de debugging.
Todos lo exploradores modernos y la mayoría de los otros ambientes soportan el “debugging” – una herramienta especial de UI para desarrolladores que nos permite encontrar y reparar errores más fácilmente.
Aquí utilizaremos Chrome porque es uno de los que mejores herramientas tienen en este aspecto.
El panel “sources/recursos”Tu version de Chrome posiblemente se vea distinta, pero sigue siendo obvio lo que hablamos aquí.

Abre la pagina de ejemplo en Chrome.
Activa las herramientas de desarrollo con F12 (Mac: Cmd+Opt+I).
Selecciona el panel sources/recursos.

Esto es lo que debería ver si lo está haciendo por primera vez:

      
      
        
      
      El botón botón de activación (toggle button)  abre la pestaña con los archivos.
Hagamos click allí y seleccionemos index.html y luego hello.js en el árbol de archivos. Esto es lo que se debería ver:

      
      
        
      
      Podemos ver tres zonas:

La Zona de recursos lista los archivos HTML, JavaScript, CSS y otros, incluyendo imágenes que están incluidas en la página. Las extensiones de Chrome quizás también aparezcan aquí.
La Zona de Recursos muestra el código fuente de los archivos.
La  Zona de información y control es para “debugging”, la exploraremos pronto.

Ahora puedes hacer click en el mismo botón de activación  otra vez para esconder la lista de recursos y darnos más espacio.
ConsolaSi presionamos Esc, la consola se abrirá debajo. Podemos escribir los comandos y presionar Enter para ejecutar.
Después de que se ejecuta una sentencia, el resultado se muestra debajo.
Por ejemplo, aquí 1+2 da el resultado 3, mientras que la llamada a función hello("debugger") no devuelve nada, entonces el resultado es undefined:

      
      
        
      
      Breakpoints (puntos de interrupción)Examinemos qué pasa con el código de la página de ejemplo. En hello.js, haz click en el número de línea 4. Si, en el número 4, no en el código.
¡Felicidades! Ya configuraste un breakpoint. Por favor haz click también en el número de la linea 8.
Debería verse así (en donde está azul es donde deberías hacer click):

      
      
        
      
      Un breakpoint es un punto de código donde el debugger pausará automáticamente la ejecución de JavaScript.
Mientras se pausa el código, podemos examinar las variables actuales, ejecutar comandos en la consola, etc. En otras palabras, podemos depurar.
Siempre podemos encontrar una lista de los breakpoints en el panel derecho. Esto es muy útil cuando tenemos muchos breakpoints en varios archivos. Ya que nos permite:

Saltar rápidamente al breakpoint en el código (haciendo click en él dentro del panel).
Desactivar temporalmente el breakpoint desmarcándolo.
Eliminar el breakpoint haciendo click derecho y seleccionando quitar/eliminar/remove.
…y mucho más.


            Breakpoints Condicionales
            Click derecho en el número de línea nos permite crear un breakpoint condicional. Solo se disparará cuando la expresión dada, que debes proveer cuando la creas, sea verdadera.
Esto es útil cuando necesitamos detener la ejecución para un determinado valor de las variables o parámetros de función.

El comando “debugger”También podemos pausar el código utilizando el comando debugger, así:

      
        
        
          function hello(name) {
  let phrase = `Hello, ${name}!`;

  debugger;  // <-- the debugger stops here

  say(phrase);
}
        
      
      
      Este comando solo funciona cuando el panel de herramientas de desarrollo está abierto, de otro modo el navegador lo ignora.
Pausar y mirar alrededorEn nuestro ejemplo, hello() se llama durante la carga de la página, entonces la forma mas fácil de activar el debugger es recargando la página. Entonces presionemos F5 (en Windows ó Linux) ó Cmd+R (en Mac).
Como el breakpoint está definido, la ejecución se detiene en la línea 4:

      
      
        
      
      Por favor abre el desplegable de información de la derecha (etiquetado con flechas). Este nos permite examinar el estado del código actual:


Watch – muestra el valor actual de cualquier expresión.
Puedes hacer click en el màs + e ingresar una expresión. El debugger mostrará su valor, y se recalculará automáticamente en el proceso de ejecución.


Call Stack – muestra las llamadas anidadas en la cadena.
En el momento actual el debugger está dentro de la función hello(), llamada por un script en index.html (no dentro de ninguna función, por lo que se llama “anonymous”).
Si haces click en un elemento de la pila (por ejemplo “anonymous”), el debugger saltará al código correspondiente, y todas sus variables también serán examinadas.


Scope – variables activas.
Local muestra las variables de la función local. También puedes ver sus valores resaltados sobre el código fuente.
Global contiene las variables globales (fuera de cualquier función).
También tenemos la palabra this la cual no estudiaremos ahora, pero pronto lo haremos.


Trazado de la ejecuciónAhora es tiempo de trazar el script.
Hay botones para esto en le panel superior derecho. Revisémoslos.


 – “Reanudar”: continúa la ejecución, hotkey F8.

Reanuda la ejecución. Si no hay breakpoints adicionales, entonces la ejecución continúa y el debugger pierde el control.
Esto es lo que podemos ver al hacer click:

      
      
        
      
      La ejecución continuó, alcanzando el siguiente breakpoint dentro de say() y pausándose allí. Revisa el “Call stack” a la derecha. Ha incrementado su valor en una llamada. Ahora estamos dentro de say().

 – “Siguiente paso”: ejecuta el siguiente comando, hotkey F9.

Ejecuta la siguiente sentencia. Si la cliqueamos ahora, se mostrara alert.
Otro clic volverá a ejecutar otro comando, y así uno por uno, a través de todo el script.

 – “saltar paso”: corre al comando siguiente, pero no te metas en la función, hotkey F10.

Similar a “siguiente paso”, pero se comporta diferente si la siguiente sentencia es un llamado a función. Esto es: no una nativa como alert, sino una función nuestra.
El comando “siguiente” entra y pausa en la primera línea, en cambio “saltar” ejecuta la función anidada de forma invisible, no mostrando el interior de la función.
La ejecución entonces se pausa inmediatamente despues de esa función.
Es útil si no estamos interesados en ver lo que pasa dentro de la función llamada.

 – siguiente paso, hotkey F11.

Similar a “siguiente”, pero se comporta diferente en las llamadas asincrónicas. Si apenas comienzas en javaScript, puedes ignorar esto por ahora pues no tenemos llamados asincrónicos aún.
Para el futuro, simplemente recuerda que “Siguiente” ignora las acciones asincrónicas tales como setTimeout (llamada a función programada), que se ejecutan después. The “Siguiente dentro” va al interior de su código, esperando por él si es necesario. Puedes ver el DevTools manual para más detalles.

 – “Step out”: continuar la ejecución hasta el final de la función actual, hotkey Shift+F11.

La ejecución se detendrá en la última línea de la función actual. Esto es útil cuando accidentalmente entramos en una llamada anidada usando  que no nos interesa, y queremos continuar hasta el final tan rápido como se pueda.

 – activar/desactivar todos los breakpoints.

Este botón no mueve la ejecución. Solo prende y apaga los breakpoints.

 – activar/desactivar pausa automática en caso de error.

Cuando está activo y la consola de developers tools esta abierta, un error de script automáticamente pausa la ejecución. Entonces podemos analizar las variables para ver qué está mal. Y si nuestro script muere por un error, podemos abrir el debugger, activar esta opción y recargar la página para ver dónde muere y cuál es el contexto en ese momento.



            Continuar hasta aquí
            Click derecho en un una línea de código abre el menú contextual con una gran opción que dice “Continua hasta aquí”.
Esto es útil cuando queremos movernos múltiples pasos adelante, pero somos muy flojos como para definir un breakpoint.

LoggingPara escribir algo en la consola, existe la función console.log.
Por ejemplo, esto muestra los valores desde el 0 hasta el 4 en la consola:

      
        
        
          
            
          
          
            
          
        
        
          // open console to see
for (let i = 0; i < 5; i++) {
  console.log("value,", i);
}
        
      
      
      Los usuarios regulares no ven este output, ya que está en la consola. Para verlo, debemos abrir la consola de desarrolladores y presionar la tecla Esc y en otro tab: se abrirá la consola debajo.
Si tenemos suficiente log en nuestro código, podemos entonces ver lo que va pasando en nuestro registro, sin el debugger.
ResumenComo podemos ver, hay tres formas principales para pausar un script:

Un breakpoint.
La declaración debugger.
Un error (Si la consola esta abierta y el botón  esta “activo”).

Cuando se pausa, podemos hacer “debug”: examinar variables y rastrear el código para ver dónde la ejecución funciona mal.
Hay muchas más opciones en la consola de desarrollo que las que se cubren aquí. El manual completo lo conseguimos en https://developers.google.com/web/tools/chrome-devtools.
La información de este capítulo es suficiente para debuggear, pero luego, especialmente si hacemos muchas cosas con el explorador, por favor revisa las capacidades avanzadas de la consola de desarrolladores.
Ah, y también puedes hacer click en todos lados en la consola a ver qué pasa. Esta es probablemente la ruta más rápida para aprender a usar la consola de desarrolladores. ¡Tampoco olvides el click derecho!
",
	"url": "https://es.javascript.info/debugging-chrome" 
},
{
	"docs_id": "25",
	"name": "Estilo de codificación",
	"description": "Nuestro código debe ser lo más limpio y fácil de leer como sea posible.",
	"content": "Nuestro código debe ser lo más limpio y fácil de leer como sea posible.
Ese es en realidad el arte de la programación: tomar una tarea compleja y codificarla de manera correcta y legible para los humanos. Un buen estilo de código ayuda mucho en eso.
SintaxisAquí hay una hoja de ayuda con algunas reglas sugeridas (ver abajo para más detalles):

      
      
        
      
      
Ahora discutamos en detalle las reglas y las razones para ellas.

            No existen reglas “usted debe”
            Nada está escrito en piedra aquí. Estos son preferencias de estilos, no dogmas religiosos.

LlavesEn la mayoría de proyectos de Javascript las llaves están escritas en estilo “Egipcio” con la llave de apertura en la misma linea como la correspondiente palabra clave – no en una nueva linea. Debe haber también un espacio después de la llave de apertura, como esto:

      
        
        
          if (condition) {
  // hacer esto
  // ...y eso
  // ...y eso
}
        
      
      
      Una construcción de una sola línea, como if (condition) doSomething(), es un caso límite importante. ¿Deberíamos usar llaves?
Aquí están las variantes anotadas para que puedas juzgar la legibilidad por ti mismo.

😠 Los principiantes a veces hacen eso. ¡Malo! Las llaves no son necesarias:
      
        
        
          if (n < 0) {alert(`Power ${n} is not supported`);}
        
      
      
      
😠 Dividir en una línea separada sin llaves. Nunca haga eso, es fácil cometer un error al agregar nuevas líneas:
      
        
        
          if (n < 0)
  alert(`Power ${n} is not supported`);
        
      
      
      
😏 Una línea sin llaves: aceptable, si es corta:
      
        
        
          if (n < 0) alert(`Power ${n} is not supported`);
        
      
      
      
😃 La mejor variante:
      
        
        
          if (n < 0) {
  alert(`Power ${n} is not supported`);
}
        
      
      
      

Para un código muy breve, se permite una línea, p. if (cond) return null. Pero un bloque de código (la última variante) suele ser más legible.
Tamaño de líneaA nadie le gusta leer una larga línea horizontal de código. Es una buena práctica dividirlos.
Por ejemplo:

      
        
        
          // acento grave ` permite dividir la cadena de caracteres en múltiples líneas
let str = `
  ECMA International's TC39 is a group of JavaScript developers,
  implementers, academics, and more, collaborating with the community
  to maintain and evolve the definition of JavaScript.
`;
        
      
      
      Y para sentencias if:

      
        
        
          if (
  id === 123 &&
  moonPhase === 'Waning Gibbous' &&
  zodiacSign === 'Libra'
) {
  letTheSorceryBegin();
}
        
      
      
      La longitud máxima de la línea debe acordarse con el equipo de trabajo. Suele tener 80 o 120 caracteres.
Indentación (sangría)Hay dos tipos de indentación:


Indentación horizontal: 2 o 4 espacios.
Se realiza una sangría horizontal utilizando 2 o 4 espacios o el símbolo de tabulación horizontal (key Tabulador). Cuál elegir es una vieja guerra santa. Los espacios son más comunes hoy en día.
Una ventaja de los espacios sobre las tabulaciones es que los espacios permiten configuraciones de sangría más flexibles que el símbolo del tabulador.
Por ejemplo, podemos alinear los argumentos con el paréntesis de apertura, así:

      
        
        
          show(parameters,
     aligned, // 5 espacios de relleno a la izquierda
     one,
     after,
     another
  ) {
  // ...
}
        
      
      
      

Indentación vertical: líneas vacías para dividir código en bloques lógicos.
Incluso una sola función a menudo se puede dividir en bloques lógicos. En el siguiente ejemplo, la inicialización de variables, el bucle principal y la devolución del resultado se dividen verticalmente:

      
        
        
          function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}
        
      
      
      Insertar una nueva línea extra donde ayude a hacer el código mas legible. No debe haber más de nueve líneas de código sin una indentación vertical.


Punto y comaDebe haber un punto y coma después de cada declaración, incluso si se puede omitir.
Hay idiomas en los que un punto y coma es realmente opcional y rara vez se usa. Sin embargo, en JavaScript, hay casos en los que un salto de línea no se interpreta como un punto y coma, lo que deja el código vulnerable a errores. Vea más sobre eso en el capítulo Estructura del código.
Si eres un programador de JavaScript experimentado, puedes elegir un estilo de código sin punto y coma como StandardJS. De lo contrario, es mejor usar punto y coma para evitar posibles escollos. La mayoría de los desarrolladores ponen punto y coma.
Niveles anidadosIntenta evitar anidar el código en demasiados niveles de profundidad.
Algunas veces es buena idea usar la directiva “continue” en un bucle para evitar anidamiento extra.
Por ejemplo, en lugar de añadir un if anidado como este:

      
        
        
          for (let i = 0; i < 10; i++) {
  if (cond) {
    ... // <- un nivel más de anidamiento
  }
}
        
      
      
      Podemos escribir:

      
        
        
          for (let i = 0; i < 10; i++) {
  if (!cond) continue;
  ...  // <- sin nivel extra de anidamiento
}
        
      
      
      Algo similar se puede hacer con if/else y return.
Por ejemplo, las dos construcciones siguientes son idénticas.
Opción 1:

      
        
        
          function pow(x, n) {
  if (n < 0) {
    alert("Negative 'n' not supported");
  } else {
    let result = 1;

    for (let i = 0; i < n; i++) {
      result *= x;
    }

    return result;
  }
}
        
      
      
      Opción 2:

      
        
        
          function pow(x, n) {
  if (n < 0) {
    alert("Negative 'n' not supported");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      El segundo es más legible porque el “caso especial” de n < 0 se maneja desde el principio. Una vez que se realiza la verificación, podemos pasar al flujo de código “principal” sin la necesidad de anidamiento adicional.
Colocación de funcionesSi está escribiendo varias funciones “auxiliares” y el código que las usa, hay tres formas de organizar las funciones.


Declare las funciones anteriores al código que las usa:

      
        
        
          // declaración de funciones
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}

// el código que las usan
let elem = createElement();
setHandler(elem);
walkAround();
        
      
      
      

Código primero, después funciones

      
        
        
          // El código que usa a las funciones
let elem = createElement();
setHandler(elem);
walkAround();

// --- Funciones auxiliares ---
function createElement() {
  ...
}

function setHandler(elem) {
  ...
}

function walkAround() {
  ...
}
        
      
      
      

Mixto: una función es declarada donde se usa por primera vez.


La mayoría del tiempo, la segunda variante es preferida.
Eso es porque al leer el código, primero queremos saber qué hace. Si el código va primero, entonces queda claro desde el principio. Entonces, tal vez no necesitemos leer las funciones, especialmente si sus nombres son descriptivos de lo que realmente hacen.
Guías de estiloUna guía de estilo contiene reglas generales sobre “cómo escribir” el código, cuáles comillas usar, cuántos espacios para indentar, la longitud máxima de la línea, etc. Muchas cosas menores.
Cuando todos los miembros de un equipo usan la misma guía de estilo, el código se ve uniforme, independientemente de qué miembro del equipo lo haya escrito.
Por supuesto, un equipo siempre puede escribir su propia guía de estilo, pero generalmente no es necesario. Hay muchas guías existentes para elegir.
Algunas opciones populares:

Google JavaScript Style Guide
Airbnb JavaScript Style Guide
Idiomatic.JS
StandardJS
(y mucho mas)

Si eres un desarrollador novato, puedes comenzar con la guía al comienzo de este capítulo. Luego, puedes buscar otras guías de estilo para recoger más ideas y decidir cuál te gusta más.
Linters automatizadosLinters son herramientas que pueden verificar automáticamente el estilo de su código y hacer sugerencias de mejora.
Lo mejor de ellos es que la comprobación de estilo también puede encontrar algunos errores, como errores tipográficos en nombres de variables o funciones. Debido a esta característica, se recomienda usar un linter incluso si no desea apegarse a un “estilo de código” en particular.
Aquí hay algunas herramientas de linting conocidas:

JSLint – uno de los primeros linters.
JSHint – más ajustes que JSLint.
ESLint – probablemente el más reciente.

Todos ellos pueden hacer el trabajo. El autor usa ESLint.
La mayoría de las linters están integradas con muchos editores populares: solo habilite el complemento en el editor y configure el estilo.
Por ejemplo, para ESLint debe hacer lo siguiente:

Instala Node.JS.
Instala ESLint con el comando npm install -g eslint (npm es un instalador de paquetes de Javascript).
Crea un archivo de configuración llamado .eslintrc en la raíz de tu proyecto de javascript (en la carpeta que contiene todos tus archivos).
Instala/Habilita el plugin para que tu editor se integre con ESLint. La mayoría de editores tienen uno.

Aquí un ejemplo de un archivo .eslintrc:

      
        
        
          {
  "extends": "eslint:recommended",
  "env": {
    "browser": true,
    "node": true,
    "es6": true
  },
  "rules": {
    "no-console": 0,
    "indent": 2
  }
}
        
      
      
      Aquí la directiva "extends" denota que la configuración se basa en el conjunto de configuraciones “eslint: recomendado”. Después de eso, especificamos el nuestro.
También es posible descargar conjuntos de reglas de estilo de la web y extenderlos. Consulte https://eslint.org/docs/user-guide/getting-started para obtener más detalles sobre la instalación.
También algunos IDE tienen linting incorporado, lo cual es conveniente pero no tan personalizable como ESLint.
ResumenTodas las reglas de sintaxis descritas en este capítulo (y en las guías de estilo mencionadas) tienen como objetivo aumentar la legibilidad de su código. Todos ellos son discutibles.
Cuando pensamos en escribir un código “mejor”, las preguntas que debemos hacernos son: “¿Qué hace que el código sea más legible y fácil de entender?” y “¿Qué puede ayudarnos a evitar errores?” Estas son las principales cosas a tener en cuenta al elegir y debatir estilos de código.
La lectura de guías de estilo populares le permitirá mantenerse al día con las últimas ideas sobre las tendencias de estilo de código y las mejores prácticas.
TareasEstilo pobreimportancia: 4¿Qué hay de malo con el estilo de código a continuación?

      
        
        
          function pow(x,n)
{
  let result=1;
  for(let i=0;i<n;i++) {result*=x;}
  return result;
}

let x=prompt("x?",''), n=prompt("n?",'')
if (n<=0)
{
  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
}
else
{
  alert(pow(x,n))
}
        
      
      
      Arreglalo.
soluciónPodrías notar lo siguiente:

      
        
        
          function pow(x,n)  // <- sin espacio entre argumentos
{  // <- llave en una línea separada
  let result=1;   // <- sin espacios antes o después de =
  for(let i=0;i<n;i++) {result*=x;}   // <- sin espacios
  // el contenido de {...} debe estar en una nueva línea
  return result;
}

let x=prompt("x?",''), n=prompt("n?",'') // <-- técnicamente posible,
// pero mejor que sea 2 líneas, también no hay espacios y falta ;
if (n<0)  // <- sin espacios dentro (n < 0), y debe haber una línea extra por encima
{   // <- llave en una línea separada
  // debajo - las líneas largas se pueden dividir en varias líneas para mejorar la legibilidad
  alert(`Power ${n} is not supported, please enter an integer number greater than zero`);
}
else // <- podría escribirlo en una sola línea como "} else {"
{
  alert(pow(x,n))  // sin espacios y falta ;
}
        
      
      
      La variante corregida:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

let x = prompt("x?", "");
let n = prompt("n?", "");

if (n <= 0) {
  alert(`Power ${n} is not supported,
    please enter an integer number greater than zero`);
} else {
  alert( pow(x, n) );
}
        
      
      
      ",
	"url": "https://es.javascript.info/coding-style" 
},
{
	"docs_id": "26",
	"name": "Comentarios",
	"description": "Como hemos aprendido en el capítulo Estructura del código, los comentarios pueden ser de una sola línea: comenzando con // y de múltiples líneas: /* ... */.",
	"content": "Como hemos aprendido en el capítulo Estructura del código, los comentarios pueden ser de una sola línea: comenzando con // y de múltiples líneas: /* ... */.
Normalmente los usamos para describir cómo y por qué el código funciona.
A primera vista, los comentarios pueden ser obvios, pero los principiantes en programación generalmente los usan incorrectamente.
Comentarios incorrectosLos principiantes tienden a utilizar los comentarios para explicar “lo que está pasando en el código”. Así:

      
        
        
          // Este código hará esto (...) y esto (...)
// ...y quién sabe qué más...
código;
muy;
complejo;
        
      
      
      Pero en un buen código, la cantidad de comentarios “explicativos” debería ser mínima. En serio, el código debería ser fácil de entender sin ellos.
Existe una fantástica regla al respeto: “si el código es tan poco claro que necesita un comentario, tal vez en su lugar debería ser reescrito.”.
Receta: funciones externasA veces es beneficioso reemplazar trozos de código con funciones, como aquí:

      
        
        
          function showPrimes(n) {
  nextPrime:
  for (let i = 2; i < n; i++) {

    // comprobar si i es un número primo
    for (let j = 2; j < i; j++) {
      if (i % j == 0) continue nextPrime;
    }

    alert(i);
  }
}
        
      
      
      La mejor variante, con una función externa isPrime:

      
        
        
          function showPrimes(n) {

  for (let i = 2; i < n; i++) {
    if (!isPrime(i)) continue;

    alert(i);
  }
}

function isPrime(n) {
  for (let i = 2; i < n; i++) {
    if (n % i == 0) return false;
  }

  return true;
}
        
      
      
      Ahora podemos entender el código fácilmente. La propia función se convierte en comentario. Este tipo de código se le llama auto descriptivo.
Receta: crear funcionesY si tenemos una larga “hoja de código” como esta:

      
        
        
          // aquí añadimos whiskey
for(let i = 0; i < 10; i++) {
  let drop = getWhiskey();
  smell(drop);
  add(drop, glass);
}

// aquí añadimos zumo
for(let t = 0; t < 3; t++) {
  let tomato = getTomato();
  examine(tomato);
  let juice = press(tomato);
  add(juice, glass);
}

// ...
        
      
      
      Entonces, una versión mejor puede ser reescribirlo en funciones de esta manera:

      
        
        
          addWhiskey(glass);
addJuice(glass);

function addWhiskey(container) {
  for(let i = 0; i < 10; i++) {
    let drop = getWhiskey();
    //...
  }
}

function addJuice(container) {
  for(let t = 0; t < 3; t++) {
    let tomato = getTomato();
    //...
  }
}
        
      
      
      De nuevo, la propias funciones nos dicen qué está pasando. No hay nada que comentar. Y además, la estructura del código es mejor cuando está dividida. Queda claro qué hace cada función, qué necesita y qué retorna.
En realidad, no podemos evitar totalmente los comentarios “explicativos”. Existen algoritmos complejos. Y existen “trucos” ingeniosos con el propósito de optimizar. Pero generalmente, tenemos que intentar mantener el código simple y auto descriptivo.
Comentarios correctosEntonces, los comentarios explicativos suelen ser incorrectos. ¿Qué comentarios son correctos?

Describe la arquitectura
Proporcionan una descripción general de alto nivel de los componentes, cómo interactúan, cuál es el flujo de control en diversas situaciones… En resumen – la vista panorámica del código. Hay un lenguaje de diagramas especial UML para diagramas de alto nivel. Definitivamente vale la pena estudiarlo.
Documenta la utilización de una función
Hay una sintaxis especial JSDoc para documentar una función: utilización, parámetros, valor devuelto.

Por ejemplo:

      
        
        
          /**
  * Devuelve x elevado a la potencia de n.
  *
  * @param {number} x El número a elevar.
  * @param {number} n La potencia, debe ser un número natural.
  * @return {number} x elevado a la potencia de n.
  */
function pow(x, n) {
  ...
}
        
      
      
      Este tipo de comentarios nos permite entender el propósito de la función y cómo usarla de la manera correcta sin tener que examinar su código.

Por cierto, muchos editores como [WebStorm](https://www.jetbrains.com/webstorm/) también pueden entenderlos y usarlos para proveer auto completado y algún tipo de verificación automática para el código.

Además, existen herramientas como [JSDoc 3](https://github.com/jsdoc3/jsdoc) que pueden generar documentación en formato HTML de los comentarios. Puedes leer más información sobre JSDoc en <https://jsdoc.app>.


¿Por qué se resuelve de esa manera?

Lo que está escrito es importante. Pero lo que no está escrito puede ser aún más importante para entender qué está pasando. ¿Por qué resuelven la tarea exactamente de esa manera? El código no nos da ninguna respuesta.
Si hay muchas maneras de resolver el problema, ¿por qué esta? Especialmente cuando no es la más obvia.
Sin dichos comentarios, las siguientes situaciones son posibles:

Tú (o tu compañero) abres el código escrito hace ya algún tiempo, y te das cuenta de que es “subóptimo”.
Piensas: “Que estúpido que era antes, y que inteligente que soy ahora”, y lo reescribes utilizando la variante “más obvia y correcta”.
…El impulso de reescribir era bueno. Pero en el proceso ves que la solución “más obvia” en realidad falla. Incluso recuerdas vagamente el porqué, porque ya lo intentaste hace mucho. Vuelves a la variante correcta, pero has estado perdiendo el tiempo.

Los comentarios que explican la solución correcta son muy importantes. Nos ayudan a continuar el desarrollo de forma correcta.

¿Alguna característica sutil del código? ¿Dónde se usan?

Si el código tiene algo sutil y contraintuitivo, definitivamente vale la pena comentarlo.


ResumenUna señal importante de un buen desarrollador son los comentarios: su presencia e incluso su ausencia.
Los buenos comentarios nos permiten mantener bien el código, volver después de un retraso y usarlo de manera más efectiva.
Comenta esto:

Arquitectura en general, vista de alto nivel.
Utilización de funciones.
Soluciones importantes, especialmente cuando no son inmediatamente obvias.

Evita comentarios:

Que explican “cómo funciona el código” y “qué hace”.
Escríbelos solo si es imposible escribir el código de manera tan simple y auto descriptiva que no los necesite.

Los comentarios también son usados para herramientas de auto documentación como JSDoc3: los leen y generan documentación en HTML (o documentos en otros formatos).
",
	"url": "https://es.javascript.info/comments" 
},
{
	"docs_id": "27",
	"name": "Código ninja",
	"description": "Aprender sin pensar es inútil. Pensar sin aprender peligroso.",
	"content": "Aprender sin pensar es inútil. Pensar sin aprender peligroso.

        Confucio (Analectas)
       Los programadores ninjas del pasado usaron estos trucos para afilar la mente de los mantenedores de código.
Los gurús de revisión de código los buscan en tareas de prueba.
Los desarrolladores novatos algunas veces los usan incluso mejor que los programadores ninjas.
Léelos detenidamente y encuentra quién eres – ¿un ninja?, ¿un novato?, o tal vez ¿un revisor de código?

            Ironía detectada
            Muchos intentan seguir los caminos de los ninjas. Pocos tienen éxito.

La brevedad es el alma del ingenioHaz el código lo más corto posible. Demuestra cuán inteligente eres.
Deja que las características sutiles del lenguaje te guíen.
Por ejemplo, echa un vistazo a este operador ternario '?':

      
        
        
          // tomado de una librería de javascript muy conocida
i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
        
      
      
      Fascinante, ¿cierto?. Si escribes de esa forma, un desarrollador que se encuentre esta línea e intente entender cuál es el valor de i la va a pasar muy mal. Por lo que tendrá que venir a ti, buscando una respuesta.
Diles que mientras más corto mucho mejor. Guíalos a los caminos del ninja.
Variables de una sola letraEl Dao se esconde sin palabras. Solo el Dao está bien comenzado y bien
terminado.

        Laozi (Tao Te Ching)
       Otra forma de programar más rápido es usando variables de una sola letra en todas partes. Como a, b o c.
Una variable corta desaparece en el código como lo hace un ninja en un bosque. Nadie será capaz de encontrarla usando “buscar” en el editor. E incluso si alguien lo hace, no será capaz de “descifrar” el significado de a o b.
…Pero hay una excepción. Un verdadero ninja nunca usaría i como el contador en un bucle "for". En cualquier otro lugar, pero no aquí. Mira alrededor, hay muchas más letras exóticas. Por ejemplo, x o y.
Una variable exótica como el contador de un bucle es especialmente genial si el cuerpo del bucle toma 1-2 páginas (hazlo más grande si puedes). Entonces si alguien mira en las profundidades del bucle, no será capaz de figurar rápidamente que la variable llamada x es el contador del bucle.
Usa abreviacionesSi las reglas del equipo prohíben el uso de nombres de una sola letra o nombres vagos – acórtalos, haz abreviaciones.
Como esto:

list → lst.
userAgent → ua.
browser → brsr.
…etc

Solo aquel con buena intuición será capaz de entender dichos nombres. Intenta acortar todo. Solo una persona digna debería ser capaz de sostener el desarrollo de tu código.
Vuela alto. Sé abstractoEl gran cuadrado no tiene esquina
La gran vasija se completa por última vez,
La gran nota es un sonido enrarecido,
La gran imagen no tiene forma.

        Laozi (Tao Te Ching)
       Cuando estés escogiendo un nombre intenta usar la palabra más abstracta. Como obj, data, value, item, elem, etc.


El nombre ideal para una variable es data. Usalo lo más que puedas. En efecto, toda variable contiene data, ¿no?
…¿Pero qué hacer si data ya está siendo usado? Intenta con value, también es universal. Después de todo, una variable eventualmente recibe un value (valor).


Nombra una variable por su tipo: str, num…
Pruébalos. Un recién iniciado puede preguntarse – ¿Son estos nombres realmente útiles para un ninja? En efecto, ¡lo son!
Claro, el nombre de la variable sigue significando algo. Dice que hay en el interior de la variable: una cadena de texto, un número o cualquier otra cosa. Pero cuando una persona ajena intenta entender el código, se verá sorprendido al ver que en realidad no hay información. Y finalmente fracasara en el intento de alterar tu código bien pensado.
El tipo de valor es fácil de encontrar con una depuración. Pero, ¿cuál es el significado de la variable? ¿Qué cadena de texto o número guarda?
¡No hay forma de saberlo sin una buena meditación!


…Pero, ¿Y si ya no hay más de tales nombres? Simplemente añade un número: data1, item2, elem5…


Prueba de atenciónSolo un programador realmente atento debería ser capaz de entender tu código. Pero, ¿cómo comprobarlo?
``
Una de las maneras – usa nombre de variables similares, como date y data.
Combínalos donde puedas.
Una lectura rápida de dicho código se hace imposible. Y cuando hay un error de tipografía…. Ummm… Estamos atrapados por mucho tiempo, hora de tomar té.
Sinónimos inteligentesEl Tao que puede ser expresado no es el Tao eterno. El nombre que puede ser nombrado no es el nombre eterno.

        Lao Tse (Tao Te Ching)
       Usando nombres similares para las mismas cosas hace tu vida mas interesante y le muestra al público tu creatividad.
Por ejemplo, considera prefijos de funciones. Si una función muestra un mensaje en la pantalla – comiénzalo con mostrar..., como mostarMensaje. Y entonces si otra función muestra en la pantalla otra cosa, como un nombre de usuario, comiénzalo con presentar... (como presentarNombre).
Insinúa que hay una diferencia sutil entre dichas funciones, cuando no lo hay.
Has un pacto con tus compañeros ninjas del equipo: si John comienza funciones de “mostrar” con presentar... en su código, entonces Peter podría usar exhibir.., y Ann – pintar.... Nota como el código es mucho más interesante y diverso ahora.
…¡Y ahora el truco del sombrero!
Para dos funciones con importantes diferencias – ¡usa el mismo prefijo!
Por ejemplo, la función imprimirPágina(página) usara una impresora. Y la función imprimirTexto(texto) mostrará el texto en la pantalla… Deja que un lector no familiar a tu código piense bien sobre una función llamada de forma similar imprimirMensaje: "¿Dónde coloca el mensaje? ¿A una impresora o en la pantalla?. Para que realmente se destaque, ¡imprimirMensaje(mensaje) debería mostrar el mensaje en una nueva ventana!
Reutilizar nombresUna vez que el todo se divide, las partes 
necesitan nombres. 
Ya hay suficientes nombres. 
Uno debe saber cuándo parar.

        Laozi (Tao Te Ching)
       Añade una nueva variable sólo cuando sea necesario.
En lugar, reutiliza nombres que ya existen. Simplemente escribe nuevo valores en ellos.
En una función intenta sólo usar las variables pasadas como parámetros.
Eso hará que sea realmente difícil identificar qué es exactamente la variable ahora. Y además de donde viene. El propósito es desarrollar la intuición y memoria de la persona que lee el código. Una persona con intuición débil tendrá que analizar el código línea por línea y seguir los cambios en cada rama de código.
Una variante avanzada del enfoque es reemplazar los valores de forma encubierta con algo parecido en la mitad de un bucle o una función.
Por ejemplo:

      
        
        
          function ninjaFunction(elem) {
  // 20 líneas de código trabajando con elem

  elem = clone(elem);

  // 20 líneas más, ¡ahora trabajando con el clon de elem!
}
        
      
      
      Un colega programador que quiera trabajar con elem en la segunda mitad de la función será sorprendido… ¡Solo durante la depuración, después de examinar el código encontrara que está trabajando con un clon!
Visto regularmente en códigos. Letalmente efectivo, incluso contra ninjas experimentados.
Guiones bajos por diversiónColoca guiones bajos _ y __ antes de los nombres de las variables. Como _name o __value. Sería genial si solo tú sabes su significado. O, mejor, añádelos simplemente por diversión, sin ningún significado especial. O diferentes significados en diferentes lugares.
Matarás dos pájaros de un solo tiro. Primero, el código se hará más largo y menos legible, y segundo, un colega desarrollador podría gastar una gran cantidad de tiempo intentado entender el significado del guion bajo.
Un ninja inteligente coloca los guiones bajos en un solo lugar del código y los evita en otros lugares. Eso hace que el código sea mucho más frágil y aumenta la probabilidad de errores futuros.
Muestra tu amor¡Deja que todos vean cuán magníficas son tus entidades! Nombres como superElement, megaFrame and niceItem iluminaran sin duda al lector.
En efecto, por una parte, algo es escrito: super.., mega.., nice.., pero por otra parte – no da ningún detalle. Un lector podría decidir mirar por un significado oculto y meditar por una hora o dos.
Superpón variables externasCuando está a la luz, no puede ver nada en la oscuridad. 
Cuando está en la oscuridad, puede ver todo a la luz.

        Guan Yin Zi
       Usa los mismos nombres para variables dentro y fuera de una función. Así de simple. Sin el esfuerzo de inventar nuevos nombres.

      
        
        
          let user = authenticateUser();

function render() {
  let user = anotherValue();
  ...
  ...many lines...
  ...
  ... // <-- un programador quiere trabajar con user aquí y...
  ...
}
        
      
      
      Un programador que se adentra en render probablemente no notara que hay un user local opacando al de afuera.
Entonces intentaran trabajar con user asumiendo que es la variable externa, el resultado de authenticateUser()… ¡Se activa la trampa! Hola, depurador…
¡Efectos secundarios en todas partes!Hay muchas funciones que parecen que no cambian nada. Como estaListo(), comprobarPermiso(), encontrarEtiquetas()… Se asume que sacan los cálculos, encuentran y regresan los datos, sin cambiar nada fuera de ellos. En otras palabras, sin “efectos secundarios”.
Un truco realmente bello es añadirles una acción “útil”, además de su tarea principal.
Una expresión de sorpresa aturdida aparecerá en la cara de tus colegas cuando vean que la función llamada es.., comprobar.. o encontrar... cambia algo – definitivamente ampliará tus límites de razón.
Otra forma de sorprender es retornar un resultado no estándar
¡Muestra tu pensamiento original! Deja que la llamada de comprobarPermiso retorne no true/false sino un objeto complejo con los resultados de tu comprobación.
Funciones poderosas!El gran Tao fluye por todas partes, 
tanto a la izquierda como a la derecha.

        Laozi (Tao Te Ching)
       No limites la función por lo que está escrito en el nombre. Se más abierto.
Por ejemplo, una función validarEmail(email) podría (además de comprobar el email por exactitud) muestra un mensaje de error y preguntar de nuevo por el email.
Acciones adicionales no deberían ser obvias por el nombre de la función. Un verdadero programador ninja no las hará obvias por el código tampoco.
Uniendo muchas acciones en una protege tu código de reúsos.
Imagina, otro desarrollador quiere solo comprobar el correo, y no mostrar ningún mensaje. Tu función validarEmail(email) que hace ambas no le será de utilidad. Así que no romperán tu meditación preguntando cualquier cosa sobre ello.
ResumenTodos los consejos anteriores son de código real… Algunas veces, escrito por desarrolladores experimentados. Quizás incluso más experimentado que tú ;)

Sigue alguno de ellos, y tu código estará lleno de sorpresas.
Sigue muchos de ellos, y tu código será realmente tuyo, nadie querrá cambiarlo.
Sigue todos, y tu código será una lección valiosa para desarrolladores jóvenes buscando iluminación.

",
	"url": "https://es.javascript.info/ninja-code" 
},
{
	"docs_id": "28",
	"name": "Test automatizados con Mocha",
	"description": "Los tests automáticos serán usados en tareas que siguen, y son ampliamente usados en proyectos reales.",
	"content": "Los tests automáticos serán usados en tareas que siguen, y son ampliamente usados en proyectos reales.
¿Por qué necesitamos tests?Cuando escribimos una función, normalmente imaginamos qué debe hacer: Para ciertos parámetros, qué resultado.
Durante el desarrollo, podemos comprobar la función ejecutándola y comparando el resultado con la salida esperada. Por ejemplo, podemos hacer eso en la consola.
Si algo está incorrecto corregimos el código, ejecutamos de nuevo, comprobamos resultado, y así sucesivamente hasta que funcione.
Pero esas “re-ejecuciones” manuales son imperfectas.
Cuando testeamos un código re-ejecutándolo manualmente es fácil obviar algo.
Por ejemplo, estamos creando una función f. Escribimos algo de código, testeamos: f(1) funciona, pero f(2) no funciona. Corregimos el código y ahora funciona f(2). ¿Está completo? Hemos olvidado re-testear f(1). Esto puede llevar a error.
Todo esto es muy típico. Cuando desarrollamos algo, mantenemos muchos casos de uso posibles en la cabeza. Pero es difícil esperar que un/a programador/a los compruebe a todos después de cada cambio. Por lo que deviene fácil arreglar una cosa y romper otra.
Los tests automatizados implican escribir los tests por separado, además del código. Ellos ejecutan nuestras funciones de varias formas y comparan los resultados con los esperados.
Desarrollo guiado por comportamiento (Behavior Driven Development, BDD)Vamos a usar una técnica llamada Desarrollo guiado por comportamiento o por sus siglas en inglés, BDD.
BDD son tres cosas en uno: tests, documentación y ejemplos.
PAra entender BDD, examinaremos un caso de desarrollo práctico:
Desarrollo de “pow”: EspecificaciónDigamos que queremos hacer una función pow(x, n) que eleve x a la potencia de un entero n. Asumimos que n≥0.
Esta tarea es sólo un ejemplo: Hay un operador ** en JavaScript que hace eso, pero queremos concentrarnos en el flujo de desarrollo que puede ser aplicado a tareas más complejas.
Antes de crear el código de pow, podemos imaginar lo que hace la función y describirlo.
Esa descripción es llamada especificación o “spec” y contiene las descripciones de uso junto con los test para probarlas, como:

      
        
        
          describe("pow", function() {

  it("eleva a la n-ésima potencia", function() {
    assert.equal(pow(2, 3), 8);
  });

});
        
      
      
      Una spec tiene tres bloques principales, mostrados abajo:

describe("titulo", function() { ... })

¿Qué funcionalidad estamos describiendo? En nuestro caso estamos describiendo la función pow. Utilizado para agrupar los “workers” (trabajadores): los bloques it.

it("titulo", function() { ... })

En el título de it introducimos una descripción legible del caso de uso. El segundo argumento es la función que testea eso.

assert.equal(value1, value2)

El código dentro del bloque it que, si la implementación es correcta, debe ejecutar sin errores.
Las funciones assert.* son usadas para comprobar que pow funcione como esperamos. Aquí mismo utilizamos una de ellas: assert.equal, que compara argumentos y produce un error si los mismos no son iguales. Arriba se está comprobando que el resultado de pow(2, 3) sea igual a 8. Hay otros tipos de comparaciones y comprobaciones que veremos más adelante.


La especificación puede ser ejecutada, y hará los los test dictados en el bloque it.  Lo veremos luego.
El flujo de desarrolloEl flujo de desarrollo se ve así:

Un spec inicial es escrito, con tests para la funcionalidad más básica.
Una implementación inicial es creada.
Para comprobar que funciona, ejecutamos el framework de test Mocha (detallado más adelante) que ejecuta el spec.  Mostrará los errores mientras la funcionalidad no esté completa. Hacemos correcciones hasta que todo funciona.
Ahora tenemos una implementación inicial con tests.
Añadimos más casos de uso al spec, seguramente no soportados aún por la implementación. Los tests empiezan a fallar.
Ir a 3, actualizar la implementación hasta que los tests no den errores.
Repetir pasos 3-6 hasta que la funcionalidad este lista.

De tal forma que el desarrollo es iterativo. Escribimos la especificación, la implementamos, aseguramos que los tests pasen y entonces escribimos más tests y volvemos a asegurar que pasen, etc. Al final tenemos una implementación funcionando con tests para ella.
Veamos el flujo de desarrollo en nuestro caso práctico.
El primer paso esta completo: tenemos una spec inicial para pow. Ahora, antes de realizar la implementación, usamos algunas librerías JavaScript para ejecutar los tests, solo para asegurarnos que funcionen (van a fallar todos).
La spec en acciónEn este tutorial estamos usando las siguientes librerías JavaScript para los tests:

Mocha – el framework central: provee funciones para test comunes como describe e it y la función principal que ejecuta los tests.
Chai – una librería con muchas funciones de comprobación (assertions). Permite el uso de diferentes comprobaciones. De momento usaremos assert.equal.
Sinon – una librería para espiar funciones. Simula funciones incorporadas al lenguaje y mucho más. La necesitaremos a menudo más adelante.

Estas librerías son adecuadas tanto para tests en el navegador como en el lado del servidor. Aquí nos enfocaremos en el navegador.
La página HTML con estos frameworks y la spec de pow:

      
        
        
          <!DOCTYPE html>
<html>
<head>
  <!-- incluir css para mocha, para mostrar los resultados -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.css">
  <!-- incluir el código del framework mocha -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/3.2.0/mocha.js"></script>
  <script>
    mocha.setup('bdd'); // configuración mínima
  </script>
  <!-- incluir chai -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/3.5.0/chai.js"></script>
  <script>
    // chai tiene un montón de cosas, hacemos assert global
    let assert = chai.assert;
  </script>
</head>

<body>

  <script>
    function pow(x, n) {
      /* código a escribir de la función, de momento vacío */
    }
  </script>

  <!-- el script con los tests (describe, it...) -->
  <script src="test.js"></script>

  <!-- el elemento con id="mocha" que contiene los resultados de los tests -->
  <div id="mocha"></div>

  <!-- ¡ejectuar los tests! -->
  <script>
    mocha.run();
  </script>
</body>

</html>
        
      
      
      La página puede ser dividida en cinco partes:

El <head> – importa librerías de terceros y estilos para los tests.
El <script> con la función a comprobar, en nuestro caso con el código de pow.
Los tests – en nuestro caso un fichero externo test.js que contiene un sentencia describe("pow", ...)al inicio.
El elemento HTML <div id="mocha"> utilizado para la salida de los resultados.
Los test se inician con el comando mocha.run().

El resultado:

    
        
      
      
    
  De momento, el test falla. Es lógico: tenemos el código vacío en la función pow, así que pow(2,3) devuelve undefined en lugar de 8.
Para más adelante, ten en cuenta que hay avanzados test-runners (Herramientas para ejecutar los test en diferentes entornos de forma automática), como karma y otros. Por lo que generalmente no es un problema configurar muchos tests diferentes.
Implementación inicialVamos a realizar una implementación simple de pow, suficiente para pasar el test:

      
        
        
          function pow(x, n) {
  return 8; // :) ¡hacemos trampas!
}
        
      
      
      ¡Ahora funciona!

    
        
      
      
    
  Mejoramos el specLo que hemos hecho es una trampa. La función no funciona bien: ejecutar un cálculo diferente, como pow(3,4), nos devuelve un resultado incorrecto, pero el test pasa.
… pero la situación es habitual, ocurre en la práctica. Los tests pasan, pero la función no funciona bien. Nuestra especificación está incompleta. Necesitamos añadir más casos de uso a la especificación.
Vamos a incluir un test para ver si pow(3,4) = 81.
Podemos escoger entre dos formas de organizar el test:


La primera manera – añadir un assert más en el mismo it:

      
        
        
          describe("pow", function() {

  it("eleva a la n-ésima potencia", function() {
    assert.equal(pow(2, 3), 8);
    assert.equal(pow(3, 4), 81);
  });

});
        
      
      
      

La segunda – hacer dos tests:

      
        
        
          describe("pow", function() {

  it("2 elevado a la potencia de 3 es 8", function() {
    assert.equal(pow(2, 3), 8);
  });

  it("3 elevado a la potencia de 3 es 27", function() {
    assert.equal(pow(3, 3), 27);
  });

});
        
      
      
      

La diferencia principal se da cuando assert lanza un error, el bloque it termina inmediatamente. De forma que si en la primera manera el primer assert falla, no veremos nunca el resultado del segundo assert.
Hacer los tests separados es útil para recoger información sobre qué está pasando, de forma que la segunda manera es mejor.
A parte de eso, hay otra regla que es bueno seguir.
Un test comprueba una sola cosa
Si vemos que un test contiene dos comprobaciones independientes, es mejor separar el test en dos tests más simples.
Así que continuamos con la segunda manera.
El resultado:

    
        
      
      
    
  Como podemos esperar, el segundo falla. Nuestra función siempre devuelve 8 mientras el assert espera 27.
Mejoramos la implementaciónVamos a escribir algo más real para que pasen los tests:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      Para estar seguros de que la función trabaja bien, vamos a hacer comprobaciones para más valores. En lugar de escribir bloques it manualmente, vamos a generarlos con un for:

      
        
        
          describe("pow", function() {

  function makeTest(x) {
    let expected = x * x * x;
    it(`${x} elevado a 3 es ${expected}`, function() {
      assert.equal(pow(x, 3), expected);
    });
  }

  for (let x = 1; x <= 5; x++) {
    makeTest(x);
  }

});
        
      
      
      El resultado:

    
        
      
      
    
  Describe anidadosVamos a añadir más tests. Pero antes, hay que apuntar que la función makeTest y la instrucción for deben ser agrupados juntos. No queremos makeTest en otros tests, solo se necesita en el for: su tarea común es comprobar cómo pow eleva a una potencia concreta.
Agrupar tests se realiza con describe:

      
        
        
          describe("pow", function() {

  describe("eleva x a la potencia de 3", function() {

    function makeTest(x) {
      let expected = x * x * x;
      it(`${x} elevado a 3 es ${expected}`, function() {
        assert.equal(pow(x, 3), expected);
      });
    }

    for (let x = 1; x <= 5; x++) {
      makeTest(x);
    }

  });

  // ... otros test irían aquí, se puede escribir describe como it
});
        
      
      
      El describe anidado define un nuevo subgrupo de tests. En la salida podemos ver la indentación en los títulos:

    
        
      
      
    
  En el futuro podemos añadir más it y describe en el primer nivel con funciones de ayuda para ellos mismos, no se solaparán con makeTest.

            before/after y beforeEach/afterEach
            Podemos configurar funciones before/after que se ejecuten antes/después de la ejecución de los tests, y también funciones beforeEach/afterEach que ejecuten antes/después de cada it.
Por ejemplo:

      
        
        
          describe("test", function() {

  before(() => alert("Inicio testing – antes de todos los tests"));
  after(() => alert("Final testing – después de todos los tests"));

  beforeEach(() => alert("Antes de un test – entramos al test"));
  afterEach(() => alert("Después de un test – salimos del test"));

  it('test 1', () => alert(1));
  it('test 2', () => alert(2));

});
        
      
      
      La secuencia que se ejecuta es la siguiente:

      
        
        
          Inicio testing – antes de todos los tests (before)
Antes de un test – entramos al test (beforeEach)
1
Después de un test – salimos del test   (afterEach)
Antes de un test – entramos al test (beforeEach)
2
Después de un test – salimos del test   (afterEach)
Final testing – después de todos los tests (after)
        
      
      
      Abre el ejemplo en un sandbox.Normalmente, beforeEach/afterEach (before/after) son usados para realizar la inicialización, poner contadores a cero o hacer algo entre cada test o cada grupo de tests.

Extender los specLa funcionalidad básica de pow está completa. La primera iteración del desarrollo está hecha. Cuando acabemos de celebrar y beber champán – sigamos adelante y mejorémosla.
Como se dijo, la función pow(x, n) está dedicada a trabajar con valores enteros positivos n.
Para indicar un error matemático, JavaScript normalmente devuelve NaN como resultado de una función. Hagamos lo mismo para valores incorrectos de n.
Primero incluyamos el comportamiento en el spec(!):

      
        
        
          describe("pow", function() {

  // ...

  it("para n negativos el resultado es NaN", function() {
    assert.isNaN(pow(2, -1));
  });

  it("para no enteros el resultado is NaN", function() {
    assert.isNaN(pow(2, 1.5));
  });

});
        
      
      
      El resultado con los nuevos tests:

    
        
      
      
    
  El test recién creado falla, porque nuestra implementación no lo soporta. Así es como funciona la metodología BDD: primero escribimos un test que falle y luego realizamos la implementación para que pase.

            Otras comprobaciones
            Por favor, ten en cuenta la comprobación assert.isNaN: ella comprueba que el valor es NaN.
Hay otras comprobaciones en Chai también Chai, por ejemplo:

assert.equal(value1, value2) – prueba la igualdad  value1 == value2.
assert.strictEqual(value1, value2) – prueba la igualdad estricta value1 === value2.
assert.notEqual, assert.notStrictEqual – el contrario que arriba.
assert.isTrue(value) – prueba que value === true
assert.isFalse(value) – prueba que value === false
… la lista entera se puede encontrar en docs


Así que podemos añadir un par de líneas a pow:

      
        
        
          function pow(x, n) {
  if (n < 0) return NaN;
  if (Math.round(n) != n) return NaN;

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      Ahora funciona y todos los tests pasan:

    
        
      
      
    
  Abre el ejemplo final en un sandbox.ResumenEn BDD, la especificación va primero, seguida de la implementación. Al final tenemos tanto la especificación como la implementación.
El spec puede ser usado de tres formas:

Como Tests garantizan que el código funciona correctamente.
Como Docs – los títulos de los describe e it nos dicen lo que la función hace.
Como Ejemplos – los tests son también ejemplos funcionales que muestran cómo una función puede ser usada.

Con la especificación, podemos mejorar de forma segura, cambiar, incluso reescribir la función desde cero y estar seguros de que seguirá funcionando.
Esto es especialmente importante en proyectos largos cuando una función es usada en muchos sitios. Cuando cambiamos una función, no hay forma manual de comprobar si cada sitio donde se usaba sigue funcionando correctamente.
Sin tests, la gente tiene dos opciones:

Realizar el cambio como sea. Luego nuestros usuarios encontrarán errores porque probablemente fallemos en encontrarlos.
O, si el castigo por errores es duro, la gente tendrá miedo de hacer cambios en las funciones. Entonces el código envejecerá, nadie querrá meterse en él y eso no es bueno para el desarrollo.

¡El test automatizado ayuda a evitar estos problemas!
Si el proyecto esta cubierto de pruebas, no tendremos ese problema. Podemos correr los tests y hacer multitud de comprobaciones en cuestión de segundos.
Además, un código bien probado tendrá una mejor arquitectura.
Naturalmente, porque el código será más fácil de cambiar y mejorar. Pero no sólo eso.
Al escribir tests, el código debe estar organizado de tal manera que cada función tenga un propósito claro y explícito, una entrada y una salida bien definida. Eso implica una buena arquitectura desde el principio.
En la vida real a veces no es tan fácil. A veces es difícil escribir una especificación antes que el código, porque no está claro aún cómo debe comportarse dicho código. Pero en general, escribir los tests hace el desarrollo más rápido y más estable.
En el tutorial encontrarás más adelante muchas tareas respaldadas con pruebas. Veremos más ejemplos prácticos de tests.
Escribir tests requiere un buen conocimiento de JavaScript. Pero nosotros justo acabamos de empezar a aprenderlo. Así que para comenzar no es necesario que escribas tests, pero ahora eres capaz de leerlos incluso si son más complejos que en este capítulo.
Tareas¿Qué esta mal en el test?importancia: 5¿Qué es incorrecto en el test de pow de abajo?

      
        
        
          it("Eleva x a la potencia n", function() {
  let x = 5;

  let result = x;
  assert.equal(pow(x, 1), result);

  result *= x;
  assert.equal(pow(x, 2), result);

  result *= x;
  assert.equal(pow(x, 3), result);
});
        
      
      
      P.S. El test es sintácticamente correcto y pasa.
soluciónEl test demuestra una tentación habitual del/a desarrollador/a al escribir tests.
Lo que tenemos aquí son en realidad 3 pruebas, pero presentadas como una sola función con 3 afirmaciones.
A veces es más fácil escribir de esta manera, pero si ocurre un error, es mucho menos obvio saber qué salió mal.
Si un error ocurre en el medio de un flujo de ejecución complejo, tendremos que imaginar los datos en tal punto.  Tendremos, en realidad, que hacer un debug del test
Sería mucho mejor dividir la prueba en múltiples bloques ‘it’ con entradas y salidas claramente escritas.
Como esto:

      
        
        
          describe("Eleva x a la potencia n", function() {
  it("5 elevado a 1 es igual a 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  it("5 elevado a 2 es igual a 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 elevado a 3 es igual a 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
        
      
      
      Reemplazamos el único it por un describe y agrupamos los bloques it dentro. Ahora si algo sale mal, podemos ver claramente qué dato fue.
Además podemos aislar un único test y ejecutarlo individualmente escribiendo it.only en lugar de it:

      
        
        
          describe("Raises x to power n", function() {
  it("5 elevado a 1 es igual a 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  // Mocha sólo ejecutará este bloque
  it.only("5 elevado a 2 es igual a 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5 elevado a 3 es igual a 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
        
      
      
      ",
	"url": "https://es.javascript.info/testing-mocha" 
},
{
	"docs_id": "29",
	"name": "Polyfills y transpiladores",
	"description": "El lenguaje JavaScript evoluciona constantemente. Nuevas propuestas al lenguaje aparecen regularmente, son analizadas y, si se consideran valiosas, se agregan a la lista en https://tc39.github.io/ecma262/ y luego avanzan a la especificación.",
	"content": "El lenguaje JavaScript evoluciona constantemente. Nuevas propuestas al lenguaje aparecen regularmente, son analizadas y, si se consideran valiosas, se agregan a la lista en https://tc39.github.io/ecma262/ y luego avanzan a la especificación.
Los equipos de desarrollo detrás de los intérpretes (engines) de JavaScript tienen sus propias ideas sobre qué implementar primero. Pueden decidir implementar propuestas que están en borrador y posponer cosas que ya están en la especificación porque son menos interesantes o simplemente porque son más difíciles de hacer.
Por lo tanto, es bastante común para un intérprete implementar solo parte del estándar.
Una buena página para ver el estado actual de soporte de características del lenguaje es https://kangax.github.io/compat-table/es6/ (es grande, todavía tenemos mucho que aprender).
Como programadores, queremos las características más recientes. Cuanto más, ¡mejor!
Por otro lado, ¿cómo hacer que nuestro código moderno funcione en intérpretes más viejos que aún no entienden las características más nuevas?
Hay dos herramientas para ello:

Transpiladores
Polyfills.

En este artículo nuestro propósito es llegar a la esencia de cómo trabajan y su lugar en el desarrollo web.
TranspiladoresUn transpilador es un software que traduce un código fuente a otro código fuente. Puede analizar (“leer y entender”) código moderno y rescribirlo usando sintaxis y construcciones más viejas para que también funcione en intérpretes antiguos.
Por ejemplo, antes del año 2020 JavaScript no tenía el operador “nullish coalescing” ??. Entonces, si un visitante lo usa en un navegador desactualizado, este fallaría en entender un código como height = height ?? 100.
Un transpilador analizaría nuestro código y rescribiría height ?? 100 como (height !== undefined && height !== null) ? height : 100.

      
        
        
          // antes de ejecutar el transpilador
height = height ?? 100;

// después de ejecutar el transpilador
height = (height !== undefined && height !== null) ? height : 100;
        
      
      
      Ahora el código rescrito es apto para los intérpretes de JavaScript más viejos.
Usualmente, un desarrollador ejecuta el transpilador en su propia computadora y luego despliega el código transpilado al servidor.
Acerca de nombres, Babel es uno de los más prominentes transpiladores circulando.
Sistemas de desarrollo de proyectos modernos, tales como webpack, brindan los medios para ejecutar la transpilación automática en cada cambio de código, haciendo muy fácil la integración al proceso de desarrollo.
PolyfillsNuevas características en el lenguaje pueden incluir no solo construcciones sintácticas y operadores, sino también funciones integradas.
Por ejemplo, Math.trunc(n) es una función que corta la parte decimal de un número, ej. Math.trunc(1.23) devuelve 1.
En algunos (muy desactualizados) intérpretes JavaScript no existe Math.trunc, así que tal código fallará.
Aquí estamos hablando de nuevas funciones, no de cambios de sintaxis. No hay necesidad de transpilar nada. Solo necesitamos declarar la función faltante.
Un script que actualiza o agrega funciones nuevas es llamado “polyfill”. Este llena los vacíos agregando las implementaciones que faltan.
En este caso particular, el polyfill para Math.trunc es un script que lo implementa:

      
        
        
          if (!Math.trunc) { // no existe tal función
  // implementarla
  Math.trunc = function(number) {
    // Math.ceil y Math.floor existen incluso en los intérpretes antiguos
    // los cubriremos luego en el tutorial
    return number < 0 ? Math.ceil(number) : Math.floor(number);
  };
}
        
      
      
      JavaScript es un lenguaje muy dinámico, los scripts pueden agregar o modificar cualquier función, incluso las integradas.
Dos librerías interesantes de polyfills son:

core js – da muchísimo soporte, pero permite que se incluyan solamente las características necesitadas.
polyfill.io – servicio que brinda un script con polyfills dependiendo de las características del navegador del usuario.

ResumenEn este artículo queremos motivarte a estudiar las características más modernas y hasta experimentales del lenguaje, incluso si aún no tienen buen soporte en los intérpretes JavaScript.
Pero no olvides usar transpiladores (si usas sintaxis u operadores modernos) y polyfills (para añadir funciones que pueden estar ausentes). Ellos se asegurarán de que el código funcione.
Por ejemplo, cuando estés más familiarizado con JavaScript puedes configurar la construcción de código basado en webpack con el plugin babel-loader.
Buenos recursos que muestran el estado actual de soporte para varias característica:

https://kangax.github.io/compat-table/es6/ – para JavaScript puro.
https://caniuse.com/ – para funciones relacionadas al navegador.

P.S. Google Chrome usualmente es el más actualizado con las características del lenguaje, pruébalo si algún demo del tutorial falla. Aunque la mayoría de los demos funciona con cualquier navegador moderno.
",
	"url": "https://es.javascript.info/polyfills" 
},
{
	"docs_id": "30",
	"name": "Objetos",
	"description": "Como aprendimos en el capítulo Tipos de datos, hay ocho tipos de datos en JavaScript. Siete de ellos se denominan “primitivos”, porque sus valores contienen solo un dato (sea un string, un número o lo que sea).",
	"content": "Como aprendimos en el capítulo Tipos de datos, hay ocho tipos de datos en JavaScript. Siete de ellos se denominan “primitivos”, porque sus valores contienen solo un dato (sea un string, un número o lo que sea).
En contraste, los objetos son usados para almacenar colecciones de varios datos y entidades más complejas asociados con un nombre clave. En JavaScript, los objetos penetran casi todos los aspectos del lenguaje. Por lo tanto, debemos comprenderlos primero antes de profundizar en cualquier otro lugar.
Podemos crear un objeto usando las llaves {…} con una lista opcional de propiedades. Una propiedad es un par “key:value”, donde key es un string (también llamado “nombre clave”), y value puede ser cualquier cosa. P.D. Para fines prácticos de la lección, nos referiremos a este par de conceptos como “clave:valor”.
Podemos imaginar un objeto como un gabinete con archivos firmados. Cada pieza de datos es almacenada en su archivo por la clave. Es fácil encontrar un archivo por su nombre o agregar/eliminar un archivo.

      
      
        
      
      Se puede crear un objeto vacío (“gabinete vacío”) utilizando una de estas dos sintaxis:

      
        
        
          let user = new Object(); // sintaxis de "constructor de objetos"
let user = {};  // sintaxis de "objeto literal"
        
      
      
      
      
      
        
      
      Normalmente se utilizan las llaves {...}. Esa declaración se llama objeto literal.
Literales y propiedadesPodemos poner inmediatamente algunas propiedades dentro de {...} como pares “clave:valor”:

      
        
        
          let user = {     // un objeto
  name: "John",  // En la clave "name" se almacena el valor "John"
  age: 30        // En la clave "age" se almacena el valor 30
};
        
      
      
      Una propiedad tiene una clave (también conocida como “nombre” o “identificador”) antes de los dos puntos ":" y un valor a la derecha.
En el objeto user hay dos propiedades:

La primera propiedad tiene la clave "name" y el valor "John".
La segunda tienen la clave "age" y el valor 30.

Podemos imaginar al objeto user resultante como un gabinete con dos archivos firmados con las etiquetas “name” y “age”.

      
      
        
      
      Podemos agregar, eliminar y leer archivos de él en cualquier momento.
Se puede acceder a los valores de las propiedades utilizando la notación de punto:

      
        
        
          // Obteniendo los valores de las propiedades del objeto:
alert( user.name ); // John
alert( user.age ); // 30
        
      
      
      El valor puede ser de cualquier tipo. Agreguemos uno booleano:

      
        
        
          user.isAdmin = true;
        
      
      
      
      
      
        
      
      Para eliminar una propiedad podemos usar el operador delete:

      
        
        
          delete user.age;
        
      
      
      
      
      
        
      
      También podemos nombrar propiedades con más de una palabra. Pero, de ser así, debemos colocar la clave entre comillas "...":

      
        
        
          let user = {
  name: "John",
  age: 30,
  "likes birds": true  // Las claves con más de una palabra deben ir entre comillas
};
        
      
      
      
      
      
        
      
      La última propiedad en la lista puede terminar con una coma:

      
        
        
          let user = {
  name: "John",
  age: 30,
}
        
      
      
      Eso se llama una coma “final” o “colgante”.  Facilita agregar, eliminar y mover propiedades, porque todas las líneas se vuelven similares.
CorchetesLa notación de punto no funciona para acceder a propiedades con claves de más de una palabra:

      
        
        
          
            
          
          
            
          
        
        
          // Esto nos daría un error de sintaxis
user.likes birds = true
        
      
      
      JavaScript no entiende eso. Piensa que hemos accedido a user.likes y entonces nos da un error de sintaxis cuando aparece el inesperado birds.
El punto requiere que la clave sea un identificador de variable válido. Eso implica que: no contenga espacios, no comience con un dígito y no incluya caracteres especiales ($ y _ sí se permiten).
Existe una “notación de corchetes” alternativa que funciona con cualquier string:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};

// asignando
user["likes birds"] = true;

// obteniendo
alert(user["likes birds"]); // true

// eliminando
delete user["likes birds"];
        
      
      
      Ahora todo está bien. Nota que el string dentro de los corchetes está adecuadamente entre comillas (cualquier tipo de comillas servirían).
Las llaves también nos proveen de una forma para obtener la clave de la propiedad como resultado de cualquier expresión como una variable – en lugar de una cadena literal – de la siguiente manera:

      
        
        
          let key = "likes birds";

// Tal cual: user["likes birds"] = true;
user[key] = true;
        
      
      
      Aquí la variable key puede calcularse en tiempo de ejecución o depender de la entrada del usuario y luego lo usamos para acceder a la propiedad. Eso nos da mucha flexibilidad.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let key = prompt("¿Qué te gustaría saber acerca del usuario?", "name");

// acceso por medio de una variable
alert( user[key] ); // John (si se ingresara "name")
        
      
      
      La notación de punto no puede ser usada de manera similar:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let key = "name";
alert( user.key ) // undefined
        
      
      
      Propiedades calculadasPodemos usar corchetes en un objeto literal al crear un objeto. A esto se le llama  propiedades calculadas.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let fruit = prompt("¿Qué fruta comprar?", "Manzana");

let bag = {
  [fruit]: 5, // El nombre de la propiedad se obtiene de la variable fruit
};

alert( bag.apple ); // 5 si fruit es="apple"
        
      
      
      El significado de una propiedad calculada es simple: [fruit] significa que se debe tomar la clave de la propiedad fruit.
Entonces, si un visitante ingresa "apple", bag se convertirá en {apple: 5}.
Esencialmente esto funciona igual que:

      
        
        
          
            
          
          
            
          
        
        
          let fruit = prompt("¿Qué fruta comprar?", "Manzana");
let bag = {};

// Toma el nombre de la propiedad de la variable fruit
bag[fruit] = 5;
        
      
      
      …Pero luce mejor.
Podemos usar expresiones más complejas dentro de los corchetes:

      
        
        
          let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
        
      
      
      Los corchetes son mucho más potentes que la notación de punto. Permiten cualquier nombre de propiedad, incluso variables. Pero también es más engorroso escribirlos.
Entonces, la mayoría de las veces, cuando los nombres de propiedad son conocidos y simples, se utiliza el punto. Y si necesitamos algo más complejo, entonces cambiamos a corchetes.
Atajo para valores de propiedadEn el código real, a menudo usamos variables existentes como valores de los nombres de propiedades.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser(name, age) {
  return {
    name: name,
    age: age,
    // ...otras propiedades
  };
}

let user = makeUser("John", 30);
alert(user.name); // John
        
      
      
      En el ejemplo anterior las propiedades tienen los mismos nombres que las variables. El uso de variables para la creación de propiedades es tán común que existe un atajo para valores de propiedad especial para hacerla más corta.
En lugar de name:name, simplemente podemos escribir name, tal cual:

      
        
        
          function makeUser(name, age) {
  return {
    name, // igual que name:name
    age,  // igual que age:age
    // ...
  };
}
        
      
      
      Podemos usar ambos tipos de notación en un mismo objeto, la normal y el atajo:

      
        
        
          let user = {
  name,  // igual que name:name
  age: 30
};
        
      
      
      Limitaciones de nombres de propiedadComo sabemos, una variable no puede tener un nombre igual a una de las palabras reservadas del lenguaje, como “for”, “let”, “return”, etc.
Pero para una propiedad de objeto no existe tal restricción:

      
        
        
          
            
          
          
            
          
        
        
          // Estas propiedades están bien
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6
        
      
      
      En resumen, no hay limitaciones en los nombres de propiedades. Pueden ser cadenas o símbolos (un tipo especial para identificadores que se cubrirán más adelante).
Otros tipos se convierten automáticamente en cadenas.
Por ejemplo, un número 0 se convierte en cadena "0" cuando se usa como clave de propiedad:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  0: "test" // igual que "0": "test"
};

// ambos alerts acceden a la misma propiedad (el número 0 se convierte a una cadena "0")
alert( obj["0"] ); // test
alert( obj[0] ); // test (la misma propiedad)
        
      
      
      Hay una pequeña sorpresa por una propiedad especial llamada __proto__. No podemos establecerlo dentro de un valor que no sea de objeto:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};
obj.__proto__ = 5; // asignando un número
alert(obj.__proto__); // [objeto Object] - el valor es un objeto, no funciona como se "debería"
        
      
      
      Como podemos ver en el código, se ignora la asignación de un valor primitivo 5.
Veremos la naturaleza especial de __proto__ en los capítulos siguientes, y sugeriremos las formas de arreglar tal comportamiento.
La prueba de propiedad existente, el operador “in”Una notable característica de los objetos en JavaScript, en comparación con muchos otros lenguajes, es que es posible acceder a cualquier propiedad. ¡No habrá error si la propiedad no existe!
La lectura de una propiedad no existente solo devuelve undefined. Así que podemos probar fácilmente si la propiedad existe:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};

alert( user.noSuchProperty === undefined ); // true significa que "no existe tal propiedad"
        
      
      
      También existe un operador especial para ello: "in".
La sintaxis es:

      
        
        
          "key" in object
        
      
      
      Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John", age: 30 };

alert( "age" in user );    // mostrará "true", porque user.age sí existe
alert( "blabla" in user ); // mostrará false, porque user.blabla no existe
        
      
      
      Nota que a la izquierda de in debe estar el nombre de la propiedad que suele ser un string entre comillas.
Si omitimos las comillas, significa que es una variable. Esta variable debe almacenar la clave real que será probada. Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let user = { age: 30 };

let key = "age";
alert( key in user ); // true, porque su propiedad "age" sí existe dentro del objeto
        
      
      
      Pero… ¿Por qué existe el operador in? ¿No es suficiente comparar con undefined?
La mayoría de las veces las comparaciones con undefined funcionan bien. Pero hay un caso especial donde esto falla y aún así "in" funciona correctamente.
Es cuando existe una propiedad de objeto, pero almacena  undefined:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  test: undefined
};

alert( obj.test ); // es undefined, entonces... ¿Quiere decir realmente existe tal propiedad?

alert( "test" in obj ); //es true, ¡La propiedad sí existe!
        
      
      
      En el código anterior, la propiedad  obj.test técnicamente existe. Entonces el operador in funciona correctamente.
Situaciones como esta suceden raramente ya que undefined no debe ser explícitamente asignado. Comúnmente usamos null para valores “desconocidos” o “vacíos”. Por lo que el operador in es un invitado exótico en nuestro código.
El bucle "for..in"Para recorrer todas las claves de un objeto existe una forma especial de bucle: for..in. Esto es algo completamente diferente a la construcción for(;;) que estudiaremos más adelante.
La sintaxis:

      
        
        
          for (key in object) {
  // se ejecuta el cuerpo para cada clave entre las propiedades del objeto
}
        
      
      
      Por ejemplo, mostremos todas las propiedades de user:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for (let key in user) {
  // claves
  alert( key );  // name, age, isAdmin
  // valores de las claves
  alert( user[key] ); // John, 30, true
}
        
      
      
      Nota que todas las construcciones “for” nos permiten declarar variables para bucle dentro del bucle, como let key aquí.
Además podríamos usar otros nombres de variables en lugar de key. Por ejemplo, "for (let prop in obj)" también se usa bastante.
Ordenado como un objeto¿Los objetos están ordenados? Es decir, si creamos un bucle sobre un objeto, ¿obtenemos todas las propiedades en el mismo orden en el que se agregaron? ¿Podemos confiar en ello?
La respuesta corta es: “ordenados de una forma especial”: las propiedades de números enteros se ordenan, los demás aparecen en el orden de la creación. Entremos en detalle.
Como ejemplo, consideremos un objeto con códigos telefónicos:

      
        
        
          
            
          
          
            
          
        
        
          let codes = {
  "49": "Germany",
  "41": "Switzerland",
  "44": "Great Britain",
  // ..,
  "1": "USA"
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}
        
      
      
      El objeto puede usarse para sugerir al usuario una lista de opciones. Si estamos haciendo un sitio principalmente para el público alemán, probablemente queremos que 49 sea el primero.
Pero si ejecutamos el código, veremos una imagen totalmente diferente:

USA (1) va primero
Luego Switzerland (41) y así sucesivamente.

Los códigos telefónicos van en orden ascendente porque son números enteros. Entonces vemos  1, 41, 44, 49.

            ¿Propiedades de números enteros? ¿Qué es eso?
            El término “propiedad de números enteros” aquí significa que una cadena se puede convertir a y desde desde un entero sin ningún cambio.
Entonces, “49” es un nombre de propiedad entero, porque cuando este se transforma a un entero y viceversa continúa siendo el mismo. Pero “+49” y “1.2” no lo son:

      
        
        
          
            
          
          
            
          
        
        
          // Number(...) convierte explícitamente a number
// Math.trunc es una función nativa que elimina la parte decimal
alert( String(Math.trunc(Number("49"))) ); // "49", es igual, una propiedad entera
alert( String(Math.trunc(Number("+49"))) ); // "49", no es igual "+49" ⇒ no es una propiedad entera
alert( String(Math.trunc(Number("1.2"))) ); // "1", no es igual "1.2" ⇒ no es una propiedad entera
        
      
      
      
…Por otro lado, si las claves no son enteras, se enumeran en el orden de creación, por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // Se agrega una propiedad más

// Las propiedades que no son enteras se enumeran en el orden de creación
for (let prop in user) {
  alert( prop ); // name, surname, age
}
        
      
      
      Entonces, para solucionar el problema con los códigos telefónicos, podemos “hacer trampa” haciendo que los códigos no sean enteros. Agregar un signo más "+" antes de cada código será más que suficiente.
Justo así:

      
        
        
          
            
          
          
            
          
        
        
          let codes = {
  "+49": "Germany",
  "+41": "Switzerland",
  "+44": "Great Britain",
  // ..,
  "+1": "USA"
};

for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}
        
      
      
      Ahora sí funciona como debería.
ResumenLos objetos son arreglos asociativos con varias características especiales.
Almacenan propiedades (pares de clave-valor), donde:

Las claves de propiedad deben ser cadenas o símbolos (generalmente strings).
Los valores pueden ser de cualquier tipo.

Para acceder a una propiedad, podemos usar:

La notación de punto: obj.property.
La notación de corchetes obj["property"]. Los corchetes permiten tomar la clave de una variable, como obj[varWithKey].

Operadores adicionales:

Para eliminar una propiedad: delete obj.prop.
Para comprobar si existe una propiedad con la clave proporcionada: "key" in obj.
Para crear bucles sobre un objeto: bucle for (let key in obj).

Lo que hemos estudiado en este capítulo se llama “objeto simple”, o solamente Object.
Hay muchos otros tipos de objetos en JavaScript:

Array para almacenar colecciones de datos ordenados,
Date para almacenar la información sobre fecha y hora,
Error para almacenar información sobre un error.
…Y así.

Tienen sus características especiales que estudiaremos más adelante. A veces las personas dicen algo como "Tipo array" o "Tipo date", pero formalmente no son tipos en sí, sino que pertenecen a un tipo de datos de “objeto” simple y lo amplían a varias maneras.
Los objetos en JavaScript son muy poderosos. Aquí acabamos de arañar la superficie de un tema que es realmente enorme. Trabajaremos estrechamente con los objetos y aprenderemos más sobre ellos en otras partes del tutorial.
TareasHola, objetoimportancia: 5Escribe el código, una línea para cada acción:

Crea un objeto user vacío.
Agrega la propiedad name con el valor John.
Agrega la propiedad surname con el valor Smith.
Cambia el valor de name a Pete.
Remueve la propiedad name del objeto.

solución
      
        
        
          let user = {};
user.name = "John";
user.surname = "Smith";
user.name = "Pete";
delete user.name;
        
      
      
      Verificar los vacíosimportancia: 5Escribe la función isEmpty(obj) que devuelva el valor true si el objeto no tiene propiedades, en caso contrario false.
Debería funcionar así:

      
        
        
          let schedule = {};

alert( isEmpty(schedule) ); // true

schedule["8:30"] = "Hora de levantarse";

alert( isEmpty(schedule) ); // false
        
      
      
      Abrir en entorno controlado con pruebas.soluciónSolo crea un bucle sobre el objeto y, si hay al menos una propiedad, devuelve false inmediatamente.

      
        
        
          function isEmpty(obj) {
  for (let key in obj) {
    //  Si el bucle ha comenzado quiere decir que sí hay al menos una propiedad
    return false;
  }
  return true;
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Suma de propiedades de un objetoimportancia: 5Tenemos un objeto que almacena los salarios de nuestro equipo:

      
        
        
          let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
}
        
      
      
      Escribe el código para sumar todos los salarios y almacenar el resultado en la variable sum. En el ejemplo de arriba nos debería dar 390.
Si salaries está vacío entonces el resultado será 0.
solución
      
        
        
          
            
          
          
            
          
        
        
          let salaries = {
  John: 100,
  Ann: 160,
  Pete: 130
};

let sum = 0;
for (let key in salaries) {
  sum += salaries[key];
}

alert(sum); // 390
        
      
      
      Multiplicar propiedades numéricas por 2importancia: 3Crea una función multiplyNumeric(obj) que multiplique todas las propiedades numéricas de obj por 2.
Por ejemplo:

      
        
        
          // Antes de la llamada
let menu = {
  width: 200,
  height: 300,
  title: "Mi menú"
};

multiplyNumeric(menu);

// Después de la llamada
menu = {
  width: 400,
  height: 600,
  title: "Mi menú"
};
        
      
      
      Nota que multiplyNumeric no necesita devolver nada. Debe modificar el objeto en su lugar.
P.D. Usa typeof para verificar si hay un número aquí.
Abrir en entorno controlado con pruebas.solución
      
        
        
          function multiplyNumeric(obj) {
  for (let key in obj) {
    if (typeof obj[key] == 'number') {
      obj[key] *= 2;
    }
  }
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/object" 
},
{
	"docs_id": "31",
	"name": "Referencias de objetos y copia",
	"description": "Una de las diferencias fundamentales entre objetos y primitivos es que los objetos son almacenados y copiados “por referencia”, en cambio los primitivos: strings, number, boolean, etc.; son asignados y copiados “como un valor completo”.",
	"content": "Una de las diferencias fundamentales entre objetos y primitivos es que los objetos son almacenados y copiados “por referencia”, en cambio los primitivos: strings, number, boolean, etc.; son asignados y copiados “como un valor completo”.
Esto es fácil de entender si miramos un poco “bajo cubierta” de lo que pasa cuando copiamos por valor.
Empecemos por un primitivo como string.
Aquí ponemos una copia de message en phrase:

      
        
        
          let message = "Hello!";
let phrase = message;
        
      
      
      Como resultado tenemos dos variables independientes, cada una almacenando la cadena "Hello!".

      
      
        
      
      Bastante obvio, ¿verdad?
Los objetos no son así.
Una variable no almacena el objeto mismo sino su “dirección en memoria”, en otras palabras “una referencia” a él.
Veamos un ejemplo de tal variable:

      
        
        
          let user = {
  name: "John"
};
        
      
      
      Y así es como se almacena en la memoria:

      
      
        
      
      El objeto es almacenado en algún lugar de la memoria (a la derecha de la imagen), mientras que la variable user (a la izquierda) tiene una “referencia” a él.
Podemos pensar de una variable objeto, como user, como una hoja de papel con la dirección del objeto escrita en ella.
Cuando ejecutamos acciones con el objeto, por ejemplo tomar una propiedad user.name, el motor JavaScript busca aquella dirección y ejecuta la operación en el objeto mismo.
Ahora, por qué esto es importante.
Cuando una variable de objeto es copiada, se copia solo la referencia. El objeto no es duplicado.
Por ejemplo:

      
        
        
          let user = { name: "John" };

let admin = user; // copia la referencia
        
      
      
      Ahora tenemos dos variables, cada una con una referencia al mismo objeto:

      
      
        
      
      Como puedes ver, aún hay un objeto, ahora con dos variables haciendo referencia a él.
Podemos usar cualquiera de las variables para acceder al objeto y modificar su contenido:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: 'John' };

let admin = user;

admin.name = 'Pete'; // cambiado por la referencia "admin"

alert(user.name); // 'Pete', los cambios se ven desde la referencia "user"
        
      
      
      Es como si tuviéramos un gabinete con dos llaves y usáramos una de ellas (admin) para acceder a él y hacer cambios. Si más tarde usamos la llave (user), estaríamos abriendo el mismo gabinete y accediendo al contenido cambiado.
Comparación por referenciaDos objetos son iguales solamente si ellos son el mismo objeto.
Por ejemplo, aquí a y b tienen referencias al mismo objeto, por lo tanto son iguales:

      
        
        
          
            
          
          
            
          
        
        
          let a = {};
let b = a; // copia la referencia

alert( a == b ); // true, verdadero. Ambas variables hacen referencia al mismo objeto
alert( a === b ); // true
        
      
      
      Y aquí dos objetos independientes no son iguales, aunque se vean iguales (ambos están vacíos):

      
        
        
          
            
          
          
            
          
        
        
          let a = {};
let b = {}; // dos objetos independientes

alert( a == b ); // false
        
      
      
      Para comparaciones como obj1 > obj2, o comparaciones contra un primitivo obj == 5, los objetos son convertidos a primitivos. Estudiaremos cómo funciona la conversión de objetos pronto, pero a decir verdad tales comparaciones ocurren raramente, suelen ser errores de código.
Clonación y mezcla, Object.assignEntonces copiar una variable de objeto crea una referencia adicional al mismo objeto.
Pero ¿y si necesitamos duplicar un objeto?
Podemos crear un nuevo objeto y replicar la estructura del existente iterando a través de sus propiedades y copiándolas en el nivel primitivo.
Como esto:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

let clone = {}; // el nuevo objeto vacío

// copiemos todas las propiedades de user en él
for (let key in user) {
  clone[key] = user[key];
}

// ahora clone es un objeto totalmente independiente con el mismo contenido
clone.name = "Pete"; // cambiamos datos en él

alert( user.name ); // John aún está en el objeto original
        
      
      
      También podemos usar el método Object.assign.
La sintaxis es:

      
        
        
          Object.assign(dest, [src1, src2, src3...])
        
      
      
      
El primer argumento dest es el objeto destinatario.
Los siguientes argumentos src1, ..., srcN (tantos como sea necesario) son objetos fuentes.
Esto copia todas las propiedades de todos los objetos fuentes src1, ..., srcN dentro del destino dest. En otras palabras, las propiedades de todos los argumentos, comenzando desde el segundo, son copiadas en el primer objeto.
El llamado devuelve dest.

Por ejemplo, podemos usarlo para combinar distintos objetos en uno:

      
        
        
          let user = { name: "John" };

let permissions1 = { canView: true };
let permissions2 = { canEdit: true };

// copia todas las propiedades desde permissions1 y permissions2 en user
Object.assign(user, permissions1, permissions2);

// ahora user = { name: "John", canView: true, canEdit: true }
        
      
      
      Si la propiedad por copiar ya existe, se sobrescribe:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };

Object.assign(user, { name: "Pete" });

alert(user.name); // ahora user = { name: "Pete" }
        
      
      
      También podemos usar Object.assign reemplazando el bucle for..in para hacer una clonación simple:

      
        
        
          let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);
        
      
      
      Copia todas las propiedades de user en un objeto vacío y lo devuelve.
También hay otras formas de clonar un objeto, por ejemplo usando la sintaxis spread clone = {...user}, cubierto más adelante en el tutorial.
Clonación anidadaHasta ahora asumimos que todas las propiedades de user son primitivas. Pero las propiedades pueden ser referencias a otros objetos.
Como esto:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

alert( user.sizes.height ); // 182
        
      
      
      Ahora no es suficiente copiar clone.sizes = user.sizes, porque user.sizes es un objeto y será copiado por referencia. Entonces clone y user compartirán las mismas tallas (.sizes):

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, el mimo objeto

// user y clone comparten sizes
user.sizes.width++;       // cambia la propiedad en un lugar
alert(clone.sizes.width); // 51, ve el resultado desde el otro
        
      
      
      Para corregir esto debemos usar un bucle de clonación que examine cada valor de user[key] y, si es un objeto, replicar su estructura también. Esto es llamado “clonación profunda”.
Podemos usar recursividad para implementarlo. O, para no inventar la rueda, tomar una implementación existente, por ejemplo _.cloneDeep(obj) de la librería JavaScript lodash.

            Los objetos con const pueden cambiarse
            Un efecto secundario importante de almacenar objetos como referencias es que un objeto declarado con const puede ser modificado.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          const user = {
  name: "John"
};

user.name = "Pete"; // (*)

alert(user.name); // Pete
        
      
      
      Puede parecer que la linea (*) ocasionaría un error, pero no.  El valor de user es constante, debe siempre hacer referencia al mismo objeto. Pero sus propiedades pueden cambiar libremente.
En otras palabras, const user solamente da error cuando intentamos asignar user=... como un todo.
Si realmente queremos hacer constantes las propiedades del objeto, también es posible; pero usando métodos totalmente diferentes, los que veremos después en el capítulo Indicadores y descriptores de propiedad.

ResumenLos objetos son asignados y copiados por referencia. En otras palabras, una variable almacena no el valor del objeto sino una referencia (dirección de memoria) del valor. Entonces copiar tal variable o pasarla como argumento de función copia la referencia, no el objeto.
Todas la operaciones a través de referencias copiadas (como agregar y borrar propiedades) son efectuadas en el mismo y único objeto .
Si queremos conseguir una “copia real” (un clon), podemos usar: Una “clonación superficial” por medio de la función Object.assign (con los objetos anidados copiados por referencia), o una “clonación profunda” con una función como _.cloneDeep(obj).
",
	"url": "https://es.javascript.info/object-copy" 
},
{
	"docs_id": "32",
	"name": "Recolección de basura",
	"description": "La gestión de la memoria en JavaScript se realiza de forma automática e invisible para nosotros. Creamos datos primitivos, objetos, funciones… Todo ello requiere memoria.",
	"content": "La gestión de la memoria en JavaScript se realiza de forma automática e invisible para nosotros. Creamos datos primitivos, objetos, funciones… Todo ello requiere memoria.
¿Qué sucede cuando algo no se necesita más? ¿Cómo hace el motor de JavaScript para encontrarlo y limpiarlo?
AlcanceEl concepto principal del manejo de memoria en JavaScript es alcance.
Puesto simple, los valores “alcanzables” son aquellos que se pueden acceder o utilizar de alguna manera: Se garantiza que serán conservados en la memoria.


Hay un conjunto base de valores inherentemente accesibles, que no se pueden eliminar por razones obvias.
Por ejemplo:

La función ejecutándose actualmente, sus variables locales y parámetros.
Otras funciones en la cadena actual de llamadas anidadas, sus variables y parámetros.
Variables Globales
(Hay algunos otros internos también)

Estos valores se llaman raíces.


Cualquier otro valor se considera accesible si se lo puede alcanzar desde una raíz por una referencia o por una cadena de referencias.
Por ejemplo, si hay un objeto en una variable global, y ese objeto tiene una propiedad que hace referencia a otro objeto, este objeto también se considera accesible. Y aquellos a los que este objeto hace referencia también son accesibles. Ejemplos detallados a continuación.


Hay un proceso en segundo plano en el motor de JavaScript que se llama recolector de basura. Este proceso monitorea todos los objetos y elimina aquellos que se han vuelto inalcanzables.
Un ejemplo sencilloAquí va el ejemplo más simple:

      
        
        
          // `user` tiene una referencia al objeto
let user = {
  name: "John"
};
        
      
      
      
      
      
        
      
      Aquí la flecha representa una referencia de objeto. La variable global "user" hace referencia al objeto {name: "John"} (lo llamaremos John por brevedad). La propiedad "name"’ de John almacena un dato primitivo, por lo que está pintada dentro del objeto.
Si se sobrescribe el valor de user, se pierde la referencia:

      
        
        
          user = null;
        
      
      
      
      
      
        
      
      Ahora John se vuelve inalcanzable. No hay forma de acceder a él, no hay referencias a él. El recolector de basura desechará los datos y liberará la memoria.
Dos referenciasAhora imaginemos que copiamos la referencia de user a admin:

      
        
        
          // `user` tiene una referencia al objeto
let user = {
  name: "John"
};

let admin = user;
        
      
      
      
      
      
        
      
      Ahora si hacemos lo mismo

      
        
        
          user = null;
        
      
      
      … el objeto todavía es accesible a través de la variable global admin, por lo que debe quedar en la memoria. Si también sobrescribimos admin, entonces se puede eliminar.
Objetos entrelazadosAhora un ejemplo más complejo. La familia:

      
        
        
          function marry(man, woman) {
  woman.husband = man;
  man.wife = woman;

  return {
    father: man,
    mother: woman
  }
}

let family = marry({
  name: "John"
}, {
  name: "Ann"
});
        
      
      
      La función marry “casa” dos objetos dándoles referencias entre sí y devuelve un nuevo objeto que los contiene a ambos.
La estructura de memoria resultante:

      
      
        
      
      Por ahora, todos los objetos son accesibles.
Ahora borremos estas dos referencias:

      
        
        
          delete family.father;
delete family.mother.husband;
        
      
      
      
      
      
        
      
      No es suficiente eliminar solo una de estas dos referencias, porque todos los objetos aún serían accesibles.
Pero si eliminamos ambos, entonces podemos ver que John ya no tiene referencias entrantes:

      
      
        
      
      Las referencias salientes no importan. Solo los entrantes pueden hacer que un objeto sea accesible. Entonces, John ahora es inalcanzable y será eliminado de la memoria con todos sus datos que también se volvieron inaccesibles.
Después de la recolección de basura:

      
      
        
      
      Isla inalcanzableEs posible que toda la isla de objetos interconectados se vuelva inalcanzable y se elimine de la memoria.
El objeto fuente es el mismo que el anterior. Entonces:

      
        
        
          family = null;
        
      
      
      La imagen en memoria se convierte en:

      
      
        
      
      Este ejemplo demuestra cuán importante es el concepto de alcance.
Es obvio que John y Ann todavía están vinculados, ambos tienen referencias entrantes. Pero eso no es suficiente.
El antiguo objeto "family" se ha desvinculado de la raíz, ya no se hace referencia a él, por lo que toda la isla se vuelve inalcanzable y se eliminará.
Algoritmos internosEl algoritmo básico de recolección de basura se llama “marcar y barrer”.
Los siguientes pasos de “recolección de basura” se realizan regularmente:

El recolector de basura busca las raíces y las “marca” (recuerda).
Luego visita y “marca” todos los objetos referenciados por ellas.
Luego visita los objetos marcados y marca sus referencias. Todos los objetos visitados son recordados, para no visitar el mismo objeto dos veces en el futuro.
…Y así sucesivamente hasta que cada referencia alcanzable (desde las raíces) sean visitadas.
Todos los objetos que no fueron marcados se eliminan.

Por ejemplo, si nuestra estructura de objeto se ve así:

      
      
        
      
      Podemos ver claramente una “isla inalcanzable” al lado derecho. Ahora veamos cómo el recolector de basura maneja “marcar y barrer”.
El primer paso marca las raíces:

      
      
        
      
      Luego se buscan sus referencias salientes y se marcan los objetos referenciados:

      
      
        
      
      … luego se continúa con las referencias salientes de estos objetos, y se continúa marcando mientras sea posible:

      
      
        
      
      Ahora los objetos que no se pudieron visitar en el proceso se consideran inalcanzables y se eliminarán:

      
      
        
      
      Podemos imaginar el proceso como derramar un enorme cubo de pintura desde las raíces, que fluye a través de todas las referencias y marca todos los objetos alcanzables. Los elementos que no queden marcados son entonces eliminados.
Ese es el concepto de cómo funciona la recolección de basura. El motor de JavaScript aplica muchas optimizaciones para que se ejecute más rápido y no introduzca retrasos en la ejecución de código.
Algunas de las optimizaciones:

Recolección generacional – los objetos se dividen en dos conjuntos: “nuevos” y “antiguos”. En un código típico, muchos objetos tienen corta vida: aparecen, hacen su trabajo y mueren rápido, entonces tiene sentido rastrear los objetos nuevos y eliminarlos de la memoria si corresponde. Aquellos que sobreviven el tiempo suficiente, se vuelven “viejos” y son examinados con menos frecuencia.
Recolección incremental – Si hay muchos objetos, y tratamos de recorrer y marcar todo el conjunto de objetos a la vez, puede llevar algún tiempo e introducir retrasos notables en la ejecución. Entonces el motor divide la recolección de basura en partes. Luego limpia esas partes, una tras otra. Hay muchas tareas de recolección pequeñas en lugar de una grande. Eso requiere un registro adicional entre ellas para rastrear los cambios, pero tenemos muchos pequeños retrasos en lugar de uno grande.
Recolección de tiempo inactivo – el recolector de basura trata de ejecutarse solo mientras la CPU está inactiva, para reducir el posible efecto en la ejecución.

Hay otras optimizaciones y tipos de algoritmos de recolección de basura. Por mucho que quiera describirlos aquí, tengo que evitarlo porque diferentes motores implementan diferentes ajustes y técnicas. Y, lo que es aún más importante, las cosas cambian a medida que se desarrollan los motores, por lo que probablemente no vale la pena profundizar sin una necesidad real. Por supuesto, si tienes verdadero interés, a continuación hay algunos enlaces para ti.
ResumenLos principales puntos a saber:

La recolección de basura se ejecuta automáticamente. No la podemos forzar o evitar.
Los objetos se retienen en la memoria mientras son accesibles.
Ser referenciado no es lo mismo que ser accesible (desde una raíz): un conjunto de objetos interconectados pueden volverse inalcanzables como un todo, como vimos en el ejemplo de arriba.

Los motores modernos implementan algoritmos avanzados de recolección de basura.
Un libro general “The Garbage Collection Handbook: The Art of Automatic Memory Management” (R. Jones et al) cubre algunos de ellos.
Si estás familiarizado con la programación de bajo nivel, la información más detallada sobre el recolector de basura V8 se encuentra en el artículo A tour of V8: Garbage Collection.
V8 blog también publica artículos sobre cambios en la administración de memoria de vez en cuando. Naturalmente, para aprender la recolección de basura, es mejor que se prepare aprendiendo sobre los componentes internos de V8 en general y lea el blog de Vyacheslav Egorov que trabajó como uno de los ingenieros de V8. Estoy diciendo: “V8”, porque se cubre mejor con artículos en Internet. Para otros motores, muchos enfoques son similares, pero la recolección de basura difiere en muchos aspectos.
Es bueno tener un conocimiento profundo de los motores cuando se necesitan optimizaciones de bajo nivel. Sería prudente planificar eso como el siguiente paso después de que esté familiarizado con el lenguaje.
",
	"url": "https://es.javascript.info/garbage-collection" 
},
{
	"docs_id": "33",
	"name": "Métodos del objeto, "this"",
	"description": "Los objetos son creados usualmente para representar entidades del mundo real, como usuarios, órdenes, etc.:",
	"content": "Los objetos son creados usualmente para representar entidades del mundo real, como usuarios, órdenes, etc.:

      
        
        
          let user = {
  name: "John",
  age: 30
};
        
      
      
      Y en el mundo real un usuario puede actuar: seleccionar algo del carrito de compras, hacer login, logout, etc.
Las acciones son representadas en JavaScript por funciones en las propiedades.
Ejemplos de métodosPara empezar, enseñemos al usuario user a decir hola:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

user.sayHi = function() {
  alert("¡Hola!");
};

user.sayHi(); // ¡Hola!
        
      
      
      Aquí simplemente usamos una expresión de función para crear la función y asignarla a la propiedad user.sayHi del objeto.
Entonces la llamamos con user.sayHi(). ¡El usuario ahora puede hablar!
Una función que es la propiedad de un objeto es denominada su método.
Así, aquí tenemos un método sayHi del objeto user.
Por supuesto, podríamos usar una función pre-declarada como un método, parecido a esto:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  // ...
};

// primero, declara
function sayHi() {
  alert("¡Hola!");
};

// entonces la agrega como un método
user.sayHi = sayHi;

user.sayHi(); // ¡Hola!
        
      
      
      
            Programación orientada a objetos
            Cuando escribimos nuestro código usando objetos que representan entidades, eso es llamado Programación Orientada a Objetos, abreviado: “POO”.
POO (OOP sus siglas en inglés) es una cosa grande, un ciencia interesante en sí misma. ¿Cómo elegir las entidades correctas? ¿Cómo organizar la interacción entre ellas? Eso es arquitectura, y hay muy buenos libros del tópico como “Patrones de diseño: Elementos de software orientado a objetos reutilizable” de E. Gamma, R. Helm, R. Johnson, J. Vissides o “Análisis y Diseño Orientado a Objetos” de G. Booch, y otros.

Formas abreviadas para los métodosExiste una sintaxis más corta para los métodos en objetos literales:

      
        
        
          // estos objetos hacen lo mismo

user = {
  sayHi: function() {
    alert("Hello");
  }
};

// la forma abreviada se ve mejor, ¿verdad?
user = {
  sayHi() {   // igual que "sayHi: function(){...}"
    alert("Hello");
  }
};
        
      
      
      Como se demostró, podemos omitir "function" y simplemente escribir sayHi().
A decir verdad, las notaciones no son completamente idénticas. Hay diferencias sutiles relacionadas a la herencia de objetos (por cubrir más adelante) que por ahora no son relevantes. En casi todos los casos la sintaxis abreviada es la preferida.
“this” en métodosEs común que un método de objeto necesite acceder a la información almacenada en el objeto para cumplir su tarea.
Por ejemplo, el código dentro de user.sayHi() puede necesitar el nombre del usuario user.
Para acceder al objeto, un método puede usar la palabra clave this.
El valor de this es el objeto “antes del punto”, el usado para llamar al método.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    // "this" es el "objeto actual"
    alert(this.name);
  }

};

user.sayHi(); // John
        
      
      
      Aquí durante la ejecución de user.sayHi(), el valor de this será user.
Técnicamente, también es posible acceder al objeto sin this, haciendo referencia a él por medio de la variable externa:

      
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert(user.name); // "user" en vez de "this"
  }

};
        
      
      
      …Pero tal código no es confiable. Si decidimos copiar user a otra variable, por ejemplo admin = user y sobrescribir user con otra cosa, entonces accederá al objeto incorrecto.
Eso queda demostrado en las siguientes lineas:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  sayHi() {
    alert( user.name ); // lleva a un error
  }

};


let admin = user;
user = null; // sobrescribimos para hacer las cosas evidentes

admin.sayHi(); // TypeError: No se puede leer la propiedad 'name' de null
        
      
      
      Si usamos this.name en vez de user.name dentro de alert, entonces el código funciona.
“this” no es vinculadoEn JavaScript, la palabra clave this se comporta de manera distinta a la mayoría de otros lenguajes de programación. Puede ser usado en cualquier función, incluso si no es el método de un objeto.
No hay error de sintaxis en el siguiente ejemplo:

      
        
        
          function sayHi() {
  alert( this.name );
}
        
      
      
      El valor de this es evaluado durante el tiempo de ejecución, dependiendo del contexto.
Por ejemplo, aquí la función es asignada a dos objetos diferentes y tiene diferentes “this” en sus llamados:

      
        
        
          
            
          
          
            
          
        
        
          let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}

// usa la misma función en dos objetos
user.f = sayHi;
admin.f = sayHi;

// estos llamados tienen diferente "this"
// "this" dentro de la función es el objeto "antes del punto"
user.f(); // John  (this == user)
admin.f(); // Admin  (this == admin)

admin['f'](); // Admin (punto o corchetes para acceder al método, no importa)
        
      
      
      La regla es simple: si obj.f() es llamado, entonces this es obj durante el llamado de f. Entonces es tanto user o admin en el ejemplo anterior.

            Llamado sin un objeto: this == undefined
            Podemos incluso llamar la función sin un objeto en absoluto:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert(this);
}

sayHi(); // undefined
        
      
      
      En este caso this es undefined en el modo estricto. Si tratamos de acceder a this.name, habrá un error.
En modo no estricto el valor de this en tal caso será el objeto global (window en un navegador, llegaremos a ello en el capítulo Objeto Global). Este es un comportamiento histórico que "use strict" corrige.
Usualmente tal llamado es un error de programa. Si hay this dentro de una función, se espera que sea llamada en un contexto de objeto.


            Las consecuencias de un this desvinculado
            Si vienes de otro lenguaje de programación, probablemente estés habituado a la idea de un "this vinculado", donde los método definidos en un objeto siempre tienen this referenciando ese objeto.
En JavaScript this es “libre”, su valor es evaluado al momento de su llamado y no depende de dónde fue declarado el método sino de cuál es el objeto “delante del punto”.
El concepto de this evaluado en tiempo de ejecución tiene sus pros y sus contras. Por un lado, una función puede ser reusada por diferentes objetos. Por otro, la mayor flexibilidad crea más posibilidades para equivocaciones.
Nuestra posición no es juzgar si la decisión del diseño de lenguaje es buena o mala. Vamos a entender cómo trabajar con ello, obtener beneficios y evitar problemas.

Las funciones de flecha no tienen “this”Las funciones de flecha son especiales: ellas no tienen su “propio” this. Si nosotros hacemos referencia a this desde tales funciones, esta será tomada desde afuera de la función “normal”.
Por ejemplo, aquí arrow() usa this desde fuera del método user.sayHi():

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};

user.sayHi(); // Ilya
        
      
      
      Esto es una característica especial de las funciones de flecha, útil cuando no queremos realmente un this separado sino tomarlo de un contexto externo. Más adelante en el capítulo Funciones de flecha revisadas las trataremos en profundidad.
Resumen
Las funciones que son almacenadas en propiedades de objeto son llamadas “métodos”.
Los método permiten a los objetos “actuar”, como object.doSomething().
Los métodos pueden hacer referencia al objeto con this.

El valor de this es definido en tiempo de ejecución.

Cuando una función es declarada, puede usar this, pero ese this no tiene valor hasta que la función es llamada.
Una función puede ser copiada entre objetos.
Cuando una función es llamada en la sintaxis de método: object.method(), el valor de this durante el llamado es object.

Ten en cuenta que las funciones de flecha son especiales: ellas no tienen this. Cuando this es accedido dentro de una función de flecha, su valor es tomado desde el exterior.
TareasUsando el "this" en un objeto literalimportancia: 5Aquí la función makeUser devuelve un objeto.
¿Cuál es el resultado de acceder a su ref? ¿Por qué?

      
        
        
          function makeUser() {
  return {
    name: "John",
    ref: this
  };
}

let user = makeUser();

alert( user.ref.name ); // ¿Cuál es el resultado?
        
      
      
      soluciónRespuesta: un error.
Pruébalo:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser() {
  return {
    name: "John",
    ref: this
  };
}

let user = makeUser();

alert( user.ref.name ); // Error: No se puede leer la propiedad 'name' de undefined
        
      
      
      Esto es porque las reglas que establecen el this no buscan en la definición del objeto. Solamente importa el momento en que se llama.
Aquí el valor de this dentro de makeUser() es undefined, porque es llamado como una función, no como un método con sintaxis de punto.
El valor de this es uno para la función entera; bloques de código y objetos literales no lo afectan.
Entonces ref: this en realidad toma el this actual de la función.
Podemos reescribir la función y devolver el mismo this con valor undefined:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser(){
  return this; // esta vez no hay objeto literal
}

alert( makeUser().name ); // Error: No se puede leer la propiedad 'name' de undefined
        
      
      
      Como puedes ver el resultado de alert( makeUser().name ) es el mismo que el resultado de alert( user.ref.name ) del ejemplo anterior.
Aquí está el caso opuesto:

      
        
        
          
            
          
          
            
          
        
        
          function makeUser() {
  return {
    name: "John",
    ref() {
      return this;
    }
  };
}

let user = makeUser();

alert( user.ref().name ); // John
        
      
      
      Ahora funciona, porque user.ref() es un método. Y el valor de this es establecido al del objeto delante del punto ..
Crea una calculadoraimportancia: 5Crea un objeto calculator con tres métodos:

read() pide dos valores y los almacena como propiedades de objeto con nombres a y b.
sum() devuelve la suma de los valores almacenados.
mul() multiplica los valores almacenados y devuelve el resultado.


      
        
        
          let calculator = {
  // ... tu código ...
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );
        
      
      
      Ejecutar el demoAbrir en entorno controlado con pruebas.solución
      
        
        
          
            
          
          
            
          
        
        
          let calculator = {
  sum() {
    return this.a + this.b;
  },

  mul() {
    return this.a * this.b;
  },

  read() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  }
};

calculator.read();
alert( calculator.sum() );
alert( calculator.mul() );
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Encadenamientoimportancia: 2Hay un objeto ladder que permite subir y bajar:

      
        
        
          let ladder = {
  step: 0,
  up() {
    this.step++;
  },
  down() {
    this.step--;
  },
  showStep: function() { // muestra el peldaño actual
    alert( this.step );
  }
};
        
      
      
      Ahora, si necesitamos hacer varios llamados en secuencia podemos hacer algo como esto:

      
        
        
          ladder.up();
ladder.up();
ladder.down();
ladder.showStep(); // 1
ladder.down();
ladder.showStep(); // 0
        
      
      
      Modifica el código de “arriba” up, “abajo” down y “mostrar peldaño” showStep para hacer los llamados encadenables como esto:

      
        
        
          ladder.up().up().down().showStep().down().showStep(); // shows 1 then 0
        
      
      
      Tal enfoque es ampliamente usado entre las librerías JavaScript.
Abrir en entorno controlado con pruebas.soluciónLa solución es devolver el objeto mismo desde cada llamado.

      
        
        
          
            
          
          
            
          
        
        
          let ladder = {
  step: 0,
  up() {
    this.step++;
    return this;
  },
  down() {
    this.step--;
    return this;
  },
  showStep() {
    alert( this.step );
    return this;
  }
};

ladder.up().up().down().showStep().down().showStep(); // shows 1 then 0
        
      
      
      También podemos escribir una simple llamada por línea. Para cadenas largas es más legible:

      
        
        
          ladder
  .up()
  .up()
  .down()
  .showStep() // 1
  .down()
  .showStep(); // 0
        
      
      
      Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/object-methods" 
},
{
	"docs_id": "34",
	"name": "Constructor, operador "new"",
	"description": "El sintaxis habitual {...} nos permite crear un objeto. Pero a menudo necesitamos crear varios objetos similares, como múltiples usuarios, elementos de menú, etcétera.",
	"content": "El sintaxis habitual {...} nos permite crear un objeto. Pero a menudo necesitamos crear varios objetos similares, como múltiples usuarios, elementos de menú, etcétera.
Esto se puede realizar utilizando el constructor de funciones y el operador "new".
Función constructoraLa función constructora es técnicamente una función normal. Aunque hay dos convenciones:

Son nombradas con la primera letra mayúscula.
Sólo deben ejecutarse con el operador "new".

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Jack");

alert(user.name); // Jack
alert(user.isAdmin); // false
        
      
      
      Cuando una función es ejecutada con new, realiza los siguientes pasos:

Se crea un nuevo objeto vacío y se asigna a this.
Se ejecuta el cuerpo de la función. Normalmente se modifica this y se le agrega nuevas propiedades.
Se devuelve el valor de this.

En otras palabras, new User(...) realiza algo como:

      
        
        
          function User(name) {
  // this = {};  (implícitamente)

  // agrega propiedades a this
  this.name = name;
  this.isAdmin = false;

  // return this;  (implícitamente)
}
        
      
      
      Entonces let user = new User("Jack") da el mismo resultado que:

      
        
        
          let user = {
  name: "Jack",
  isAdmin: false
};
        
      
      
      Ahora si queremos crear otros usuarios, podemos llamar a new User("Ann"), new User("Alice"), etcétera. Mucho más corto que usar literales todo el tiempo y también fácil de leer.
Este es el principal propósito del constructor – implementar código de creación de objetos re-utilizables.
Tomemos nota otra vez: técnicamente cualquier función (excepto las de flecha pues no tienen this) puede ser utilizada como constructor. Puede ser llamada con new, y ejecutará el algoritmo de arriba. La “primera letra mayúscula” es un acuerdo general, para dejar en claro que la función debe ser ejecutada con new.

            new function() { … }
            Si tenemos muchas líneas de código todas sobre la creación de un único objeto complejo, podemos agruparlas en un constructor de función que es llamado inmediatamente de esta manera:

      
        
        
          // crea una función e inmediatamente la llama con new
let user = new function() {
  this.name = "John";
  this.isAdmin = false;

  // ...otro código para creación de usuario
  // tal vez lógica compleja y sentencias
  // variables locales etc
};
        
      
      
      Este constructor no puede ser llamado de nuevo porque no es guardado en ninguna parte, sólo es creado y llamado. Por lo tanto este truco apunta a encapsular el código que construye el objeto individual, sin reutilización futura.

Constructor modo test: new.target
            Temas avanzados
            La sintaxis de esta sección es raramente utilizada, puedes omitirla a menos que quieras saber todo.

Dentro de una función, podemos verificar si ha sido llamada con o sin el new utilizando una propiedad especial: new.target.
En las llamadas normales devuelve undefined, y cuando es llamada con new devuelve la función:

      
        
        
          
            
          
          
            
          
        
        
          function User() {
  alert(new.target);
}

// sin  "new":
User(); // undefined

// con  "new":
new User(); // function User { ... }
        
      
      
      Esto puede ser utilizado dentro de la función para conocer si ha sido llamada con new, "en modo constructor "; o sin él, “en modo regular”.
También podemos hacer que ambas formas de llamarla, con new y “regular”, realicen lo mismo:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  if (!new.target) { // si me ejecutas sin new
    return new User(name); // ...Agregaré new por ti
  }

  this.name = name;
}

let john = User("John"); // redirige llamado a new User
alert(john.name); // John
        
      
      
      Este enfoque es utilizado aveces en las librerías para hacer el sintaxis más flexible. Así la gente puede llamar a la función con o sin new y aún funciona.
Sin embargo, probablemente no sea algo bueno para usar en todas partes, porque omitir new hace que sea un poco menos obvio lo que está sucediendo. Con new todos sabemos que se está creando el nuevo objeto.
Return desde constructoresNormalmente, los constructores no tienen una sentencia return. Su tarea es escribir todo lo necesario al this, y automáticamente este se convierte en el resultado.
Pero si hay una sentencia return, entonces la regla es simple:

Si return es llamado con un objeto, entonces se devuelve tal objeto en vez de this.
Si return es llamado con un tipo de dato primitivo, es ignorado.

En otras palabras, return con un objeto devuelve ese objeto, en todos los demás casos se devuelve this.
Por ejemplo, aquí return anula this al devolver un objeto:

      
        
        
          
            
          
          
            
          
        
        
          function BigUser() {

  this.name = "John";

  return { name: "Godzilla" };  // <-- devuelve este objeto
}

alert( new BigUser().name );  // Godzilla, recibió ese objeto
        
      
      
      Y aquí un ejemplo con un return vacío (o podemos colocar un primitivo después de él, no importa):

      
        
        
          
            
          
          
            
          
        
        
          function SmallUser() {

  this.name = "John";

  return; // <-- devuelve this
}

alert( new SmallUser().name );  // John
        
      
      
      Normalmente los constructores no tienen una sentencia return. Aquí mencionamos el comportamiento especial con devolución de objetos principalmente por el bien de la integridad.

            Omitir paréntesis
            Por cierto, podemos omitir paréntesis después de new, si no tiene argumentos:

      
        
        
          let user = new User; // <-- sin paréntesis
// lo mismo que
let user = new User();
        
      
      
      Omitir paréntesis aquí no se considera “buen estilo”, pero la especificación permite esa sintaxis.

Métodos en constructorUtilizar constructor de funciones para crear objetos nos da mucha flexibilidad. La función constructor puede tener argumentos que definan cómo construir el objeto y qué colocar dentro.
Por supuesto podemos agregar a this no sólo propiedades, sino también métodos.
Por ejemplo, new User(name) de abajo, crea un objeto con el name dado y el método sayHi:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  this.name = name;

  this.sayHi = function() {
    alert( "Mi nombre es: " + this.name );
  };
}

let john = new User("John");

john.sayHi(); // Mi nombre es: John

/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
        
      
      
      Para crear objetos complejos existe una sintaxis más avanzada, classes, que cubriremos más adelante.
Resumen
Las funciones Constructoras o, más corto, constructores, son funciones normales, pero existe un común acuerdo para nombrarlas con la primera letra en mayúscula.
Las funciones Constructoras sólo deben ser llamadas utilizando new. Tal llamado implica la creación de un this vacío al comienzo y devolver el this rellenado al final.

Podemos utilizar funciones constructoras para crear múltiples objetos similares.
JavaScript proporciona funciones constructoras para varios objetos de lenguaje incorporados: como Date para fechas, Set para conjuntos y otros que planeamos estudiar.

            Objetos, ¡volveremos!
            En este capítulo solo cubrimos los conceptos básicos sobre objetos y constructores. Son esenciales para aprender más sobre tipos de datos y funciones en los próximos capítulos.
Después de aprender aquello, volvemos a los objetos y los cubrimos en profundidad en los capítulos Prototipos y herencia y Clases.

TareasDos funciones – un objetoimportancia: 2¿Es posible crear las funciones A y B para que se cumpla new A() == new B()?

      
        
        
          function A() { ... }
function B() { ... }

let a = new A;
let b = new B;

alert( a == b ); // true
        
      
      
      Si es posible, entonces proporcione un ejemplo de su código.
soluciónSi, es posible.
Si una función devuelve un objeto, entonces new lo devuelve en vez de this.
Por lo tanto pueden, por ejemplo, devolver el mismo objeto definido externamente obj:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};

function A() { return obj; }
function B() { return obj; }

alert( new A() == new B() ); // true
        
      
      
      Crear nueva Calculadoraimportancia: 5Crear una función constructora Calculator que crea objetos con 3 métodos:

read() pide dos valores usando prompt y los recuerda en las propiedades del objeto.
sum() devuelve la suma de estas propiedades.
mul() devuelve el producto de multiplicación de estas propiedades.

Por ejemplo:

      
        
        
          let calculator = new Calculator();
calculator.read();

alert( "Sum=" + calculator.sum() );
alert( "Mul=" + calculator.mul() );
        
      
      
      Ejecutar el demoAbrir en entorno controlado con pruebas.solución
      
        
        
          
            
          
          
            
          
        
        
          function Calculator() {

  this.read = function() {
    this.a = +prompt('a?', 0);
    this.b = +prompt('b?', 0);
  };

  this.sum = function() {
    return this.a + this.b;
  };

  this.mul = function() {
    return this.a * this.b;
  };
}

let calculator = new Calculator();
calculator.read();

alert( "Sum=" + calculator.sum() );
alert( "Mul=" + calculator.mul() );
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Crear nuevo Acumuladorimportancia: 5Crear una función constructor Accumulator(startingValue).
El objeto que crea debería:

Almacene el “valor actual” en la propiedad value. El valor inicial se establece en el argumento del constructor startingValue.
El método read() debe usar prompt para leer un nuevo número y agregarlo a value.

En otras palabras, la propiedad value es la suma de todos los valores ingresados por el usuario con el valor inicial startingValue.
Aquí está la demostración del código:

      
        
        
          let accumulator = new Accumulator(1); // valor inicial 1

accumulator.read(); // agrega el valor introducido por el usuario
accumulator.read(); // agrega el valor introducido por el usuario

alert(accumulator.value); // muestra la suma de estos valores
        
      
      
      Ejecutar el demoAbrir en entorno controlado con pruebas.solución
      
        
        
          
            
          
          
            
          
        
        
          function Accumulator(startingValue) {
  this.value = startingValue;

  this.read = function() {
    this.value += +prompt('Cuánto más agregar?', 0);
  };

}

let accumulator = new Accumulator(1);
accumulator.read();
accumulator.read();
alert(accumulator.value);
        
      
      
      Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/constructor-new" 
},
{
	"docs_id": "35",
	"name": "Encadenamiento opcional '?.'",
	"description": "El encadenamiento opcional ?. es una forma a prueba de errores para acceder a las propiedades anidadas de los objetos, incluso si no existe una propiedad intermedia.",
	"content": "
            Una adición reciente
            
            Esta es una adición reciente al lenguaje.
            Los navegadores antiguos pueden necesitar polyfills.
            
El encadenamiento opcional ?. es una forma a prueba de errores para acceder a las propiedades anidadas de los objetos, incluso si no existe una propiedad intermedia.
El problema de la propiedad que no existeSi acaba de comenzar a leer el tutorial y aprender JavaScript, quizás el problema aún no lo haya tocado, pero es bastante común.
Como ejemplo, digamos que tenemos objetos user que contienen información de nuestros usuarios.
La mayoría de nuestros usuarios tienen la dirección en la propiedad user.address, con la calle en user.address.street, pero algunos no la proporcionaron.
En tal caso, cuando intentamos obtener user.address.streeten un usuario sin dirección obtendremos un error:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // usuario sin propiedad "address"

alert(user.address.street); // Error!
        
      
      
      Este es el resultado esperado. JavaScript funciona así, como user.address es undefined, el intento de obtener user.address.street falla dando un error.
En muchos casos prácticos preferiríamos obtener undefined en lugar del error (dando a entender “sin calle”)
… y otro ejemplo. En desarrollo web, podemos obtener un objeto que corresponde a un elemento de página web usando el llamado a un método especial como document.querySelector('.elem'), que devuelve null cuando no existe tal elemento.

      
        
        
          
            
          
          
            
          
        
        
          // Error si el resultado de querySelector (...) es null
let html = document.querySelector('.my-element').innerHTML;
        
      
      
      Una vez más, si el elemento no existe, obtendremos un error al intentar acceder a la propiedad .innerHTML de null. Y en algunos casos, cuando la ausencia del elemento es normal, quisiéramos evitar el error y simplemente aceptar html = null como resultado.
¿Cómo podemos hacer esto?
La solución obvia sería chequear el valor usando if o el operador condicional ? antes de usar la propiedad:

      
        
        
          let user = {};

alert(user.address ? user.address.street : undefined);
        
      
      
      Esto funciona, no hay error… Pero es bastante poco elegante. Como puedes ver, "user.address" aparece dos veces en el código.
El mismo caso, pero con la búsqueda de document.querySelector:

      
        
        
          
            
          
          
            
          
        
        
          let html = document.querySelector('.elem') ? document.querySelector('.elem').innerHTML : null;
        
      
      
      Podemos ver que el elemento de búsqueda document.querySelector('.elem') es llamado dos veces aquí. Nada bueno.
En propiedades anidadas más profundamente, esto se vuelve un problema porque se requerirán más repeticiones.
Ejemplo: Tratemos de obtener user.address.street.name de manera similar.

      
        
        
          let user = {}; // El usuario no tiene dirección

alert(user.address ? user.address.street ? user.address.street.name : null : null);
        
      
      
      Esto es horrible, podemos tener problemas para siquiera entender tal código.
Hay una mejor manera de escribirlo, usando el operador &&:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // usuario sin dirección

alert( user.address && user.address.street && user.address.street.name ); // undefined (sin error)
        
      
      
      Poniendo AND en el camino completo a la propiedad asegura que todos los componentes existen (si no, la evaluación se detiene), pero no es lo ideal.
Como puedes ver, los nombres de propiedad aún están duplicados en el código. Por ejemplo en el código de arriba user.address aparece tres veces.
Es por ello que el encadenamiento opcional ?. fue agregado al lenguaje. ¡Para resolver este problema de una vez por todas!
Encadenamiento opcionalEl encadenamiento opcional ?. detiene la evaluación y devuelve undefined si el valor antes del ?. es undefined o null.
De aquí en adelante en este artículo, por brevedad, diremos que algo “existe” si no es null o undefined.
En otras palabras, value?.prop:

funciona como value.prop si value existe,
de otro modo (cuando value es undefined/null) devuelve undefined.

Aquí está la forma segura de acceder a user.address.street usando ?.:

      
        
        
          
            
          
          
            
          
        
        
          let user = {}; // El usuario no tiene dirección

alert( user?.address?.street ); // undefined (no hay error)
        
      
      
      El código es corto y claro, no hay duplicación en absoluto
Aquí tenemos un ejemplo con document.querySelector:

      
        
        
          
            
          
          
            
          
        
        
          let html = document.querySelector('.elem')?.innerHTML; // será undefined si no existe el elemento
        
      
      
      Leer la dirección con user?.Address funciona incluso si el objeto user no existe:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
        
      
      
      Tenga en cuenta: la sintaxis ?. hace opcional el valor delante de él, pero no más allá.
Por ejemplo, en user?.address.street.name, el ?. permite que user sea null/undefined (y devuelve undefined en tal caso), pero solo a user. El resto de las propiedades son accedidas de la manera normal.  Si queremos que algunas de ellas sean opcionales, necesitamos reemplazar más . con ?..

            No abuses del encadenamiento opcional
            Deberíamos usar ?. solo donde está bien que algo no exista.
Por ejemplo, si de acuerdo con la lógica de nuestro código, el objeto user debe existir, pero address es opcional, entonces deberíamos escribir user.address?.street y no user?.address?.street.
De esta forma, si por un error user no está definido, lo sabremos y lo arreglaremos. De lo contrario, los errores de codificación pueden silenciarse donde no sea apropiado y volverse más difíciles de depurar.


            La variable antes de ?. debe declararse
            Si no hay una variable user declarada, entonces user?.anything provocará un error:

      
        
        
          
            
          
          
            
          
        
        
          // ReferenceError: user no está definido
user?.address;
        
      
      
      La variable debe ser declarada (con let/const/var user o como parámetro de función). El encadenamiento opcional solo funciona para variables declaradas.

Short-circuiting (Cortocircuitos)Como se dijo antes, el ?. detiene inmediatamente (“cortocircuito”) la evaluación si la parte izquierda no existe.
Entonces, si a la derecha de ?. hay funciones u operaciones adicionales, estas no se ejecutarán:
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;
let x = 0;

user?.sayHi(x++); // no hay "user", por lo que la ejecución no alcanza a sayHi ni a x++

alert(x); // 0, el valor no se incrementa
        
      
      
      Otros casos: ?.(), ?.[]El encadenamiento opcional ?. no es un operador, es una construcción de sintaxis especial que también funciona con funciones y corchetes.
Por ejemplo, ?.() se usa para llamar a una función que puede no existir.
En el siguiente código, algunos de nuestros usuarios tienen el método admin, y otros no:

      
        
        
          
            
          
          
            
          
        
        
          let userAdmin = {
  admin() {
    alert("I am admin");
  }
};

let userGuest = {};

userAdmin.admin?.(); // I am admin

userGuest.admin?.(); // no pasa nada (no existe tal método)
        
      
      
      Aquí, en ambas líneas, primero usamos el punto (userAdmin.admin) para obtener la propiedad admin, porque asumimos que el objeto user existe y es seguro leerlo.
Entonces ?.() comprueba la parte izquierda: si la función admin existe, entonces se ejecuta (para userAdmin). De lo contrario (para userGuest) la evaluación se detiene sin errores.
La sintaxis ?.[] también funciona si quisiéramos usar corchetes [] para acceder a las propiedades en lugar de punto .. Al igual que en casos anteriores, permite leer de forma segura una propiedad de un objeto que puede no existir.

      
        
        
          
            
          
          
            
          
        
        
          let key = "firstName";

let user1 = {
  firstName: "John"
};

let user2 = null;

alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined
        
      
      
      También podemos usar ?. con delete:

      
        
        
          
            
          
          
            
          
        
        
          delete user?.name; // Eliminar user.name si el usuario existe
        
      
      
      
            Podemos usar ?. para una lectura y eliminación segura, pero no para escribir
            El encadenamiento opcional ?. no puede usarse en el lado izquierdo de una asignación:
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let user = null;

user?.name = "John"; // Error, no funciona
// porque se evalúa como: undefined = "John"
        
      
      
      
ResumenLa sintaxis de encadenamiento opcional ?. tiene tres formas:

obj?.prop – devuelve obj.prop si obj existe, si no, undefined.
obj?.[prop] – devuelve obj[prop] si obj existe, si no, undefined.
obj.method?.() – llama a obj.method() si obj.method existe, si no devuelve undefined.

Como podemos ver, todos ellos son sencillos y fáciles de usar. El ?. comprueba si la parte izquierda es null/undefined y permite que la evaluación continúe si no es así.
Una cadena de ?. permite acceder de forma segura a las propiedades anidadas.
Aún así, debemos aplicar ?. con cuidado, solamente donde sea aceptable que, de acuerdo con nuestra lógica, la parte izquierda no exista. Esto es para que no nos oculte errores de programación, si ocurren.
",
	"url": "https://es.javascript.info/optional-chaining" 
},
{
	"docs_id": "36",
	"name": "Tipo Symbol",
	"description": "Según la especificación, solo dos de los tipos primitivos pueden servir como clave de propiedad de objetos:",
	"content": "Según la especificación, solo dos de los tipos primitivos pueden servir como clave de propiedad de objetos:

string, o
symbol.

Si se usa otro tipo, como un número, este se autoconvertirá a string. Así, obj[1] es lo mismo que obj["1"], y obj[true] es lo mismo que obj["true"].
Hasta ahora solo estuvimos usando strings.
Ahora exploremos symbols y ver lo que pueden hacer por nosotros.
SymbolsEl valor de “Symbol” representa un identificador único.
Un valor de este tipo puede ser creado usando Symbol():

      
        
        
          let id = Symbol();
        
      
      
      Al crearlo, podemos agregarle una descripción (también llamada symbol name), que será útil en la depuración de código:

      
        
        
          
            
          
          
            
          
        
        
          // id es un symbol con la descripción "id"
let id = Symbol("id");
        
      
      
      Se garantiza que los símbolos son únicos. Aunque declaremos varios Symbols con la misma descripción, éstos tendrán valores distintos. La descripción es solamente una etiqueta que no afecta nada más.
Por ejemplo, aquí hay dos Symbols con la misma descripción… pero no son iguales:

      
        
        
          
            
          
          
            
          
        
        
          let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false
        
      
      
      Si estás familiarizado con Ruby u otro lenguaje que también tiene symbols, por favor no te confundas. Los Symbols de Javascript son diferentes.
Para resumir: un symbol es un “valor primitivo único” con una descripción opcional. Veamos dónde podemos usarlos.

            Symbols no se autoconvierten a String
            La mayoría de los valores en JavaScript soportan la conversión implícita a string. Por ejemplo, podemos hacer un ´alert´ con casi cualquier valor y funcionará. Los Symbols son especiales, éstos no se autoconvierten.
Por ejemplo, este alert mostrará un error:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id); // TypeError: No puedes convertir un valor Symbol en string
        
      
      
      Esta es una “protección del lenguaje” para evitar errores, ya que String y Symbol son fundamentalmente diferentes y no deben convertirse accidentalmente uno en otro.
Si realmente queremos mostrar un Symbol, necesitamos llamar el método .toString() explícitamente:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id.toString()); // Symbol(id), ahora sí funciona
        
      
      
      U obtener symbol.description para mostrar solamente la descripción:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
alert(id.description); // id
        
      
      
      
Claves “Ocultas”Los Symbols nos permiten crear propiedades “ocultas” en un objeto, a las cuales ninguna otra parte del código puede accesar ni sobrescribir accidentalmente.
Por ejemplo, si estamos trabajando con objetos user que pertenecen a código de terceros y queremos agregarles identificadores:
Utilicemos una clave symbol para ello:

      
        
        
          
            
          
          
            
          
        
        
          let user = { // pertenece a otro código
  name: "John"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // podemos accesar a la información utilizando el symbol como nombre de clave
        
      
      
      ¿Cuál es la ventaja de usar Symbol("id") y no un string "id"?
Como los objetos user pertenecen a otro código, es inseguro agregarles campos pues podría afectar su comportamiento predefinido en ese otro código. Sin embargo, los símbolos no pueden ser accedidos accidentalmente. El código de terceros no se percataría de los símbolos nuevos, por lo que se considera seguro agregar símbolos a los objetos user.
Además, imagina que otro script quiere tener su propio identificador “id” dentro de user para sus propios fines.
Entonces ese script puede crear su propio Symbol("id"), como aquí:

      
        
        
          // ...
let id = Symbol("id");

user[id] = "Su valor de id";
        
      
      
      No habrá conflicto porque los Symbols siempre son diferentes, incluso si tienen el mismo nombre.
… pero si utilizamos un string "id" en lugar de un Symbol para el mismo propósito, ciertamente habrá un conflicto:

      
        
        
          let user = { name: "John" };

// Nuestro script usa la propiedad "id"
user.id = "Nuestro valor id";

// ...Otro script también quiere usar "id"  ...

user.id = "Su valor de id"
// Boom! sobreescrito por otro script!
        
      
      
      Symbols en objetos literalesSi queremos usar un Symbol en un objeto literal, debemos usar llaves.
Como se muestra a continuación:

      
        
        
          let id = Symbol("id");

let user = {
  name: "John",
  [id]: 123 // no "id": 123
};
        
      
      
      Se hace así porque necesitamos que el valor de la variable id sea la clave, no el string “id”.
Los Symbols son omitidos en for…inLas claves de Symbol no participan dentro de los ciclos for..in.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

for (let key in user) alert(key); // nombre, edad (no aparecen symbols)

// el acceso directo a la clave de symbol funciona
alert( "Direct: " + user[id] );
        
      
      
      Object.keys(user) también los ignora. Esto forma parte del principio general de “ocultamiento de propiedades simbólicas”. Si otro script o si otra librería itera sobre nuestro objeto, este no accesará inesperadamente a la clave de Symbol.
En contraste, Object.assign copia tanto las claves string como symbol:

      
        
        
          
            
          
          
            
          
        
        
          let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
        
      
      
      No hay paradoja aquí. Es así por diseño. La idea es que cuando clonamos un objeto o cuando fusionamos objetos, generalmente queremos que se copien todas las claves (incluidos los Symbol como id).
Symbols GlobalesComo hemos visto, normalmente todos los Symbols son diferentes aunque tengan el mismo nombre. Pero algunas veces necesitamos que symbols con el mismo nombre sean la misma entidad.
Para lograr esto, existe un global symbol registry. Ahí podemos crear symbols y accesarlos después, lo cual nos garantiza que cada vez que se acceda a la clave con el mismo nombre, esta te devuelva exactamente el mismo symbol.
Para crear u accesar a un symbol en el registro global, usa Symbol.for(key).
Esta llamada revisa el registro global, y si existe un symbol descrito como key, lo retornará; de lo contrario creará un nuevo symbol Symbol(key) y lo almacenará en el registro con el key dado.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // leer desde el registro global
let id = Symbol.for("id"); // si el símbolo no existe, se crea

// léelo nuevamente (tal vez de otra parte del código)
let idAgain = Symbol.for("id");

// el mismo symbol
alert( id === idAgain ); // true
        
      
      
      Los Symbols dentro de este registro son llamados global symbols y están disponibles y al alcance de todo el código en la aplicación.

            Eso suena a Ruby
            En algunos lenguajes de programación, como Ruby, hay un solo Symbol por cada nombre.
En Javascript, como podemos ver, eso es verdad para los global symbols.

Symbol.keyForPara los global symbols, no solo Symbol.for(key) devuelve un symbol por su nombre. Para hacer lo opuesto, – devolver el nombre de  un global symbol – podemos usar: Symbol.keyFor(sym).
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // tomar symbol por nombre
let sym = Symbol.for("nombre");
let sym2 = Symbol.for("id");

// tomar name por symbol
alert( Symbol.keyFor(sym) ); // nombre
alert( Symbol.keyFor(sym2) ); // id
        
      
      
      El Symbol.keyFor utiliza internamente el registro “global symbol registry” para buscar la clave del symbol, por lo tanto, no funciona para los symbol que no están dentro del registro. Si el symbol no es global, no será capaz de encontrarlo y por lo tanto devolverá undefined.
Dicho esto, todo symbol tiene la propiedad description.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let globalSymbol = Symbol.for("nombre");
let localSymbol = Symbol("nombre");

alert( Symbol.keyFor(globalSymbol) ); // nombre, global symbol
alert( Symbol.keyFor(localSymbol) ); // undefined, no global

alert( localSymbol.description ); // nombre
        
      
      
      System symbolsExisten varios symbols del sistema que JavaScript utiliza internamente, y que podemos usar para ajustar varios aspectos de nuestros objetos.
Se encuentran listados en Well-known symbols :

Symbol.hasInstance
Symbol.isConcatSpreadable
Symbol.iterator
Symbol.toPrimitive
…y así.

Por ejemplo, Symbol.toPrimitive nos permite describir el objeto para su conversión primitiva. Más adelante veremos su uso.
Otros symbols también te serán más familiares cuando estudiemos las características correspondientes.
ResumenSymbol es un tipo de dato primitivo para identificadores únicos.
Symbols son creados al llamar Symbol() con una descripción opcional.
Symbols son siempre valores distintos aunque tengan el mismo nombre. Si queremos que symbols con el mismo nombre tengan el mismo valor, entonces debemos guardarlos en el registro global: Symbol.for(key) retornará un symbol (en caso de no existir, lo creará) con el key como su nombre. Todas las llamadas de Symbol.for con ese nombre retornarán siempre el mismo symbol.
Symbols se utilizan principalmente en dos casos:


Propiedades de objeto “Ocultas”
Si queremos agregar una propiedad a un objeto que “pertenece” a otro script u otra librería, podemos crear un symbol y usarlo como clave. Una clave symbol no aparecerá en los ciclos for..in, por lo que no podrá ser procesada accidentalmente junto con las demás propiedades. Tampoco puede ser accesada directamente, porque un script ajeno no tiene nuestro symbol. Por lo tanto la propiedad estará protegida contra uso y escritura accidentales.
Podemos “ocultar” ciertos valores dentro de un objeto que solo estarán disponibles dentro de ese script usando las claves de symbol.


Existen diversos symbols del sistema que utiliza Javascript, a los cuales podemos accesar por medio de Symbol.*. Podemos usarlos para alterar algunos comportamientos. Por ejemplo, más adelante en el tutorial, usaremos Symbol.iterator para iterables, Symbol.toPrimitive para configurar object-to-primitive conversion.


Técnicamente, los symbols no están 100% ocultos. Existe un método incorporado Object.getOwnPropertySymbols(obj) que nos permite obtener todos los symbols. También existe un método llamado Reflect.ownKeys(obj) que devuelve todas las claves de un objeto, incluyendo las que son de tipo symbol. Pero la mayoría de las librerías, los métodos incorporados y las construcciones de sintaxis no usan estos métodos.
",
	"url": "https://es.javascript.info/symbol" 
},
{
	"docs_id": "37",
	"name": "Conversión de objeto a valor primitivo",
	"description": "¿Qué sucede cuando los objetos se suman obj1 + obj2, se restan obj1 - obj2 o se imprimen utilizando alert(obj)?",
	"content": "¿Qué sucede cuando los objetos se suman obj1 + obj2, se restan obj1 - obj2 o se imprimen utilizando alert(obj)?
JavaScript no permite personalizar cómo los operadores trabajan con los objetos. Al contrario de otros lenguajes de programación como Ruby o C++, no podemos implementar un método especial para manejar una suma (u otros operadores).
En ese caso, los objetos se convierten automáticamente en valores primitivos, y luego se lleva a cabo la operación sobre esos primitivos, y resultan en un valor primitivo.
Esto es una limitación importante: el resultado de obj1 + obj2 (u otra operación) ¡no puede ser otro objeto!
Por ejemplo no podemos hacer objetos que representen vectores o matrices (o conquistas o lo que sea), sumarlas y esperar un objeto “sumado” como resultado. Tal objetivo arquitectural cae automáticamente “fuera del tablero”.
Como técnicamente no podemos hacer mucho aquí, no se hacen matemáticas con objetos en proyectos reales. Cuando ocurre, con alguna rara excepción es por un error de código.
En este capítulo cubriremos cómo un objeto se convierte a primitivo y cómo podemos personalizarlo.
Tenemos dos propósitos:

Nos permitirá entender qué ocurre en caso de errores de código, cuando tal operación ocurre accidentalmente.
Hay excepciones, donde tales operaciones son posibles y se ven bien. Por ejemplo al restar o comparar fechas (objetos Date). Las discutiremos más adelante.

Reglas de conversiónEn el capítulo Conversiones de Tipos, hemos visto las reglas para las conversiones de valores primitivos numéricos, strings y booleanos. Pero dejamos un hueco en los objetos. Ahora, como sabemos sobre métodos y símbolos, es posible completarlo.

No hay conversión a boolean. Todos los objetos son true en un contexto booleano, tan simple como eso. Solo hay conversiones numéricas y de strings.
La conversión numérica ocurre cuando restamos objetos o aplicamos funciones matemáticas. Por ejemplo, los objetos de tipo Date (que se cubrirán en el capítulo Fecha y Hora) se pueden restar, y el resultado de date1 - date2 es la diferencia horaria entre dos fechas.
En cuanto a la conversión de strings: generalmente ocurre cuando imprimimos un objeto como en alert(obj) y en contextos similares.

Podemos implementar la conversión de tipo string y numérica por nuestra cuenta, utilizando métodos de objeto especiales.
Ahora entremos en los detalles técnicos, porque es la única forma de cubrir el tópico en profundidad.
Hints (sugerencias)¿Cómo decide JavaScript cuál conversión aplicar?
Hay tres variantes de conversión de tipos que ocurren en varias situaciones. Son llamadas “hints” y están descriptas en la especificación:

"string"

Para una conversión de objeto a string, cuando hacemos una operación que espera un string en un objeto, como alert:

      
        
        
          // salida
alert(obj);

// utilizando un objeto como clave
anotherObj[obj] = 123;
        
      
      
      
"number"

Para una conversión de objeto a número, como cuando hacemos operaciones matemáticas:

      
        
        
          // conversión explícita
let num = Number(obj);

// matemáticas (excepto + binario)
let n = +obj; // + unario
let delta = date1 - date2;

// comparación menor que / mayor que
let greater = user1 > user2;
        
      
      
      La mayoría de las funciones matemáticas nativas también incluyen tal conversión.

"default"

Ocurre en casos raros cuando el operador “no está seguro” de qué tipo esperar.
Por ejemplo, el operador binario + puede funcionar con strings (los concatena) y números (los suma). Entonces, si el + binario obtiene un objeto como argumento, utiliza la sugerencia "default" para convertirlo.
También, si un objeto es comparado utilizando == con un string, un número o un símbolo, tampoco está claro qué conversión se debe realizar, por lo que se utiliza la sugerencia "default".

      
        
        
          // + binario utiliza la sugerencia "default"
let total = obj1 + obj2;

// obj == número utiliza la sugerencia "default"
if (user == 1) { ... };
        
      
      
      Los operadores de comparación mayor que y menor que, como < >, también pueden funcionar con strings y números. Aún así, utilizan la sugerencia "number", y no "default". Eso es por razones históricas.


Aunque en la práctica las cosas son más simples.
Todos los objetos nativos&#8209;excepto un caso (objeto Date, lo veremos más adelante)-  implementan la conversión "default" del mismo modo que "number". Y probablemente debiéramos hacer lo mismo.
Aún así, es importante conocer los 3 “hints”, pronto veremos el porqué.
Para realizar la conversión, JavaScript intenta buscar y llamar a tres métodos del objeto:

Busca y llama, si el método existe, a obj[Symbol.toPrimitive](hint): el método con la clave simbólica Symbol.toPrimitive (símbolo del sistema);
Si no lo encuentra y “hint” es "string":

intenta llamar a obj.toString() y obj.valueOf(), lo que exista.


Si no lo encuentra y “hint” es "number" o "default"

intenta llamar a obj.valueOf() y obj.toString(), lo que exista.



Symbol.toPrimitiveEmpecemos por el primer método. Hay un símbolo incorporado llamado Symbol.toPrimitive que debe utilizarse para nombrar el método de conversión, así:

      
        
        
          obj[Symbol.toPrimitive] = function(hint) {
  // aquí va el código para convertir este objeto a un primitivo
  // debe devolver un valor primitivo
  // hint = "sugerencia", uno de: "string", "number", "default"
};
        
      
      
      Si el método Symbol.toPrimitive existe, es usado para todos los hints y no serán necesarios más métodos.
Por ejemplo, aquí el objeto user lo implementa:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`sugerencia: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// demostración de conversiones:
alert(user); // sugerencia: string -> {name: "John"}
alert(+user); // sugerencia: number -> 1000
alert(user + 500); // sugerencia: default -> 1500
        
      
      
      Como podemos ver en el código, user se convierte en un string autodescriptivo o en una cantidad de dinero, depende de la conversión. Un único método user[Symbol.toPrimitive] maneja todos los casos de conversión.
toString/valueOfSi no existe Symbol.toPrimitive entonces JavaScript trata de encontrar los métodos toString y valueOf:

Para una sugerencia “string”: llama a toString, y si no existe, a valueOf (así toString tiene prioridad en conversiones string.
Para otras sugerencias: llama a valueOf, y si no existe, a toString (así valueOf tiene prioridad para matemáticas).

Los métodos toString y valueOf provienen de la antigüedad. No son símbolos (los símbolos no existían en aquel tiempo), sino métodos “regulares” nombrados con strings. Proporcionan una forma alternativa “al viejo estilo” de implementar la conversión.
Estos métodos deben devolver un valor primitivo. Si toString o valueOf devuelve un objeto, entonces se ignora (lo mismo que si no hubiera un método).
De forma predeterminada, un objeto simple tiene los siguientes métodos toString y valueOf:

El método toString devuelve un string "[object Object]".
El método valueOf devuelve el objeto en sí.

Aquí está la demostración:

      
        
        
          
            
          
          
            
          
        
        
          let user = {name: "John"};

alert(user); // [object Object]
alert(user.valueOf() === user); // true
        
      
      
      Por lo tanto, si intentamos utilizar un objeto como un string, como en un alert o algo así, entonces por defecto vemos [object Object].
El valueOf predeterminado se menciona aquí solo en favor de la integridad, para evitar confusiones. Como puede ver, devuelve el objeto en sí, por lo que se ignora. No me pregunte por qué, es por razones históricas. Entonces podemos asumir que no existe.
Implementemos estos métodos para personalizar la conversión.
Por ejemplo, aquí user hace lo mismo que el ejemplo anterior utilizando una combinación de toString y valueOf en lugar de Symbol.toPrimitive:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  money: 1000,

  // para sugerencia="string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // para sugerencia="number" o "default"
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
        
      
      
      Como podemos ver, el comportamiento es el mismo que en el ejemplo anterior con Symbol.toPrimitive.
A menudo queremos un único lugar “general” para manejar todas las conversiones primitivas. En este caso, podemos implementar solo toString, así:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",

  toString() {
    return this.name;
  }
};

alert(user); // toString -> John
alert(user + 500); // toString -> John500
        
      
      
      En ausencia de Symbol.toPrimitive y valueOf, toString manejará todas las conversiones primitivas.
Una conversión puede devolver cualquier tipo primitivoLo importante que debe saber acerca de todos los métodos de conversión primitiva es que no necesariamente devuelven la primitiva “sugerida”.
No hay control para que toString devuelva exactamente un string, ni para que el método Symbol.toPrimitive con una sugerencia "number" devuelva un número.
Lo único obligatorio: estos métodos deben devolver un valor primitivo, no un objeto.

            Notas históricas
            Por razones históricas, si toString o valueOf devuelve un objeto, no hay ningún error, pero dicho valor se ignora (como si el método no existiera). Esto se debe a que en la antigüedad no existía un buen concepto de “error” en JavaScript.
Por el contrario, Symbol.toPrimitive es más estricto, debe devolver un valor primitivo, en caso contrario habrá un error.

Más conversionesComo ya sabemos, muchos operadores y funciones realizan conversiones de tipo, por ejemplo la multiplicación * convierte operandos en números.
Si pasamos un objeto como argumento, entonces hay dos etapas de cómputo:

El objeto se convierte en un valor primitivo (utilizando las reglas descritas anteriormente).
Si es necesario para más cómputo, el valor primitivo resultante también se convierte.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  // toString maneja todas las conversiones en ausencia de otros métodos
  toString() {
    return "2";
  }
};

alert(obj * 2); // 4, objeto convertido a valor primitivo "2", luego la multiplicación lo convirtió en un número
        
      
      
      
La multiplicación obj * 2 primero convierte el objeto en valor primitivo (que es un string "2").
Luego "2" * 2 se convierte en 2 * 2 (el string se convierte en número).

El + binario concatenará los strings en la misma situación, ya que acepta con gusto un string:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  toString() {
    return "2";
  }
};

alert(obj + 2); // 22 ("2" + 2), la conversión a valor primitivo devolvió un string => concatenación
        
      
      
      ResumenLa conversión de objeto a valor primitivo es llamada automáticamente por muchas funciones y operadores incorporados que esperan un valor primitivo.
Hay 3 tipos (hints o sugerencias) de estas:

"string" (para alert y otras operaciones que necesitan un string)
"number" (para matemáticas)
"default" (pocos operadores, usualmente los objetos lo implementan del mismo modo que "number")

La especificación describe explícitamente qué operador utiliza qué sugerencia.
El algoritmo de conversión es:

Llamar a obj[Symbol.toPrimitive](hint) si el método existe,
En caso contrario, si la sugerencia es "string"

intentar llamar a obj.toString() y obj.valueOf(), lo que exista.


En caso contrario, si la sugerencia es "number" o "default"

intentar llamar a obj.valueOf() y obj.toString(), lo que exista.



Todos estos métodos deben devolver un primitivo para funcionar (si está definido).
En la práctica, a menudo es suficiente implementar solo obj.toString() como un método “atrapatodo” para todas las conversiones a string que deben devolver la representación “legible por humanos” de un objeto, con fines de registro o depuración.
Como en las operaciones matemáticas, JavaScript no ofrece una forma de “sobrescribir” operadores usando métodos. Así que en proyectos de la vida real raramente se los usa en objetos.
",
	"url": "https://es.javascript.info/object-toprimitive" 
},
{
	"docs_id": "38",
	"name": "Métodos en tipos primitivos",
	"description": "JavaScript nos permite trabajar con tipos de datos primitivos (string, number, etc) como si fueran objetos. Los primitivos también ofrecen métodos que podemos llamar. Los estudiaremos pronto, pero primero veamos cómo trabajan porque, por supuesto, los primitivos no son objetos (y aquí lo haremos aún más evidente).",
	"content": "JavaScript nos permite trabajar con tipos de datos primitivos (string, number, etc) como si fueran objetos. Los primitivos también ofrecen métodos que podemos llamar. Los estudiaremos pronto, pero primero veamos cómo trabajan porque, por supuesto, los primitivos no son objetos (y aquí lo haremos aún más evidente).
Veamos las diferencias fundamentales entre primitivos y objetos.
Un primitivo

Es un valor de tipo primitivo.
Hay 7 tipos primitivos: string, number, bigint, boolean, symbol, null y undefined.

Un objeto

Es capaz de almacenar múltiples valores como propiedades.
Puede ser creado con {}.  Ejemplo: {name: "John", age: 30}. Hay otras clases de objetos en JavaScript; las funciones, por ejemplo, son objetos.

Una de las mejores cosas de los objetos es que podemos almacenar una función como una de sus propiedades.

      
        
        
          
            
          
          
            
          
        
        
          let john = {
  name: "John",
  sayHi: function() {
    alert("Hi buddy!");
  }
};

john.sayHi(); // Hi buddy!
        
      
      
      Aquí hemos creado un objeto john con el método sayHi.
Ya existen muchos objetos integrados al lenguaje, como los que trabajan con fechas, errores, elementos HTML, etc.  Ellos tienen diferentes propiedades y métodos.
¡Pero estas características tienen un precio!
Los objetos son más “pesados” que los primitivos. Ellos requieren recursos adicionales para soportar su maquinaria interna.
Un primitivo como objetoAquí el dilema que enfrentó el creador de JavaScript:

Hay muchas cosas que uno querría hacer con los tipos primitivos, como un string o un number. Sería grandioso accederlas usando métodos.
Los Primitivos deben ser tan rápidos y livianos como sea posible.

La solución es algo enrevesada, pero aquí está:

Los primitivos son aún primitivos. Con un valor único, como es deseable.
El lenguaje permite el acceso a métodos y propiedades de strings, numbers, booleans y symbols.
Para que esto funcione, se crea una envoltura especial, un “object wrapper” (objeto envoltorio) que provee la funcionalidad extra y luego es destruido.

Los “object wrappers” son diferentes para cada primitivo y son llamados: String, Number, Boolean, Symbol y BigInt.  Así, proveen diferentes sets de métodos.
Por ejemplo, existe un método str.toUpperCase() que devuelve un string en mayúsculas.
Aquí el funcionamiento:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

alert( str.toUpperCase() ); // HELLO
        
      
      
      Simple, ¿no es así?  Lo que realmente ocurre en str.toUpperCase():

El string str es primitivo.  Al momento de acceder a su propiedad, un objeto especial es creado, uno que conoce el valor del string y tiene métodos útiles como toUpperCase().
Ese método se ejecuta y devuelve un nuevo string (mostrado con alert).
El objeto especial es destruido, dejando solo el primitivo str.

Así los primitivos pueden proveer métodos y aún permanecer livianos.
El motor JavaScript optimiza este proceso enormemente.  Incluso puede saltarse la creación del objeto extra por completo.  Pero aún se debe adherir a la especificación y comportarse como si creara uno.
Un number tiene sus propios métodos, por ejemplo toFixed(n) redondea el número a la precisión dada:

      
        
        
          
            
          
          
            
          
        
        
          let n = 1.23456;

alert( n.toFixed(2) ); // 1.23
        
      
      
      Veremos más métodos específicos en los capítulos Números y Strings.

            Los constructores String/Number/Boolean son de uso interno solamente
            Algunos lenguajes como Java permiten crear “wrapper objects” para primitivos explícitamente usando una sintaxis como new Number(1) o new Boolean(false).
En JavaScript, eso también es posible por razones históricas, pero firmemente desaconsejado. Las cosas enloquecerían en varios lugares.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( typeof 0 ); // "number"

alert( typeof new Number(0) ); // "object"!
        
      
      
      Los objetos siempre son true en un if, entonces el alert mostrará:

      
        
        
          
            
          
          
            
          
        
        
          let cero = new Number(0);

if (cero) { // cero es true, porque es un objeto
  alert( "¿cero es verdadero?!?" );
}
        
      
      
      Por otro lado, usar las mismas funciones String/Number/Boolean sin new es totalmente sano y útil. Ellas convierten un valor al tipo primitivo correspondiente: a un string, number, o boolean.
Por ejemplo, esto es perfectamente válido:

      
        
        
          let num = Number("123"); // convierte string a number
        
      
      
      

            null/undefined no poseen métodos
            Los primitivos especiales null y undefined son excepciones. No tienen “wrapper objects” correspondientes y no proveen métodos. En ese sentido son “lo más primitivo”.
El intento de acceder a una propiedad de tal valor daría error:

      
        
        
          
            
          
          
            
          
        
        
          alert(null.test); // error
        
      
      
      
Resumen
Los primitivos excepto null y undefined proveen muchos métodos útiles.  Los estudiaremos en los próximos capítulos.
Formalmente, estos métodos trabajan a través de objetos temporales, pero los motores de JavaScript están bien afinados para optimizarlos internamente así que llamarlos no es costoso.

Tareas¿Puedo agregar una propiedad a un string?importancia: 5Considera el siguiente código:

      
        
        
          let str = "Hello";

str.test = 5;

alert(str.test);
        
      
      
      Qué piensas: ¿funcionará? ¿Qué mostrará?
soluciónPrueba ejecutándolo:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hello";

str.test = 5; // (*)

alert(str.test);
        
      
      
      Depende de si usas el modo estricto “use strict” o no, el resultado será:

undefined (sin strict mode)
Un error.  (strict mode)

¿Por qué? Repasemos lo que ocurre en la línea (*):

Cuando se accede a una propiedad de str, se crea un “wrapper object” (objeto envolvente ).
Con modo estricto, tratar de alterarlo produce error.
Sin modo estricto, la operación es llevada a cabo y el objeto obtiene la propiedad test, pero después de ello el “objeto envolvente” desaparece, entonces en la última linea str queda sin rastros de la propiedad.

Este ejemplo claramente muestra que los tipos primitivos no son objetos.
Ellos no pueden almacenar datos adicionales.
",
	"url": "https://es.javascript.info/primitives-methods" 
},
{
	"docs_id": "39",
	"name": "Números",
	"description": "En JavaScript moderno, hay dos tipos de números:",
	"content": "En JavaScript moderno, hay dos tipos de números:


Los números regulares en JavaScript son almacenados con el formato de 64-bit IEEE-754, conocido como “números de doble precisión de coma flotante”. Estos números son los que estaremos usando la mayor parte del tiempo y hablaremos de ellos en este capítulo.


Los números BigInt representan enteros de longitud arbitraria. A veces son necesarios porque un número regular no puede exceder 253 ni ser menor a -253 manteniendo la precisión. Como los bigints son usados en algunas áreas especiales, les dedicamos un capítulo especial BigInt.


Aquí hablaremos de números regulares. Ampliemos lo que ya sabemos de ellos.
Más formas de escribir un númeroImagina que necesitamos escribir mil millones (En inglés “1 billion”). La forma obvia es:

      
        
        
          let billion = 1000000000;
        
      
      
      También podemos usar guion bajo _ como separador:

      
        
        
          let billion = 1_000_000_000;
        
      
      
      Aquí _ es “azúcar sintáctica”, hace el número más legible. El motor JavaScript simplemente ignora _ entre dígitos, así que es exactamente igual al “billion” de más arriba.
Pero en la vida real tratamos de evitar escribir una larga cadena de ceros porque es fácil tipear mal.
En JavaScript, acortamos un número agregando la letra "e" y especificando la cantidad de ceros:

      
        
        
          
            
          
          
            
          
        
        
          let billion = 1e9;  // 1 billion, literalmente: 1 y 9 ceros

alert( 7.3e9 );  // 7.3 billions (tanto 7300000000 como 7_300_000_000)
        
      
      
      En otras palabras, "e" multiplica el número por el 1 seguido de la cantidad de ceros dada.

      
        
        
          1e3 === 1 * 1000; // e3 significa *1000
1.23e6 === 1.23 * 1000000; // e6 significa *1000000
        
      
      
      Ahora escribamos algo muy pequeño. Digamos 1 microsegundo (un millonésimo de segundo):

      
        
        
          let mсs = 0.000001;
        
      
      
      Igual que antes, el uso de "e" puede ayudar. Si queremos evitar la escritura de ceros explícitamente, podríamos expresar lo mismo como:

      
        
        
          let mcs = 1e-6; // cinco ceros a la izquierda de 1
        
      
      
      Si contamos los ceros en 0.000001, hay 6 de ellos en total. Entonces naturalmente es 1e-6.
En otras palabras, un número negativo detrás de "e" significa una división por el 1 seguido de la cantidad dada de ceros:

      
        
        
          // -3 divide por 1 con 3 ceros
1e-3 === 1 / 1000; // 0.001

// -6 divide por 1 con 6 ceros
1.23e-6 === 1.23 / 1000000; // 0.00000123

// un ejemplo con un número mayor
1234e-2 === 1234 / 100; // 12.34, el punto decimal se mueve 2 veces
        
      
      
      Números hexadecimales, binarios y octalesLos números Hexadecimales son ampliamente usados en JavaScript para representar colores, codificar caracteres y muchas otras cosas. Es natural que exista una forma breve de escribirlos: 0x y luego el número.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0xff ); // 255
alert( 0xFF ); // 255 (lo mismo en mayúsculas o minúsculas )
        
      
      
      Los sistemas binario y octal son raramente usados, pero también soportados mediante el uso de los prefijos 0b y 0o:

      
        
        
          
            
          
          
            
          
        
        
          let a = 0b11111111; // binario de 255
let b = 0o377; // octal de 255

alert( a == b ); // true, el mismo número 255 en ambos lados
        
      
      
      Solo 3 sistemas numéricos tienen tal soporte. Para otros sistemas numéricos, debemos usar la función parseInt (que veremos luego en este capítulo).
toString(base)El método num.toString(base) devuelve la representación num en una cadena, en el sistema numérico con la base especificada.
Ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
        
      
      
      La base puede variar entre 2 y 36. La predeterminada es 10.
Casos de uso común son:


base=16 usada para colores hex, codificación de caracteres, etc; los dígitos pueden ser 0..9 o A..F.


base=2 mayormente usada para el debug de operaciones de bit, los dígitos pueden ser 0 o 1.


base=36 Es el máximo, los dígitos pueden ser 0..9 o A..Z.  Aquí el alfabeto inglés completo es usado para representar un número.  Un uso peculiar pero práctico para la base 36 es cuando necesitamos convertir un largo identificador numérico en algo más corto, por ejemplo para abreviar una url. Podemos simplemente representarlo en el sistema numeral de base 36:

      
        
        
          
            
          
          
            
          
        
        
          alert( 123456..toString(36) ); // 2n9c
        
      
      
      


            Dos puntos para llamar un método
            Por favor observa que los dos puntos en 123456..toString(36) no son un error tipográfico. Si queremos llamar un método directamente sobre el número, como toString del ejemplo anterior, necesitamos ubicar los dos puntos .. tras él.
Si pusiéramos un único punto: 123456.toString(36), habría un error, porque la sintaxis de JavaScript implica una parte decimal después del primer punto. Al poner un punto más, JavaScript reconoce que la parte decimal está vacía y luego va el método.
También podríamos escribir (123456).toString(36).

RedondeoUna de las operaciones más usadas cuando se trabaja con números es el redondeo.
Hay varias funciones incorporadas para el redondeo:

Math.floor
Redondea hacia abajo: 3.1 se convierte en 3, y -1.1 se hace -2.
Math.ceil
Redondea hacia arriba: 3.1 torna en 4, y -1.1 torna en -1.
Math.round
Redondea hacia el entero más cercano: 3.1 redondea a 3, 3.6 redondea a 4, el caso medio 3.5 redondea a 4 también.
Math.trunc (no soportado en Internet Explorer)
Remueve lo que haya tras el punto decimal sin redondear: 3.1 torna en 3, -1.1 torna en -1.

Aquí, la tabla que resume las diferencias entre ellos:




Math.floor
Math.ceil
Math.round
Math.trunc




3.1
3
4
3
3


3.6
3
4
4
3


-1.1
-2
-1
-1
-1


-1.6
-2
-1
-2
-1



Estas funciones cubren todas las posibles formas de lidiar con la parte decimal de un número. Pero ¿si quisiéramos redondear al enésimo n-th dígito tras el decimal?
Por ejemplo, tenemos 1.2345 y queremos redondearlo a 2 dígitos obteniendo solo 1.23.
Hay dos formas de hacerlo:


Multiplicar y dividir.
Por ejemplo, para redondear el número a dos dígitos tras el decimal, podemos multiplicarlo por 100, llamar la función de redondeo y entonces volverlo a dividir.

      
        
        
          
            
          
          
            
          
        
        
          let num = 1.23456;

alert( Math.round(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23
        
      
      
      

El método toFixed(n) redondea el número a n dígitos después del punto decimal y devuelve una cadena que representa el resultado.

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
        
      
      
      Redondea hacia arriba o abajo al valor más cercano, similar a Math.round:

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
        
      
      
      Ten en cuenta que el resultado de toFixed es una cadena. Si la parte decimal es más corta que lo requerido, se agregan ceros hasta el final:

      
        
        
          
            
          
          
            
          
        
        
          let num = 12.34;
alert( num.toFixed(5) ); // "12.34000", con ceros agregados para dar exactamente 5 dígitos
        
      
      
      Podemos convertirlo a “number” usando el operador unario más o llamando a Number(); por ejemplo, escribir +num.toFixed(5).


Cálculo imprecisoInternamente, un número es representado en formato de 64-bit IEEE-754, donde hay exactamente 64 bits para almacenar un número: 52 de ellos son usados para almacenar los dígitos, 11 para almacenar la posición del punto decimal (son cero para los enteros), y 1 bit es para el signo.
Si un número es verdaderamente grande, puede rebasar el almacén de 64 bit y obtenerse el valor numérico Infinity:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1e500 ); // Infinity
        
      
      
      Lo que puede ser algo menos obvio, pero ocurre a menudo, es la pérdida de precisión.
Considera este (¡falso!) test de igualdad:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1 + 0.2 == 0.3 ); // false
        
      
      
      Es así, al comprobar si la suma de 0.1 y 0.2 es 0.3, obtenemos false.
¡Qué extraño! ¿Qué es si no 0.3?

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1 + 0.2 ); // 0.30000000000000004
        
      
      
      ¡Ay! Imagina que estás haciendo un sitio de compras electrónicas y el visitante pone $0.10 y $0.20 en productos en su carrito. El total de la orden será $0.30000000000000004. Eso sorprendería a cualquiera…
¿Pero por qué pasa esto?
Un número es almacenado en memoria en su forma binaria, una secuencia de bits, unos y ceros. Pero decimales como 0.1, 0.2 que se ven simples en el sistema decimal son realmente fracciones sin fin en su forma binaria.
¿Qué es 0.1? Es un uno dividido por 10 1/10, un décimo. En sistema decimal es fácilmente representable. Compáralo con un tercio: 1/3, se vuelve una fracción sin fin 0.33333(3).
Así, la división en potencias de diez garantizan un buen funcionamiento en el sistema decimal, pero divisiones por 3 no.  Por la misma razón, en el sistema binario la división en potencias de 2 garantizan su funcionamiento, pero 1/10 se vuelve una fracción binaria sin fin.
Simplemente no hay manera de guardar exactamente 0.1 o exactamente 0.2 usando el sistema binario, así como no hay manera de guardar un tercio en fracción decimal.
El formato numérico IEEE-754 resuelve esto redondeando al número posible más cercano. Estas reglas de redondeo normalmente no nos permiten percibir aquella “pequeña pérdida de precisión”, pero existe.
Podemos verlo en acción:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0.1.toFixed(20) ); // 0.10000000000000000555
        
      
      
      Y cuando sumamos dos números, se apilan sus “pérdidas de precisión”.
Y es por ello que 0.1 + 0.2 no es exactamente 0.3.

            No solo JavaScript
            El mismo problema existe en muchos otros lenguajes de programación.
PHP, Java, C, Perl, Ruby dan exactamente el mismo resultado, porque ellos están basados en el mismo formato numérico.

¿Podemos resolver el problema? Seguro, la forma más confiable es redondear el resultado con la ayuda de un método. toFixed(n):

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // "0.30"
        
      
      
      Ten en cuenta que toFixed siempre devuelve un string. Esto asegura que tiene 2 dígitos después del punto decimal. Esto es en verdad conveniente si tenemos un sitio de compras y necesitamos mostrar $0.30. Para otros casos, podemos usar el + unario para forzar un número:

      
        
        
          
            
          
          
            
          
        
        
          let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
        
      
      
      También podemos multiplicar temporalmente por 100 (o un número mayor) para transformarlos a enteros, hacer las cuentas, y volverlos a dividir. Como hacemos las cuentas con enteros el error se reduce, pero aún lo tenemos en la división:

      
        
        
          
            
          
          
            
          
        
        
          alert( (0.1 * 10 + 0.2 * 10) / 10 ); // 0.3
alert( (0.28 * 100 + 0.14 * 100) / 100); // 0.4200000000000001
        
      
      
      Entonces el enfoque de multiplicar/dividir reduce el error, pero no lo elimina por completo.
A veces podemos tratar de evitar los decimales del todo. Si estamos tratando con una tienda, podemos almacenar precios en centavos en lugar de dólares. Pero ¿y si aplicamos un descuento de 30%? En la práctica, evitar la parte decimal por completo es raramente posible. Simplemente se redondea y se corta el “rabo” decimal cuando es necesario.

            Algo peculiar
            Prueba ejecutando esto:

      
        
        
          
            
          
          
            
          
        
        
          // ¡Hola! ¡Soy un número que se autoincrementa!
alert( 9999999999999999 ); // muestra 10000000000000000
        
      
      
      Esto sufre del mismo problema: Una pérdida de precisión. Hay 64 bits para el número, 52 de ellos pueden ser usados para almacenar dígitos, pero no es suficiente. Entonces los dígitos menos significativos desaparecen.
JavaScript no dispara error en tales eventos. Hace lo mejor que puede para ajustar el número al formato deseado, pero desafortunadamente este formato no es suficientemente grande.


            Dos ceros
            Otra consecuencia peculiar de la representación interna de los números es la existencia de dos ceros: 0 y -0.
Esto es porque el signo es representado por un bit, así cada número puede ser positivo o negativo, incluyendo al cero.
En la mayoría de los casos la distinción es imperceptible, porque los operadores están adaptados para tratarlos como iguales.

Tests: isFinite e isNaN¿Recuerdas estos dos valores numéricos especiales?

Infinity (y -Infinity) es un valor numérico especial que es mayor (menor) que cualquier otra cosa.
NaN (“No un Número”) representa un error.

Ambos pertenecen al tipo number, pero no son números “normales”, así que hay funciones especiales para chequearlos:


isNaN(value) convierte su argumento a número entonces testea si es NaN:

      
        
        
          
            
          
          
            
          
        
        
          alert( isNaN(NaN) ); // true
alert( isNaN("str") ); // true
        
      
      
      Pero ¿necesitamos esta función? ¿No podemos simplemente usar la comparación === NaN? Desafortunadamente no. El valor NaN es único en que no es igual a nada, incluyendo a sí mismo:

      
        
        
          
            
          
          
            
          
        
        
          alert( NaN === NaN ); // false
        
      
      
      

isFinite(value) convierte su argumento a un número y devuelve  true si es un número regular, no NaN/Infinity/-Infinity:

      
        
        
          
            
          
          
            
          
        
        
          alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, porque es un valor especial: NaN
alert( isFinite(Infinity) ); // false, porque es un valor especial: Infinity
        
      
      
      

A veces isFinite es usado para validar si un valor string es un número regular:

      
        
        
          
            
          
          
            
          
        
        
          let num = +prompt("Enter a number", '');

// siempre true salvo que ingreses  Infinity, -Infinity o  un valor no numérico
alert( isFinite(num) );
        
      
      
      Ten en cuenta que un valor vacío o un string de solo espacios es tratado como 0 en todas las funciones numéricas incluyendo isFinite.

            Comparación con Object.is
            Existe un método nativo especial Object.is que compara valores al igual que ===, pero es más confiable para dos casos extremos:

Funciona con NaN: Object.is(NaN, NaN) === true, lo que es una buena cosa.
Los valores 0 y -0 son diferentes: Object.is(0, -0) === false. false es técnicamente correcto, porque internamente el número puede tener el bit de signo diferente incluso aunque todos los demás sean ceros.

En todos los demás casos, Object.is(a, b) es lo mismo que a === b.
Esta forma de comparación se usa a menudo en la especificación JavaScript. Cuando un algoritmo interno necesita comparar que dos valores sean exactamente iguales, usa Object.is (internamente llamado SameValue).

parseInt y parseFloatLa conversión numérica usando un más + o Number() es estricta. Si un valor no es exactamente un número, falla:

      
        
        
          
            
          
          
            
          
        
        
          alert( +"100px" ); // NaN
        
      
      
      Siendo la única excepción los espacios al principio y al final del string, pues son ignorados.
Pero en la vida real a menudo tenemos valores en unidades como "100px" o "12pt" en CSS.  También el símbolo de moneda que en varios países va después del monto, tenemos "19€" y queremos extraerle la parte numérica.
Para eso sirven parseInt y parseFloat.
Estas “leen” el número desde un string hasta que dejan de poder hacerlo. Cuando se topa con un error devuelve el número que haya registrado hasta ese momento. La función parseInt devuelve un entero, mientras que parseFloat devolverá un punto flotante:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5

alert( parseInt('12.3') ); // 12, devuelve solo la parte entera
alert( parseFloat('12.3.4') ); // 12.3, el segundo punto detiene la lectura
        
      
      
      Hay situaciones en que parseInt/parseFloat devolverán NaN. Ocurre cuando no puedo encontrar dígitos:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('a123') ); // NaN, el primer símbolo detiene la lectura
        
      
      
      
            El segundo argumento de parseInt(str, radix)
            La función parseInt() tiene un segundo parámetro opcional. Este especifica la base de sistema numérico, entonces parseInt puede también analizar cadenas de números hexa, binarios y otros:

      
        
        
          
            
          
          
            
          
        
        
          alert( parseInt('0xff', 16) ); // 255
alert( parseInt('ff', 16) ); // 255, sin 0x también funciona

alert( parseInt('2n9c', 36) ); // 123456
        
      
      
      
Otras funciones matemáticasJavaScript tiene un objeto incorporado Math que contiene una pequeña biblioteca de funciones matemáticas y constantes.
Unos ejemplos:

Math.random()

Devuelve un número aleatorio entre 0 y 1 (no incluyendo 1)

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.random() ); // 0.1234567894322
alert( Math.random() ); // 0.5435252343232
alert( Math.random() ); // ... (cualquier número aleatorio)
        
      
      
      
Math.max(a, b, c...) y Math.min(a, b, c...)

Devuelven el mayor y el menor de entre una cantidad arbitraria de argumentos.

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.min(1, 2) ); // 1
        
      
      
      
Math.pow(n, power)

Devuelve n elevado a la potencia power dada

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.pow(2, 10) ); // 2 elevado a la potencia de 10 = 1024
        
      
      
      

Hay más funciones y constantes en el objeto Math, incluyendo trigonometría, que puedes encontrar en la documentación del objeto Math.
ResumenPara escribir números con muchos ceros:

Agregar "e" con la cantidad de ceros al número. Como: 123e6 es 123 con 6 ceros 123000000.
un número negativo después de "e" causa que el número sea dividido por 1 con los ceros dados:. 123e-6 significa 0.000123 (123 millonésimos).

Para sistemas numéricos diferentes:

Se pueden escribir números directamente en sistemas hexa (0x), octal (0o) y binario (0b).
parseInt(str, base) convierte un string a un entero en el sistema numérico de la base dada base, 2 ≤ base ≤ 36.
num.toString(base) convierte un número a string en el sistema de la base dada.

Para tests de números regulares:

isNaN(value) convierte su argumento a number y luego verifica si es NaN
isFinite(value) convierte su argumento a number y devuelve true si es un número regular, no NaN/Infinity/-Infinity

Para convertir valores como 12pt y 100px a un número:

Usa parseInt/parseFloat para una conversión “suave”, que lee un número desde un string y devuelve el valor del número que pudiera leer antes de encontrar error.

Para números con decimales:

Redondea usando Math.floor, Math.ceil, Math.trunc, Math.round o num.toFixed(precision).
Asegúrate de recordar que hay pérdida de precisión cuando se trabaja con decimales.

Más funciones matemáticas:

Revisa el documento del objeto Math cuando las necesites. La biblioteca es pequeña, pero puede cubrir las necesidades básicas.

TareasSuma números del visitanteimportancia: 5Crea un script que pida al visitante que ingrese dos números y muestre su suma.
Ejecutar el demoP.D. Hay una trampa con los tipos de valores.
solución
      
        
        
          
            
          
          
            
          
        
        
          let a = +prompt("¿El primer número?", "");
let b = +prompt("¿El segundo número?", "");

alert( a + b );
        
      
      
      Toma nota del más unario + antes del prompt. Este convierte inmediatamente el valor a number.
De otra manera a and b serían string, y la suma, su concatenación: "1" + "2" = "12".
¿Por qué 6.35.toFixed(1) == 6.3?importancia: 4Según la documentación Math.round y toFixed redondean al número más cercano: 0..4 hacia abajo mientras 5..9 hacia arriba.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1.35.toFixed(1) ); // 1.4
        
      
      
      En el ejemplo  similar que sigue, ¿por qué 6.35 es redondeado a 6.3, y no a 6.4?

      
        
        
          
            
          
          
            
          
        
        
          alert( 6.35.toFixed(1) ); // 6.3
        
      
      
      ¿Cómo redondear 6.35 de manera correcta?
soluciónInternamente, la fracción decimal 6.35 resulta en binario sin fin. Como siempre en estos casos, es almacenado con pérdida de precisión.
Veamos:

      
        
        
          
            
          
          
            
          
        
        
          alert( 6.35.toFixed(20) ); // 6.34999999999999964473
        
      
      
      La pérdida de precisión puede causar que el número incremente o decremente. En este caso particular el número se vuelve ligeramente menor, por ello es redondeado hacia abajo.
¿Y qué pasa con 1.35?

      
        
        
          
            
          
          
            
          
        
        
          alert( 1.35.toFixed(20) ); // 1.35000000000000008882
        
      
      
      Aquí la pérdida de precisión hace el número algo mayor, por ello redondea hacia arriba.
¿Cómo podemos arreglar el problema con 6.35 si queremos redondearlo de manera correcta?
Debemos llevarlo más cerca de un entero antes del redondeo:

      
        
        
          
            
          
          
            
          
        
        
          alert( (6.35 * 10).toFixed(20) ); // 63.50000000000000000000
        
      
      
      Observa que 63.5 no tiene pérdida de precisión en absoluto. Esto es porque la parte decimal 0.5 es realmente 1/2. Fracciones divididas por potencias de 2 son representadas exactamente en el sistema binario, ahora podemos redondearlo:

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.round(6.35 * 10) / 10); // 6.35 -> 63.5 -> 64(redondeado) -> 6.4
        
      
      
      Repetir hasta que lo ingresado sea un númeroimportancia: 5Crea una función readNumber que pida un número hasta que el visitante ingrese un valor numérico válido.
El valor resultante debe ser devuelto como number.
El visitante puede también detener el proceso ingresando una linea vacía o presionando “CANCEL”. En tal caso la función debe devolver null.
Ejecutar el demoAbrir en entorno controlado con pruebas.solución
      
        
        
          
            
          
          
            
          
        
        
          function readNumber() {
  let num;

  do {
    num = prompt("Ingrese un número por favor:", 0);
  } while ( !isFinite(num) );

  if (num === null || num === '') return null;

  return +num;
}

alert(`Read: ${readNumber()}`);
        
      
      
      La solución es un poco más intrincada de lo que podría ser porque necesitamos manejar null y líneas vacías.
Entonces aceptamos entrada de datos hasta que sea un “número regular”.  También null (cancel) y las líneas vacías encajan en esa condición porque un su forma numérica estos son 0.
Una vez detenido el ingreso, necesitamos tratar especialmente los casos null y línea vacía (return null), porque al convertirlos devolverían 0.
Abrir la solución con pruebas en un entorno controlado.Un bucle infinito ocasionalimportancia: 4Este bucle es infinito. Nunca termina, ¿por qué?

      
        
        
          let i = 0;
while (i != 10) {
  i += 0.2;
}
        
      
      
      soluciónEs porque i nunca sería igual a 10.
Ejecuta esto para ver los valores reales de i:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;
while (i < 11) {
  i += 0.2;
  if (i > 9.8 && i < 10.2) alert( i );
}
        
      
      
      Ninguno de ellos es exactamente 10.
Tales cosas suceden por las pérdidas de precisión cuando sumamos decimales como 0.2.
Conclusión: evita chequeos de igualdad al trabajar con números decimales.
Un número aleatorio entre min y maximportancia: 2La función incorporada Math.random() crea un valor aleatorio entre 0 y 1 (no incluyendo 1).
Escribe una función random(min, max) para generar un número de punto flotante entre min y max (no incluyendo max).
Ejemplos de su funcionamiento:

      
        
        
          alert( random(1, 5) ); // 1.2345623452
alert( random(1, 5) ); // 3.7894332423
alert( random(1, 5) ); // 4.3435234525
        
      
      
      soluciónNecesitamos hacer un “mapeo” de todos los valores del intervalo 0…1 a valores desde min a max.
Esto puede hacerse en dos pasos:

Si multiplicamos el número aleatorio 0…1 por max-min, entonces el intervalo de valores posibles va de 0..1 a 0..max-min.
Ahora si sumamos min, el intervalo posible se vuelve desde min a max.

La función:

      
        
        
          
            
          
          
            
          
        
        
          function random(min, max) {
  return min + Math.random() * (max - min);
}

alert( random(1, 5) );
alert( random(1, 5) );
alert( random(1, 5) );
        
      
      
      Un entero aleatorio entre min y maximportancia: 2Crea una función randomInteger(min, max) que genere un número entero aleatorio entre min y max incluyendo ambos, min y max, como valores posibles.
Todo número del intervalo min..max debe aparecer con la misma probabilidad.
Ejemplos de funcionamiento:

      
        
        
          alert( randomInteger(1, 5) ); // 1
alert( randomInteger(1, 5) ); // 3
alert( randomInteger(1, 5) ); // 5
        
      
      
      Puedes usar la solución de la tarea previa como base.
soluciónLa solución simple, pero equivocadaLa solución simple, pero equivocadaLa solución más simple, pero equivocada, sería generar un valor entre min y max y redondearlo:

      
        
        
          
            
          
          
            
          
        
        
          function randomInteger(min, max) {
  let rand = min + Math.random() * (max - min);
  return Math.round(rand);
}

alert( randomInteger(1, 3) );
        
      
      
      La función funciona, pero es incorrecta. La probabilidad de obtener los valores extremos min y max es la mitad de la de los demás.
Si ejecutas el ejemplo que sigue muchas veces, fácilmente verás que 2 aparece más a menudo.
Esto ocurre porque Math.round() obtiene los números del intervalo 1..3 y los redondea como sigue:

      
        
        
          valores desde 1    ... hasta 1.4999999999  se vuelven 1
valores desde 1.5  ... hasta 2.4999999999  se vuelven 2
valores desde 2.5  ... hasta 2.9999999999  se vuelven 3
        
      
      
      Ahora podemos ver claramente que 1 obtiene la mitad de valores que 2. Y lo mismo con 3.
La solución correctaLa solución correctaHay muchas soluciones correctas para la tarea. una es ajustar los bordes del intervalo. Para asegurarse los mismos intervalos, podemos generar valores entre 0.5 a 3.5, así sumando las probabilidades requeridas a los extremos:

      
        
        
          
            
          
          
            
          
        
        
          function randomInteger(min, max) {
  // ahora rand es desde  (min-0.5) hasta (max+0.5)
  let rand = min - 0.5 + Math.random() * (max - min + 1);
  return Math.round(rand);
}

alert( randomInteger(1, 3) );
        
      
      
      Una alternativa es el uso de Math.floor para un número aleatorio entre min y max+1:

      
        
        
          
            
          
          
            
          
        
        
          function randomInteger(min, max) {
  // aquí rand es desde min a (max+1)
  let rand = min + Math.random() * (max + 1 - min);
  return Math.floor(rand);
}

alert( randomInteger(1, 3) );
        
      
      
      Ahora todos los intervalos son mapeados de esta forma:

      
        
        
          valores desde 1  ... hasta 1.9999999999  se vuelven 1
valores desde 2  ... hasta 2.9999999999  se vuelven 2
valores desde 3  ... hasta 3.9999999999  se vuelven 3
        
      
      
      Todos los intervalos tienen el mismo largo, haciendo la distribución final uniforme.
",
	"url": "https://es.javascript.info/number" 
},
{
	"docs_id": "40",
	"name": "Strings",
	"description": "En JavaScript, los datos textuales son almacenados como strings (cadena de caracteres). No hay un tipo de datos separado para caracteres unitarios.",
	"content": "En JavaScript, los datos textuales son almacenados como strings (cadena de caracteres). No hay un tipo de datos separado para caracteres unitarios.
El formato interno para strings es siempre UTF-16, no está vinculado a la codificación de la página.
ComillasRecordemos los tipos de comillas.
Los strings pueden estar entre comillas simples, comillas dobles o backticks (acento grave):

      
        
        
          let single = 'comillas simples';
let double = "comillas dobles";

let backticks = `backticks`;
        
      
      
      Comillas simples y dobles son esencialmente lo mismo. Sin embargo los “backticks” nos permiten ingresar expresiones dentro del string, envolviéndolos en ${…}:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a, b) {
  return a + b;
}

alert(`1 + 2 = ${sum(1, 2)}.`); // 1 + 2 = 3.
        
      
      
      Otra ventaja de usar backticks es que nos permiten extender en múltiples líneas el string:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = `Invitados:
 * Juan
 * Pedro
 * Maria
`;

alert(guestList); // una lista de invitados, en múltiples líneas
        
      
      
      Se ve natural, ¿no es cierto? Pero las comillas simples y dobles no funcionan de esa manera.
Si intentamos usar comillas simples o dobles de la misma forma, obtendremos un error:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = "Invitados:  // Error: Unexpected token ILLEGAL
  * Juan";
        
      
      
      Las comillas simples y dobles provienen de la creación de lenguajes en tiempos ancestrales, cuando la necesidad de múltiples líneas no era tomada en cuenta. Los backticks aparecieron mucho después y por ende son más versátiles.
Los backticks además nos permiten especificar una “función de plantilla” antes del primer backtick. La sintaxis es: func`string`. La función func es llamada automáticamente, recibe el string y la expresión insertada y los puede procesar. Eso se llama “plantillas etiquetadas”. Esta característica hace que sea más fácil implementar plantillas personalizadas, pero es raramente usada en la práctica. Puedes leer más sobre esto en docs.
Caracteres especialesEs posible crear strings de múltiples líneas usando comillas simples, usando un llamado “carácter de nueva línea”, escrito como \n, lo que denota un salto de línea:

      
        
        
          
            
          
          
            
          
        
        
          let guestList = 'Invitados:\n * Juan\n * Pedro\n * Maria';

alert(guestList); // una lista de invitados en múltiples líneas
        
      
      
      Por ejemplo, estas dos líneas son iguales, pero escritas en forma diferente:

      
        
        
          
            
          
          
            
          
        
        
          let str1 = "Hello\nWorld"; // dos líneas usando el "símbolo de nueva línea"

// dos líneas usando nueva línea normal y backticks
let str2 = `Hello
World`;

alert(str1 == str2); // true
        
      
      
      Existen otros tipos de caracteres especiales, menos comunes.
Esta es la lista completa:



Carácter
Descripción




\n
Nueva línea


\r
Retorno de carro: En Windows, los archivos de texto usan una combinación de dos caracteres \r\n para representar un corte de línea mientras que en otros SO es simplemente ‘\n’. Esto es por razones históricas, la mayoría del software para Windows también entienden ‘\n’.


\', \"
Comillas


\\
Barra invertida


\t
Tabulación


\b, \f, \v
Backspace, Form Feed, Vertical Tab – Se mantienen por compatibilidad. No son usados actualmente


\xXX
Carácter Unicode con el hexadecimal dado XX, por ej. '\x7A' es lo mismo que 'z'.


\uXXXX
Un símbolo unicode con el hexadecimal dado XXXX en codificación UTF-16, p.ej. \u00A9 – es el unicode para el símbolo copyright ©. Debe ser exactamente 4 dígitos  hex.


\u{X…XXXXXX} (1 a 6 caracteres hex)
Un símbolo unicode con el hexadecimal dado en codificación UTF-32. Algunos caracteres raros son codificados con  dos símbolos unicode, tomando 4 bytes. De esta manera podemos insertar códigos largos.



Ejemplos con unicode:

      
        
        
          
            
          
          
            
          
        
        
          alert('\u00A9'); // ©
alert('\u{20331}'); // 佫, un raro jeroglífico chino (unicode largo)
alert('\u{1F60D}'); // 😍, un emoticón sonriendo (otro unicode largo)
        
      
      
      Todos los caracteres especiales comienzan con una barra invertida \. También conocida como “carácter de escape”.
También la usamos si queremos insertar una comilla dentro de un string.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert('Yo soy \'Walrus\''); // Yo soy 'Walrus'
        
      
      
      Como puedes ver, debimos anteponer un carácter de escape \ antes de cada comilla ya que de otra manera hubiera indicado el final del string.
Obviamente, eso se refiere sólo a las comillas que son iguales a las que están rodeando al string. Una solución más elegante sería cambiar a comillas dobles o backticks:

      
        
        
          
            
          
          
            
          
        
        
          alert(`Yo soy "Walrus"`); // Yo soy "Walrus"
        
      
      
      Notar que el carácter de escape \ sirve para la correcta lectura del string por JavaScript, luego desaparece. El string que quedó en la memoria no incluye \. Lo puedes ver claramente en el alert del ejemplo anterior.
¿Pero qué pasa si necesitamos incluir un carácter de escape \ en el string?
Es posible, pero debemos duplicarlo como sigue \\:

      
        
        
          
            
          
          
            
          
        
        
          alert(`El carácter de escape: \\`); // El carácter de escape: \
        
      
      
      Largo del stringLa propiedad ‘length’ entrega el largo del string:

      
        
        
          
            
          
          
            
          
        
        
          alert(`Mi\n`.length); // 3
        
      
      
      Notar que \n es un carácter “especial” único, por lo que el largo es 3.

            length es una propiedad
            Gente con experiencia en otros lenguajes a veces comete el error de tipear str.length() en vez de str.length. Eso no funciona.
Por favor notar que str.length es una propiedad numérica, no una función. No hay necesidad de agregar un paréntesis después de ella.

Accediendo caracteresPara acceder a un carácter en la posición pos, se debe usar paréntesis cuadrados [pos] o llamar al método str.charAt(pos). El primer carácter comienza desde la posición cero:

      
        
        
          
            
          
          
            
          
        
        
          let str = `Hola`;

// el primer carácter
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// el último carácter
alert( str[str.length - 1] ); // a
        
      
      
      Los corchetes son una forma moderna de acceder a los caracteres, mientras que charAt existe principalmente por razones históricas.
La única diferencia entre ellos es que si no se encuentra un carácter, [] devuelve undefined, y charAt devuelve un string vacío.

      
        
        
          
            
          
          
            
          
        
        
          let str = `Hola`;

alert(str[1000]); // undefined
alert(str.charAt(1000)); // '' (un string vacío)
        
      
      
      Podemos además iterar sobre los caracteres usando for..of:

      
        
        
          
            
          
          
            
          
        
        
          for (let char of 'Hola') {
  alert(char); // H,o,l,a (char se convierte en "H", luego "o", luego "l" etc)
}
        
      
      
      Strings son inmutablesStrings no pueden ser modificados en JavaScript. Es imposible modificar un carácter.
Intentémoslo para demostrar que no funciona:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Hola';

str[0] = 'h'; // error
alert(str[0]); // no funciona
        
      
      
      La solución alternativa es crear un nuevo string y asignarlo a str en vez de asignarlo al anterior.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Hola';

str = 'h' + str[1] + str[2] + str[3]; // reemplaza el string

alert( str ); // hola
        
      
      
      En la sección siguiente veremos más ejemplos de esto.
Cambiando mayúsculas y minúsculasLos métodos toLowerCase() y toUpperCase() cambian los caracteres a minúscula y mayúscula respectivamente:

      
        
        
          
            
          
          
            
          
        
        
          alert('Interfaz'.toUpperCase()); // INTERFAZ
alert('Interfaz'.toLowerCase()); // interfaz
        
      
      
      Si queremos un solo carácter en minúscula:

      
        
        
          
            
          
          
            
          
        
        
          alert('Interfaz'[0].toLowerCase()); // 'i'
        
      
      
      Buscando una subcadena de caracteresExisten muchas formas de buscar por subcadenas de caracteres dentro de una cadena completa.
str.indexOfEl primer método es str.indexOf(substr, pos).
Este busca un substr en str, comenzando desde la posición entregada pos, y retorna la posición donde es encontrada la coincidencia o -1 en caso de no encontrar nada.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Widget con id';

alert(str.indexOf('Widget')); // 0, ya que 'Widget' es encontrado al comienzo
alert(str.indexOf('widget')); // -1, no es encontrado, la búsqueda toma en cuenta minúsculas y mayúsculas.

alert(str.indexOf('id')); // 1, "id" es encontrado en la posición 1 (..idget con id)
        
      
      
      El segundo parámetro es opcional y nos permite buscar desde la posición entregada.
Por ejemplo, la primera ocurrencia de "id" es en la posición 1. Para buscar por la siguiente ocurrencia, comencemos a buscar desde la posición 2:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Widget con id';

alert(str.indexOf('id', 2)); // 11
        
      
      
      Si estamos interesados en todas las ocurrencias, podemos correr indexOf en un bucle. Cada nuevo llamado es hecho utilizando la posición posterior a la encontrada anteriormente:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Astuto como un zorro, fuerte como un buey';

let target = 'como'; // busquemos por él

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert(`Encontrado en ${foundPos}`);
  pos = foundPos + 1; // continuar la búsqueda desde la siguiente posición
}
        
      
      
      Podemos escribir el mismo algoritmo, pero más corto:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Astuto como un zorro, fuerte como un buey';
let target = "como";

let pos = -1;
while ((pos = str.indexOf(target, pos + 1)) != -1) {
  alert( pos );
}
        
      
      
      
            str.lastIndexOf(substr, position)
            Existe también un método similar str.lastIndexOf(substr, position) que busca desde el final del string hasta el comienzo.
Este imprimirá las ocurrencias en orden invertido.

Existe un leve inconveniente con indexOf en la prueba if. No podemos utilizarlo en el if como sigue:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Widget con id";

if (str.indexOf("Widget")) {
    alert("Lo encontramos"); // no funciona!
}
        
      
      
      La alerta en el ejemplo anterior no se muestra ya que str.indexOf("Widget") retorna 0 (lo que significa que encontró el string en la posición inicial). Eos correcto, pero if considera 0 como falso.
Por ello debemos buscar por -1 como sigue:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Widget con id";

if (str.indexOf("Widget") != -1) {
    alert("Lo encontramos"); // ahora funciona!
}
        
      
      
      El truco “bitwise NOT”Uno de los antiguos trucos es el operador bitwise NOT) ~. Este convierte el número en un entero de 32-bits (elimina la parte decimal si es que existe) y luego invierte todos los bits en su representación binaria.
En la práctica, esto significa una simple cosa: Para enteros de 32 bits, ~n es igual a -(n+1).
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( ~2 ); // -3, lo mismo que -(2+1)
alert( ~0 ); // -1, lo mismo que -(0+1)
alert( ~1 ); // -2, lo mismo que -(1+1)
alert( ~-1 ); // 0, lo mismo que -(-1+1)
        
      
      
      Como podemos ver, ~n es cero sólo si n == -1.  (para cualquier entero de 32-bit con signo).
Por lo que, la prueba if ( ~str.indexOf("...") ) es veraz y el resultado de ``indexOf no es -1. En otras palabras, cuando es encontrado.
La gente lo usa para acortar verificaciones indexOf:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Widget";

if (~str.indexOf("Widget")) {
  alert( 'Lo encontramos!' ); // funciona
}
        
      
      
      Usualmente no es recomendado utilizar características del lenguaje en formas no obvias, pero en particular, este truco es utilizado ampliamente en código antiguo, por lo que debemos entenderlo.
Recuerda: if (~str.indexOf(...)) es leído como “si es encontrado”.
Para ser preciso, como los números grandes son truncados a 32 bits por el operador ~,  existen otros números que dan 0, el menor es ~4294967295=0.  Esto hace que tal chequeo sea correcto solo si el string no es así de largo.
Ahora podemos ver este truco solo en código viejo, porque JavaScript moderno provee el método .includes (ver a continuación).
includes, startsWith, endsWithEl método más moderno str.includes(substr, pos) retorna true/false dependiendo si str contiene substr dentro.
Es la opción correcta, si lo que necesitamos es encontrar el substr pero no necesitamos su posición.

      
        
        
          
            
          
          
            
          
        
        
          alert('Widget con id'.includes('Widget')); // true

alert('Hola'.includes('Adiós')); // false
        
      
      
      El segundo argumento opcional de str.includes es la posición desde donde comienza a buscar:

      
        
        
          
            
          
          
            
          
        
        
          alert('Midget'.includes('id')); // true
alert('Midget'.includes('id', 3)); // false, desde la posición 3 no hay "id"
        
      
      
      Los métodos str.startsWith (comienza con) y str.endsWith (termina con) hacen exactamente lo que dicen:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Widget".startsWith("Wid") ); // true, "Widget" comienza con "Wid"
alert( "Widget".endsWith("get") ); // true, "Widget" termina con "get"
        
      
      
      Obteniendo un substringExisten 3 métodos en JavaScript para obtener un substring: substring, substr y slice.

str.slice(comienzo [, final])

Retorna la parte del string desde comienzo hasta (pero sin incluir) final.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.slice(0, 5) ); // 'strin', el substring desde 0 hasta 5 (sin incluir 5)
alert( str.slice(0, 1) ); // 's', desde 0 hasta 1, pero sin incluir 1, por lo que sólo el carácter en 0
        
      
      
      Si no existe segundo argumento, entonces slice va hasta el final del string:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.slice(2) ); // ringify, desde la 2nda posición hasta el final
        
      
      
      También son posibles valores negativos para comienzo/final. Ellos indican que la posición es contada desde el final del string.

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
// comienza en la 4ta posición desde la derecha, finaliza en la 1era posición desde la derecha
alert( str.slice(-4, -1) ); // gif
        
      
      
      
str.substring(comienzo [, final])

Devuelve la parte del string entre comienzo y final.
Esto es casi lo mismo que slice, pero permite que comienzo sea mayor que final.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";

// esto es lo mismo para substring
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"

// ...pero no para slice:
alert( str.slice(2, 6) ); // "ring" (lo mismo)
alert( str.slice(6, 2) ); // "" (un string vacío)
        
      
      
      Los argumentos negativos (al contrario de slice) no son soportados, son tratados como 0.

str.substr(comienzo [, largo])

Retorna la parte del string desde comienzo, con el largo dado.
A diferencia de los métodos anteriores, este nos permite especificar el largo en lugar de la posición final:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.substr(2, 4) ); // ring, desde la 2nda posición toma 4 caracteres
        
      
      
      El primer argumento puede ser negativo, para contar desde el final:

      
        
        
          
            
          
          
            
          
        
        
          let str = "stringify";
alert( str.substr(-4, 2) ); // gi, desde la 4ta posición toma 2 caracteres
        
      
      
      

Recapitulemos los métodos para evitar confusiones:



método
selecciona…
negativos




slice(comienzo, final)
desde comienzo hasta final (sin incluir final)
permite negativos


substring(comienzo, final)
entre comienzo y final
valores negativos significan 0


substr(comienzo, largo)
desde comienzo toma largo caracteres
permite negativos comienzo




            ¿Cuál elegir?
            Todos son capaces de hacer el trabajo. Formalmente, substr tiene una pequeña desventaja: no es descrito en la especificación central de JavaScript, sino en el anexo B, el cual cubre características sólo de navegadores, que existen principalmente por razones históricas. Por lo que entornos sin navegador pueden fallar en compatibilidad. Pero en la práctica funciona en todos lados.
De las otras dos variantes, slice es algo más flexible, permite argumentos negativos y es más corta. Entones, es suficiente con, de estos tres métodos, recordar únicamente slice.

Comparando stringsComo sabemos desde el capítulo Comparaciones, strings son comparados carácter por carácter en orden alfabético.
Aunque existen algunas singularidades.


Una letra minúscula es siempre mayor que una mayúscula:

      
        
        
          
            
          
          
            
          
        
        
          alert('a' > 'Z'); // true
        
      
      
      

Letras con marcas diacríticas están “fuera de orden”:

      
        
        
          
            
          
          
            
          
        
        
          alert('Österreich' > 'Zealand'); // true
        
      
      
      Esto puede conducir a resultados extraños si clasificamos los nombres de estos países. Usualmente, la gente esperaría que Zealand apareciera después de Österreich en la lista.


Para entender qué pasa, revisemos la representación interna de strings en JavaScript.
Todos los strings son codificados usando UTF-16. Esto significa: cada carácter tiene un código numérico correspondiente. Existen métodos especiales que permiten obtener el carácter para el código y viceversa.

str.codePointAt(pos)

Retorna el código para el carácter en la posición pos:

      
        
        
          
            
          
          
            
          
        
        
          // mayúsculas y minúsculas tienen códigos diferentes
alert( "z".codePointAt(0) ); // 122
alert( "Z".codePointAt(0) ); // 90
        
      
      
      
String.fromCodePoint(code)

Crea un carácter por su código numérico:

      
        
        
          
            
          
          
            
          
        
        
          alert( String.fromCodePoint(90) ); // Z
        
      
      
      También podemos agregar caracteres unicode por sus códigos usando \u seguido de un código hex:

      
        
        
          
            
          
          
            
          
        
        
          // 90 es 5a en el sistema hexadecimal
alert( '\u005a' ); // Z
        
      
      
      

Ahora veamos los caracteres con códigos 65..220 (el alfabeto latín y unos extras) haciendo de ellos un string:

      
        
        
          
            
          
          
            
          
        
        
          let str = '';

for (let i = 65; i <= 220; i++) {
  str += String.fromCodePoint(i);
}
alert(str);
// ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
// ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜ
        
      
      
      ¿Lo ves? Caracteres capitalizados (mayúsculas) van primero, luego unos cuantos caracteres especiales, luego las minúsculas.
Ahora se vuelve obvio por qué a > Z.
Los caracteres son comparados por su código numérico. Código mayor significa que el carácter es mayor. El código para a (97) es mayor que el código para Z (90).

Todas las letras minúsculas van después de las mayúsculas ya que sus códigos son mayores.
Algunas letras como Ö se mantienen apartadas del alfabeto principal. Aquí el código es mayor que cualquiera desde a hasta z.

Comparaciones correctasEl algoritmo “correcto” para realizar comparaciones de strings es más complejo de lo que parece, debido a que los alfabetos son diferentes para diferentes lenguajes. Una letra que se ve igual en dos alfabetos distintos, pueden tener distintas posiciones.
Por lo que el navegador necesita saber el lenguaje para comparar.
Por suerte, todos los navegadores modernos (IE10- requiere adicionalmente la biblioteca Intl.JS) mantienen la internacionalización del estándar ECMA 402.
Este provee un método especial para comparar strings en distintos lenguajes, siguiendo sus reglas.
El llamado str.localeCompare(str2):

Retorna 1 si str es mayor que str2 de acuerdo a las reglas del lenguaje.
Retorna -1 si str es menor que str2.
Retorna 0 si son iguales.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert('Österreich'.localeCompare('Zealand')); // -1
        
      
      
      Este método tiene dos argumentos adicionales especificados en la documentación, la cual le permite especificar el lenguaje (por defecto lo toma del entorno) y configura reglas adicionales como sensibilidad a las mayúsculas y minúsculas o si debe "a" y "á" ser tratadas como iguales, etc.
Internals, Unicode
            Conocimiento avanzado
            Esta sección ahonda en string internals. Este conocimiento será útil para ti si planeas lidiar con emoticones, raros caracteres matemáticos, jeroglíficos u otros símbolos extraños.
Puedes saltar esta sección si no planeas mantenerlos.

Pares sustitutosLa mayoría de los símbolos tienen código de 2 bytes. Las letras de la mayoría de los lenguajes europeos, números e incluso los jeroglíficos más importantes, tienen una representación de 2 bytes.
Pero 2 bytes sólo permiten 65536 combinaciones y eso no es suficiente para todos los símbolos posibles. Símbolos muy raros son codificados con un par de caracteres de 2 bytes llamados “pares sustitutos”.
El largo de dichos símbolos es 2:

      
        
        
          
            
          
          
            
          
        
        
          alert('𝒳'.length); // 2, LETRA CURSIVA MATEMÁTICA X CAPITALIZADA
alert('😂'.length); // 2, EMOTICÓN CON LÁGRIMAS DE ALEGRÍA
alert('𩷶'.length); // 2, un raro jeroglífico chino
        
      
      
      Notar que los pares sustitutos no existían en el tiempo que JavaScript fue creado, y por ello no son procesados correctamente por el lenguaje!
De hecho, tenemos un solo símbolo en cada string más arriba, pero el length (largo) muestra 2.
String.fromCodePoint y str.codePointAt son algunos métodos extraños que tratan con pares sustitutos. Aparecieron recientemente en el lenguaje. Antes de ellos, existían sólo String.fromCharCode y str.charCodeAt. Estos métodos son actualmente lo mismo que fromCodePoint/codePointAt, pero no funcionan con pares sustitutos.
Obtener un símbolo puede ser difícil, ya que los pares substitutos son tratados como dos caracteres:

      
        
        
          
            
          
          
            
          
        
        
          alert('𝒳'[0]); // símbolo extraño...
alert('𝒳'[1]); // ...piezas del par sustituto
        
      
      
      Notar que piezas del par sustituto no tienen significado sin las otras. Por lo que la alerta en el ejemplo anterior despliega garabatos.
Técnicamente, pares sustitutos son también detectables por su propio código: si un carácter tiene código en el intervalo de 0xd800..0xdbff, entonces es la primera parte de un par sustituto. El siguiente carácter (segunda parte) debe tener el código en el intervalo 0xdc00..0xdfff. Estos intervalos son reservados exclusivamente para pares sustitutos por el estándar.
En el caso de arriba:

      
        
        
          
            
          
          
            
          
        
        
          // charCodeAt no es consciente de pares sustitutos, por lo que entrega código por partes

alert('𝒳'.charCodeAt(0).toString(16)); // d835, entre 0xd800 y 0xdbff
alert('𝒳'.charCodeAt(1).toString(16)); // dcb3, entre 0xdc00 y 0xdfff
        
      
      
      Encontrarás más formas de trabajar con pares sustitutos más adelante en el capítulo Iterables. Probablemente hay bibliotecas especiales para eso también, pero nada lo suficientemente famoso como para sugerirlo aquí.
Marcas diacríticas y normalizaciónEn muchos idiomas hay símbolos compuestos, con un carácter de base y una marca arriba o debajo.
Por ejemplo, la letra a puede ser el carácter base para:àáâäãåā. Los caracteres “compuestos” más comunes tienen su propio código en la tabla UTF-16. Pero no todos ellos, porque hay demasiadas combinaciones posibles.
Para mantener composiciones arbitrarias, UTF-16 nos permite usar varios caracteres Unicode. El carácter base y uno o varios caracteres de “marca” que lo “decoran”.
Por ejemplo, si tenemos S seguido del carácter especial" punto arriba "(código\ u0307), se muestra como Ṡ.

      
        
        
          
            
          
          
            
          
        
        
          alert('S\u0307'); // Ṡ
        
      
      
      Si necesitamos una marca adicional sobre la letra (o debajo de ella), no hay problema, simplemente agrega el carácter de marca necesario.
Por ejemplo, si agregamos un carácter “punto debajo” (código \u0323), entonces tendremos" S con puntos arriba y abajo ": Ṩ.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert('S\u0307\u0323'); // Ṩ
        
      
      
      Esto proporciona una gran flexibilidad, pero también un problema interesante: dos caracteres pueden ser visualmente iguales, pero estar representados con diferentes composiciones Unicode.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let s1 = 'S\u0307\u0323'; // Ṩ, S + punto arriba + punto debajo
let s2 = 'S\u0323\u0307'; // Ṩ, S + punto debajo + punto arriba

alert( `s1: ${s1}, s2: ${s2}` );

alert( s1 == s2 ); // false aunque los caracteres se ven idénticos (?!)
        
      
      
      Para resolver esto, existe un algoritmo de “normalización Unicode” que lleva cada cadena a la forma “normal”.
Este es implementado por str.normalize().

      
        
        
          
            
          
          
            
          
        
        
          alert('S\u0307\u0323'.normalize() == 'S\u0323\u0307'.normalize()); // true
        
      
      
      Es curioso que en esta situación normalize () realmente reúna una secuencia de 3 caracteres en uno: \u1e68 (S con dos puntos).

      
        
        
          
            
          
          
            
          
        
        
          alert('S\u0307\u0323'.normalize().length); // 1

alert('S\u0307\u0323'.normalize() == '\u1e68'); // true
        
      
      
      En realidad, este no es siempre el caso. La razón es que el símbolo Ṩ es “bastante común”, por lo que los creadores de UTF-16 lo incluyeron en la tabla principal y le dieron el código.
Si desea obtener más información sobre las reglas y variantes de normalización, se describen en el apéndice del estándar Unicode: Formas de normalización Unicode, pero para la mayoría de los propósitos prácticos, la información de esta sección es suficiente.
Resumen
Existen 3 tipos de entrecomillado. Los backticks permiten que una cadena abarque varias líneas e incorporar expresiones ${…}.
Strings en JavaScript son codificados usando UTF-16.
Podemos usar caracteres especiales como \n e insertar letras por su código único usando \u ....
Para obtener un carácter, usa: [].
Para obtener un substring, usa: slice o substring.
Para convertir un string en minúsculas/mayúsculas, usa: toLowerCase/toUpperCase.
Para buscar por un substring, usa: indexOf, o includes/startsWith/endsWith para chequeos simples.
Para comparar strings de acuerdo al lenguaje, usa: localeCompare, de otra manera serán comparados como códigos de carácter.

Existen varios otros métodos útiles en cadenas:

str.trim() – remueve (“recorta”) espacios desde el comienzo y final de un string.
str.repeat(n) – repite el string n veces.
…y más. Mira el manual para más detalles.

Strings también tienen métodos con expresiones regulares para buscar/reemplazar. Es un tema importante, así que es explicado en su propia sección Expresiones Regulares .
TareasHacer mayúscula el primer carácterimportancia: 5Escribe una función ucFirst(str) que devuelva el string str con el primer carácter en mayúscula, por ejemplo:

      
        
        
          ucFirst("john") == "John";
        
      
      
      Abrir en entorno controlado con pruebas.soluciónNo podemos “reemplazar” el primer carácter, debido a que los strings en JavaScript son inmutables.
Pero podemos hacer un nuevo string basado en el existente, con el primer carácter en mayúsculas:

      
        
        
          let newStr = str[0].toUpperCase() + str.slice(1);
        
      
      
      Sin embargo, hay un pequeño problema. Si str está vacío, entonces str[0] es undefined, y como  undefined no tiene  el método toUpperCase(), obtendremos un error.
Existen dos variantes:

Usar str.charAt(0), ya que siempre devuelve una cadena (tal vez vacía).
Agregar una prueba para un string vacío.

Aquí está la segunda variante:

      
        
        
          
            
          
          
            
          
        
        
          function ucFirst(str) {
  if (!str) return str;

  return str[0].toUpperCase() + str.slice(1);
}

alert( ucFirst("john") ); // John
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Buscar spamimportancia: 5Escribe una función checkSpam(str) que devuelva true si str contiene ‘viagra’ o ‘XXX’, de lo contrario false.
La función debe ser insensible a mayúsculas y minúsculas:

      
        
        
          checkSpam('compra ViAgRA ahora') == true
checkSpam('xxxxx gratis') == true
checkSpam("coneja inocente") == false
        
      
      
      Abrir en entorno controlado con pruebas.soluciónPara que la búsqueda no distinga entre mayúsculas y minúsculas, llevemos el string a minúsculas y luego busquemos:

      
        
        
          
            
          
          
            
          
        
        
          function checkSpam(str) {
  let lowerStr = str.toLowerCase();

  return lowerStr.includes('viagra') || lowerStr.includes('xxx');
}

alert( checkSpam('compra ViAgRA ahora') );
alert( checkSpam('xxxxx gratis') );
alert( checkSpam("coneja inocente") );
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Truncar el textoimportancia: 5Crea una función truncate(str, maxlength) que verifique la longitud de str y, si excede maxlength – reemplaza el final de str con el carácter de puntos suspensivos "…", para hacer su longitud igual a maxlength.
El resultado de la función debe ser la cadena truncada (si es necesario).
Por ejemplo:

      
        
        
          truncate("Lo que me gustaría contar sobre este tema es:", 20) = "Lo que me gustaría c…"

truncate("Hola a todos!", 20) = "Hola a todos!"
        
      
      
      Abrir en entorno controlado con pruebas.soluciónLa longitud máxima debe ser ‘maxlength’, por lo que debemos acortarla un poco para dar espacio a los puntos suspensivos.
Tener en cuenta que en realidad hay un único carácter unicode para puntos suspensivos. Eso no son tres puntos.

      
        
        
          
            
          
          
            
          
        
        
          function truncate(str, maxlength) {
  return (str.length > maxlength) ?
    str.slice(0, maxlength - 1) + '…' : str;
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Extraer el dineroimportancia: 4Tenemos un costo en forma de “$120”. Es decir: el signo de dólar va primero y luego el número.
Crea una función extractCurrencyValue(str) que extraiga el valor numérico de dicho string y lo devuelva.
Por ejemplo:

      
        
        
          alert( extractCurrencyValue('$120') === 120 ); // true
        
      
      
      Abrir en entorno controlado con pruebas.solución
      
        
        
          function extractCurrencyValue(str) {
  return +str.slice(1);
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/string" 
},
{
	"docs_id": "41",
	"name": "Arrays",
	"description": "Los objetos te permiten almacenar colecciones de datos a través de nombres. Eso está bien.",
	"content": "Los objetos te permiten almacenar colecciones de datos a través de nombres. Eso está bien.
Pero a menudo necesitamos una colección ordenada, donde tenemos un 1ro, un 2do, un 3er elemento y así sucesivamente. Por ejemplo, necesitamos almacenar una lista de algo: usuarios, bienes, elementos HTML, etc.
No es conveniente usar objetos aquí, porque no proveen métodos para manejar el orden de los elementos. No podemos insertar una nueva propiedad “entre” los existentes. Los objetos no están hechos para eso.
Existe una estructura llamada Array (llamada en español arreglo o matriz/vector) para almacenar colecciones ordenadas.
DeclaraciónHay dos sintaxis para crear un array vacío:

      
        
        
          let arr = new Array();
let arr = [];
        
      
      
      Casi siempre se usa la segunda. Podemos suministrar elementos iniciales entre los corchetes:

      
        
        
          let fruits = ["Apple", "Orange", "Plum"];
        
      
      
      Los elementos del array están numerados comenzando desde cero.
Podemos obtener un elemento por su número entre corchetes:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[0] ); // Apple
alert( fruits[1] ); // Orange
alert( fruits[2] ); // Plum
        
      
      
      Podemos reemplazar un elemento:

      
        
        
          fruits[2] = 'Pear'; // ahora ["Apple", "Orange", "Pear"]
        
      
      
      …o agregar uno nuevo al array:

      
        
        
          fruits[3] = 'Lemon'; // ahora ["Apple", "Orange", "Pear", "Lemon"]
        
      
      
      La cuenta total de elementos en el array es su longitud length:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits.length ); // 3
        
      
      
      También podemos usar alert para mostrar el array completo.

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits ); // Apple,Orange,Plum
        
      
      
      Un array puede almacenar elementos de cualquier tipo.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // mezcla de valores
let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ];

// obtener el objeto del índice 1 y mostrar su nombre
alert( arr[1].name ); // John

// obtener la función del índice 3 y ejecutarla
arr[3](); // hello
        
      
      
      
            Coma residual
            Un array, al igual que un objeto, puede tener una coma final:

      
        
        
          let fruits = [
  "Apple",
  "Orange",
  "Plum",
];
        
      
      
      La “coma final” hace más simple insertar y remover items, porque todas la líneas se vuelven similares.

Obtener los últimos elementos con “at”
            Una adición reciente
            
            Esta es una adición reciente al lenguaje.
            Los navegadores antiguos pueden necesitar polyfills.
            
Digamos que queremos el último elemento de un array.
Algunos lenguajes de programación permiten el uso de índices negativos para este propósito, como fruits[-1].
Aunque en JavaScript esto no funcionará. El resultado será undefined, porque el índice de los corchetes es tratado literalmente.
Podemos calcular explícitamente el último índice y luego acceder al elemento: fruits[fruits.length - 1].

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

alert( fruits[fruits.length-1] ); // Plum
        
      
      
      Un poco engorroso, ¿no es cierto? Necesitamos escribir el nombre de la variable dos veces.
Afortunadamente, hay una sintaxis más corta: fruits.at(-1):

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

// es lo mismo que fruits[fruits.length-1]
alert( fruits.at(-1) ); // Plum
        
      
      
      En otras palabras, arr.at(i):

es exactamente lo mismo que arr[i], si i >= 0.
para valores negativos de i, salta hacia atrás desde el final del array.

Métodos pop/push, shift/unshiftUna cola es uno de los usos más comunes de un array. En ciencias de la computación, significa una colección ordenada de elementos que soportan dos operaciones:

push inserta un elemento al final.
shift obtiene el elemento del principio, avanzando la cola, y así el segundo elemento se vuelve primero.


      
      
        
      
      Los arrays soportan ambas operaciones.
En la práctica los necesitamos muy a menudo. Por ejemplo, una cola de mensajes que necesitamos mostrar en pantalla.
Hay otro caso de uso para los arrays – la estructura de datos llamada pila.
Ella soporta dos operaciones:

push agrega un elemento al final.
pop toma un elemento desde el final.

Entonces los elementos nuevos son agregados o tomados siempre desde el “final”.
Una pila es usualmente mostrada como un mazo de cartas, donde las nuevas cartas son agregadas al tope o tomadas desde el tope:

      
      
        
      
      Para las pilas, la última introducida es la primera en ser recibida, en inglés esto es llamado principio LIFO (Last-In-First-Out, última en entrar primera en salir). Para las colas, tenemos FIFO (First-In-First-Out primera en entrar, primera en salir).
Los arrays en JavaScript pueden trabajar como colas o pilas. Ellos permiten agregar/quitar elementos al/del principio o al/del final.
En ciencias de la computación, la estructura de datos que permite esto se denomina cola de doble extremo o bicola.
Métodos que trabajan sobre el final del array:

pop

Extrae el último elemento del array y lo devuelve:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.pop() ); // quita "Pear" y lo muestra en un alert

alert( fruits ); // Apple, Orange
        
      
      
      Tanto fruits.pop() como fruits.at(-1) devuelven el último elemento del array, pero fruits.pop() también modifica el array eliminando tal elemento.

push

Agrega el elemento al final del array:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange"];

fruits.push("Pear");

alert( fruits ); // Apple, Orange, Pear
        
      
      
      El llamado a fruits.push(...) es igual a fruits[fruits.length] = ....


Métodos que trabajan con el principio del array:

shift

Extrae el primer elemento del array y lo devuelve:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Pear"];

alert( fruits.shift() ); // quita Apple y lo muestra en un alert

alert( fruits ); // Orange, Pear
        
      
      
      
unshift

Agrega el elemento al principio del array:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Orange", "Pear"];

fruits.unshift('Apple');

alert( fruits ); // Apple, Orange, Pear
        
      
      
      

Los métodos push y unshift pueden agregar múltiples elementos de una vez:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple"];

fruits.push("Orange", "Peach");
fruits.unshift("Pineapple", "Lemon");

// ["Pineapple", "Lemon", "Apple", "Orange", "Peach"]
alert( fruits );
        
      
      
      InterioresUn array es una clase especial de objeto. Los corchetes usados para acceder a una propiedad arr[0] vienen de la sintaxis de objeto. Son esencialmente lo mismo que obj[key], donde arr es el objeto mientras los números son usados como claves.
Ellos extienden los objetos proveyendo métodos especiales para trabajar con colecciones ordenadas de datos y también la propiedad length. Pero en el corazón es aún un objeto.
Recuerde, solo hay ocho tipos de datos básicos en JavaScript (consulte el capítulo Tipos de datos para obtener más información). Array es un objeto y, por tanto, se comporta como un objeto.
Por ejemplo, es copiado por referencia:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Banana"]

let arr = fruits; // copiado por referencia (dos variables referencian al mismo array)

alert( arr === fruits ); // true

arr.push("Pear"); // modifica el array por referencia

alert( fruits ); // Banana, Pear - ahora con 2 items
        
      
      
      …Pero lo que hace a los array realmente especiales es su representación interna. El motor trata de almacenarlos en áreas de memoria contigua, uno tras otro, justo como muestra la ilustración en este capítulo. Hay otras optimizaciones también para hacer que los arrays trabajen verdaderamente rápido.
Pero todo esto se puede malograr si dejamos de trabajarlos como arrays de colecciones ordenadas y comenzamos a usarlos como si fueran objetos comunes.
Por ejemplo, técnicamente podemos hacer esto:

      
        
        
          let fruits = []; // crea un array

fruits[99999] = 5; // asigna una propiedad con un índice mucho mayor que su longitud

fruits.age = 25; // crea una propiedad con un nombre arbitrario
        
      
      
      Esto es posible porque los arrays son objetos en su base. Podemos agregar cualquier propiedad en ellos.
Pero el motor verá que estamos tratándolo como un objeto común. Las optimizaciones específicas no son aptas para tales casos y serán desechadas, y sus beneficios desaparecerán.
Las formas de malograr un array:

Agregar una propiedad no numérica como arr.test = 5.
Generar agujeros como: agregar arr[0] y luego arr[1000] (y nada entre ellos).
Llenar el array en orden inverso, como arr[1000], arr[999] y así.

Piensa en los arrays como estructuras especiales para trabajar con datos ordenados. Ellos proveen métodos especiales para ello. Los arrays están cuidadosamente afinados dentro de los motores JavaScript para funcionar con datos ordenados contiguos, por favor úsalos de esa manera. Y si necesitas claves arbitrarias, hay altas chances de que en realidad necesites objetos comunes {}.
PerformanceLos métodos push/pop son rápidos, mientras que shift/unshift son lentos.

      
      
        
      
      ¿Por qué es más rápido trabajar con el final del array que con el principio? Veamos qué pasa durante la ejecución:

      
        
        
          fruits.shift(); // toma 1 elemento del principio
        
      
      
      No es suficiente tomar y eliminar el elemento con el índice 0. Los demás elementos necesitan ser renumerados también.
La operación shift debe hacer 3 cosas:

Remover el elemento con índice 0.
Mover todos lo elementos hacia la izquierda y renumerarlos: desde el índice 1 a 0, de 2 a 1 y así sucesivamente.
Actualizar la longitud: la propiedad length.


      
      
        
      
      Cuanto más elementos haya en el array, más tiempo tomará moverlos, más operaciones en memoria.
Algo similar ocurre con unshift: para agregar un elemento al principio del array, necesitamos primero mover todos los elementos hacia la derecha, incrementando sus índices.
¿Y qué pasa con push/pop? Ellos no necesitan mover nada. Para extraer un elemento del final, el método pop limpia el índice y acorta length.
Las acciones para la operación pop:

      
        
        
          fruits.pop(); // toma 1 elemento del final
        
      
      
      
      
      
        
      
      El método pop no necesita mover nada, porque los demás elementos mantienen sus índices. Es por ello que es muy rápido.
Algo similar ocurre con el método push.
BuclesUna de las formas más viejas de iterar los items de un array es el bucle for sobre sus índices:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Apple", "Orange", "Pear"];

for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}
        
      
      
      Pero para los arrays también hay otra forma de bucle,for..of:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apple", "Orange", "Plum"];

// itera sobre los elementos del array
for (let fruit of fruits) {
  alert( fruit );
}
        
      
      
      for..of no da acceso al número del elemento en curso, solamente a su valor, pero en la mayoría de los casos eso es suficiente. Y es más corto.
Técnicamente, y porque los arrays son objetos, es también posible usar for..in:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Apple", "Orange", "Pear"];

for (let key in arr) {
  alert( arr[key] ); // Apple, Orange, Pear
}
        
      
      
      Pero es una mala idea. Existen problemas potenciales con esto:


El bucle for..in itera sobre todas las propiedades, no solo las numéricas.
Existen objetos “simil-array” en el navegador y otros ambientes que parecen arrays. Esto es, tienen length y propiedades indexadas, pero pueden también tener propiedades no numéricas y métodos que usualmente no necesitemos. Y el bucle for..in los listará. Entonces si necesitamos trabajar con objetos simil-array, estas propiedades “extras” pueden volverse un problema.


El bucle for..in está optimizado para objetos genéricos, no para arrays, y es de 10 a 100 veces más lento. Por supuesto es aún muy rápido. Una optimización puede que solo sea importante en cuellos de botella, pero necesitamos ser concientes de la diferencia.


En general, no deberíamos usar for..in en arrays.
Acerca de “length”La propiedad length automáticamente se actualiza cuando se modifica el array. Para ser precisos, no es la cuenta de valores del array sino el mayor índice más uno.
Por ejemplo, un elemento simple con un índice grande da una longitud grande:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = [];
fruits[123] = "Apple";

alert( fruits.length ); // 124
        
      
      
      Nota que usualmente no usamos arrays de este modo.
Otra cosa interesante acerca de la propiedad length es que se puede sobrescribir.
Si la incrementamos manualmente, nada interesante ocurre. Pero si la decrementamos, el array se trunca.  El proceso es irreversible, aquí el ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

arr.length = 2; // truncamos a 2 elementos
alert( arr ); // [1, 2]

arr.length = 5; // reponemos la longitud length
alert( arr[3] ); // undefined: el valor no se recupera
        
      
      
      Entonces la forma más simple de limpiar un array es: arr.length = 0;.
new Array()Hay una sintaxis más para crear un array:

      
        
        
          let arr = new Array("Apple", "Pear", "etc");
        
      
      
      Es raramente usada porque con corchetes [] es más corto. También hay una característica peculiar con ella.
Si new Array es llamado con un único argumento numérico, se crea un array sin items, pero con la longitud “length” dada.
Veamos cómo uno puede dispararse en el pie:

      
        
        
          
            
          
          
            
          
        
        
          let arr = new Array(2); // ¿Creará un array de [2]?

alert( arr[0] ); // undefined! sin elementos.

alert( arr.length ); // longitud 2
        
      
      
      Para evitar sorpresas solemos usar corchetes, salvo que sepamos lo que estamos haciendo.
Arrays multidimensionalesLos arrays pueden tener items que a su vez sean arrays. Podemos usarlos como arrays multidimensionales, por ejemplo para almacenar matrices:

      
        
        
          
            
          
          
            
          
        
        
          let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];

alert( matrix[1][1] ); // 5, el elemento central
        
      
      
      toStringLos arrays tienen su propia implementación del método toString que devuelve un lista de elementos separados por coma.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
        
      
      
      Probemos esto también:

      
        
        
          
            
          
          
            
          
        
        
          alert( [] + 1 ); // "1"
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
        
      
      
      Los arrays no tienen Symbol.toPrimitive ni un valueOf viable, ellos implementan la conversión toString solamente, así [] se vuelve una cadena vacía, [1] se vuelve "1" y [1,2] se vuelve "1,2".
Cuando el operador binario más "+" suma algo a una cadena, lo convierte a cadena también, entonces lo siguiente se ve así:

      
        
        
          
            
          
          
            
          
        
        
          alert( "" + 1 ); // "1"
alert( "1" + 1 ); // "11"
alert( "1,2" + 1 ); // "1,21"
        
      
      
      No compares arrays con ==Las arrays en JavaScript, a diferencia de otros lenguajes de programación, no deben ser comparadas con el operador ==.
Este operador no tiene un tratamiento especial para arrays, trabaja con ellas como con cualquier objeto.
Recordemos las reglas:

Dos objetos son iguales == solo si hacen referencia al mismo objeto.
Si uno de los argumentos de == es un objeto y el otro es un primitivo, entonces el objeto se convierte en primitivo, como se explica en el capítulo Conversión de objeto a valor primitivo.
…Con la excepción de null y undefined que son iguales == entre sí y nada más.

La comparación estricta === es aún más simple, ya que no convierte tipos.
Entonces, si comparamos arrays con ==, nunca son iguales, a no ser que comparemos dos variables que hacen referencia exactamente a la misma array.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( [] == [] ); // falso
alert( [0] == [0] ); // falso
        
      
      
      Estas arrays son técnicamente objetos diferentes. Así que no son iguales. El operador == no hace comparaciones de elemento a elemento.
Comparaciones con primitivos también pueden dar resultados aparentemente extraños:

      
        
        
          
            
          
          
            
          
        
        
          alert( 0 == [] ); // verdadero

alert('0' == [] ); // falso
        
      
      
      Aquí, en ambos casos, comparamos un primitivo con un objeto array. Entonces la array [] se convierte a primitivo para el propósito de comparar y se convierte en una string vacía ''.
Luego el proceso de comparación continúa con los primitivos, como se describe en el capítulo Conversiones de Tipos:

      
        
        
          
            
          
          
            
          
        
        
          // después de que [] se convierta en ''
alert( 0 == '' ); // verdadero, ya que '' se convierte en el número 0

alert('0' == '' ); // falso, sin conversión de tipos, strings diferentes
        
      
      
      Entonces, ¿cómo comparamos arrays?
Simple: no utilices el operador ==. En lugar, compáralas elemento a elemento en un bucle o utilizando métodos de iteración explicados en el siguiente capítulo.
ResumenLos arrays son una clase especial de objeto, adecuados para almacenar y manejar items de datos ordenados.
La declaración:

      
        
        
          // corchetes (lo usual)
let arr = [item1, item2...];

// new Array (excepcionalmente raro)
let arr = new Array(item1, item2...);
        
      
      
      El llamado a new Array(number) crea un array con la longitud dada, pero sin elementos.

La propiedad length es la longitud del array o, para ser preciso, el último índice numérico más uno. Se autoajusta al usar los métodos de array.
Si acortamos length manualmente, el array se trunca.

Obtener los elementos:

Podemos obtener un elemento por su índice, como arr[0]
También podemos usar el método at(i), que permite índices negativos. Para valores negativos de i, cuenta hacia atrás desde el final del array. Cuando i >= 0, funciona igual que arr[i].

Podemos usar un array como una pila “deque” o “bicola” con las siguientes operaciones:

push(...items) agrega items al final.
pop() remueve el elemento del final y lo devuelve.
shift() remueve el elemento del principio y lo devuelve.
unshift(...items) agrega items al principio.

Para iterar sobre los elementos de un array:

for (let i=0; i<arr.length; i++) – lo más rápido, compatible con viejos navegadores.
for (let item of arr) – la sintaxis moderna para items solamente.
for (let i in arr) – nunca lo uses.

Para comparar arrays, no uses el operador == (como tampoco >, < y otros), ya que no tienen un tratamiento especial para arrays. Lo manejan como cualquier objeto y no es lo que normalmente queremos.
En su lugar puedes utilizar el bucle for..of para comparar arrays elemento a elemento.
Volveremos a los arrays y estudiaremos más métodos para agregar, quitar, extraer elementos y ordenar arrays en el capítulo Métodos de arrays.
Tareas¿El array es copiado?importancia: 3¿Qué va a mostrar este código?

      
        
        
          let fruits = ["Apples", "Pear", "Orange"];

// introduce un valor nuevo dentro de una copia
let shoppingCart = fruits;
shoppingCart.push("Banana");

// ¿Qué hay en "fruits"?
alert( fruits.length ); // ¿?
        
      
      
      soluciónEl resultado es 4:

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ["Apples", "Pear", "Orange"];

let shoppingCart = fruits;

shoppingCart.push("Banana");

alert( fruits.length ); // 4
        
      
      
      Esto es porque los arrays son objetos. Entonces ambos, shoppingCart y fruits son referencias al mismo array.
Operaciones en arrays.importancia: 5Tratemos 5 operaciones de array.

Crear un array styles con los items “Jazz” y “Blues”.
Agregar “Rock-n-Roll” al final.
Reemplazar el valor en el medio por “Classics”. Tu código para encontrar el valor medio debe funcionar con cualquier array de longitud impar.
Quitar el primer valor del array y mostrarlo.
Anteponer Rap y Reggae al array.

El array durante el proceso:

      
        
        
          Jazz, Blues
Jazz, Blues, Rock-n-Roll
Jazz, Classics, Rock-n-Roll
Classics, Rock-n-Roll
Rap, Reggae, Classics, Rock-n-Roll
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          let styles = ["Jazz", "Blues"];
styles.push("Rock-n-Roll");
styles[Math.floor((styles.length - 1) / 2)] = "Classics";
alert( styles.shift() );
styles.unshift("Rap", "Reggae");
        
      
      
      LLamados en un contexto de arrayimportancia: 5¿Cuál es el resultado y por qué?

      
        
        
          let arr = ["a", "b"];

arr.push(function() {
  alert( this );
});

arr[2](); // ?
        
      
      
      soluciónEl llamado a arr[2]() es sintácticamente el buen y viejo obj[method](), en el rol de obj tenemos arr, y en el rol de method tenemos 2.
Entonces tenemos una llamada a función arr[2] como un método de objeto. Naturalmente, recibe this referenciando el objeto arr y su salida es el array:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["a", "b"];

arr.push(function() {
  alert( this );
})

arr[2](); // a,b,function(){...}
        
      
      
      El array tiene 3 valores: Inicialmente tenía 2 y se agregó la función.
Suma de números ingresadosimportancia: 4Escribe una función sumInput() que:

Pida al usuario valores usando prompt y los almacene en el array.
Termine de pedirlos cuando el usuario ingrese un valor no numérico, una cadena vacía, o presione “Escape”.
Calcule y devuelva la suma de los items del array.

P.D. Un cero 0 es un número válido, por favor no detengas los ingresos con el cero.
Ejecutar el demosoluciónToma nota del sutil pero importante detalle de la solución. No convertimos value a número instantáneamente después de prompt, porque después de value = +value no seríamos capaces de diferenciar una cadena vacía (señal de detención) de un cero (un número válido). Lo hacemos más adelante.

      
        
        
          
            
          
          
            
          
        
        
          function sumInput() {

  let numbers = [];

  while (true) {

    let value = prompt("Un número, por favor...", 0);

    // ¿Debemos cancelar?
    if (value === "" || value === null || !isFinite(value)) break;

    numbers.push(+value);
  }

  let sum = 0;
  for (let number of numbers) {
    sum += number;
  }
  return sum;
}

alert( sumInput() );
        
      
      
      Subarray máximoimportancia: 2La entrada es un array de números, por ejemplo arr = [1, -2, 3, 4, -9, 6].
La tarea es: encuentra el subarray contiguo de items de arr con la suma máxima.
Escribe la función getMaxSubSum(arr) que devuelva tal sumo.
Por ejemplo:

      
        
        
          getMaxSubSum([-1, 2, 3, -9]) == 5 (la suma de items resaltados)
getMaxSubSum([2, -1, 2, 3, -9]) == 6
getMaxSubSum([-1, 2, 3, -9, 11]) == 11
getMaxSubSum([-2, -1, 1, 2]) == 3
getMaxSubSum([100, -9, 2, -3, 5]) == 100
getMaxSubSum([1, 2, 3]) == 6 (toma todo)
        
      
      
      Si todos los elementos son negativos, significa que que no tomamos ninguno (el subarray está vacío), entonces la suma es cero:

      
        
        
          getMaxSubSum([-1, -2, -3]) = 0
        
      
      
      Trata de pensar un solución rápida: O(n2) o incluso O(n) si puedes.
Abrir en entorno controlado con pruebas.soluciónSolución lentaSolución lentaPodemos calcular todas las subsumas.
La forma más simple es tomar cada elemento y calcular las sumas de todos los subarrays que comienzan con él.
Por ejemplo, para [-1, 2, 3, -9, 11]:

      
        
        
          // Comenzando desde -1:
-1
-1 + 2
-1 + 2 + 3
-1 + 2 + 3 + (-9)
-1 + 2 + 3 + (-9) + 11

// Comenzando desde 2:
2
2 + 3
2 + 3 + (-9)
2 + 3 + (-9) + 11

// Comenzando desde 3:
3
3 + (-9)
3 + (-9) + 11

// Comenzando desde -9
-9
-9 + 11

// Comenzando desde 11
11
        
      
      
      El código es un bucle anidado. El bucle externo itera sobre los elementos del array, y el interno cuenta subsumas comenzando con cada uno de ellos.

      
        
        
          
            
          
          
            
          
        
        
          function getMaxSubSum(arr) {
  let maxSum = 0; // si no obtenemos elementos, devolverá cero

  for (let i = 0; i < arr.length; i++) {
    let sumFixedStart = 0;
    for (let j = i; j < arr.length; j++) {
      sumFixedStart += arr[j];
      maxSum = Math.max(maxSum, sumFixedStart);
    }
  }

  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
        
      
      
      La solución tiene una complejidad 2 en notación Landau O(n2) (coste respecto al tiempo). Es decir, si multiplicamos el tamaño del array por 2, el tiempo del algoritmo se multiplicará por 4.
Para arrays muy grandes (1000, 10000 o más items) tales algoritmos llevarán a una severa lentitud.
Solución rápidaSolución rápidaRecorramos el array y registremos la suma parcial actual de los elementos en la variable s. Si s se vuelve cero en algún punto, le asignamos s=0. El máximo entre todas las sumas parciales s será la respuesta.
Si la descripción te resulta demasiado vaga, por favor mira el código. Es bastante corto:

      
        
        
          
            
          
          
            
          
        
        
          function getMaxSubSum(arr) {
  let maxSum = 0;
  let partialSum = 0;

  for (let item of arr) { // por cada item de arr
    partialSum += item; // se lo suma a partialSum
    maxSum = Math.max(maxSum, partialSum); // registra el máximo
    if (partialSum < 0) partialSum = 0; // cero si se vuelve negativo
  }

  return maxSum;
}

alert( getMaxSubSum([-1, 2, 3, -9]) ); // 5
alert( getMaxSubSum([-1, 2, 3, -9, 11]) ); // 11
alert( getMaxSubSum([-2, -1, 1, 2]) ); // 3
alert( getMaxSubSum([100, -9, 2, -3, 5]) ); // 100
alert( getMaxSubSum([1, 2, 3]) ); // 6
alert( getMaxSubSum([-1, -2, -3]) ); // 0
        
      
      
      El algoritmo requiere exactamente una pasada, entonces la complejidad es O(n).
Puedes encontrar información detallada acerca del algoritmo: Subvector de suma máxima. Si aún no es obvio cómo funciona, traza el algoritmo en los ejemplos de arriba y observa cómo trabaja, es mejor que cualquier explicación.
Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/array" 
},
{
	"docs_id": "42",
	"name": "Métodos de arrays",
	"description": "Los arrays (también llamados arreglos o matrices) cuentan con muchos métodos. Para hacer las cosas más sencillas, en este capítulo se encuentran divididos en dos partes.",
	"content": "Los arrays (también llamados arreglos o matrices) cuentan con muchos métodos. Para hacer las cosas más sencillas, en este capítulo se encuentran divididos en dos partes.
Agregar/remover ítemsYa conocemos algunos métodos que agregan o extraen elementos del inicio o final de un array:

arr.push(...items) – agrega ítems al final,
arr.pop() – extrae un ítem del final,
arr.shift() – extrae un ítem del inicio,
arr.unshift(...items) – agrega ítems al principio.

Veamos algunos métodos más.
splice¿Cómo podemos borrar un elemento de un array?
Los arrays son objetos, por lo que podemos intentar con delete:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["voy", "a", "casa"];

delete arr[1]; // remueve "a"

alert( arr[1] ); // undefined

// ahora arr = ["voy",  , "casa"];
alert( arr.length ); // 3
        
      
      
      El elemento fue borrado, pero el array todavía tiene 3 elementos; podemos ver que arr.length == 3.
Es natural, porque delete obj.key borra el valor de key, pero es todo lo que hace. Esto está bien en los objetos, pero en general lo que buscamos en los arrays es que el resto de los elementos se desplace y se ocupe el lugar libre. Lo que esperamos es un array más corto.
Por lo tanto, necesitamos utilizar métodos especiales.
El método arr.splice funciona como una navaja suiza para arrays. Puede hacer todo: insertar, remover y remplazar elementos.
La sintaxis es:

      
        
        
          arr.splice(start[, deleteCount, elem1, ..., elemN])
        
      
      
      Esto modifica arr comenzando en el índice start: remueve la cantidad deleteCount de elementos y luego inserta elem1, ..., elemN en su lugar. Lo que devuelve es un array de los elementos removidos.
Este método es más fácil de entender con ejemplos.
Empecemos removiendo elementos:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Yo", "estudio", "JavaScript"];

arr.splice(1, 1); // desde el índice 1, remover 1 elemento

alert( arr ); // ["Yo", "JavaScript"]
        
      
      
      ¿Fácil, no? Empezando desde el índice 1 removió 1 elemento.
En el próximo ejemplo removemos 3 elementos y los reemplazamos con otros 2:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Yo", "estudio", "JavaScript", "ahora", "mismo"];

// remueve los primeros 3 elementos y los reemplaza con otros
arr.splice(0, 3, "a", "bailar");

alert( arr ) // ahora ["a", "bailar", "ahora", "mismo"]
        
      
      
      Aquí podemos ver que splice devuelve un array con los elementos removidos:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Yo", "estudio", "JavaScript", "ahora", "mismo"];

// remueve los 2 primeros elementos
let removed = arr.splice(0, 2);

alert( removed ); // "Yo", "estudio" <-- array de los elementos removidos
        
      
      
      El método splice también es capaz de insertar elementos sin remover ningún otro. Para eso necesitamos establecer deleteCount en 0:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["Yo", "estudio", "JavaScript"];

// desde el index 2
// remover 0
// después insertar "el", "complejo" y "language"
arr.splice(2, 0,"el", "complejo", "language");

alert( arr ); // "Yo", "estudio","el", "complejo", "language", "JavaScript"
        
      
      
      
            Los índices negativos están permitidos
            En este y en otros métodos de arrays, los índices negativos están permitidos. Estos índices indican la posición comenzando desde el final del array, de la siguiente manera:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 5];

// desde el index -1 (un lugar desde el final)
// remover 0 elementos,
// después insertar 3 y 4
arr.splice(-1, 0, 3, 4);

alert( arr ); // 1,2,3,4,5
        
      
      
      
sliceEl método arr.slice es mucho más simple que arr.splice.
La sintaxis es:

      
        
        
          arr.slice([principio], [final])
        
      
      
      Devuelve un nuevo array copiando en el mismo todos los elementos desde principio hasta final (sin incluir final). principio y final pueden ser negativos, en cuyo caso se asume la posición desde el final del array.
Es similar al método para strings str.slice, pero en lugar de substrings genera subarrays.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ["t", "e", "s", "t"];

alert( arr.slice(1, 3) ); // e,s (copia desde 1 hasta 3)

alert( arr.slice(-2) ); // s,t (copia desde -2 hasta el final)
        
      
      
      También podemos invocarlo sin argumentos: arr.slice() crea una copia de arr. Se utiliza a menudo para obtener una copia que se puede  transformar sin afectar el array original.
concatEl método arr.concat crea un nuevo array que incluye los valores de otros arrays y elementos adicionales.
La sintaxis es:

      
        
        
          arr.concat(arg1, arg2...)
        
      
      
      Este acepta cualquier número de argumentos, tanto arrays como valores.
El resultado es un nuevo array conteniendo los elementos de arr, después arg1, arg2 etc.
Si un argumento argN es un array, entonces todos sus elementos son copiados. De otro modo el argumento en sí es copiado.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

// crea un array a partir de: arr y [3,4]
alert( arr.concat([3, 4]) ); // 1,2,3,4

// crea un array a partir de: arr y [3,4] y [5,6]
alert( arr.concat([3, 4], [5, 6]) ); // 1,2,3,4,5,6

// crea un array a partir de: arr y [3,4], luego agrega los valores 5 y 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
        
      
      
      Normalmente, solo copia elementos desde arrays. Otros objetos, incluso si parecen arrays, son agregados como un todo:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

let arrayLike = {
  0: "something",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
        
      
      
      …Pero si un objeto similar a un array tiene la propiedad especial Symbol.isConcatSpreadable, entonces concat lo trata como un array y en lugar de añadirlo como un todo, solo añade sus elementos.

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2];

let arrayLike = {
  0: "something",
  1: "else",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,something,else
        
      
      
      Iteración: forEachEl método arr.forEach permite ejecutar una función a cada elemento del array.
La sintaxis:

      
        
        
          arr.forEach(function(item, index, array) {
  // ... hacer algo con el elemento
});
        
      
      
      Por ejemplo, el siguiente código muestra cada elemento del array:

      
        
        
          
            
          
          
            
          
        
        
          // para cada elemento ejecuta alert
["Bilbo", "Gandalf", "Nazgul"].forEach(alert);
        
      
      
      Y este caso más detallado da la posición del elemento en el array:

      
        
        
          
            
          
          
            
          
        
        
          ["Bilbo", "Gandalf", "Nazgul"].forEach((item, index, array) => {
  alert(`${item} is at index ${index} in ${array}`);
});
        
      
      
      El resultado de la función (si lo hay) se descarta y se ignora.
Buscar dentro de un arrayAhora vamos a ver métodos que buscan elementos dentro de un array.
indexOf/lastIndexOf e includesLos métodos arr.indexOf y arr.includes tienen una sintaxis similar y hacen básicamente lo mismo que sus contrapartes de strings, pero operan sobre elementos en lugar de caracteres:

arr.indexOf(item, from) – busca item comenzando desde el index from, y devuelve el index donde fue encontrado, de otro modo devuelve -1.
arr.includes(item, from) – busca item comenzando desde el índice from, devuelve true en caso de ser encontrado.

Usualmente estos métodos se usan con un solo argumento: el item a buscar. De manera predeterminada, la búsqueda es desde el principio.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
        
      
      
      Tener en cuenta que el método usa la comparación estricta (===). Por lo tanto, si buscamos false, encontrará exactamente false y no cero.
Si queremos comprobar si un elemento existe en el array, pero no necesitamos saber su ubicación exacta, es preferible usar arr.includes
El método arr.lastIndexOf es lo mismo que indexOf, pero busca de derecha a izquierda.

      
        
        
          
            
          
          
            
          
        
        
          let fruits = ['Apple', 'Orange', 'Apple']

alert( arr.indexOf('Apple') ); // 0 (primera "Apple")
alert( arr.lastIndexOf('Apple') ); // 2 (última "Apple")
        
      
      
      
            El método includes maneja NaN correctamente
            Una característica menor pero notable de includes es que, a diferencia de indexOf, maneja correctamente NaN:

      
        
        
          
            
          
          
            
          
        
        
          const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (debería ser 0, pero la igualdad === no funciona para NaN)
alert( arr.includes(NaN) );// true (correcto)
        
      
      
      Esto es porque includes fue agregado mucho después y usa un algoritmo interno de comparación actualizado.

find y findIndex/findLastIndexImaginemos que tenemos un array de objetos. ¿Cómo podríamos encontrar un objeto con una condición específica?
Para este tipo de casos es útil el método arr.find(fn)
La sintaxis es:

      
        
        
          let result = arr.find(function(item, index, array) {
  // si true es devuelto aquí, find devuelve el ítem y la iteración se detiene
  // para el caso en que sea false, devuelve undefined
});
        
      
      
      La función es llamada para cada elemento del array, uno después del otro:

item es el elemento.
index es su índice.
array es el array mismo.

Si devuelve true, la búsqueda se detiene y el item es devuelto. Si no encuentra nada, entonces devuelve undefined.
Por ejemplo, si tenemos un array de usuarios, cada uno con los campos id y name. Encontremos el elemento con id == 1:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "Celina"},
  {id: 2, name: "David"},
  {id: 3, name: "Federico"}
];

let user = users.find(item => item.id == 1);

alert(user.name); // Celina
        
      
      
      En la vida real los arrays de objetos son bastante comunes por lo que el método find resulta muy útil.
Ten en cuenta que en el ejemplo anterior le pasamos a find la función item => item.id == 1 con un argumento. Esto es lo más común, otros argumentos son raramente usados en esta función.
El método arr.findIndex tiene la misma sintaxis, pero devuelve el índice donde el elemento fue encontrado en lugar del elemento en sí. Devuelve -1 cuando no lo encuentra.
El método arr.findLastIndex es como findIndex, pero busca de derecha a izquierda, similar a lastIndexOf.
Un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "John"},
  {id: 2, name: "Pete"},
  {id: 3, name: "Mary"},
  {id: 4, name: "John"}
];

// Encontrar el índice del primer John
alert(users.findIndex(user => user.name == 'John')); // 0

// Encontrar el índice del último John
alert(users.findLastIndex(user => user.name == 'John')); // 3
        
      
      
      filterEl método find busca un único elemento (el primero) que haga a la función devolver true.
Si existieran varios elementos que cumplen la condición, podemos usar arr.filter(fn).
La sintaxis es similar a find, pero filter devuelve un array con todos los elementos encontrados:

      
        
        
          let results = arr.filter(function(item, index, array) {
  // si devuelve true, el elemento es ingresado al array y la iteración continua
  // si nada es encontrado, devuelve un array vacío
});
        
      
      
      Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let users = [
  {id: 1, name: "Celina"},
  {id: 2, name: "David"},
  {id: 3, name: "Federico"}
];

// devuelve un array con los dos primeros usuarios
let someUsers = users.filter(item => item.id < 3);

alert(someUsers.length); // 2
        
      
      
      Transformar un arrayPasamos ahora a los métodos que transforman y reordenan un array.
mapEl método arr.map es uno de los métodos más comunes y ampliamente usados.
Este método llama a la función para cada elemento del array y devuelve un array con los resultados.
La sintaxis es:

      
        
        
          let result = arr.map(function(item, index, array) {
  // devuelve el nuevo valor en lugar de item
});
        
      
      
      Por ejemplo, acá transformamos cada elemento en el valor de su respectivo largo (length):

      
        
        
          
            
          
          
            
          
        
        
          let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length);
alert(lengths); // 5,7,6
        
      
      
      sort(fn)Cuando usamos arr.sort(), este ordena el propio array cambiando el orden de los elementos.
También devuelve un nuevo array ordenado, pero este usualmente se descarta ya que arr en sí mismo es modificado.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [ 1, 2, 15 ];

// el método reordena el contenido de arr
arr.sort();

alert( arr );  // 1, 15, 2
        
      
      
      ¿Notas algo extraño en los valores de salida?
Los elementos fueron reordenados a 1, 15, 2. Pero ¿por qué pasa esto?
Los elementos son ordenados como strings (cadenas de caracteres) por defecto
Todos los elementos son literalmente convertidos a string para ser comparados. En el caso de strings se aplica el orden lexicográfico, por lo que efectivamente "2" > "15".
Para usar nuestro propio criterio de reordenamiento, necesitamos proporcionar una función como argumento de arr.sort().
La función debe comparar dos valores arbitrarios, y devolver:

      
        
        
          function compare(a, b) {
  if (a > b) return 1; // si el primer valor es mayor que el segundo
  if (a == b) return 0; // si ambos valores son iguales
  if (a < b) return -1; // si el primer valor es menor que el segundo
}
        
      
      
      Por ejemplo, para ordenar como números:

      
        
        
          
            
          
          
            
          
        
        
          function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15
        
      
      
      Ahora sí funciona como esperábamos.
Detengámonos un momento y pensemos qué es lo que está pasando. El array arr puede ser un array de cualquier cosa, ¿no? Puede contener números, strings, objetos o lo que sea. Podemos decir que tenemos un conjunto de ciertos items. Para ordenarlos, necesitamos una función de ordenamiento que sepa cómo comparar los elementos. El orden por defecto es hacerlo como strings.
El método arr.sort(fn) implementa un algoritmo genérico de orden. No necesitamos preocuparnos de cómo funciona internamente (la mayoría de las veces es una forma optimizada del algoritmo quicksort o Timsort). Este método va a recorrer el array, comparar sus elementos usando la función dada y, finalmente, reordenarlos. Todo los que necesitamos hacer es proveer la fn que realiza la comparación.
Por cierto, si queremos saber qué elementos son comparados, nada nos impide ejecutar alert() en ellos:

      
        
        
          
            
          
          
            
          
        
        
          [1, -2, 15, 2, 0, 8].sort(function(a, b) {
  alert( a + " <> " + b );
  return a - b;
});
        
      
      
      El algoritmo puede comparar un elemento con muchos otros en el proceso, pero trata de hacer la menor cantidad de comparaciones posible.

            Una función de comparación puede devolver cualquier número
            En realidad, una función de comparación solo es requerida para devolver un número positivo para “mayor” y uno negativo para “menor”.
Esto nos permite escribir una función más corta:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [ 1, 2, 15 ];

arr.sort(function(a, b) { return a - b; });

alert(arr);  // 1, 2, 15
        
      
      
      

            Mejor, con funciones de flecha
            ¿Recuerdas las arrow functions? Podemos usarlas en este caso para un ordenamiento más prolijo:

      
        
        
          arr.sort( (a, b) => a - b );
        
      
      
      Esto funciona exactamente igual que la versión más larga de arriba.


            Usa localeCompare para strings
            ¿Recuerdas el algoritmo de comparación strings? Este compara letras por su código por defecto.
Para muchos alfabetos, es mejor usar el método str.localeCompare para ordenar correctamente letras como por ejemplo Ö.
Por ejemplo, vamos a ordenar algunos países en alemán:

      
        
        
          
            
          
          
            
          
        
        
          let paises = ['Österreich', 'Andorra', 'Vietnam'];

alert( paises.sort( (a, b) => a > b ? 1 : -1) ); // Andorra, Vietnam, Österreich (incorrecto)

alert( paises.sort( (a, b) => a.localeCompare(b) ) ); // Andorra,Österreich,Vietnam (¡correcto!)
        
      
      
      
reverseEl método arr.reverse revierte el orden de los elementos en arr.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];
arr.reverse();

alert( arr ); // 5,4,3,2,1
        
      
      
      También devuelve el array arr después de revertir el orden.
split y joinAnalicemos una situación de la vida real. Estamos programando una app de mensajería y y el usuario ingresa una lista de receptores delimitada por comas: Celina, David, Federico. Pero para nosotros un array sería mucho más práctico que una simple string. ¿Cómo podemos hacer para obtener un array?
El método str.split(delim) hace precisamente eso. Separa la string en elementos según el delimitante delim dado y los devuelve como un array.
En el ejemplo de abajo, separamos por “coma seguida de espacio”:

      
        
        
          
            
          
          
            
          
        
        
          let nombres = 'Bilbo, Gandalf, Nazgul';

let arr = nombres.split(', ');

for (let name of arr) {
  alert( `Un mensaje para ${name}.` ); // Un mensaje para Bilbo  (y los otros nombres)
}
        
      
      
      El método split tiene un segundo argumento numérico opcional: un límite en la extensión del array. Si se provee este argumento, entonces el resto de los elementos son ignorados. Sin embargo en la práctica rara vez se utiliza:

      
        
        
          
            
          
          
            
          
        
        
          let arr = 'Bilbo, Gandalf, Nazgul, Saruman'.split(', ', 2);

alert(arr); // Bilbo, Gandalf
        
      
      
      
            Separar en letras
            El llamado a split(s) con un s vacío separará el string en un array de letras:

      
        
        
          
            
          
          
            
          
        
        
          let str = "test";

alert( str.split('') ); // t,e,s,t
        
      
      
      
arr.join(glue) hace lo opuesto a split. Crea una string de arr elementos unidos con glue (pegamento) entre ellos.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let arr = ['Bilbo', 'Gandalf', 'Nazgul'];

let str = arr.join(';'); // une el array en una string usando ;

alert( str ); // Bilbo;Gandalf;Nazgul
        
      
      
      reduce/reduceRightCuando necesitamos iterar sobre un array podemos usar forEach, for o for..of.
Cuando necesitamos iterar y devolver un valor por cada elemento podemos usar map.
Los métodos arr.reduce y arr.reduceRight también pertenecen a ese grupo de acciones, pero son un poco más complejos. Se los utiliza para calcular un único valor a partir del array.
La sintaxis es la siguiente:

      
        
        
          let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial]);
        
      
      
      La función es aplicada a todos los elementos del array, uno tras de otro, y va arrastrando el resultado parcial al próximo llamado.
Argumentos:

accumulator – es el resultado del llamado previo de la función, equivale a  initial la primera vez (si initial es dado como argumento).
item – es el elemento actual del array.
index – es la posición.
array – es el array.

Mientras la función sea llamada, el resultado del llamado anterior se pasa al siguiente como primer argumento.
Entonces, el primer argumento es el acumulador que almacena el resultado combinado de todas las veces anteriores en que se ejecutó, y al final se convierte en el resultado de reduce.
¿Suena complicado?
La forma más simple de entender algo es con un ejemplo.
Acá tenemos la suma de un array en una línea:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
        
      
      
      La función pasada a reduce utiliza solo 2 argumentos, esto generalmente es suficiente.
Veamos los detalles de lo que está pasando.

En la primera pasada, sum es el valor initial (el último argumento de reduce), equivale a 0, y current es el primer elemento de array, equivale a 1. Entonces el resultado de la función es 1.
En la segunda pasada, sum = 1, agregamos el segundo elemento del array (2) y devolvemos el valor.
En la tercera pasada, sum = 3 y le agregamos un elemento más, y así sucesivamente…

El flujo de cálculos:

      
      
        
      
      O en la forma de una tabla, donde cada fila representa un llamado a una función en el próximo elemento del array:




sum
current
result




primer llamado
0
1
1


segundo llamado
1
2
3


tercer llamado
3
3
6


cuarto llamado
6
4
10


quinto llamado
10
5
15



Acá podemos ver claramente como el resultado del llamado anterior se convierte en el primer argumento del llamado siguiente.
También podemos omitir el valor inicial:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3, 4, 5];

// valor inicial removido (no 0)
let result = arr.reduce((sum, current) => sum + current);

alert( result ); // 15
        
      
      
      El resultado es el mismo. Esto es porque en el caso de no haber valor inicial, reduce toma el primer elemento del array como valor inicial y comienza la iteración a partir del segundo elemento.
La tabla de cálculos es igual a la anterior menos la primer fila.
Pero este tipo de uso requiere tener extremo cuidado. Si el array está vacío, entonces el llamado a reduce sin valor inicial devuelve error.
Acá vemos un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [];

// Error: Reduce en un array vacío sin valor inicial
// si el valor inicial existe, reduce lo devuelve en el arr vacío.
arr.reduce((sum, current) => sum + current);
        
      
      
      Por lo tanto siempre se recomienda especificar un valor inicial.
El método arr.reduceRight realiza lo mismo, pero va de derecha a izquierda.
Array.isArrayLos arrays no conforman un tipo diferente. Están basados en objetos.
Por eso typeof no ayuda a distinguir un objeto común de un array:

      
        
        
          
            
          
          
            
          
        
        
          alert(typeof {}); // object
alert(typeof []); // object (lo mismo)
        
      
      
      …Pero los arrays son utilizados tan a menudo que tienen un método especial para eso: Array.isArray(value). Este devuelve true si el valor es un array y false si no lo es.

      
        
        
          
            
          
          
            
          
        
        
          alert(Array.isArray({})); // false

alert(Array.isArray([])); // true
        
      
      
      La mayoría de los métodos aceptan “thisArg”Casi todos los métodos para arrays que realizan llamados a funciones – como find, filter, map, con la notable excepción de sort– aceptan un parámetro opcional adicional thisArg.
Ese parámetro no está explicado en la sección anterior porque es raramente usado. Pero para ser exhaustivos necesitamos verlo.
Esta es la sintaxis completa de estos métodos:

      
        
        
          arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg es el último argumento opcional
        
      
      
      EL valor del parámetro thisArg se convierte en this para func.
Por ejemplo, acá usamos un método del objeto army como un filtro y thisArg da el contexto:

      
        
        
          
            
          
          
            
          
        
        
          let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// encuentra usuarios para los cuales army.canJoin devuelve true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
        
      
      
      Si en el ejemplo anterior usáramos users.filter(army.canJoin), entonces army.canJoin sería llamada como una función independiente con this=undefined, lo que llevaría a un error inmediato.
La llamada a users.filter(army.canJoin, army) puede ser reemplazada con users.filter(user => army.canJoin(user)) que realiza lo mismo. Esta última se usa más a menudo ya que es un poco más fácil de entender.
ResumenVeamos el ayudamemoria de métodos para arrays:


Para agregar/remover elementos:

push(...items) – agrega ítems al final,
pop() – extrae un ítem del final,
shift() – extrae un ítem del inicio,
unshift(...items) – agrega ítems al inicio.
splice(pos, deleteCount, ...items) – desde el índice pos borra deleteCount elementos e inserta items.
slice(start, end) – crea un nuevo array y copia elementos desde la posición start hasta end (no incluido) en el nuevo array.
concat(...items) – devuelve un nuevo array: copia todos los elementos del array actual y le agrega items. Si alguno de los items es un array, se toman sus elementos.



Para buscar entre elementos:

indexOf/lastIndexOf(item, pos) – busca por item comenzando desde la posición pos, devolviendo el índice o -1 si no se encuentra.
includes(value) – devuelve true si el array tiene value, si no false.
find/filter(func) – filtra elementos a través de la función, devuelve el primer/todos los valores que devuelven true.
findIndex es similar a  find, pero devuelve el índice en lugar del valor.



Para iterar sobre elementos:

forEach(func) – llama la func para cada elemento, no devuelve nada.



Para transformar el array:

map(func) – crea un nuevo array a partir de los resultados de llamar a la func para cada elemento.
sort(func) – ordena el array y lo devuelve.
reverse() – ordena el array de forma inversa y lo devuelve.
split/join – convierte una cadena en un array y viceversa.
reduce/reduceRight(func, initial) – calcula un solo valor para todo el array, llamando a la func para cada elemento, obteniendo un resultado parcial en cada llamada y pasándolo a la siguiente.



Adicional:

Array.isArray(value) comprueba si value es un array.



Por favor tener en cuenta que sort, reverse y splice modifican el propio array.
Estos métodos son los más utilizados y cubren el 99% de los casos. Pero existen algunos más:


arr.some(fn)/arr.every(fn) comprueba el array.
La función fn es llamada para cada elemento del array de manera similar a map. Si alguno/todos los resultados son true, devuelve true, si no, false.
Estos métodos se comportan con similitud a los operadores || y &&: si fn devuelve un valor verdadero, arr.some() devuelve true y detiene la iteración de inmediato; si fn  devuelve un valor falso, arr.every() devuelve false y detiene la iteración también.


Podemos usar every para comparar arrays:

      
        
        
          
            
          
          
            
          
        
        
          function arraysEqual(arr1, arr2) {
  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
}

alert( arraysEqual([1, 2], [1, 2])); // true
        
      
      
      

arr.fill(value, start, end) – llena el array repitiendo value desde el índice start hasta end.


arr.copyWithin(target, start, end) – copia sus elementos desde la posición start hasta la posición end en si mismo, a la posición target (reescribe lo existente).


arr.flat(depth)/arr.flatMap(fn) crea un nuevo array plano desde un array multidimensional .


Para la lista completa, ver manual.
A primera vista puede parecer que hay demasiados métodos para aprender y un tanto difíciles de recordar. Pero con el tiempo se vuelve más fácil.
Revisa el ayudamemoria para conocerlos. Después realiza las prácticas de este capítulo para ganar experiencia con los métodos para arrays.
Finalmente si en algún momento necesitas hacer algo con un array y no sabes cómo, vuelve a esta página, mira el ayudamemoria y encuentra el método correcto. Los ejemplos te ayudarán a escribirlos correctamente y pronto los recordarás automáticamente y sin esfuerzo.
TareasTransforma border-left-width en borderLeftWidthimportancia: 5Escribe la función camelize(str) que convierta palabras separadas por guión como “mi-cadena-corta” en palabras con mayúscula “miCadenaCorta”.
Esto sería: remover todos los guiones y que cada palabra después de un guión comience con mayúscula.
Ejemplos:

      
        
        
          camelize("background-color") == 'backgroundColor';
camelize("list-style-image") == 'listStyleImage';
camelize("-webkit-transition") == 'WebkitTransition';
        
      
      
      P.D. Pista: usa split para dividir el string en un array, transfórmalo y vuelve a unirlo (join).
Abrir en entorno controlado con pruebas.solución
      
        
        
          function camelize(str) {
  return str
    .split('-') // separa 'my-long-word' en el array ['my', 'long', 'word']
    .map(
      // convierte en mayúscula todas las primeras letras de los elementos del array excepto por el primero
      // convierte ['my', 'long', 'word'] en ['my', 'Long', 'Word']
      (word, index) => index == 0 ? word : word[0].toUpperCase() + word.slice(1)
    )
    .join(''); // une ['my', 'Long', 'Word'] en 'myLongWord'
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Filtrar un rangoimportancia: 4Escribe una función filterRange(arr, a, b) que obtenga un array arr, busque los elementos con valor mayor o igual a a y menor o igual a b y devuelva un array con los resultados.
La función no debe modificar el array. Debe devolver un nuevo array.
Por ejemplo:

      
        
        
          let arr = [5, 3, 8, 1];

let filtered = filterRange(arr, 1, 4);

alert( filtered ); // 3,1 (valores dentro del rango)

alert( arr ); // 5,3,8,1 (array original no modificado)
        
      
      
      Abrir en entorno controlado con pruebas.solución
      
        
        
          
            
          
          
            
          
        
        
          function filterRange(arr, a, b) {
  // agregamos paréntesis en torno a la expresión para mayor legibilidad
  return arr.filter(item => (a <= item && item <= b));
}

let arr = [5, 3, 8, 1];

let filtered = filterRange(arr, 1, 4);

alert( filtered ); // 3,1 (valores dentro del rango)

alert( arr ); // 5,3,8,1 (array original no modificado)
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Filtrar rango "en el lugar"importancia: 4Escribe una función filterRangeInPlace(arr, a, b) que obtenga un array arr y remueva del mismo todos los valores excepto aquellos que se encuentran entre a y b. El test es: a ≤ arr[i] ≤ b.
La función solo debe modificar el array. No debe devolver nada.
Por ejemplo:

      
        
        
          let arr = [5, 3, 8, 1];

filterRangeInPlace(arr, 1, 4); // remueve los números excepto aquellos entre 1 y 4

alert( arr ); // [3, 1]
        
      
      
      Abrir en entorno controlado con pruebas.solución
      
        
        
          
            
          
          
            
          
        
        
          function filterRangeInPlace(arr, a, b) {

  for (let i = 0; i < arr.length; i++) {
    let val = arr[i];

    // remueve aquellos elementos que se encuentran fuera del intervalo
    if (val < a || val > b) {
      arr.splice(i, 1);
      i--;
    }
  }

}

let arr = [5, 3, 8, 1];

filterRangeInPlace(arr, 1, 4); // remueve los números excepto aquellos entre 1 y 4

alert( arr ); // [3, 1]
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Ordenar en orden decrecienteimportancia: 4
      
        
        
          let arr = [5, 2, 1, -10, 8];

// ... tu código para ordenar en orden decreciente

alert( arr ); // 8, 5, 2, 1, -10
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          let arr = [5, 2, 1, -10, 8];

arr.sort((a, b) => b - a);

alert( arr );
        
      
      
      Copia y ordena un arrayimportancia: 5Supongamos que tenemos un array arr. Nos gustaría tener una copia ordenada del mismo, pero mantener arr sin modificar.
Crea una función copySorted(arr) que devuelva esa copia.

      
        
        
          let arr = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr);

alert( sorted ); // CSS, HTML, JavaScript
alert( arr ); // HTML, JavaScript, CSS (sin cambios)
        
      
      
      soluciónPodemos usar slice() para crear una copia y realizar el ordenamiento en ella:

      
        
        
          
            
          
          
            
          
        
        
          function copySorted(arr) {
  return arr.slice().sort();
}

let arr = ["HTML", "JavaScript", "CSS"];

let sorted = copySorted(arr);

alert( sorted );
alert( arr );
        
      
      
      Crea una calculadora extensibleimportancia: 5Crea una función Calculator que cree objetos calculadores “extensibles”.
La actividad consiste de dos partes.


Primero, implementar el método calculate(str) que toma un string como "1 + 2" en el formato “NUMERO operador NUMERO” (delimitado por espacios) y devuelve el resultado. Debe entender más + y menos -.
Ejemplo de uso:

      
        
        
          let calc = new Calculator;

alert( calc.calculate("3 + 7") ); // 10
        
      
      
      

Luego agrega el método addMethod(name, func) que enseñe a la calculadora una nueva operación. Toma el operador name y la función con dos argumentos func(a,b) que lo implementa.
Por ejemplo, vamos a agregar la multiplicación *, division / y potencia **:

      
        
        
          let powerCalc = new Calculator;
powerCalc.addMethod("*", (a, b) => a * b);
powerCalc.addMethod("/", (a, b) => a / b);
powerCalc.addMethod("**", (a, b) => a ** b);

let result = powerCalc.calculate("2 ** 3");
alert( result ); // 8
        
      
      
      


Sin paréntesis ni expresiones complejas en esta tarea.
Los números y el operador deben estar delimitados por exactamente un espacio.
Puede haber manejo de errores si quisieras agregarlo.

Abrir en entorno controlado con pruebas.solución
Por favor ten en cuenta cómo son almacenados los métodos. Simplemente son agregados a la propiedad this.methods.
Todos los test y conversiones son hechas con el método calculate. En el futuro puede ser extendido para soportar expresiones más complejas.


      
        
        
          function Calculator() {

  this.methods = {
    "-": (a, b) => a - b,
    "+": (a, b) => a + b
  };

  this.calculate = function(str) {

    let split = str.split(' '),
      a = +split[0],
      op = split[1],
      b = +split[2];

    if (!this.methods[op] || isNaN(a) || isNaN(b)) {
      return NaN;
    }

    return this.methods[op](a, b);
  };

  this.addMethod = function(name, func) {
    this.methods[name] = func;
  };
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Mapa a nombresimportancia: 5Tienes un array de objetos user, cada uno tiene user.name. Escribe el código que lo convierta en un array de nombres.
Por ejemplo:

      
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let users = [ john, pete, mary ];

let names = /* ... tu código */

alert( names ); // John, Pete, Mary
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let users = [ john, pete, mary ];

let names = users.map(item => item.name);

alert( names ); // John, Pete, Mary
        
      
      
      Mapa a objetosimportancia: 5Tienes un array de objetos user, cada uno tiene name, surname e id.
Escribe el código para crear otro array a partir de este, de objetos con id y fullName, donde fullName es generado a partir de name y surname.
Por ejemplo:

      
        
        
          let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };

let users = [ john, pete, mary ];

let usersMapped = /* ... tu código ... */

/*
usersMapped = [
  { fullName: "John Smith", id: 1 },
  { fullName: "Pete Hunt", id: 2 },
  { fullName: "Mary Key", id: 3 }
]
*/

alert( usersMapped[0].id ) // 1
alert( usersMapped[0].fullName ) // John Smith
        
      
      
      Entonces, en realidad lo que necesitas es mapear un array de objetos a otro. Intenta usar => en este caso. Hay un pequeño truco.
solución
      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John", surname: "Smith", id: 1 };
let pete = { name: "Pete", surname: "Hunt", id: 2 };
let mary = { name: "Mary", surname: "Key", id: 3 };

let users = [ john, pete, mary ];

let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));

/*
usersMapped = [
  { fullName: "John Smith", id: 1 },
  { fullName: "Pete Hunt", id: 2 },
  { fullName: "Mary Key", id: 3 }
]
*/

alert( usersMapped[0].id ); // 1
alert( usersMapped[0].fullName ); // John Smith
        
      
      
      Ten en cuenta que para las funciones arrow necesitamos usar paréntesis adicionales.
No podemos escribirlo de la siguiente manera:

      
        
        
          let usersMapped = users.map(user => {
  fullName: `${user.name} ${user.surname}`,
  id: user.id
});
        
      
      
      Como recordarás, existen dos funciones arrow: sin cuerpo value => expr y con cuerpo value => {...}.
Acá JavaScript tratará { como el inicio de cuerpo de la función, no el inicio del objeto. La manera de resolver esto es encerrarlo dentro de paréntesis:

      
        
        
          let usersMapped = users.map(user => ({
  fullName: `${user.name} ${user.surname}`,
  id: user.id
}));
        
      
      
      Ahora funciona.
Ordena usuarios por edadimportancia: 5Escribe la función sortByAge(users) que cree un array de objetos con al propiedad age y los ordene según age.
Por ejemplo:

      
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let arr = [ pete, john, mary ];

sortByAge(arr);

// ahora: [john, mary, pete]
alert(arr[0].name); // John
alert(arr[1].name); // Mary
alert(arr[2].name); // Pete
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          function sortByAge(arr) {
  arr.sort((a, b) => a.age - b.age);
}

let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 28 };

let arr = [ pete, john, mary ];

sortByAge(arr);

// ahora ordenado es: [john, mary, pete]
alert(arr[0].name); // John
alert(arr[1].name); // Mary
alert(arr[2].name); // Pete
        
      
      
      Barajar un arrayimportancia: 3Escribe la función shuffle(array) que baraje (reordene de forma aleatoria) los elementos del array.
Múltiples ejecuciones de shuffle puede conducir a diferentes órdenes de elementos. Por ejemplo:

      
        
        
          let arr = [1, 2, 3];

shuffle(arr);
// arr = [3, 2, 1]

shuffle(arr);
// arr = [2, 1, 3]

shuffle(arr);
// arr = [3, 1, 2]
// ...
        
      
      
      Todos los reordenamientos de elementos tienen que tener la misma probabilidad. Por ejemplo, [1,2,3] puede ser reordenado como [1,2,3] o [1,3,2] o [3,1,2] etc, con igual probabilidad en cada caso.
soluciónUna solución simple podría ser:

      
        
        
          
            
          
          
            
          
        
        
          function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

let arr = [1, 2, 3];
shuffle(arr);
alert(arr);
        
      
      
      Eso funciona de alguna manera, porque Math.random() - 0.5 es un número aleatorio que puede ser positivo o negativo, por lo tanto, la función de ordenamiento reordena los elementos de forma aleatoria.
Pero debido a que la función de ordenamiento no está hecha para ser usada de esta manera, no todas las permutaciones tienen la misma probabilidad.
Por ejemplo, consideremos el código siguiente. Ejecuta shuffle 1000000 veces y cuenta las apariciones de todos los resultados posibles:

      
        
        
          
            
          
          
            
          
        
        
          function shuffle(array) {
  array.sort(() => Math.random() - 0.5);
}

// cuenta las apariciones para todas las permutaciones posibles
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// muestra conteo de todas las permutaciones posibles
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
        
      
      
      Un resultado de ejemplo (depende del motor JS):

      
        
        
          123: 250706
132: 124425
213: 249618
231: 124880
312: 125148
321: 125223
        
      
      
      Podemos ver una clara tendencia: 123 y 213 aparecen mucho más seguido que otros.
El resultado del código puede variar entre distintos motores JavaScript, pero ya podemos ver que esta forma de abordar el problema es poco confiable.
¿Por qué no funciona? Generalmente hablando, sort es una “caja negra”: tiramos dentro un array y una función de ordenamiento y esperamos que el array se ordene. Pero debido a la total aleatoriedad de la comparación, la caja negra se vuelve loca y exactamente en que sentido se vuelve loca depende de la implementación específica, que difiere de un motor a otro.
Existen otra formas mejores de realizar la tarea. Por ejemplo, hay un excelente algoritmo llamado Algoritmo de Fisher-Yates. La idea es recorrer el array en sentido inverso e intercambiar cada elemento con un elemento aleatorio anterior:

      
        
        
          function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1)); // índice aleatorio entre 0 e i

    // intercambia elementos array[i] y array[j]
    // usamos la sintaxis "asignación de desestructuración" para lograr eso
    // encontrarás más información acerca de esa sintaxis en los capítulos siguientes
    // lo mismo puede ser escrito como:
    // let t = array[i]; array[i] = array[j]; array[j] = t
    [array[i], array[j]] = [array[j], array[i]];
  }
}
        
      
      
      Probémoslo de la misma manera:

      
        
        
          
            
          
          
            
          
        
        
          function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    let j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// conteo de apariciones para todas las permutaciones posibles
let count = {
  '123': 0,
  '132': 0,
  '213': 0,
  '231': 0,
  '321': 0,
  '312': 0
};

for (let i = 0; i < 1000000; i++) {
  let array = [1, 2, 3];
  shuffle(array);
  count[array.join('')]++;
}

// muestra el conteo para todas las permutaciones posibles
for (let key in count) {
  alert(`${key}: ${count[key]}`);
}
        
      
      
      La salida del ejemplo:

      
        
        
          123: 166693
132: 166647
213: 166628
231: 167517
312: 166199
321: 166316
        
      
      
      Ahora sí se ve bien: todas las permutaciones aparecen con la misma probabilidad.
Además, en cuanto al rendimiento el algoritmo de Fisher-Yates es mucho mejor, no hay “ordenamiento” superpuesto.
Obtener edad promedioimportancia: 4Escribe la función getAverageAge(users) que obtenga un array de objetos con la propiedad age y devuelva el promedio de age.
La fórmula de promedio es (age1 + age2 + ... + ageN) / N.
Por ejemplo:

      
        
        
          let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 29 };

let arr = [ john, pete, mary ];

alert( getAverageAge(arr) ); // (25 + 30 + 29) / 3 = 28
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          function getAverageAge(users) {
  return users.reduce((prev, user) => prev + user.age, 0) / users.length;
}

let john = { name: "John", age: 25 };
let pete = { name: "Pete", age: 30 };
let mary = { name: "Mary", age: 29 };

let arr = [ john, pete, mary ];

alert( getAverageAge(arr) ); // 28
        
      
      
      Filtrar elementos únicos de un arrayimportancia: 4Partiendo del array arr.
Crea una función unique(arr) que devuelva un array con los elementos que se encuentran una sola vez dentro de arr.
Por ejemplo:

      
        
        
          function unique(arr) {
  /* tu código */
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
        
      
      
      Abrir en entorno controlado con pruebas.soluciónRecorramos los elementos dentro del array:

Para cada elemento vamos a comprobar si el array resultante ya tiene ese elemento.
Si ya lo tiene, ignora. Si no, agrega el resultado.


      
        
        
          
            
          
          
            
          
        
        
          function unique(arr) {
  let result = [];

  for (let str of arr) {
    if (!result.includes(str)) {
      result.push(str);
    }
  }

  return result;
}

let strings = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(strings) ); // Hare, Krishna, :-O
        
      
      
      El código funciona, pero tiene un problema potencial de desempeño.
El método result.includes(str) internamente recorre el array result y compara cada elemento con str para encontrar una coincidencia.
Por lo tanto, si hay 100 elementos en result y ninguno coincide con str, entonces habrá recorrido todo el array result y ejecutado 100 comparaciones. Y si result es tan grande como 10000, entonces habrá 10000 comparaciones.
Esto no es un problema en sí mismo, porque los motores JavaScript son muy rápidos, por lo que recorrer 10000 elementos de un array solo le tomaría microsegundos.
Pero ejecutamos dicha comprobación para cada elemento de arr en el loop for.
Entonces si arr.length es 10000 vamos a tener algo como 10000*10000 = 100 millones de comparaciones. Esto es realmente mucho.
Por lo que la solución solo es buena para arrays pequeños.
Más adelante en el capítulo Map y Set vamos a ver como optimizarlo.
Abrir la solución con pruebas en un entorno controlado.Crea un objeto a partir de un arrayimportancia: 4Supongamos que recibimos un array de usuarios con la forma {id:..., name:..., age:... }.
Crea una función groupById(arr) que cree un objeto, con id como clave (key) y los elementos del array como valores.
Por ejemplo:

      
        
        
          let users = [
  {id: 'john', name: "John Smith", age: 20},
  {id: 'ann', name: "Ann Smith", age: 24},
  {id: 'pete', name: "Pete Peterson", age: 31},
];

let usersById = groupById(users);

/*
// después de llamar a la función deberíamos tener:

usersById = {
  john: {id: 'john', name: "John Smith", age: 20},
  ann: {id: 'ann', name: "Ann Smith", age: 24},
  pete: {id: 'pete', name: "Pete Peterson", age: 31},
}
*/
        
      
      
      Dicha función es realmente útil cuando trabajamos con información del servidor.
Para esta actividad asumimos que cada id es único. No existen dos elementos del array con el mismo id.
Usa el método de array .reduce en la solución.
Abrir en entorno controlado con pruebas.solución
      
        
        
          function groupById(array) {
  return array.reduce((obj, value) => {
    obj[value.id] = value;
    return obj;
  }, {})
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/array-methods" 
},
{
	"docs_id": "43",
	"name": "Iterables",
	"description": "Los objetos iterables son una generalización de arrays. Es un concepto que permite que cualquier objeto pueda ser utilizado en un bucle for..of.",
	"content": "Los objetos iterables son una generalización de arrays. Es un concepto que permite que cualquier objeto pueda ser utilizado en un bucle for..of.
Por supuesto, las matrices o arrays son iterables. Pero hay muchos otros objetos integrados que también lo son. Por ejemplo, las cadenas o strings son iterables también. Como veremos, muchos operadores y métodos se basan en la iterabilidad.
Si un objeto no es técnicamente una matriz, pero representa una colección (lista, conjunto) de algo, entonces el uso de la sintaxis for..of es una gran forma de recorrerlo. Veamos cómo funciona.
Symbol.iteratorPodemos comprender fácilmente el concepto de iterables construyendo uno.
Por ejemplo: tenemos un objeto que no es un array, pero parece adecuado para for..of.
Como un objeto range que representa un intervalo de números:

      
        
        
          let range = {
  from: 1,
  to: 5
};

// Queremos que el for..of funcione de la siguiente manera:
// for(let num of range) ... num=1,2,3,4,5
        
      
      
      Para hacer que el objeto range sea iterable (y así permitir que for..of funcione) necesitamos agregarle un método llamado Symbol.iterator (un símbolo incorporado especial usado solo para realizar esa función).

Cuando se inicia for..of, éste llama al método Symbol.iterator una vez (o genera un error si no lo encuentra). El método debe devolver un iterador : un objeto con el método next().
En adelante, for..of trabaja solamente con ese objeto devuelto.
Cuando for..of quiere el siguiente valor, llama a next() en ese objeto.
El resultado de next() debe tener la forma {done: Boolean, value: any}, donde done=true significa que el bucle ha finalizado; de lo contrario, el nuevo valor es value.

Aquí está la implementación completa de range:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5
};

// 1. Una llamada a for..of inicializa una llamada a esto:
range[Symbol.iterator] = function() {

  // ... devuelve el objeto iterador:
  // 2. En adelante, for..of trabaja solo con el objeto iterador debajo, pidiéndole los siguientes valores
  return {
    current: this.from,
    last: this.to,

    // 3. next() es llamado en cada iteración por el bucle for..of
    next() {
      // 4. debe devolver el valor como un objeto {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// ¡Ahora funciona!
for (let num of range) {
  alert(num); // 1, luego 2, 3, 4, 5
}
        
      
      
      Note una característica fundamental de los iterables: separación de conceptos.

El range en sí mismo no tiene el método next().
En cambio, la llamada a range[Symbol.iterator]() crea un otro objeto llamado “iterador”, y su next() genera valores para la iteración.

Por lo tanto, el objeto iterador está separado del objeto sobre el que itera.
Técnicamente, podríamos fusionarlos y usar el range mismo como iterador para simplificar el código.
De esta manera:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() {
    this.current = this.from;
    return this;
  },

  next() {
    if (this.current <= this.to) {
      return { done: false, value: this.current++ };
    } else {
      return { done: true };
    }
  }
};

for (let num of range) {
  alert(num); // 1, luego 2, 3, 4, 5
}
        
      
      
      Ahora range[Symbol.iterator]() devuelve el objeto range en sí: tiene el método next() necesario y recuerda el progreso de iteración actual en this.current. ¿Más corto? Sí. Y a veces eso también está bien.
La desventaja es que ahora es imposible tener dos bucles for..of corriendo sobre el objeto simultáneamente: compartirán el estado de iteración, porque solo hay un iterador: el objeto en sí. Pero dos for-of paralelos es algo raro, incluso en escenarios asíncronos.

            Iteradores Infinitos
            También son posibles los iteradores infinitos. Por ejemplo, el objeto range se vuelve infinito así: range.to = Infinity. O podemos hacer un objeto iterable que genere una secuencia infinita de números pseudoaleatorios. También puede ser útil.
No hay limitaciones en next, puede devolver más y más valores, eso es normal.
Por supuesto, el bucle for..of sobre un iterable de este tipo sería interminable. Pero siempre podemos detenerlo usando break.

String es iterableLas matrices y cadenas son los iterables integrados más utilizados.
En una cadena o string, el bucle for..of recorre sus caracteres:

      
        
        
          
            
          
          
            
          
        
        
          for (let char of "test") {
  // Se dispara 4 veces: una vez por cada carácter
  alert( char ); // t, luego e, luego s, luego t
}
        
      
      
      ¡Y trabaja correctamente con valores de pares sustitutos (codificación UTF-16)!

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';
for (let char of str) {
    alert( char ); // 𝒳, y luego 😂
}
        
      
      
      Llamar a un iterador explícitamentePara una comprensión más profunda, veamos cómo usar un iterador explícitamente.
Vamos a iterar sobre una cadena exactamente de la misma manera que for..of, pero con llamadas directas. Este código crea un iterador de cadena y obtiene valores de él “manualmente”:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hola";

// hace lo mismo que
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // retorna los caracteres uno por uno
}
        
      
      
      Rara vez se necesita esto, pero nos da más control sobre el proceso que for..of. Por ejemplo, podemos dividir el proceso de iteración: iterar un poco, luego parar, hacer otra cosa y luego continuar.
Iterables y simil-array (array-like)Los dos son términos oficiales que se parecen, pero son muy diferentes. Asegúrese de comprenderlos bien para evitar confusiones.

Iterables son objetos que implementan el método Symbol.iterator, como se describió anteriormente.
simil-array son objetos que tienen índices y longitud o length, por lo que se “ven” como arrays.

Cuando usamos JavaScript para tareas prácticas en el navegador u otros entornos, podemos encontrar objetos que son iterables o array-like, o ambos.
Por ejemplo, las cadenas son iterables (for..of funciona en ellas) y array-like (tienen índices numéricos y length).
Pero un iterable puede que no sea array-like. Y viceversa, un array-like puede no ser iterable.
Por ejemplo, range en el ejemplo anterior es iterable, pero no es array-like porque no tiene propiedades indexadas ni length.
Y aquí el objeto tiene forma de matriz, pero no es iterable:

      
        
        
          
            
          
          
            
          
        
        
          let arrayLike = { // tiene índices y longitud => array-like
  0: "Hola",
  1: "Mundo",
  length: 2
};

// Error (sin Symbol.iterator)
for (let item of arrayLike) {}
        
      
      
      Tanto los iterables como los array-like generalmente no son arrays, no tienen “push”, “pop”, etc. Eso es bastante inconveniente si tenemos un objeto de este tipo y queremos trabajar con él como con una matriz. P.ej. nos gustaría trabajar con range utilizando métodos de matriz. ¿Cómo lograr eso?
Array.fromExiste un método universal Array.from que toma un valor iterable o simil-array y crea un Array ¨real¨ a partir de él. De esta manera podemos llamar y usar métodos que pertenecen a una matriz.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let arrayLike = {
  0: "Hola",
  1: "Mundo",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // Mundo (el método pop funciona)
        
      
      
      Array.from en la línea (*) toma el objeto, y si es iterable o simil-array crea un nuevo array y copia allí todos los elementos.
Lo mismo sucede para un iterable:

      
        
        
          // suponiendo que range se toma del ejemplo anterior
let arr = Array.from(range);
alert(arr); // 1,2,3,4,5 (la conversión de matriz a cadena funciona)
        
      
      
      La sintaxis completa para Array.from también nos permite proporcionar una función opcional de “mapeo”:

      
        
        
          Array.from(obj[, mapFn, thisArg])
        
      
      
      El segundo argumento opcional mapFn puede ser una función que se aplicará a cada elemento antes de agregarlo a la matriz, y thisArg permite establecer el this para ello.
Por ejemplo:

      
        
        
          // suponiendo que range se toma del ejemplo anterior

// el cuadrado de cada número
let arr = Array.from(range, num => num * num);

alert(arr); // 1,4,9,16,25
        
      
      
      Aquí usamos Array.from para convertir una cadena en una matriz de caracteres:

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';

// separa str en un array de caracteres
let chars = Array.from(str);

alert(chars[0]); // 𝒳
alert(chars[1]); // 😂
alert(chars.length); // 2
        
      
      
      A diferencia de str.split, Array.from se basa en la naturaleza iterable de la cadena y, por lo tanto, al igual que for..of, funciona correctamente con pares sustitutos.
Técnicamente aquí hace lo mismo que:

      
        
        
          
            
          
          
            
          
        
        
          let str = '𝒳😂';

let chars = []; // Array.from internamente hace el mismo bucle
for (let char of str) {
  chars.push(char);
}

alert(chars);
        
      
      
      … Pero es más corto.
Incluso podemos construir un segmento o slice compatible con sustitutos en él:

      
        
        
          
            
          
          
            
          
        
        
          function slice(str, start, end) {
  return Array.from(str).slice(start, end).join('');
}

let str = '𝒳😂𩷶';

alert( slice(str, 1, 3) ); // 😂𩷶

// el método nativo no admite pares sustitutos
alert( str.slice(1, 3) ); // garbage (dos piezas de diferentes pares sustitutos)
        
      
      
      ResumenLos objetos que se pueden usar en for..of se denominan iterables.

Técnicamente, los iterables deben implementar el método llamado Symbol.iterator.

El resultado de obj[Symbol.iterator]() se llama iterador. Maneja el proceso de iteración adicional.
Un iterador debe tener el método llamado next() que devuelve un objeto {done: Boolean, value: any}, donde done: true marca el fin de la iteración; de lo contrario, value es el siguiente valor.


El método Symbol.iterator se llama automáticamente por for..of, pero también podemos llamarlo directamente.
Los iterables integrados, como cadenas o matrices, también implementan Symbol.iterator.
El iterador de cadena es capaz de manejar los pares sustitutos.

Los objetos que tienen propiedades indexadas y longitud o length se llaman array-like. Dichos objetos también pueden tener otras propiedades y métodos, pero carecen de los métodos integrados de las matrices.
Si miramos dentro de la especificación, veremos que la mayoría de los métodos incorporados suponen que funcionan con iterables o array-likes en lugar de matrices “reales”, porque eso es más abstracto.
Array.from (obj[, mapFn, thisArg]) crea un verdadero Array de un obj iterable o array-like, y luego podemos usar métodos de matriz en él. Los argumentos opcionales mapFn y thisArg nos permiten aplicar una función a cada elemento.
",
	"url": "https://es.javascript.info/iterable" 
},
{
	"docs_id": "44",
	"name": "Map y Set",
	"description": "Hasta este momento, hemos aprendido sobre las siguientes estructuras de datos:",
	"content": "Hasta este momento, hemos aprendido sobre las siguientes estructuras de datos:

Objetos para almacenar colecciones de datos ordenadas mediante una clave.
Arrays para almacenar colecciones ordenadas de datos.

Pero eso no es suficiente para la vida real. Por eso también existen Map y Set.
MapMap es, al igual que Objet, una colección de datos identificados por claves. Pero la principal diferencia es que Map permite claves de cualquier tipo.
Los métodos y propiedades son:

new Map() – crea el mapa.
map.set(clave, valor) – almacena el valor asociado a la clave.
map.get(clave) – devuelve el valor de la clave. Será undefined si la clave no existe en map.
map.has(clave) – devuelve true si la clave existe en map, false si no existe.
map.delete(clave) – elimina el valor de la clave.
map.clear() – elimina todo de map.
map.size – tamaño, devuelve la cantidad actual de elementos.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set('1', 'str1');   // un string como clave
map.set(1, 'num1');     // un número como clave
map.set(true, 'bool1'); // un booleano como clave

// ¿recuerda el objeto regular? convertiría las claves a string.
// Map mantiene el tipo de dato en las claves, por lo que estas dos son diferentes:
alert( map.get(1)   ); // 'num1'
alert( map.get('1') ); // 'str1'

alert( map.size ); // 3
        
      
      
      Podemos ver que, a diferencia de los objetos, las claves no se convierten en strings. Cualquier tipo de clave es posible en un Map.

            map[clave] no es la forma correcta de usar Map
            Aunque map[clave] también funciona (por ejemplo podemos establecer map[clave] = 2), esto es tratar a map como un objeto JavaScript simple, lo que implica tener todas las limitaciones correspondientes (que solo se permita string/symbol como clave, etc.).
Por lo tanto, debemos usar los métodos de Map: set, get y demás.

También podemos usar objetos como claves.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John" };

// para cada usuario, almacenemos el recuento de visitas
let visitsCountMap = new Map();

// john es la clave para el Map
visitsCountMap.set(john, 123);

alert( visitsCountMap.get(john) ); // 123
        
      
      
      El uso de objetos como claves es una de las características de Map más notables e importantes. Esto no se aplica a los objetos: una clave de tipo string está bien en un Object, pero no podemos usar otro Object como clave.
Intentémoslo:

      
        
        
          
            
          
          
            
          
        
        
          let john = { name: "John" };
let ben = { name: "Ben" };

let visitsCountObj = {}; // intenta usar un objeto

visitsCountObj[ben] = 234; // intenta usar el objeto ben como clave
visitsCountObj[john] = 123; // intenta usar el objeto john como clave, el objeto ben es reemplazado

// Esto es lo que se escribió!
alert( visitsCountObj["[object Object]"] ); // 123
        
      
      
      Como visitsCountObj es un objeto, convierte todas los objetos como john y ben en el mismo string "[objeto Objeto]". Definitivamente no es lo que queremos.

            Cómo Map compara las claves
            Para probar la equivalencia de claves, Map utiliza el algoritmo SameValueZero. Es aproximadamente lo mismo que la igualdad estricta ===, pero la diferencia es que NaN se considera igual a NaN. Por lo tanto, NaN también se puede usar como clave.
Este algoritmo no se puede cambiar ni personalizar.


            Encadenamiento
            Cada llamada a map.set devuelve map en sí, así que podamos “encadenar” las llamadas:

      
        
        
          map.set('1', 'str1')
   .set(1, 'num1')
   .set(true, 'bool1');
        
      
      
      
Iteración sobre MapPara recorrer un map, hay 3 métodos:

map.keys() –- devuelve un iterable para las claves.
map.values() -– devuelve un iterable para los valores.
map.entries() -– devuelve un iterable para las entradas [clave, valor]. Es el que usa por defecto en for..of.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let recipeMap = new Map([
  ['pepino', 500],
  ['tomates', 350],
  ['cebollas',    50]
]);

// iterando sobre las claves (verduras)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // pepino, tomates, cebollas
}

// iterando sobre los valores (precios)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// iterando sobre las entradas [clave, valor]
for (let entry of recipeMap) { // lo mismo que recipeMap.entries()
  alert(entry); // pepino,500 (etc)
}
        
      
      
      
            Se utiliza el orden de inserción.
            La iteración va en el mismo orden en que se insertaron los valores. Map conserva este orden, a diferencia de un Objeto normal.

Además, Map tiene un método forEach incorporado, similar al de Array:

      
        
        
          // recorre la función para cada par (clave, valor)
recipeMap.forEach( (value, key, map) => {
  alert(`${key}: ${value}`); // pepino: 500 etc
});
        
      
      
      Object.entries: Map desde ObjetoAl crear un Map, podemos pasarle un array (u otro iterable) con pares clave/valor para la inicialización:

      
        
        
          
            
          
          
            
          
        
        
          // array de [clave, valor]
let map = new Map([
  ['1',  'str1'],
  [1,    'num1'],
  [true, 'bool1']
]);

alert( map.get('1') ); // str1
        
      
      
      Si tenemos un objeto plano y queremos crear un Map a partir de él, podemos usar el método incorporado Object.entries(obj) que devuelve un array de pares clave/valor para un objeto exactamente en ese formato.
Entonces podemos inicializar un map desde un objeto:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  name: "John",
  age: 30
};

let map = new Map(Object.entries(obj));

alert( map.get('name') ); // John
        
      
      
      Aquí, Object.entries devuelve el array de pares clave/valor: [ ["name","John"], ["age", 30] ]. Es lo que necesita Map.
Object.fromEntries: Objeto desde MapAcabamos de ver cómo crear un Map a partir de un objeto simple con Object.entries (obj).
Existe el método Object.fromEntries que hace lo contrario: dado un array de pares [clave, valor], crea un objeto a partir de ellos:

      
        
        
          
            
          
          
            
          
        
        
          let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);

// ahora prices = { banana: 1, orange: 2, meat: 4 }

alert(prices.orange); // 2
        
      
      
      Podemos usar Object.fromEntries para obtener un objeto desde Map.
Ejemplo: almacenamos los datos en un Map, pero necesitamos pasarlos a un código de terceros que espera un objeto simple.
Aquí vamos:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();
map.set('banana', 1);
map.set('orange', 2);
map.set('meat', 4);

let obj = Object.fromEntries(map.entries()); // hace un objeto simple (*)

// Hecho!
// obj = { banana: 1, orange: 2, meat: 4 }

alert(obj.orange); // 2
        
      
      
      Una llamada a map.entries() devuelve un array de pares clave/valor, exactamente en el formato correcto para Object.fromEntries.
También podríamos acortar la línea (*):

      
        
        
          let obj = Object.fromEntries(map); // omitimos .entries()
        
      
      
      Es lo mismo, porque Object.fromEntries espera un objeto iterable como argumento. No necesariamente un array. Y la iteración estándar para el Map devuelve los mismos pares clave/valor que map.entries(). Entonces obtenemos un objeto simple con las mismas claves/valores que Map.
SetUn Set es una colección de tipo especial: “conjunto de valores” (sin claves), donde cada valor puede aparecer solo una vez.
Sus principales métodos son:

new Set(iterable) – crea el set. El argumento opcional es un objeto iterable (generalmente un array) con valores para inicializarlo.
set.add(valor) – agrega un valor, y devuelve el set en sí.
set.delete(valor) – elimina el valor, y devuelve true si el valor existía al momento de la llamada; si no, devuelve false.
set.has(valor) – devuelve true si el valor existe en el set, si no, devuelve false.
set.clear() – elimina todo el continido del set.
set.size – es la cantidad de elementos.

La característica principal es que llamadas repetidas de set.add(valor) con el mismo valor no hacen nada. Esa es la razón por la cual cada valor aparece en Set solo una vez.
Por ejemplo, vienen visitantes y queremos recordarlos a todos. Pero las visitas repetidas no deberían llevar a duplicados. Un visitante debe ser “contado” solo una vez.
Set es lo correcto para eso:

      
        
        
          
            
          
          
            
          
        
        
          let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// visitas, algunos usuarios lo hacen varias veces
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set solo guarda valores únicos
alert( set.size ); // 3

for (let user of set) {
  alert(user.name); // John (luego Pete y Mary)
}
        
      
      
      La alternativa a Set podría ser un array de usuarios y el código para verificar si hay duplicados en cada inserción usando arr.find. Pero el rendimiento sería mucho peor, porque este método recorre el array completo comprobando cada elemento. Set está optimizado internamente para verificar unicidad.
Iteración sobre SetPodemos recorrer Set con for..of o usando forEach:

      
        
        
          
            
          
          
            
          
        
        
          let set = new Set(["oranges", "apples", "bananas"]);

for (let value of set) alert(value);

// lo mismo que forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
        
      
      
      Tenga en cuenta algo peculiar: la función callback pasada en forEach tiene 3 argumentos:  un valor, luego el mismo valor “valueAgain” y luego el objeto de destino que es set. El mismo valor aparece en los argumentos dos veces.
Eso es por compatibilidad con Map donde la función callback tiene tres argumentos. Parece un poco extraño, seguro. Pero en ciertos casos puede ayudar a reemplazar Map con Set y viceversa con facilidad.
También soporta los mismos métodos que Map tiene para los iteradores:

set.keys() – devuelve un iterable para las claves.
set.values() – lo mismo que set.keys(), por su compatibilidad con Map.
set.entries() – devuelve un iterable para las entradas [clave, valor], por su compatibilidad con Map.

ResumenMap: es una colección de valores con clave.
Métodos y propiedades:

new Map() – crea el mapa.
map.set(clave, valor) – almacena el valor para la clave.
map.get(clave) – devuelve el valor de la clave: será undefined si la clave no existe en Map.
map.has(clave) – devuelvetrue si la clave existe, y false si no existe.
map.delete(clave) – elimina el valor de esa clave.
map.clear() – limpia el Map.
map.size – devuelve la cantidad de elementos en el Map.

La diferencia con un Objeto regular:

Cualquier clave. Los objetos también pueden ser claves.
Métodos adicionales convenientes, y la propiedad size.

Set: es una colección de valores únicos.
Métodos y propiedades:

new Set(iterable) – crea el set. Tiene un argumento opcional, un objeto iterable (generalmente un array) de valores para inicializarlo.
set.add(valor) – agrega un valor, devuelve el set en sí.
set.delete(valor) – elimina el valor, devuelve true si valor existe al momento de la llamada; si no, devuelve false.
set.has(valor) – devuelve true si el valor existe en el set, si no, devuelve false.
set.clear() – elimina todo del set.
set.size – es la cantidad de elementos.

La iteración sobre Map y Set siempre está en el orden de inserción, por lo que no podemos decir que estas colecciones están desordenadas, pero no podemos reordenar elementos u obtener un elemento directamente por su número.
TareasFiltrar miembros únicos del arrayimportancia: 5Digamos que arr es un array.
Cree una función unique(arr) que debería devolver un array con elementos únicos de arr.
Por ejemplo:

      
        
        
          function unique(arr) {
  /* tu código */
}

let values = ["Hare", "Krishna", "Hare", "Krishna",
  "Krishna", "Krishna", "Hare", "Hare", ":-O"
];

alert( unique(values) ); // Hare, Krishna, :-O
        
      
      
      P.D. Aquí se usan strings, pero pueden ser valores de cualquier tipo.
P.D.S. Use Set para almacenar valores únicos.
Abrir en entorno controlado con pruebas.solución
      
        
        
          function unique(arr) {
  return Array.from(new Set(arr));
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Filtrar anagramasimportancia: 4Anagramas son palabras que tienen el mismo número de letras, pero en diferente orden.
Por ejemplo:

      
        
        
          nap - pan
ear - are - era
cheaters - hectares - teachers
        
      
      
      Escriba una función aclean(arr) que devuelva un array limpio de anagramas.
Por ejemplo:

      
        
        
          let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) ); // "nap,teachers,ear" o "PAN,cheaters,era"
        
      
      
      Es decir, de cada grupo de anagramas debe quedar solo una palabra, sin importar cual.
Abrir en entorno controlado con pruebas.soluciónPara encontrar todos los anagramas, dividamos cada palabra en letras y las ordenamos. Cuando se clasifican las letras, todos los anagramas son iguales.
Por ejemplo:

      
        
        
          nap, pan -> anp
ear, era, are -> aer
cheaters, hectares, teachers -> aceehrst
...
        
      
      
      Utilizaremos las variantes ordenadas por letras como claves de Map para almacenar solo un valor por cada clave:

      
        
        
          
            
          
          
            
          
        
        
          function aclean(arr) {
  let map = new Map();

  for (let word of arr) {
    // dividir la palabra por letras, ordenarlas y volver a unir
    let sorted = word.toLowerCase().split('').sort().join(''); // (*)
    map.set(sorted, word);
  }

  return Array.from(map.values());
}

let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) );
        
      
      
      La clasificación de letras se realiza mediante la cadena de llamadas en la línea (*).
Por conveniencia la dividimos en múltiples líneas:

      
        
        
          let sorted = word // PAN
  .toLowerCase() // pan
  .split('') // ['p','a','n']
  .sort() // ['a','n','p']
  .join(''); // anp
        
      
      
      Dos palabras diferentes'PAN' y 'nap' reciben la misma forma ordenada por letras 'anp'.
La siguiente línea pone la palabra en el Map:

      
        
        
          map.set(sorted, word);
        
      
      
      Si alguna vez volvemos a encontrar una palabra con la misma forma ordenada por letras, sobrescribiría el valor anterior con la misma clave en Map. Por lo tanto, siempre tendremos como máximo una palabra ordenada por letras.
Al final, Array.from (map.values()) toma un valor iterativo sobre los valores de Map (no necesitamos claves en el resultado) y devuelve un array de ellos.
Aquí también podríamos usar un objeto plano en lugar del Map, porque las claves son strings.
Así es como puede verse la solución:

      
        
        
          
            
          
          
            
          
        
        
          function aclean(arr) {
  let obj = {};

  for (let i = 0; i < arr.length; i++) {
    let sorted = arr[i].toLowerCase().split("").sort().join("");
    obj[sorted] = arr[i];
  }

  return Object.values(obj);
}

let arr = ["nap", "teachers", "cheaters", "PAN", "ear", "era", "hectares"];

alert( aclean(arr) );
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Claves iterablesimportancia: 5Nos gustaría obtener un array de map.keys() en una variable y luego aplicarle métodos específicos de array, ej. .push.
Pero eso no funciona:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set("name", "John");

let keys = map.keys();

// Error: keys.push no es una función
keys.push("more");
        
      
      
      ¿Por qué? ¿Cómo podemos arreglar el código para que funcione keys.push?
soluciónEso es porque map.keys() devuelve un iterable, pero no un array.
Podemos convertirlo en un array usando Array.from:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

map.set("name", "John");

let keys = Array.from(map.keys());

keys.push("more");

alert(keys); // name, more
        
      
      
      ",
	"url": "https://es.javascript.info/map-set" 
},
{
	"docs_id": "45",
	"name": "WeakMap y WeakSet",
	"description": "Como vimos en el artículo  Recolección de basura, el motor de JavaScript mantiene un valor en la memoria mientras sea “accesible” y pueda ser potencialmente usado.",
	"content": "Como vimos en el artículo  Recolección de basura, el motor de JavaScript mantiene un valor en la memoria mientras sea “accesible” y pueda ser potencialmente usado.
Por ejemplo:

      
        
        
          let john = { name: "John" };

// se puede acceder al objeto, john hace referencia a él

// sobrescribe la referencia
john = null;

// el objeto ya no es accesible y será eliminado de la memoria
        
      
      
      Por lo general, las propiedades de un objeto, elementos de un array u otra estructura de datos se consideran accesibles y se mantienen en la memoria mientras esa estructura permanezca en la memoria.
Por ejemplo, si colocamos un objeto en un array, mientras el array esté vivo el objeto también lo estará, incluso si no hay otras referencias a él.
Como aquí:

      
        
        
          let john = { name: "John" };

let array = [ john ];

john = null; // sobrescribe la referencia

// El objeto referenciado por John se almacena dentro del array,
// por lo que no será borrado por el recolector de basura
// Lo podemos obtener como array[0]
        
      
      
      Del mismo modo, si usamos un objeto como la clave en un Map regular, entonces mientras exista elMap, ese objeto también existe. Este objeto ocupa memoria y no puede ser reclamado por el recolector de basura.
Por ejemplo:

      
        
        
          let john = { name: "John" };

let map = new Map();
map.set(john, "...");

john = null; // sobreescribe la referencia

// john se almacena dentro de map,
// podemos obtenerlo usando map.keys ()
        
      
      
      WeakMap es fundamentalmente diferente en este aspecto. No impide la recolección de basura de objetos usados como claves.
Veamos qué significa esto en los ejemplos.
WeakMapLa primera diferencia con Map es que las claves WeakMap deben ser objetos, no valores primitivos:

      
        
        
          
            
          
          
            
          
        
        
          let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // funciona bien (la clave es un objeto)

// no puede usar un string como clave
weakMap.set("test", "Whoops"); // Error, porque "test" no es un objeto
        
      
      
      Ahora, si usamos un objeto como clave y no hay otras referencias a ese objeto, se eliminará de la memoria (y del map) automáticamente.

      
        
        
          let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // sobreescribe la referencia

// ¡John se eliminó de la memoria!
        
      
      
      Compárelo con el ejemplo del Map regular anterior. Ahora, si john solo existe como la clave deWeakMap, se eliminará automáticamente del map (y de la memoria).
WeakMap no admite la iteración ni los métodos keys(), values(), entries(), así que no hay forma de obtener todas las claves o valores de él.
WeakMap tiene solo los siguientes métodos:

weakMap.get(clave)
weakMap.set(clave, valor)
weakMap.delete(clave)
weakMap.has(clave)

¿Por qué tanta limitación? Eso es por razones técnicas. Si un objeto ha perdido todas las demás referencias (como john en el código anterior), entonces se debe recolectar automáticamente como basura. Pero técnicamente no se especifica exactamente cuándo se realiza la limpieza.
El motor de JavaScript decide eso. Puede optar por realizar la limpieza de la memoria inmediatamente o esperar y realizar la limpieza más tarde cuando ocurran más eliminaciones. Por lo tanto, técnicamente no se conoce el recuento actual de elementos de un WeakMap. El motor puede haberlo limpiado o no, o lo hizo parcialmente. Por esa razón, los métodos que acceden a todas las claves/valores no son soportados.
Ahora, ¿dónde necesitamos esta estructura de datos?
Caso de uso: datos adicionalesEl área principal de aplicación de WeakMap es como almacenamiento de datos adicional.
Si estamos trabajando con un objeto que “pertenece” a otro código (tal vez incluso una biblioteca de terceros), y queremos almacenar algunos datos asociados a él que solo deberían existir mientras el objeto esté vivo, entonces WeakMap es exactamente lo que se necesita.
Ponemos los datos en un WeakMap utilizando el objeto como clave, y cuando el objeto sea recolectado por el recolector de basura, esos datos también desaparecerán automáticamente.

      
        
        
          weakMap.set(john, "secret documents");
// si John muere, secret documents será destruido automáticamente
        
      
      
      Veamos un ejemplo.
Por ejemplo, tenemos un código que mantiene un recuento de visitas para los usuarios. La información se almacena en un map: un objeto de usuario es la clave y el recuento de visitas es el valor. Cuando un usuario se va (su objeto será recolectado por el recolector de basura), ya no queremos almacenar su recuento de visitas.
Aquí hay un ejemplo de una función de conteo con Map:

      
        
        
          // 📁 visitsCount.js
let visitsCountMap = new Map(); // map: user => visits count

// incrementar el recuento de visitas
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
        
      
      
      Y aquí hay otra parte del código, tal vez otro archivo usándolo:

      
        
        
          // 📁 main.js
let john = { name: "John" };

countUser(john); // cuenta sus visitas

// luego John nos deja
john = null;
        
      
      
      Ahora el objeto john debería ser recolectado como basura, pero permanece en la memoria, ya que es una propiedad envisitCountMap.
Necesitamos limpiar visitCountMap cuando eliminamos usuarios, de lo contrario, crecerá en la memoria indefinidamente. Tal limpieza puede convertirse en una tarea tediosa en arquitecturas complejas.
Lo podemos evitar cambiando a WeakMap en su lugar:

      
        
        
          // 📁 visitsCount.js
let visitsCountMap = new WeakMap(); // weakmap: user => visits count

// incrementar el recuento de visitas
function countUser(user) {
  let count = visitsCountMap.get(user) || 0;
  visitsCountMap.set(user, count + 1);
}
        
      
      
      Ahora no tenemos que limpiar visitasCountMap. Después de que el objeto john se vuelve inalcanzable por todos los medios excepto como una propiedad deWeakMap, se elimina de la memoria junto con la información asociada a esa clave de WeakMap.
Caso de uso: almacenamiento en cachéOtro ejemplo común es el almacenamiento en caché: cuando se debe recordar el resultado de una función (“en caché”), para que las llamadas futuras en el mismo objeto lo reutilicen.
Podemos usar Map para almacenar resultados:

      
        
        
          
            
          
          
            
          
        
        
          // 📁 cache.js
let cache = new Map();

// calcular y recordar el resultado
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* cálculo de resultado para */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

// Ahora usamos process() en otro archivo:

// 📁 main.js
let obj = {/* digamos que tenemos un objeto */};

let result1 = process(obj); // calculado

// ...después, en otro lugar del código...
let result2 = process(obj); // resultado recordado tomado de la memoria caché

// ...después, cuando el objeto no se necesita más:
obj = null;

alert(cache.size); // 1 (¡Ouch! ¡El objeto todavía está en caché, tomando memoria!)
        
      
      
      Para múltiples llamadas de proceso (obj) con el mismo objeto, solo calcula el resultado la primera vez, y luego lo toma de caché. La desventaja es que necesitamos limpiar el ‘caché’ cuando el objeto ya no es necesario.
Si reemplazamos Map por WeakMap, este problema desaparece: el resultado en caché se eliminará de la memoria automáticamente después de que el objeto se recolecte.

      
        
        
          
            
          
          
            
          
        
        
          // 📁 cache.js
let cache = new WeakMap();

// calcular y recordad el resultado
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* calcular el resultado para */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* algún objeto */};

let result1 = process(obj);
let result2 = process(obj);

// ...después, cuando el objeto no se necesitará más:
obj = null;

// No se puede obtener cache.size, ya que es un WeakMap,
// pero es 0 o pronto será 0
// Cuando obj se recolecte como basura, los datos en caché también se eliminarán
        
      
      
      WeakSetWeakSet se comporta de manera similar:

Es análogo a Set, pero solo podemos agregar objetos a WeakSet (no primitivos).
Existe un objeto en el conjunto mientras es accesible desde otro lugar.
Al igual que Set, admiteadd, has ydelete, pero no size,keys() ni iteraciones.

Al ser “débil”, también sirve como almacenamiento adicional. Pero no para datos arbitrarios, sino para hechos “sí/no”. Una membresía en WeakSet puede significar algo sobre el objeto.
Por ejemplo, podemos agregar usuarios a WeakSet para realizar un seguimiento de los que visitaron nuestro sitio:

      
        
        
          
            
          
          
            
          
        
        
          let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John nos visita
visitedSet.add(pete); // luego Pete
visitedSet.add(john); // John otra vez

// visitedSet tiene 2 usuarios ahora

// comprobar si John nos visitó?
alert(visitedSet.has(john)); // true

// comprobar si Mary nos visitó?
alert(visitedSet.has(mary)); // false

john = null;

// visitedSet se limpiará automáticamente
        
      
      
      La limitación más notable de WeakMap yWeakSet es la ausencia de iteraciones y la imposibilidad de obtener todo el contenido actual. Esto puede parecer inconveniente, pero no impide que WeakMap / WeakSet haga su trabajo principal: ser un almacenamiento “adicional” de datos para objetos que se almacenan/administran en otro lugar.
ResumenWeakMap es una colección similar a Map que permite solo objetos como propiedades y los elimina junto con el valor asociado una vez que se vuelven inaccesibles por otros medios.
WeakSet es una colección tipo Set que almacena solo objetos y los elimina una vez que se vuelven inaccesibles por otros medios.
Sus principales ventajas son que tienen referencias débiles a los objetos, así pueden ser fácilmente eliminados por el recolector de basura.
Esto viene al costo de no tener soporte para clear, size, keys, values…
WeakMap yWeakSet se utilizan como estructuras de dato “secundarias” además del almacenamiento de objetos “principal”. Una vez que el objeto se elimina del almacenamiento principal, si solo se encuentra como la clave de WeakMap o en unWeakSet, se limpiará automáticamente.
TareasAlmacenar banderas "no leídas"importancia: 5Hay un array de mensajes:

      
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];
        
      
      
      Su código puede acceder a él, pero los mensajes son administrados por el código de otra persona. Se agregan mensajes nuevos, los códigos viejos se eliminan regularmente con ese código, y usted no sabe los momentos exactos en que sucede.
Ahora, ¿qué estructura de datos podría usar para almacenar información sobre si el mensaje “ha sido leído”? La estructura debe ser adecuada para dar la respuesta “¿se leyó?” para el objeto del mensaje dado.
P.D Cuando un mensaje se elimina de messages, también debería desaparecer de su estructura.
P.P.D. No debemos modificar los objetos del mensaje, o agregarles nuestras propiedades. Como son administrados por el código de otra persona, eso puede generarnos resultados no deseados.
soluciónGuardemos los mensajes leídos en WeakSet:

      
        
        
          
            
          
          
            
          
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];

let readMessages = new WeakSet();

// se han leído dos mensajes
readMessages.add(messages[0]);
readMessages.add(messages[1]);
// readMessages tiene 2 elementos

// ...¡leamos nuevamente el primer mensaje!
readMessages.add(messages[0]);
// readMessages todavía tiene dos únicos elementos

// respuesta: ¿se leyó el mensaje [0]?
alert("Read message 0: " + readMessages.has(messages[0])); // true

messages.shift();
// ahora readMessages tiene 1 elemento (técnicamente la memoria puede limpiarse más tarde)
        
      
      
      El WeakSet permite almacenar un conjunto de mensajes y verificar fácilmente la existencia de un mensaje en él.
Se limpia automáticamente. La desventaja es que no podemos iterar sobre él, no podemos obtener “todos los mensajes leídos” directamente. Pero podemos hacerlo iterando sobre todos los mensajes y filtrando los que están en el conjunto.
Otra solución diferente podría ser agregar una propiedad como message.isRead = true a un mensaje después de leerlo. Como los objetos de mensajes son administrados por otro código, generalmente se desaconseja, pero podemos usar una propiedad simbólica para evitar conflictos.
Como esto:

      
        
        
          // la propiedad simbólica solo es conocida por nuestro código
let isRead = Symbol("isRead");
messages[0][isRead] = true;
        
      
      
      Ahora el código de terceros probablemente no verá nuestra propiedad adicional.
Aunque los símbolos permiten reducir la probabilidad de problemas, usar WeakSet es mejor desde el punto de vista arquitectónico.
Almacenar fechas de lecturaimportancia: 5Hay un array semejante al de la  actividad anterior. La situación es similar:

      
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];
        
      
      
      La pregunta ahora es: ¿qué estructura de datos es la adecuada para almacenar la información: “¿cuándo se leyó el mensaje?”.
En la tarea anterior solo necesitábamos almacenar el hecho de “sí/no”. Ahora necesitamos almacenar la fecha, y solo debe permanecer en la memoria hasta que el mensaje sea recolectado como basura.
P.D Las fechas se pueden almacenar como objetos de la clase incorporada Date, que cubriremos más adelante.
soluciónPara almacenar una fecha, podemos usar WeakMap:

      
        
        
          let messages = [
  {text: "Hello", from: "John"},
  {text: "How goes?", from: "John"},
  {text: "See you soon", from: "Alice"}
];

let readMap = new WeakMap();

readMap.set(messages[0], new Date(2017, 1, 1));
// // Objeto Date que estudiaremos más tarde
        
      
      
      ",
	"url": "https://es.javascript.info/weakmap-weakset" 
},
{
	"docs_id": "46",
	"name": "Object.keys, values, entries",
	"description": "Alejémonos de las estructuras de datos individuales y hablemos sobre las iteraciones sobre ellas.",
	"content": "Alejémonos de las estructuras de datos individuales y hablemos sobre las iteraciones sobre ellas.
En el capítulo anterior vimos métodos map.keys(), map.values(), map.entries().
Estos métodos son genéricos, existe un acuerdo común para usarlos para estructuras de datos. Si alguna vez creamos una estructura de datos propia, también deberíamos implementarla.
Son compatibles para:

Map
Set
Array

Los objetos simples también admiten métodos similares, pero la sintaxis es un poco diferente.
Object.keys, values, entriesPara objetos simples, los siguientes métodos están disponibles:

Object.keys(obj) – devuelve un array de propiedades.
Object.values(obj) – devuelve un array de valores.
Object.entries(obj) – devuelve un array de pares [propiedad, valor].

Observe las diferencias (en comparación con Map, por ejemplo):




Map
Objeto




Sintaxis de llamada
map.keys()
Object.keys(obj), pero no obj.keys()


Devuelve
iterable
un Array “real”



La primera diferencia es que tenemos que llamar Object.keys(obj), y no obj.keys().
¿Por qué? La razón principal es la flexibilidad. Recuerda que los objetos son la base de todas las estructuras complejas en JavaScript. Entonces, podemos tener un objeto propio como data que implementa su propio método data.values (): todavía podemos llamar a Object.values(data) en él.
La segunda diferencia es que los métodos Object.* devuelven objetos array “reales”, no solo un iterable. Eso es principalmente por razones históricas.
Por ejemplo:

      
        
        
          let user = {
  name: "John",
  age: 30
};
        
      
      
      
Object.keys(user) = ["name", "age"]
Object.values(user) = ["John", 30]
Object.entries(user) = [ ["name","John"], ["age",30] ]

Aquí hay un ejemplo del uso de Object.values para recorrer los valores de propiedad:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

// bucle sobre los valores
for (let value of Object.values(user)) {
  alert(value); // John, luego 30
}
        
      
      
      
            Object.keys/values/entries ignoran propiedades simbólicas
            Al igual que un bucle for..in, estos métodos ignoran propiedades que utilizan Symbol(...) como nombre de propiedades.
Normalmente, esto es conveniente. Pero si también queremos propiedades simbólicas, entonces hay un método aparte Object.getOwnPropertySymbols que devuelve un array de únicamente propiedades simbólicas. También existe un método Reflect.ownKeys(obj) que devuelve todas las propiedades.

Transformando objetosLos objetos carecen de muchos métodos que existen para los arrays, tales como map,filter y otros.
Si queremos aplicarlos, entonces podemos usar Object.entries seguido de Object.fromEntries:

Use Object.entries(obj) para obtener un array de pares clave/valor de obj.
Use métodos de array en ese array, por ejemplo map para transformar estos pares clave/valor.
Use Object.fromEntries(array) en el array resultante para convertirlo nuevamente en un objeto.

Por ejemplo, tenemos un objeto con precios y queremos duplicarlos:

      
        
        
          
            
          
          
            
          
        
        
          let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // convertir precios a array, map - cada par clave/valor en otro par
  // y luego fromEntries nos devuelve el objeto
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8
        
      
      
      Puede parecer difícil a primera vista, pero se vuelve fácil de entender después de usarlo una o dos veces. Podemos hacer poderosas cadenas de transformaciones de esta manera.
TareasSuma las propiedadesimportancia: 5Hay un objeto salaries con un número arbitrario de salarios.
Escriba la función sumSalaries(salaries) que devuelva la suma de todos los salarios utilizando Object.values y el bucle for..of.
Si salaries está vacío, entonces el resultado debe ser 0.
Por ejemplo:

      
        
        
          let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};

alert( sumSalaries(salaries) ); // 650
        
      
      
      Abrir en entorno controlado con pruebas.solución
      
        
        
          
            
          
          
            
          
        
        
          function sumSalaries(salaries) {

  let sum = 0;
  for (let salary of Object.values(salaries)) {
    sum += salary;
  }

  return sum; // 650
}

let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};

alert( sumSalaries(salaries) ); // 650
        
      
      
      Otra opción, también podemos obtener la suma utilizando Object.values y reduce:

      
        
        
          // reduce recorre el array de salarios,
// sumándolos
// y devuelve el resultado
function sumSalaries(salaries) {
  return Object.values(salaries).reduce((a, b) => a + b, 0) // 650
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Contar propiedadesimportancia: 5Escriba una función count(obj) que devuelva el número de propiedades en el objeto:

      
        
        
          let user = {
  name: 'John',
  age: 30
};

alert( count(user) ); // 2
        
      
      
      Trate de hacer el código lo más corto posible.
PD: Ignore propiedades simbólicas, solamente cuente las propiedades “regulares”.
Abrir en entorno controlado con pruebas.solución
      
        
        
          function count(obj) {
  return Object.keys(obj).length;
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/keys-values-entries" 
},
{
	"docs_id": "47",
	"name": "Asignación desestructurante",
	"description": "Las dos estructuras de datos más usadas en JavaScript son Object y Array.",
	"content": "Las dos estructuras de datos más usadas en JavaScript son Object y Array.

Los objetos nos permiten crear una simple entidad que almacena items con una clave cada uno.
los arrays nos permiten reunir items en una lista ordenada.

Pero cuando los pasamos a una función, tal vez no necesitemos un objeto o array como un conjunto sino en piezas individuales.
La asignación desestructurante es una sintaxis especial que nos permite “desempaquetar” arrays u objetos en varias variables, porque a veces es más conveniente.
La desestructuración también funciona bien con funciones complejas que tienen muchos argumentos, valores por defecto, etcétera. Pronto lo veremos.
Desestructuración de ArraysUn ejemplo de cómo el array es desestructurado en variables:

      
        
        
          // tenemos un array con el nombre y apellido
let arr = ["John", "Smith"]

// asignación desestructurante
// fija firstName = arr[0]
// y surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // John
alert(surname);  // Smith
        
      
      
      Ahora podemos trabajar con variables en lugar de miembros de array.
Se ve genial cuando se combina con split u otro método que devuelva un array:

      
        
        
          
            
          
          
            
          
        
        
          let [firstName, surname] = "John Smith".split(' ');
alert(firstName); // John
alert(surname);  // Smith
        
      
      
      Como puedes ver, la sintaxis es simple. Aunque hay varios detalles peculiares. Veamos más ejemplos para entenderlo mejor.

            “Desestructuración” no significa “destructivo”.
            Se llama “asignación desestructurante” porque “desestructura” al copiar elementos dentro de variables, pero el array en sí no es modificado.
Es sólo una manera más simple de escribir:

      
        
        
          // let [firstName, surname] = arr;
let firstName = arr[0];
let surname = arr[1];
        
      
      
      

            Ignorar elementos utilizando comas
            Los elementos no deseados de un array también pueden ser descartados por medio de una coma extra:

      
        
        
          
            
          
          
            
          
        
        
          // segundo elemento no es necesario
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul
        
      
      
      En el código de arriba, el segundo elemento del array es omitido, el tercero es asignado a title, y el resto de los elementos del array también se omiten (debido a que no hay variables para ellos).


            Funciona con cualquier iterable en el lado derecho
            …Incluso lo podemos usar con cualquier iterable, no sólo arrays:

      
        
        
          let [a, b, c] = "abc"; // ["a", "b", "c"]
let [one, two, three] = new Set([1, 2, 3]);
        
      
      
      Esto funciona, porque internamente una desestructuración trabaja iterando sobre el valor de la derecha. Es una clase de azúcar sintáctica para llamar for..of sobre el valor a la derecha del = y asignar esos valores.


            Asignar a cualquier cosa en el lado izquierdo
            Podemos usar cualquier “asignable” en el lado izquierdo.
Por ejemplo, una propiedad de objeto:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};
[user.name, user.surname] = "John Smith".split(' ');

alert(user.name); // John
alert(user.surname); // Smith
        
      
      
      

            Bucle con .entries()
            En el capítulo anterior vimos el método Object.entries(obj).
Podemos usarlo con la desestructuración para recorrer claves-y-valores de un objeto:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30
};

// recorrer claves-y-valores
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, luego age:30
}
        
      
      
      El código equivalente para Map es más simple, porque es iterable:

      
        
        
          
            
          
          
            
          
        
        
          let user = new Map();
user.set("name", "John");
user.set("age", "30");

// Map itera como pares [key, value], muy conveniente para desestructurar
for (let [key, value] of user) {
  alert(`${key}:${value}`); // name:John, luego age:30
}
        
      
      
      

            Truco para intercambiar variables
            Hay un conocido truco para intercambiar los valores de dos variables usando asignación desestructurante:

      
        
        
          
            
          
          
            
          
        
        
          let guest = "Jane";
let admin = "Pete";

// Intercambiemos valores: hagamos guest=Pete, admin=Jane
[guest, admin] = [admin, guest];

alert(`${guest} ${admin}`); // Pete Jane (¡intercambiados con éxito!)
        
      
      
      Aquí creamos un array temporal de dos variables e inmediatamente lo desestructuramos con el orden cambiado.
Podemos intercambiar más de dos variables de este modo.

El resto ‘…’En general, si el array es mayor que la lista de la izquierda, los ítems extras son omitidos.
Por ejemplo, aquí solo dos items son tomados, el resto simplemente es ignorado:

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar
// items posteriores no serán asignados a ningún lugar
        
      
      
      si queremos también obtener todo lo que sigue, podemos agregarle un parámetro que obtiene “el resto” usando puntos suspensivos “…”`:

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

// `rest` es un array de ítems, comenzando en este caso por el tercero.
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
        
      
      
      El valor de rest es un array con los elementos restantes del array original.
Podemos usar cualquier otro nombre de variable en lugar de rest, sólo hay que asegurar que tenga tres puntos que lo antecedan y que esté último en la asignación desestructurante.

      
        
        
          
            
          
          
            
          
        
        
          let [name1, name2, ...titles] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
// ahora titles = ["Consul", "of the Roman Republic"]
        
      
      
      Valores predeterminadosSi el array es más corto que la lista de variables a la izquierda, no habrá errores. Los valores ausentes son considerados undefined:

      
        
        
          
            
          
          
            
          
        
        
          let [firstName, surname] = [];

alert(firstName); // undefined
alert(surname); // undefined
        
      
      
      Si queremos un valor “predeterminado” para reemplazar el valor faltante, podemos proporcionarlo utilizando =:

      
        
        
          
            
          
          
            
          
        
        
          // valores predeterminados
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius (desde array)
alert(surname); // Anonymous (predeterminado utilizado)
        
      
      
      Los valores predeterminados pueden ser expresiones más complejas e incluso llamadas a función, que serán evaluadas sólo si el valor no ha sido proporcionado.
Por ejemplo, aquí utilizamos la función prompt para dos valores predeterminados.

      
        
        
          
            
          
          
            
          
        
        
          // sólo ejecuta la captura para surname
let [name = prompt('nombre?'), surname = prompt('apellido?')] = ["Julius"];

alert(name);    // Julius (desde array)
alert(surname); // lo que reciba la captura
        
      
      
      Observa que el prompt se ejecuta solamente para el valor faltante (surname).
Desestructuración de objetosLa asignación desestructurante también funciona con objetos.
La sintaxis básica es:

      
        
        
          let {var1, var2} = {var1:…, var2:…}
        
      
      
      Debemos tener un símil-objeto en el lado derecho, el que queremos separar en variables. El lado izquierdo contiene un símil-objeto “pattern” para sus propiedades correspondientes. En el caso más simple, es la lista de nombres de variables en {...}.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
        
      
      
      Las propiedades options.title, options.width y options.height son asignadas a las variables correspondientes.
No importa el orden sino los nombres. Esto también funciona:

      
        
        
          // cambiado el orden en let {...}
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
        
      
      
      El patrón de la izquierda puede ser más complejo y especificar el mapeo entre propiedades y variables.
Si queremos asignar una propiedad a una variable con otro nombre, por ejemplo que options.width vaya en la variable llamada w, lo podemos establecer usando dos puntos:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { propiedadOrigen: variableObjetivo }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
        
      
      
      Los dos puntos muestran “qué : va dónde”. En el ejemplo de arriba la propiedad width va a w, height va a h, y title es asignado al mismo nombre.
Para propiedades potencialmente faltantes podemos establecer valores predeterminados utilizando "=", de esta manera:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
        
      
      
      Al igual que con arrays o argumentos de función, los valores predeterminados pueden ser cualquier expresión e incluso llamados a función, las que serán evaluadas si el valor no ha sido proporcionado.
En el código de abajo prompt pregunta por width, pero no por title:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width = prompt("¿ancho?"), title = prompt("¿título?")} = options;

alert(title);  // Menu
alert(width);  // (lo que sea el resultado de la captura)
        
      
      
      También podemos combinar ambos, los dos puntos y la igualdad:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
        
      
      
      Si tenemos un objeto complejo con muchas propiedades, podemos extraer solamente las que necesitamos:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// sólo extrae título como variable
let { title } = options;

alert(title); // Menu
        
      
      
      El patrón resto “…”¿Qué pasa si el objeto tiene más propiedades que las variables que tenemos? ¿Podemos tomar algunas y luego asignar el “resto” en alguna parte?
Podemos usar el patrón resto de la misma forma que lo usamos con arrays. Esto no es soportado en algunos navegadores antiguos (para IE, use el polyfill Babel), pero funciona en los navegadores modernos.
Se ve así:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// title = propiedad llamada title
// rest = objeto con el resto de las propiedades
let {title, ...rest} = options;

// ahora title="Menu", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100
        
      
      
      
            La trampa si no hay let
            En los ejemplos de arriba, las variables fueron declaradas en la asignación: let {…} = {…}. Por supuesto que también podemos usar variables existentes, sin let. Pero hay una trampa.
Esto no funcionará:

      
        
        
          
            
          
          
            
          
        
        
          let title, width, height;

// error en esta línea
{title, width, height} = {title: "Menu", width: 200, height: 100};
        
      
      
      El problema es que JavaScript trata al {...} como un bloque de código en el flujo principal de código (no dentro de otra expresión). Estos bloques de código pueden ser usados para agrupar sentencias, de esta manera:

      
        
        
          
            
          
          
            
          
        
        
          {
  // una bloque de código
  let message = "Hola";
  // ...
  alert( message );
}
        
      
      
      Aquí JavaScript supone que tenemos un bloque de código, es por eso que hay un error. Nosotros en cambio queremos desestructuración.
Para mostrarle a JavaScript que no es un bloque de código, podemos rodear la expresión entre paréntesis (...):

      
        
        
          
            
          
          
            
          
        
        
          let title, width, height;

// ahora está bien
({title, width, height} = {title: "Menu", width: 200, height: 100});

alert( title ); // Menu
        
      
      
      
Desestructuración anidadaSi un objeto o array contiene objetos y arrays anidados, podemos utilizar patrones del lado izquierdo más complejos para extraer porciones más profundas.
En el código de abajo options tiene otro objeto en la propiedad size y un array en la propiedad items. El patrón en el lado izquierdo de la asignación tiene la misma estructura para extraer valores de ellos:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// la asignación desestructurante fue dividida en varias líneas para mayor claridad
let {
  size: { // colocar tamaño aquí
    width,
    height
  },
  items: [item1, item2], // asignar ítems aquí
  title = "Menu" // no se encuentra en el objeto (se utiliza valor predeterminado)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
        
      
      
      Todas las propiedades del objeto options con excepción de extra que no está en el lado izquierda, son asignadas a las variables correspondientes:

      
      
        
      
      Por último tenemos width, height, item1, item2 y title desde el valor predeterminado.
Tenga en cuenta que no hay variables para size e items, ya que tomamos su contenido en su lugar.
Argumentos de función inteligentesHay momentos en que una función tiene muchos argumentos, la mayoría de los cuales son opcionales. Eso es especialmente cierto para las interfaces de usuario. Imagine una función que crea un menú. Puede tener ancho, altura, título, elementos de lista, etcétera.
Aquí hay una forma errónea de escribir tal función:

      
        
        
          function showMenu(title = "Untitled", width = 200, height = 100, items = []) {
  // ...
}
        
      
      
      En la vida real, el problema es cómo recordar el orden de los argumentos. Normalmente los IDEs (Entorno de desarrollo integrado) intentan ayudarnos, especialmente si el código está bien documentado, pero aún así… Otro problema es cómo llamar a una función si queremos que use sus valores predeterminados en la mayoría de los argumentos.
¿Así?

      
        
        
          // undefined para que use los valores predeterminados
showMenu("My Menu", undefined, undefined, ["Item1", "Item2"])
        
      
      
      Esto no es nada grato. Y se torna ilegible cuando tratamos con muchos argumentos.
¡La desestructuración llega al rescate!
Podemos pasar los argumentos como un objeto, y la función inmediatamente los desestructura en variables:

      
        
        
          
            
          
          
            
          
        
        
          // pasamos un objeto a la función
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

// ...y los expande inmediatamente a variables
function showMenu({title = "Untitled", width = 200, height = 100, items = []}) {
  // title, items – desde options
  // width, height – usan los predeterminados
  alert( `${title} ${width} ${height}` ); // My Menu 200 100
  alert( items ); // Item1, Item2
}

showMenu(options);
        
      
      
      También podemos usar desestructuración más compleja con objetos anidados y mapeo de dos puntos:

      
        
        
          
            
          
          
            
          
        
        
          let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width va a w
  height: h = 200, // height va a h
  items: [item1, item2] // el primer elemento de items va a item1, el segundo a item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
        
      
      
      La sintaxis completa es la misma que para una asignación desestructurante:

      
        
        
          function({
  incomingProperty: varName = defaultValue  // propiedadEntrante: nombreVariable = valorPredeterminado
  ...
})
        
      
      
      Entonces, para un objeto de parámetros, habrá una variable varName para la propiedad incomingProperty, con defaultValue por defecto.
Por favor observe que tal desestructuración supone que showMenu() tiene un argumento. Si queremos todos los valores predeterminados, debemos especificar un objeto vacío:

      
        
        
          showMenu({}); // ok, todos los valores son predeterminados

showMenu(); // esto daría un error
        
      
      
      Podemos solucionar esto, poniendo {} como valor predeterminado para todo el objeto de argumentos:

      
        
        
          
            
          
          
            
          
        
        
          function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
        
      
      
      En el código de arriba, todo el objeto de argumentos es {} por defecto, por lo tanto siempre hay algo para desestructurar.
Resumen

La asignación desestructurante permite mapear instantáneamente un objeto o array en varias variables.


La sintaxis completa para objeto:

      
        
        
          let {prop : varName = default, ...rest} = object
        
      
      
      Esto significa que la propiedad prop se asigna a la variable varName; pero si no existe tal propiedad, se usa el valor default.
Las propiedades de objeto que no fueron mapeadas son copiadas al objeto rest.


La sintaxis completa para array:

      
        
        
          let [item1 = default, item2, ...resto] = array
        
      
      
      El primer item va a item1, el segundo a item2, todos los ítems restantes crean el array resto.


Es posible extraer información desde arrays/objetos anidados, para esto el lado izquierdo debe tener la misma estructura que el lado derecho.


TareasAsignación desestructuranteimportancia: 5Tenemos un objeto:

      
        
        
          let user = {
  name: "John",
  years: 30
};
        
      
      
      Escriba la asignación desestructurante que asigne las propiedades:

name en la variable name.
years en la variable age.
isAdmin en la variable isAdmin (false, si no existe tal propiedad)

Este es un ejemplo de los valores después de su asignación:

      
        
        
          let user = { name: "John", years: 30 };

// tu código al lado izquierdo:
// ... = user

alert( name ); // John
alert( age ); // 30
alert( isAdmin ); // false
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  years: 30
};

let {name, years: age, isAdmin = false} = user;

alert( name ); // John
alert( age ); // 30
alert( isAdmin ); // false
        
      
      
      El salario máximoimportancia: 5Hay un objeto salaries:

      
        
        
          let salaries = {
  "John": 100,
  "Pete": 300,
  "Mary": 250
};
        
      
      
      Crear la función topSalary(salaries) que devuelva el nombre de la persona mejor pagada.

Si salaries es vacío, debe devolver null.
Si hay varias personas con la mejor paga, devolver cualquiera de ellas.

PD: Utilice Object.entries y desestructuración para iterar sobre pares de claves/valores.
Abrir en entorno controlado con pruebas.solución
      
        
        
          function topSalary(salaries) {

  let maxSalary = 0;
  let maxName = null;

  for(const [name, salary] of Object.entries(salaries)) {
    if (maxSalary < salary) {
      maxSalary = salary;
      maxName = name;
    }
  }

  return maxName;
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/destructuring-assignment" 
},
{
	"docs_id": "48",
	"name": "Fecha y Hora",
	"description": "Aprendamos un nuevo objeto incorporado de JS: Date. Este objeto almacena la fecha, la hora, y brinda métodos para administrarlas.",
	"content": "Aprendamos un nuevo objeto incorporado de JS: Date. Este objeto almacena la fecha, la hora, y brinda métodos para administrarlas.
Por ejemplo, podemos usarlo para almacenar horas de creación o modificación, medir tiempo, o simplemente mostrar en pantalla la fecha actual.
CreaciónPara crear un nuevo objeto Date se lo instancia con new Date() junto con uno de los siguientes argumentos:

new Date()

Sin argumentos – crea un objeto Date para la fecha y la hora actuales:

      
        
        
          
            
          
          
            
          
        
        
          let now = new Date();
alert( now ); // muestra en pantalla la fecha y la hora actuales
        
      
      
      
new Date(milliseconds)

Crea un objeto Date con la cantidad de tiempo igual al número de milisegundos (1/1000 de un segundo) transcurrido a partir del 1° de enero de 1970 UTC+0.

      
        
        
          
            
          
          
            
          
        
        
          // 0 significa 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );

// ahora se le agregan 24 horas, se obtiene 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );
        
      
      
      Un timestamp es un número entero que representa la cantidad de milisegundos transcurridos desde el inicio de 1970.
Este timestamp es una representación numérica liviana de una fecha. Es posible crear una fecha a partir de un timestamp usando new Date(timestamp), y convertir el objeto Date actual a un timestamp utilizando el método date.getTime() (ver abajo).
Las fechas anteriores a 01.01.1970 tienen timestamps negativos, por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // 31 Dec 1969
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert( Dec31_1969 );
        
      
      
      
new Date(datestring)

Si se pasa un único argumento, y es de tipo string, entonces es analizado y convertido a fecha automáticamente. El algoritmo es el mismo que el que utiliza Date.parse, lo veremos mas en detalle luego.

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date("2017-01-26");
alert(date);
// La hora no está definida, por lo que se asume que es la medianoche GMT (0 hs. de la fecha) y
// se ajusta de acuerdo al huso horario de la zona geográfica en la que está ejecutándose el código.
// Por consiguiente, el resultado podría ser
// Thu Jan 26 2017 11:00:00 GMT+1100 (Hora Estándar del Este de Australia)
// o
// Wed Jan 25 2017 16:00:00 GMT-0800 (Hora Estándar del Pacífico)
        
      
      
      
new Date(año, mes, fecha, horas, minutos, segundos, ms)

Crea una fecha con los componentes pasados como argumentos en la zona horaria local. Sólo los primeros dos parámetros son obligatorios.

El año debería tener 4 dígitos. Por compatibilidad, aquí 2 dígitos serán considerados ‘19xx’, pero 4 dígitos es lo firmemente sugerido.
La cuenta del mes comienza desde el 0 (enero), y termina en el 11 (diciembre).
El parámetro fecha efectivamente es el día del mes, si está ausente se asume su valor en 1.
Si los parámetros horas/minutos/segundos/ms están ausentes, se asumen sus valores iguales a 0.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          new Date(2011, 0, 1, 0, 0, 0, 0); // 1 Jan 2011, 00:00:00
new Date(2011, 0, 1); // Igual que la línea de arriba, sólo que a los últimos 4 parámetros se les asigna '0' por defecto.
        
      
      
      La precisión máxima es de 1 ms (1/1000 de segundo):

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 1.01.2011, 02:03:04.567
        
      
      
      

Acceso a los componentes de la fechaExisten métodos que sirven para obtener el año, el mes, y los demás componentes a partir de un objeto de tipo Date:

getFullYear()
Devuelve el año (4 dígitos)
getMonth()
Devuelve el mes, de 0 a 11.
getDate()
Devuelve el día del mes desde 1 a 31. Nótese que el nombre del método no es muy intuitivo.
getHours(), getMinutes(), getSeconds(), getMilliseconds()
Devuelve los componentes del horario correspondientes.


            No getYear(), sino getFullYear()
            Algunos motores de JavaScript poseen implementado un método no estándar llamado getYear(). Este método actualmente está obsoleto. A veces devuelve un año de 2 dígitos. Por favor, nunca lo uses. Usa getFullYear() para obtener el año.

Además, podemos obtener un día de la semana:

getDay()
Devuelve el día de la semana, partiendo de 0 (Domingo) hasta 6 (Sábado). El primer día siempre es el Domingo. Por más que en algunos países no sea así, no se puede modificar.

Todos los métodos mencionados anteriormente devuelven los componentes correspondientes a la zona horaria local.
También existen sus contrapartes UTC, que devuelven el día, mes, año, y demás componentes, para la zona horaria UTC+0: getUTCFullYear(), getUTCMonth(), getUTCDay(). Solo debemos agregarle el "UTC" justo después de "get".
Si tu zona horaria está desplazada respecto de UTC el código de abajo va a mostrar horas diferentes:

      
        
        
          
            
          
          
            
          
        
        
          // fecha actual
let date = new Date();

// la hora en tu zona horaria actual
alert( date.getHours() );

// la hora respecto de la zona horaria UTC+0 (Hora de Londres sin horario de verano)
alert( date.getUTCHours() );
        
      
      
      Además de los anteriormente mencionados, hay dos métodos especiales que no poseen una variante de UTC:

getTime()

Devuelve el timestamp para una fecha determinada – cantidad de milisegundos transcurridos a partir del 1° de Enero de 1970 UTC+0.

getTimezoneOffset()

Devuelve la diferencia entre UTC y el huso horario de la zona actual, en minutos:

      
        
        
          
            
          
          
            
          
        
        
          // Si estás en la zona horaria UTC-1, devuelve 60
// Si estás en la zona horaria UTC+3, devuelve -180
alert( new Date().getTimezoneOffset() );
        
      
      
      

Estableciendo los componentes de la fechaLos siguientes métodos permiten establecer los componentes de fecha y hora:

setFullYear(year, [month], [date])
setMonth(month, [date])
setDate(date)
setHours(hour, [min], [sec], [ms])
setMinutes(min, [sec], [ms])
setSeconds(sec, [ms])
setMilliseconds(ms)
setTime(milliseconds) (Establece la cantidad de segundos transcurridos desde 01.01.1970 GMT+0)

A excepción de setTime(), todos los demás métodos poseen una variante UTC, por ejemplo: setUTCHours().
Como podemos ver, algunos métodos nos permiten fijar varios componentes al mismo tiempo, por ej. setHours. Los componentes que no son mencionados no se modifican.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let today = new Date();

today.setHours(0);
alert(today); // Sigue siendo el día de hoy, pero con la hora cambiada a 0.

today.setHours(0, 0, 0, 0);
alert(today); // Sigue siendo la fecha de hoy, pero ahora en formato 00:00:00 en punto.
        
      
      
      AutocorrecciónLa autocorrección es una característica muy útil de los objetos Date. Podemos fijar valores fuera de rango, y se ajustarán automáticamente.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2013, 0, 32); // ¿32 de Enero 2013?
alert(date); // ¡Se autocorrigió al 1° de Febrero de 2013!
        
      
      
      Los componentes de la fecha que están fuera de rango se distribuyen automáticamente.
Por ejemplo, supongamos que necesitamos incrementar la fecha “28 Feb 2016” en 2 días. El resultado puede ser “2 Mar” o “1 Mar” dependiendo de si es año bisiesto. Afortunadamente, no tenemos de qué preocuparnos. Sólo debemos agregarle los 2 días y el objeto Date se encargará del resto:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2016, 1, 28);
date.setDate(date.getDate() + 2);

alert( date ); // 1 Mar 2016
        
      
      
      Esta característica se usa frecuentemente para obtener la fecha, a partir de un período de tiempo específico. Por ejemplo, supongamos que queremos obtener “la fecha de hoy pero transcurridos 70 segundos a partir de este preciso instante.”

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date();
date.setSeconds(date.getSeconds() + 70);

alert( date ); // Se muestra la fecha correcta.
        
      
      
      También podemos fijar valores en 0 o incluso valores negativos. Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(2016, 0, 2); // 2 Jan 2016

date.setDate(1); // Fija '1' día del mes
alert( date );

date.setDate(0); // el día mínimo es 1, entonces asume el último día del mes anterior
alert( date ); // 31 Dec 2015
        
      
      
      Conversión de fechas a números y diferencia entre fechas.Cuando convertimos un objeto Date a número toma el valor del timestamp actual, al igual que el método date.getTime():

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date();
alert(+date); // devuelve el número de milisegundos, al igual que date.getTime()
        
      
      
      El efecto secundario importante: las fechas pueden ser restadas, el resultado es su diferencia en ms.
Esto puede ser usado para medición de tiempo:

      
        
        
          
            
          
          
            
          
        
        
          let start = new Date(); // comienza a medir el tiempo (valor inicial)

// la función hace su trabajo
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = new Date(); // termina de medir el tiempo (valor final)

alert(`El tiempo transcurrido es de ${end - start} ms`);
        
      
      
      Date.now()Si lo único que queremos es medir el tiempo transcurrido, no es necesario utilizar el objeto Date.
Podemos utilizar el método especial Date.now() que nos devuelve el timestamp actual.
Es el equivalente semántico a new Date().getTime(), pero no crea una instancia intermediaria del objeto Date. De esta manera, el proceso es mas rápido y, por consiguiente, no afecta a la recolección de basura.
Mayormente se utiliza por conveniencia o cuando la performance del código es fundamental, como por ejemplo en juegos de JavaScript u otras aplicaciones específicas.
Por lo tanto, es mejor hacerlo de esta manera:

      
        
        
          
            
          
          
            
          
        
        
          let start = Date.now(); // milisegundos transcurridos a partir del 1° de Enero de 1970

// la función realiza su trabajo
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}

let end = Date.now(); // listo

alert( `El bucle tardó ${end - start} ms` ); // restamos números en lugar de fechas
        
      
      
      BenchmarkingSi queremos realizar una medición de performance confiable de una función que vaya a consumir muchos recursos de CPU, debemos hacerlo con precaución.
En este caso, vamos a medir dos funciones que calculen la diferencia entre dos fechas determinadas: ¿Cuál es la más rápida?
Estas evaluaciones de performance son comúnmente denominadas “benchmarks”.

      
        
        
          // Tenemos date1 y date2. ¿Cuál de las siguientes funciones nos devuelve su diferencia, expresada en ms, más rápido?
function diffSubtract(date1, date2) {
  return date2 - date1;
}

// o
function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}
        
      
      
      Ambas funciones hacen exactamente lo mismo, pero una de ellas utiliza explícitamente date.getTime() para obtener la fecha expresada en ms, y la otra se basa en la autoconversión de fecha a número. Sin embargo, su resultado es el mismo.
Pero entonces, ¿Cuál de las dos es más rápida?
La primera idea sería ejecutar las funciones varias veces seguidas y medir la diferencia de tiempo de ejecución. En nuestro caso, las funciones son bastante simples, por lo que debemos hacerlo al menos unas 100000 veces.
Midamos:

      
        
        
          
            
          
          
            
          
        
        
          function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

alert("Tiempo de ejecución de diffSubtract: " + bench(diffSubtract) + "ms");
alert("Tiempo de ejecución de diffGetTime: " + bench(diffGetTime) + "ms");
        
      
      
      ¡Guau! ¡Utilizando el método getTime() es mucho más rápido! Esto es debido a que no se produce ninguna conversión de tipo de dato, por lo que se le hace mucho mas fácil de optimizar a los motores.
Bueno, ya tenemos algo. Pero todavía no es un benchmark completo.
Imaginemos que en el momento en el que bench(diffSubtract) estaba corriendo, la CPU estaba ejecutando otra tarea en paralelo que consumía recursos y al momento de correr bench(diffGetTime) esa tarea ya había concluido.
Es un escenario bastante posible para los sistemas operativos multi-procesos de hoy en día.
Como consecuencia, el primer benchmark dispondrá de una menor cantidad de recursos de CPU que el segundo, lo que podría generar resultados engañosos.
Para realizar un benchmarking más confiable, todas las benchmarks deberían ser ejecutadas múltiples veces.
Como por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function diffSubtract(date1, date2) {
  return date2 - date1;
}

function diffGetTime(date1, date2) {
  return date2.getTime() - date1.getTime();
}

function bench(f) {
  let date1 = new Date(0);
  let date2 = new Date();

  let start = Date.now();
  for (let i = 0; i < 100000; i++) f(date1, date2);
  return Date.now() - start;
}

let time1 = 0;
let time2 = 0;

// ejecuta bench(diffSubtract) y bench(diffGetTime) cada 10 iteraciones alternándolas
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}

alert( 'Tiempo total de diffSubtract: ' + time1 );
alert( 'Tiempo total de diffGetTime: ' + time2 );
        
      
      
      Los motores modernos de JavaScript realizan una optimización avanzada únicamente a los bloques de código que se ejecutan varias veces (no es necesario optimizar código que raramente se ejecuta). En el ejemplo de abajo, las primeras ejecuciones no están bien optimizadas, por lo que quizás querríamos agregar ejecuciones antes de realizar el benchmark, a modo de “precalentamiento”:

      
        
        
          // Agregamos las funciones, antes de realizar el *benchmark*, a modo de "precalentamiento"
bench(diffSubtract);
bench(diffGetTime);

// Ahora sí realizamos el benchmark
for (let i = 0; i < 10; i++) {
  time1 += bench(diffSubtract);
  time2 += bench(diffGetTime);
}
        
      
      
      
            Cuidado con los micro-benchmarks
            Los motores Modernos de JavaScript realizan varias optimizaciones al ejecutar código. Esto podría alterar los resultados de las “pruebas artificiales” respecto del “uso normal”, especialmente cuando hacemos un benchmark tan pequeño, como por ejemplo: el funcionamiento de un operador o una función incorporada de JavaScript. Por esta razón, si se quiere entender más en profundidad cómo funciona la performance, se recomienda estudiar el funcionamiento del motor de JavaScript. Probablemente no necesites realizar microbenchmarks en absoluto.
Se pueden encontrar una gran cantidad de artículos acerca del motor V8 en http://mrale.ph.

Date.parse a partir de un stringEl método Date.parse(str) permite leer una fecha desde un string.
El formato del string debe ser: YYYY-MM-DDTHH:mm:ss.sssZ, donde:

YYYY-MM-DD – es la fecha: año-mes-día.
El carácter "T" se usa como delimitador.
HH:mm:ss.sss – es la hora: horas, minutos, segundos y milisegundos.
El carácter 'Z' es opcional y especifica la zona horaria, con el formato +-hh:mm. Si se incluye únicamente la letra Z equivale a UTC+0.

También es posible pasar como string variantes abreviadas, tales como YYYY-MM-DD o YYYY-MM o incluso YYYY.
La llamada del método Date.parse(str) convierte el string en el formato especificado y nos devuelve un timestamp (cantidad de milisegundos transcurridos desde el 1° de Enero de 1970 UTC+0). Si el formato del string no es válido, devuelve es NaN.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let ms = Date.parse("2012-01-26T13:51:50.417-07:00");

alert(ms); // 1327611110417  (timestamp)
        
      
      
      Podemos crear un objeto  new Date instantáneamente desde el timestamp:

      
        
        
          
            
          
          
            
          
        
        
          let date = new Date(Date.parse("2012-01-26T13:51:50.417-07:00"));

alert(date);
        
      
      
      Resumen
En JavaScript, la fecha y la hora se representan con el objeto Date. No es posible obtener sólo la fecha o sólo la hora: los objetos Date incluyen ambas.
Los meses se cuentan desde el cero (sí: enero es el mes cero).
Los días de la semana en getDay() también se cuentan desde el cero (que corresponde al día Domingo).
El objeto Date se autocorrige cuando recibe un componente fuera de rango. Es útil para sumar o restar días/meses/horas.
Las fechas se pueden restar entre sí, dando el resultado expresado en milisegundos: esto se debe a que el objeto Date toma el valor del timestamp cuando es convertido a número.
Para obtener el timestamp actual de manera inmediata se utiliza Date.now().

Nótese que, a diferencia de otros sistemas, los timestamps en JavaScript están representados en milisegundos (ms), no en segundos.
Suele suceder que necesitemos tomar medidas de tiempo más precisas. En sí, JavaScript no tiene incorporada una manera de medir el tiempo en microsegundos (1 millonésima parte de segundo), pero la mayoría de los entornos de ejecución sí lo permiten. Por ejemplo, el navegador posee performance.now() que nos permite saber la cantidad de milisegundos que tarda una página en cargar, con una precisión de microsegundos (3 dígitos después del punto):

      
        
        
          
            
          
          
            
          
        
        
          alert(`La carga de la página comenzó hace ${performance.now()}ms`);
// Devuelve algo así como: "La carga de la página comenzó hace 34731.26000000001ms"
// los dígitos .26 son microsegundos (260 microsegundos)
// Sólo los 3 primeros dígitos después del punto decimal son correctos, los demás son errores de precisión.
        
      
      
      Node.js posee el módulo microtime, entre otros. Prácticamente casi cualquier dispositivo y entorno de ejecución permite mayor precisión, sólo que no es posible almacenarla en Date.
TareasCrea una fechaimportancia: 5Crea un objeto Date para la fecha: Feb 20, 2012, 3:12am. La zona horaria es local.
Muéstralo en pantalla utilizando alert.
soluciónEl constructor new Date utiliza la zona horaria local. Lo único importante por recordar es que los meses se cuentan desde el 0.
Por ejemplo, febrero es el mes 1.
Aquí hay un ejemplo con números como componentes de fecha:

      
        
        
          
            
          
          
            
          
        
        
          //new Date(año, mes, día, hora, minuto, segundo, milisegundo)
let d1 = new Date(2012, 1, 20, 3, 12);
alert( d1 );
        
      
      
      También podríamos crear una fecha a partir de un string, así:

      
        
        
          
            
          
          
            
          
        
        
          //new Date(datastring)
let d2 = new Date("2012-02-20T03:12");
alert( d2 );
        
      
      
      Muestra en pantalla un día de la semanaimportancia: 5Escribe una función getWeekDay(date) para mostrar el día de la semana en formato corto: ‘MO’, ‘TU’, ‘WE’, ‘TH’, ‘FR’, ‘SA’, ‘SU’.
Por ejemplo:

      
        
        
          let date = new Date(2012, 0, 3);  // 3 Jan 2012
alert( getWeekDay(date) );        // debería mostrar "TU"
        
      
      
      Abrir en entorno controlado con pruebas.soluciónEl método date.getDay() devuelve el número del día de la semana, empezando por el domingo.
Hagamos un array de días de la semana, así podemos obtener el nombre del día a través de su número correspondiente.

      
        
        
          
            
          
          
            
          
        
        
          function getWeekDay(date) {
  let days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];

  return days[date.getDay()];
}

let date = new Date(2014, 0, 3); // 3 Jan 2014
alert( getWeekDay(date) ); // FR
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Día de la semana europeoimportancia: 5En los países europeos se cuentan los días de la semana a partir del lunes (número 1), seguido del martes (número 2), hasta el domingo (número 7). Escribe una función getLocalDay(date) que devuelva el día de la semana “europeo” para la variable date.

      
        
        
          let date = new Date(2012, 0, 3);  // 3 Jan 2012
alert( getLocalDay(date) );       // tuesday, should show 2
        
      
      
      Abrir en entorno controlado con pruebas.solución
      
        
        
          function getLocalDay(date) {

  let day = date.getDay();

  if (day == 0) { // weekday 0 (sunday) is 7 in european
    day = 7;
  }

  return day;
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.¿Qué día del mes era hace algunos días atrás?importancia: 4Crea una función getDateAgo(date, days) que devuelva el día del mes que corresponde, contando la cantidad de días days respecto de la fecha date.
Por ejemplo, si hoy es 20, entonces getDateAgo(new Date(), 1) debería ser 19 y getDateAgo(new Date(), 2) debería ser 18.
Debe poder funcionar para days=365 o más:

      
        
        
          let date = new Date(2015, 0, 2);

alert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
alert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
alert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)
        
      
      
      P.D.: La función no debería modificar la fecha date pasada como argumento.
Abrir en entorno controlado con pruebas.soluciónLa idea es simple: restarle a la fecha date la cantidad de días especificada.

      
        
        
          function getDateAgo(date, days) {
  date.setDate(date.getDate() - days);
  return date.getDate();
}
        
      
      
      …Pero la función no debería modificar la fecha date. Esto es importante, ya que no se espera que cambie la variable externa que contiene la fecha.
Para hacerlo, clonemos la fecha de esta manera:

      
        
        
          
            
          
          
            
          
        
        
          function getDateAgo(date, days) {
  let dateCopy = new Date(date);

  dateCopy.setDate(date.getDate() - days);
  return dateCopy.getDate();
}

let date = new Date(2015, 0, 2);

alert( getDateAgo(date, 1) ); // 1, (1 Jan 2015)
alert( getDateAgo(date, 2) ); // 31, (31 Dec 2014)
alert( getDateAgo(date, 365) ); // 2, (2 Jan 2014)
        
      
      
      Abrir la solución con pruebas en un entorno controlado.¿Cuál es el último día del mes?importancia: 5Escribe una función getLastDayOfMonth(year, month) que devuelva el último día del mes dado. A veces es 30, 31 o incluso 28/29 para febrero.
Parámetros:

year – el año en formato de cuatro dígitos, por ejemplo 2012.
month – el mes, de 0 a 11.

Por ejemplo, getLastDayOfMonth(2012, 1) = 29 (febrero, año bisiesto).
Abrir en entorno controlado con pruebas.soluciónCreemos una fecha utilizando el mes próximo, pero pasando 0 como número de día:

      
        
        
          
            
          
          
            
          
        
        
          function getLastDayOfMonth(year, month) {
  let date = new Date(year, month + 1, 0);
  return date.getDate();
}

alert( getLastDayOfMonth(2012, 0) ); // 31
alert( getLastDayOfMonth(2012, 1) ); // 29
alert( getLastDayOfMonth(2013, 1) ); // 28
        
      
      
      Normalmente, las fechas comienzan a partir del 1, sin embargo podemos pasar como argumento cualquier número, ya que se corregirá automáticamente. De esta manera, si pasamos el número 0 como día, se interpreta como “el día anterior al primer día del mes”, o en otras palabras: “el último día del mes anterior”.
Abrir la solución con pruebas en un entorno controlado.¿Cuántos segundos transcurrieron el día de hoy?importancia: 5Escribe una función getSecondsToday() que devuelva la cantidad de segundos transcurridos desde el comienzo del día.
Por ejemplo, si en este momento fueran las 10:00 am, sin horario de verano, entonces:

      
        
        
          getSecondsToday() == 36000 // (3600 * 10)
        
      
      
      La función debe poder funcionar correctamente cualquier día. Es decir, no debe poseer valores fijos en el código, como por ej. “today”.
soluciónPara obtener la cantidad de segundos, podemos generar una fecha en la variable “today” utilizando el día de hoy con la hora en 00:00:00, y luego restárselo a la variable “now”.
El resultado será la cantidad de milisegundos transcurridos desde el comienzo del día, el cual debemos dividir por 1000 para pasarlo a segundos:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToday() {
  let now = new Date();

  // creamos un objeto que contenga el día/mes/año actual
  let today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

  let diff = now - today; // diferencia entre fechas, representado en ms
  return Math.round(diff / 1000); // pasaje a segundos
}

alert( getSecondsToday() );
        
      
      
      Una solución alternativa sería obtener las horas/minutos/segundos actuales y pasar todo a segundos:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToday() {
  let d = new Date();
  return d.getHours() * 3600 + d.getMinutes() * 60 + d.getSeconds();
}

alert( getSecondsToday() );
        
      
      
      ¿Cuantos segundos faltan para el día de mañana?importancia: 5Crea una función getSecondsToTomorrow() que devuelva la cantidad de segundos que faltan para el día de mañana.
Por ejemplo, si ahora son las 23:00, entonces:

      
        
        
          getSecondsToTomorrow() == 3600
        
      
      
      P.D.: La función debe poder funcionar para cualquier día, sin valores fijos en el código como “today”.
soluciónPara obtener la cantidad de milisegundos que faltan para mañana, podemos restarle la fecha actual a “mañana 00:00:00”.
Primero generamos ese “mañana” y luego restamos:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToTomorrow() {
  let now = new Date();

  // el día de mañana
  let tomorrow = new Date(now.getFullYear(), now.getMonth(), now.getDate()+1);

  let diff = tomorrow - now; // diferencia en ms
  return Math.round(diff / 1000); // conversión a segundos
}
        
      
      
      Solución alternativa:

      
        
        
          
            
          
          
            
          
        
        
          function getSecondsToTomorrow() {
  let now = new Date();
  let hour = now.getHours();
  let minutes = now.getMinutes();
  let seconds = now.getSeconds();
  let totalSecondsToday = (hour * 60 + minutes) * 60 + seconds;
  let totalSecondsInADay = 86400;

  return totalSecondsInADay - totalSecondsToday;
}
        
      
      
      Ten en cuenta que algunos países tienen horarios de verano (DST), así que es posible que existan días con 23 o 25 horas. Podríamos querer tratar estos días por separado.
Cambia el formato a fecha relativaimportancia: 4Escribe una función formatDate(date) que muestre la fecha en el siguiente formato:

Si a partir de la fecha date pasó menos de 1 segundo, debe devolver "ahora mismo".
De no ser así, si a partir de la fecha date pasó menos de 1 minuto, debe retornar "hace n seg,".
De no ser así, si pasó menos de una hora, debe retornar "hace n min.".
De no ser así, debe retornar la fecha completa en el formato "DD.MM.AA HH:mm". Es decir: "día.mes.año horas:minutos", cada uno de ellos en formato de 2 dígitos, por ej. 31.12.16 10:00.

For instance:

      
        
        
          alert( formatDate(new Date(new Date - 1)) ); // "ahora mismo"

alert( formatDate(new Date(new Date - 30 * 1000)) ); // "hace 30 seg."

alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // "hace 5 min."

// la fecha de ayer en formato 31.12.16 20:00
alert( formatDate(new Date(new Date - 86400 * 1000)) );
        
      
      
      Abrir en entorno controlado con pruebas.soluciónPara obtener el tiempo que transcurrió desde la fecha date hasta ahora, restemos ambas fechas entre sí.

      
        
        
          
            
          
          
            
          
        
        
          function formatDate(date) {
  let diff = new Date() - date; // la diferencia entre ambas, representada en milisegundos

  if (diff < 1000) { // menos de 1 segundo
    return 'ahora mismo';
  }

  let sec = Math.floor(diff / 1000); // convierte el resultado en segundos

  if (sec < 60) {
    return 'hace ' sec + ' seg.';
  }

  let min = Math.floor(diff / 60000); // convierte el resultado en minutos
  if (min < 60) {
    return 'hace ' + min + ' min.';
  }

  // cambia le formato de la fecha
  // se le agrega un dígito 0 al día/mes/horas/minutos que contenga un único digito.
  let d = date;
  d = [
    '0' + d.getDate(),
    '0' + (d.getMonth() + 1),
    '' + d.getFullYear(),
    '0' + d.getHours(),
    '0' + d.getMinutes()
  ].map(component => component.slice(-2)); // toma los últimos 2 dígitos de cada componente

  // une los componentes para formar una única fecha
  return d.slice(0, 3).join('.') + ' ' + d.slice(3).join(':');
}

alert( formatDate(new Date(new Date - 1)) ); // "ahora mismo"

alert( formatDate(new Date(new Date - 30 * 1000)) ); // "hace 30 seg."

alert( formatDate(new Date(new Date - 5 * 60 * 1000)) ); // "hace 5 min."

// la fecha de ayer en formato 31.12.2016 20:00
alert( formatDate(new Date(new Date - 86400 * 1000)) );
        
      
      
      Solución alternativa:

      
        
        
          
            
          
          
            
          
        
        
          function formatDate(date) {
  let dayOfMonth = date.getDate();
  let month = date.getMonth() + 1;
  let year = date.getFullYear();
  let hour = date.getHours();
  let minutes = date.getMinutes();
  let diffMs = new Date() - date;
  let diffSec = Math.round(diffMs / 1000);
  let diffMin = diffSec / 60;
  let diffHour = diffMin / 60;

  // dándole formato
  year = year.toString().slice(-2);
  month = month < 10 ? '0' + month : month;
  dayOfMonth = dayOfMonth < 10 ? '0' + dayOfMonth : dayOfMonth;
  hour = hour < 10 ? '0' + hour : hour;
  minutes = minutes < 10 ? '0' + minutes : minutes;

  if (diffSec < 1) {
    return 'ahora mismo';
  } else if (diffMin < 1) {
    return `hace ${diffSec} seg.`
  } else if (diffHour < 1) {
    return `hace ${diffMin} min.`
  } else {
    return `${dayOfMonth}.${month}.${year} ${hour}:${minutes}`
  }
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/date" 
},
{
	"docs_id": "49",
	"name": "Métodos JSON, toJSON",
	"description": "Digamos que tenemos un objeto complejo y nos gustaría convertirlo en un string (cadena de caracteres), para enviarlos por la red, o simplemente mostrarlo para fines de registro.",
	"content": "Digamos que tenemos un objeto complejo y nos gustaría convertirlo en un string (cadena de caracteres), para enviarlos por la red, o simplemente mostrarlo para fines de registro.
Naturalmente, tal string debe incluir todas las propiedades importantes.
Podríamos implementar la conversión de esta manera:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,

  toString() {
    return `{name: "${this.name}", age: ${this.age}}`;
  }
};

alert(user); // {name: "John", age: 30}
        
      
      
      …Pero en el proceso de desarrollo se agregan nuevas propiedades, y otras son renombradas y eliminadas. Actualizar el toString cada vez se vuelve penoso. Podemos intentar recorrer las propiedades, pero ¿qué pasa si el objeto es complejo y tiene objetos anidados en las propiedades? Vamos a necesitar implementar su conversión también.
Por suerte no hay necesidad de escribir el código para manejar todo esto. La tarea ya ha sido resuelta.
JSON.stringifyJSON (Notación de objeto JavaScript) es un formato general para representar valores y objetos. Se lo describe como el estándar RFC 4627. En un principio fue creado para Javascript, pero varios lenguajes tienen librerías para manejarlo también. Por lo tanto es fácil utilizar JSON para intercambio de información cuando el cliente utiliza JavaScript y el servidor está escrito en Ruby, PHP, Java, lo que sea.
JavaScript proporciona métodos:

JSON.stringify para convertir objetos a JSON.
JSON.parse para convertir JSON de vuelta a un objeto.

Por ejemplo, aquí hacemos JSON.stringify a student:

      
        
        
          
            
          
          
            
          
        
        
          let student = {
  name: 'John',
  age: 30,
  isAdmin: false,
  courses: ['html', 'css', 'js'],
  spouse: null
};

let json = JSON.stringify(student);

alert(typeof json); // ¡obtenemos un string!

alert(json);
/* Objeto JSON-codificado:
{
  "name": "John",
  "age": 30,
  "isAdmin": false,
  "courses": ["html", "css", "js"],
  "spouse": null
}
*/
        
      
      
      El método JSON.stringify(student) toma al objeto y lo convierte a un string.
La cadena de caracteres json resultante se llama objeto JSON-codificado o serializado o convertido a String o reunido. Estamos listos para enviarlo por la red o colocarlo en el almacenamiento de información simple.
Por favor tomar nota que el objeto JSON-codificado tiene varias diferencias importantes con el objeto literal:

Los strings utilizan comillas dobles. No hay comillas simples o acentos abiertos en JSON. Por lo tanto 'John' pasa a ser "John".
Los nombres de propiedades de objeto también llevan comillas dobles. Eso es obligatorio. Por lo tanto age:30 pasa a ser "age":30.

JSON.stringify puede ser aplicado a los tipos de datos primitivos también.
JSON admite los siguientes tipos de datos:

Objects { ... }
Arrays [ ... ]
Primitives:

strings,
numbers,
boolean values true/false,
null.



Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // un número en JSON es sólo un número
alert( JSON.stringify(1) ) // 1

// un string en JSON sigue siendo una cadena de caracteres, pero con comillas dobles
alert( JSON.stringify('test') ) // "test"

alert( JSON.stringify(true) ); // true

alert( JSON.stringify([1, 2, 3]) ); // [1,2,3]
        
      
      
      JSON es una especificación de sólo datos independiente del lenguaje, por lo tanto algunas propiedades de objeto específicas de Javascript son omitidas por JSON.stringify.
A saber:

Propiedades de funciones (métodos).
Propiedades simbólicas.
Propiedades que almacenan undefined.


      
        
        
          
            
          
          
            
          
        
        
          let user = {
  sayHi() { // ignorado
    alert("Hello");
  },
  [Symbol("id")]: 123, // ignorado
  something: undefined // ignorado
};

alert( JSON.stringify(user) ); // {} (objeto vacío)
        
      
      
      Normalmente esto está bien. Si esto no es lo que queremos, pronto veremos cómo personalizar el proceso.
Lo mejor es que se permiten objetos anidados y se convierten automáticamente.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let meetup = {
  title: "Conference",
  room: {
    number: 23,
    participants: ["john", "ann"]
  }
};

alert( JSON.stringify(meetup) );
/* La estructura completa es convertida a String:
{
  "title":"Conference",
  "room":{"number":23,"participants":["john","ann"]},
}
*/
        
      
      
      La limitación importante: no deben existir referencias circulares.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: ["john", "ann"]
};

meetup.place = room;       // meetup tiene referencia a room
room.occupiedBy = meetup; // room hace referencia a meetup

JSON.stringify(meetup); // Error: Convirtiendo estructura circular a JSON
        
      
      
      Aquí, la conversión falla debido a una referencia circular: room.occupiedBy hace referencia a meetup, y meetup.place hace referencia a room:

      
      
        
      
      Excluyendo y transformando: sustitutoLa sintaxis completa de JSON.stringify es:

      
        
        
          let json = JSON.stringify(value[, replacer, space])
        
      
      
      
value
Un valor para codificar.
replacer
Array de propiedades para codificar o una función de mapeo function(propiedad, valor).
space
Cantidad de espacio para usar para el formateo

La mayor parte del tiempo, JSON.stringify es utilizado con el primer argumento unicamente. Pero si necesitamos ajustar el proceso de sustitución, como para filtrar las referencias circulares, podemos utilizar el segundo argumento de JSON.stringify.
Si pasamos un array de propiedades a él, solamente éstas propiedades serán codificadas.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup hace referencia a room
};

room.occupiedBy = meetup; // room hace referencia a meetup

alert( JSON.stringify(meetup, ['title', 'participants']) );
// {"title":"Conference","participants":[{},{}]}
        
      
      
      Aquí probablemente seamos demasiado estrictos. La lista de propiedades se aplica a toda la estructura de objeto. Por lo tanto los objetos en participants están vacíos, porque name no está en la lista.
Incluyamos en la lista todas las propiedades excepto room.occupiedBy esto causaría la referencia circular:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup hace referencia a room
};

room.occupiedBy = meetup; // room hace referencia a meetup

alert( JSON.stringify(meetup, ['title', 'participants', 'place', 'name', 'number']) );
/*
{
  "title":"Conference",
  "participants":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      Ahora todo con excepción de occupiedBy está serializado. Pero la lista de propiedades es bastante larga.
Por suerte podemos utilizar una función en lugar de un array como el sustituto.
La función se llamará para cada par de (propiedad, valor) y debe devolver el valor “sustituido”, el cual será utilizado en lugar del original. O undefined si el valor va a ser omitido.
En nuestro caso, podemos devolver value “tal cual” para todo excepto occupiedBy. Para ignorar occupiedBy, el código de abajo devuelve undefined:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  participants: [{name: "John"}, {name: "Alice"}],
  place: room // meetup hace referencia a room
};

room.occupiedBy = meetup; // room hace referencia a meetup

alert( JSON.stringify(meetup, function replacer(key, value) {
  alert(`${key}: ${value}`);
  return (key == 'occupiedBy') ? undefined : value;
}));

/* pares de propiedad:valor que llegan a replacer:
:             [object Object]
title:        Conference
participants: [object Object],[object Object]
0:            [object Object]
name:         John
1:            [object Object]
name:         Alice
place:        [object Object]
number:       23
occupiedBy: [object Object]
*/
        
      
      
      Por favor tenga en cuenta que la función replacer recibe todos los pares de propiedad/valor incluyendo objetos anidados y elementos de array. Se aplica recursivamente. El valor de this dentro de replacer es el objeto que contiene la propiedad actual.
El primer llamado es especial. Se realiza utilizando un “Objeto contenedor” especial: {"": meetup}. En otras palabras, el primer par  (propiedad, valor) tiene una propiedad vacía, y el valor es el objeto objetivo como un todo. Es por esto que la primer línea es ":[object Object]" en el ejemplo de arriba.
La idea es proporcionar tanta capacidad para replacer como sea posible: tiene una oportunidad de analizar y reemplazar/omitir incluso el objeto entero si es necesario.
Formato: espacioEl tercer argumento de JSON.stringify(value, replacer, space) es el número de espacios a utilizar para un formato agradable.
Anteriormente todos los objetos convertidos a String no tenían sangría ni espacios adicionales. Eso está bien si queremos enviar un objeto por la red. El argumento space es utilizado exclusivamente para una salida agradable.
Aquí space = 2 le dice a JavaScript que muestre objetos anidados en varias líneas, con sangría de 2 espacios dentro de un objeto:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 25,
  roles: {
    isAdmin: false,
    isEditor: true
  }
};

alert(JSON.stringify(user, null, 2));
/* sangría de dos espacios:
{
  "name": "John",
  "age": 25,
  "roles": {
    "isAdmin": false,
    "isEditor": true
  }
}
*/

/* para JSON.stringify(user, null, 4) el resultado sería más indentado:
{
    "name": "John",
    "age": 25,
    "roles": {
        "isAdmin": false,
        "isEditor": true
    }
}
*/
        
      
      
      El tercer argumento puede ser también string. En ese caso el string será usado como indentación en lugar de un número de espacios.
El argumento space es utilizado únicamente para propósitos de registro y agradable impresión.
“toJSON” PersonalizadoTal como toString para conversión de String, un objeto puede proporcionar el método toJSON para conversión a JSON. JSON.stringify automáticamente la llama si está disponible.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  date: new Date(Date.UTC(2017, 0, 1)),
  room
};

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "date":"2017-01-01T00:00:00.000Z",  // (1)
    "room": {"number":23}               // (2)
  }
*/
        
      
      
      Aquí podemos ver que date (1) se convirtió en un string. Esto es debido a que todas las fechas tienen un método toJSON incorporado que devuelve este tipo de string.
Ahora incluyamos un toJSON personalizado para nuestro objeto room (2):

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23,
  toJSON() {
    return this.number;
  }
};

let meetup = {
  title: "Conference",
  room
};

alert( JSON.stringify(room) ); // 23

alert( JSON.stringify(meetup) );
/*
  {
    "title":"Conference",
    "room": 23
  }
*/
        
      
      
      Como podemos ver, toJSON es utilizado para ambos el llamado directo  JSON.stringify(room) y cuando room está anidado en otro objeto codificado.
JSON.parsePara decodificar un string JSON, necesitamos otro método llamado JSON.parse.
La sintaxis:

      
        
        
          let value = JSON.parse(str, [reviver]);
        
      
      
      
str
string JSON para analizar.
reviver
function(key,value) opcional que será llamado para cada par (propiedad, valor) y puede transformar el valor.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // array convertido en String
let numbers = "[0, 1, 2, 3]";

numbers = JSON.parse(numbers);

alert( numbers[1] ); // 1
        
      
      
      O para objetos anidados:

      
        
        
          
            
          
          
            
          
        
        
          let userData = '{ "name": "John", "age": 35, "isAdmin": false, "friends": [0,1,2,3] }';

let user = JSON.parse(userData);

alert( user.friends[1] ); // 1
        
      
      
      El JSON puede ser tan complejo como sea necesario, los objetos y arrays pueden incluir otros objetos y arrays. Pero deben cumplir el mismo formato JSON.
Aquí algunos de los errores más comunes al escribir JSON a mano (a veces tenemos que escribirlo por debugging):

      
        
        
          let json = `{
  name: "John",                     // error: nombre de propiedad sin comillas
  "surname": 'Smith',               // error: comillas simples en valor (debe ser doble)
  'isAdmin': false                  // error: comillas simples en propiedad (debe ser doble)
  "birthday": new Date(2000, 2, 3), // error: no se permite "new", únicamente valores simples
  "friends": [0,1,2,3]              // aquí todo bien
}`;
        
      
      
      Además, JSON no admite comentarios. Agregar un comentario a JSON lo hace inválido.
Existe otro formato llamado JSON5, que permite propiedades sin comillas, comentarios, etcétera. Pero es una librería independiente, no una especificación del lenguaje.
El JSON normal es tan estricto no porque sus desarrolladores sean flojos, sino para permitir la implementación fácil, confiable y muy rápida del algoritmo analizador.
Utilizando reactivadorImagina esto, obtenemos un objeto meetup convertido en String desde el servidor.
Se ve así:

      
        
        
          // title: (meetup title), date: (meetup date)
let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';
        
      
      
      …Y ahora necesitamos deserializarlo, para convertirlo de vuelta a un objeto JavaScript.
Hagámoslo llamando a JSON.parse:

      
        
        
          
            
          
          
            
          
        
        
          let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str);

alert( meetup.date.getDate() ); // Error!
        
      
      
      ¡Upss! ¡Un error!
El valor de meetup.date es un string, no un objeto Date. Cómo puede saber JSON.parse que debe transformar ese string a una Date?
Le pasemos a JSON.parse la función reactivadora como el segundo argumento, esto devuelve todos los valores “tal cual”, pero date se convertirá en una Date:

      
        
        
          
            
          
          
            
          
        
        
          let str = '{"title":"Conference","date":"2017-11-30T12:00:00.000Z"}';

let meetup = JSON.parse(str, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( meetup.date.getDate() ); // ¡Ahora funciona!
        
      
      
      Por cierto, esto funciona también para objetos anidados:

      
        
        
          
            
          
          
            
          
        
        
          let schedule = `{
  "meetups": [
    {"title":"Conference","date":"2017-11-30T12:00:00.000Z"},
    {"title":"Birthday","date":"2017-04-18T12:00:00.000Z"}
  ]
}`;

schedule = JSON.parse(schedule, function(key, value) {
  if (key == 'date') return new Date(value);
  return value;
});

alert( schedule.meetups[1].date.getDate() ); // ¡Funciona!
        
      
      
      Resumen
JSON es un formato de datos que tiene su propio estándar independiente y librerías para la mayoría de los lenguajes de programación.
JSON admite objetos simples, arrays, strings, números, booleanos y null.
JavaScript proporciona los métodos JSON.stringify para serializar en JSON y JSON.parse para leer desde JSON.
Ambos métodos admiten funciones transformadoras para lectura/escritura inteligente.
Si un objeto tiene toJSON, entonces es llamado porJSON.stringify.

TareasConvierte el objeto en JSON y de vueltaimportancia: 5Convierte el user a JSON y luego léalo de vuelta en otra variable.

      
        
        
          let user = {
  name: "John Smith",
  age: 35
};
        
      
      
      solución
      
        
        
          let user = {
  name: "John Smith",
  age: 35
};

let user2 = JSON.parse(JSON.stringify(user));
        
      
      
      Excluir referencias circularesimportancia: 5En casos simples de referencias circulares, podemos excluir una propiedad infractora de la serialización por su nombre.
Pero a veces no podemos usar el nombre, ya que puede usarse tanto en referencias circulares como en propiedades normales. Entonces podemos verificar la propiedad por su valor.
Escriba la función replacer para convertir todo a string, pero elimine las propiedades que hacen referencia a meetup:

      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  occupiedBy: [{name: "John"}, {name: "Alice"}],
  place: room
};

// referencias circulares
room.occupiedBy = meetup;
meetup.self = meetup;

alert( JSON.stringify(meetup, function replacer(key, value) {
  /* tu código */
}));

/* el resultado debería ser:
{
  "title":"Conference",
  "occupiedBy":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          let room = {
  number: 23
};

let meetup = {
  title: "Conference",
  occupiedBy: [{name: "John"}, {name: "Alice"}],
  place: room
};

room.occupiedBy = meetup;
meetup.self = meetup;

alert( JSON.stringify(meetup, function replacer(key, value) {
  return (key != "" && value == meetup) ? undefined : value;
}));

/*
{
  "title":"Conference",
  "occupiedBy":[{"name":"John"},{"name":"Alice"}],
  "place":{"number":23}
}
*/
        
      
      
      Aquí también necesitamos verificar key=="" para excluir el primer llamado donde es normal que valor sea meetup.
",
	"url": "https://es.javascript.info/json" 
},
{
	"docs_id": "50",
	"name": "",
	"description": "Aquí aprenderemos JavaScript, empezando desde cero y llegaremos hasta conceptos avanzados como POO.",
	"content": "Parte 1El lenguaje JavaScriptParte 2El navegador: Documentos, Eventos e InterfacesParte 3Artículos adicionalesEl lenguaje JavaScriptAquí aprenderemos JavaScript, empezando desde cero y llegaremos hasta conceptos avanzados como POO.
Nos concentraremos en el lenguaje mismo con el mínimo de notas específicas del entorno.
Una introducciónUna introducción a JavaScriptManuales y especificacionesEditores de CódigoConsola de desarrolladorFundamentos de JavaScript¡Hola, mundo!Estructura del códigoEl modo moderno, "use strict"VariablesTipos de datosInteracción: alert, prompt, confirmConversiones de TiposOperadores básicos, matemáticasComparacionesEjecución condicional: if, '?'Operadores LógicosOperador Nullish Coalescing '??'Bucles: while y forLa sentencia "switch"FuncionesExpresiones de funciónFunciones Flecha, lo básicoEspeciales JavaScriptMás…Calidad del códigoDebugging en el navegadorEstilo de codificaciónComentariosCódigo ninjaTest automatizados con MochaPolyfills y transpiladoresObjetos: lo básicoObjetosReferencias de objetos y copiaRecolección de basuraMétodos del objeto, "this"Constructor, operador "new"Encadenamiento opcional '?.'Tipo SymbolConversión de objeto a valor primitivoTipos de datosMétodos en tipos primitivosNúmerosStringsArraysMétodos de arraysIterablesMap y SetWeakMap y WeakSetObject.keys, values, entriesAsignación desestructuranteFecha y HoraMétodos JSON, toJSONMás…Trabajo avanzado con funcionesRecursión y pilaParámetros Rest y operador SpreadÁmbito de Variable y el concepto "closure"La vieja "var"Objeto GlobalFunción como objeto, NFELa sintaxis "new Function"Planificación: setTimeout y setIntervalDecoradores y redirecciones, call/applyFunción bind: vinculación de funcionesFunciones de flecha revisadasMás…Configuración de las propiedades de objetosIndicadores y descriptores de propiedad"Getters" y "setters" de propiedadPrototipos y herenciaHerencia prototípicaF.prototypePrototipos nativosMétodos prototipo, objetos sin __proto__ClasesSintaxis básica de `class`Herencia de clasePropiedades y métodos estáticos.Propiedades y métodos privados y protegidos.Ampliación de clases integradasComprobación de clase: "instanceof"Los MixinsManejo de erroresManejo de errores, "try...catch"Errores personalizados, extendiendo ErrorPromesas y async/awaitIntroducción: callbacksPromesaEncadenamiento de promesasManejo de errores con promesasPromise APIPromisificaciónMicrotareas (Microtasks)Async/awaitGeneradores e iteración avanzadaGeneradoresIteradores y generadores asíncronosMódulosMódulos, introducciónExport e ImportImportaciones dinámicasTemas diversosProxy y ReflectEval: ejecutando una cadena de códigoCurrificaciónTipo de ReferenciaBigIntEl navegador: Documentos, Eventos e InterfacesAprenderemos a manejar la página del navegador: agregar elementos, manipular su tamaño y posición, crear interfaces dinámicamente e interactuar con el visitante.
DocumentoEntorno del navegador, especificacionesÁrbol del Modelo de Objetos del Documento (DOM)Recorriendo el DOMBuscar: getElement*, querySelector*Propiedades del nodo: tipo, etiqueta y contenidoAtributos y propiedadesModificando el documentoEstilos y clasesTamaño de elementos y desplazamientoTamaño de ventana y desplazamientoCoordenadasMás…Introducción a los eventosIntroducción a los eventos en el navegadorPropagación y capturaDelegación de eventosAcciones predeterminadas del navegadorEnvío de eventos personalizadosEventos en la UIEventos del MouseMoviendo el mouse: mouseover/out, mouseenter/leaveArrastrar y Soltar con eventos del ratónEventos de punteroTeclado: keydown y keyupDesplazamientoFormularios y controlesPropiedades y Métodos de FormulariosEnfocado: enfoque/desenfoqueEventos: change, input, cut, copy, pasteFormularios: evento y método submitEl documento y carga de recursosPágina: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferCarga de recursos: onload y onerrorTemas diversosMutation observerSelection y RangeLoop de eventos: microtareas y macrotareasArtículos adicionalesLista de temas adicionales que supone que ha cubierto las dos primeras partes del tutorial. Aquí no hay una jerarquía clara, puede leer los artículos en el orden que desee.Marcos y ventanasVentanas emergentes y métodos de ventanaComunicación entre ventanasEl ataque de secuestro de clicsDatos binarios y archivosArrayBuffer, arrays binariosTextDecoder y TextEncoderBlobFile y FileReaderSolicitudes de redFetchFormDataFetch: Progreso de la descargaFetch: AbortFetch: Cross-Origin RequestsFetch APIObjetos URLXMLHttpRequestCarga de archivos reanudableSondeo largoWebSocketEventos enviados por el servidorMás…Almacenando datos en el navegadorCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimacionesCurva de BézierAnimaciones CSSAnimaciones JavaScriptComponentes WebDesde la altura orbitalElementos personalizadosShadow DOMElemento templateShadow DOM slots, composiciónEstilo Shadow DOMShadow DOM y eventosExpresiones RegularesPatrones y banderas (flags)Clases de caracteresUnicode: bandera "u" y clase \p{...}Anclas: inicio ^ y final $ de cadenaModo multilínea de anclas ^ $, bandera "m"Límite de palabra: \bEscapando, caracteres especialesConjuntos y rangos [...]Cuantificadores +, *, ? y {n}Cuantificadores codiciosos y perezososGrupos de capturaReferencias inversas en patrones: \N y \k<nombre>Alternancia (O) |Lookahead y lookbehind (revisar delante/detrás)Backtracking catastróficoIndicador adhesivo “y”, buscando en una posición.Métodos de RegExp y StringMás…{
  "@context": "http://schema.org",
  "@type": "WebSite",
  "url": "https://es.javascript.info/",
  "potentialAction": {
    "@type": "SearchAction",
    "target": "https://es.javascript.info/search?query={search_term_string}",
    "query-input": "required name=search_term_string"
  }
}",
	"url": "https://es.javascript.info#" 
},
{
	"docs_id": "51",
	"name": "Recursión y pila",
	"description": "Volvamos a las funciones y estudiémoslas más en profundidad.",
	"content": "Volvamos a las funciones y estudiémoslas más en profundidad.
Nuestro primer tema será la recursividad.
Si no eres nuevo en la programación, probablemente te resulte familiar y puedes saltarte este capítulo.
La recursión es un patrón de programación que es útil en situaciones en las que una tarea puede dividirse naturalmente en varias tareas del mismo tipo, pero más simples. O cuando una tarea se puede simplificar en una acción fácil más una variante más simple de la misma tarea. O, como veremos pronto, tratar con ciertas estructuras de datos.
Sabemos que cuando una función resuelve una tarea, en el proceso puede llamar a muchas otras funciones. Un caso particular de esto se da cuando una función se llama a sí misma. Esto es lo que se llama recursividad.
Dos formas de pensarPara comenzar con algo simple, escribamos una función pow(x, n) que eleve x a una potencia natural den. En otras palabras, multiplica x por sí mismo n veces.

      
        
        
          pow(2, 2) = 4
pow(2, 3) = 8
pow(2, 4) = 16
        
      
      
      Hay dos formas de implementarlo.


Pensamiento iterativo: el bucle for:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  let result = 1;

  // multiplicar el resultado por x n veces en el ciclo
  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}

alert( pow(2, 3) ); // 8
        
      
      
      

Pensamiento recursivo: simplifica la tarea y se llama a sí mismo:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) ); // 8
        
      
      
      

Note cómo la variante recursiva es fundamentalmente diferente.
Cuando se llama a pow(x, n), la ejecución se divide en dos ramas:

      
        
        
                        if n==1  = x
             /
pow(x, n) =
             \
              else     = x * pow(x, n - 1)
        
      
      
      
Si n == 1, entonces todo es trivial. Esto se llama base de la recursividad, porque produce inmediatamente el resultado obvio: pow (x, 1) es igual a x.
De lo contrario, podemos representar pow (x, n) como x * pow (x, n - 1). En matemáticas, uno escribiría xn = x * x n-1. Esto se llama paso recursivo: transformamos la tarea en una acción más simple (multiplicación por x) y una llamada más simple de la misma tarea (pow con menor n). Los siguientes pasos lo simplifican más y más hasta que n llegue a1.

También podemos decir que pow se llama a sí mismo recursivamente hasta quen == 1.

      
      
        
      
      Por ejemplo, para calcular pow (2, 4) la variante recursiva realiza estos pasos:

pow(2, 4) = 2 * pow(2, 3)
pow(2, 3) = 2 * pow(2, 2)
pow(2, 2) = 2 * pow(2, 1)
pow(2, 1) = 2

Por lo tanto, la recursión reduce una llamada de función a una más simple y luego… a una más simple, y así sucesivamente, hasta que el resultado se vuelve obvio.

            La recursión suele ser más corta
            Una solución recursiva suele ser más corta que una iterativa.
Aquí podemos reescribir lo mismo usando el operador condicional ? En lugar de if para hacer que pow (x, n) sea más conciso y aún bastante legible:

      
        
        
          
            
          
          
            
          
        
        
          function pow (x, n) {
   return (n == 1)? x: (x * pow (x, n - 1));
}
        
      
      
      
El número máximo de llamadas anidadas (incluida la primera) se llama profundidad de recursión. En nuestro caso, será exactamente n.
La profundidad máxima de recursión está limitada por el motor de JavaScript. Podemos confiar en que sea 10 000; algunos motores permiten más, pero 100 000 probablemente esté fuera del límite para la mayoría de ellos. Hay optimizaciones automáticas que ayudan a aliviar esto (“optimizaciones de llamadas de cola”), pero aún no tienen soporte en todas partes y funcionan solo en casos simples.
Eso limita la aplicación de la recursividad, pero sigue siendo muy amplia. Hay muchas tareas donde la forma recursiva de pensar proporciona un código más simple y fácil de mantener.
El contexto de ejecución y pilaAhora examinemos cómo funcionan las llamadas recursivas. Para eso espiemos lo que sucede bajo la capa en las funciones.
La información sobre el proceso de ejecución de una función en ejecución se almacena en su contexto de ejecución.
El contexto de ejecución es una estructura de datos interna que contiene detalles sobre la ejecución de una función: dónde está el flujo de control ahora, las variables actuales, el valor de this (que no usamos aquí) y algunos otros detalles internos.
Una llamada de función tiene exactamente un contexto de ejecución asociado.
Cuando una función realiza una llamada anidada, sucede lo siguiente:

La función actual se pausa.
El contexto de ejecución asociado con él se recuerda en una estructura de datos especial llamada pila de contexto de ejecución.
La llamada anidada se ejecuta.
Una vez que finaliza, el antiguo contexto de ejecución se recupera de la pila y la función externa se reanuda desde donde se pausó.

Veamos qué sucede durante la llamada de pow (2, 3).
pow (2, 3)Al comienzo de la llamada pow (2, 3) el contexto de ejecución almacenará variables: x = 2, n = 3, el flujo de ejecución está en la línea 1 de la función.
Podemos esbozarlo como:

  
    Context: { x: 2, n: 3, at line 1 }
    pow(2, 3)
  

Ahí es cuando la función comienza a ejecutarse. La condición n == 1 es falsa, por lo que el flujo continúa en la segunda rama de if:

      
        
        
          
            
          
          
            
          
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}

alert( pow(2, 3) );
        
      
      
      Las variables son las mismas, pero la línea cambia, por lo que el contexto es ahora:

  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

Para calcular x * pow (x, n - 1), necesitamos hacer una sub-llamada de pow con nuevos argumentospow (2, 2).
pow (2, 2)Para hacer una llamada anidada, JavaScript recuerda el contexto de ejecución actual en la pila de contexto de ejecución.
Aquí llamamos a la misma función pow, pero no importa en absoluto. El proceso es el mismo para todas las funciones:

El contexto actual se “recuerda” en la parte superior de la pila.
El nuevo contexto se crea para la subllamada.
Cuando finaliza la subllamada, el contexto anterior se extrae de la pila y su ejecución continúa.

Aquí está la pila de contexto cuando ingresamos la subllamada pow (2, 2):

  
    Context: { x: 2, n: 2, at line 1 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

El nuevo contexto de ejecución actual está en la parte superior (y en negrita), y los contextos recordados anteriores están debajo.
Cuando terminamos la subllamada: es fácil reanudar el contexto anterior, ya que mantiene ambas variables y el lugar exacto del código donde se detuvo.

            Por favor tome nota:
            En la figura usamos la palabra línea “line” porque en nuestro ejemplo hay solo una subllamada en línea, pero generalmente una simple línea de código puede contener múltiples subllamadas, como pow(…) + pow(…) + otraCosa(…).
Entonces sería más preciso decir que la ejecución se reanuda “inmediatamente después de la subllamada”.

pow(2, 1)El proceso se repite: se realiza una nueva subllamada en la línea 5, ahora con argumentosx = 2, n = 1.
Se crea un nuevo contexto de ejecución, el anterior se coloca en la parte superior de la pila:

  
    Context: { x: 2, n: 1, at line 1 }
    pow(2, 1)
  
  
    Context: { x: 2, n: 2, at line 5 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

Hay 2 contextos antiguos ahora y 1 actualmente en ejecución para pow (2, 1).
La salidaDurante la ejecución de pow (2, 1), a diferencia de antes, la condición n == 1 es verdadera, por lo que funciona la primera rama de if :

      
        
        
          function pow(x, n) {
  if (n == 1) {
    return x;
  } else {
    return x * pow(x, n - 1);
  }
}
        
      
      
      No hay más llamadas anidadas, por lo que la función finaliza y devuelve 2.
Cuando finaliza la función, su contexto de ejecución ya no es necesario y se elimina de la memoria. El anterior se restaura desde la parte superior de la pila:

  
    Context: { x: 2, n: 2, at line 5 }
    pow(2, 2)
  
  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

Se reanuda la ejecución de pow (2, 2). Tiene el resultado de la subllamada pow (2, 1), por lo que también puede finalizar la evaluación de x * pow (x, n - 1), devolviendo 4.
Luego se restaura el contexto anterior:

  
    Context: { x: 2, n: 3, at line 5 }
    pow(2, 3)
  

Cuando termina, tenemos un resultado de pow (2, 3) = 8.
La profundidad de recursión en este caso fue: 3.
Como podemos ver en las ilustraciones anteriores, la profundidad de recursión es igual al número máximo de contexto en la pila.
Tenga en cuenta los requisitos de memoria. Los contextos toman memoria. En nuestro caso, elevar a la potencia de n realmente requiere la memoria para n contextos, para todos los valores más bajos de n.
Un algoritmo basado en bucles ahorra más memoria:

      
        
        
          function pow(x, n) {
  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
        
      
      
      El pow iterativo utiliza un solo contexto, cambiando i y result en el proceso. Sus requisitos de memoria son pequeños, fijos y no dependen de n.
Cualquier recursión puede reescribirse como un bucle. La variante de bucle generalmente se puede hacer más eficaz.
… Pero a veces la reescritura no es trivial, especialmente cuando la función utiliza sub-llamadas recursivas diferentes según las condiciones y combina sus resultados, o cuando la ramificación es más intrincada. Y la optimización podría ser innecesaria y no merecer la pena el esfuerzo en absoluto.
La recursión puede dar un código más corto y fácil de entender y mantener. No se requiere optimización en todo lugar, principalmente lo que nos interesa es un buen código y por eso se usa.
Recorridos recursivosOtra gran aplicación de la recursión es un recorrido recursivo.
Imagina que tenemos una empresa. La estructura del personal se puede presentar como un objeto:

      
        
        
          let company = {
  sales: [{
    name: 'John',
    salary: 1000
  }, {
    name: 'Alice',
    salary: 1600
  }],

  development: {
    sites: [{
      name: 'Peter',
      salary: 2000
    }, {
      name: 'Alex',
      salary: 1800
    }],

    internals: [{
      name: 'Jack',
      salary: 1300
    }]
  }
};
        
      
      
      Vemos que esta empresa tiene departamentos.


Un departamento puede tener una gran variedad de personal. Por ejemplo, el departamento de ventas sales tiene 2 empleados: John y Alice.


O un departamento puede dividirse en subdepartamentos, como development que tiene dos ramas: sites e internals: cada uno de ellos tiene su propio personal.


También es posible que cuando un subdepartamento crece, se divida en subdepartamentos (o equipos).
Por ejemplo, el departamento sites en el futuro puede dividirse en equipos para siteA y siteB. Y ellos, potencialmente, pueden dividirse aún más. Eso no está en la imagen, es solo algo a tener en cuenta.


Ahora digamos que queremos una función para obtener la suma de todos los salarios. ¿Cómo podemos hacer eso?
Un enfoque iterativo no es fácil, porque la estructura no es simple. La primera idea puede ser hacer un bucle for sobre company con un sub-bucle anidado sobre departamentos de primer nivel. Pero luego necesitamos más sub-bucles anidados para iterar sobre el personal en los departamentos de segundo nivel como sites. …¿Y luego otro sub-bucle dentro de los de los departamentos de tercer nivel que podrían aparecer en el futuro? ¿Deberíamos parar en el nivel 3 o hacer 4 niveles de bucles? Si ponemos 3-4 bucles anidados en el código para atravesar un solo objeto, se vuelve bastante feo.
Probemos la recursividad.
Como podemos ver, cuando nuestra función hace que un departamento sume, hay dos casos posibles:

O bien es un departamento “simple” con una array de personas: entonces podemos sumar los salarios en un bucle simple.
O es un objeto con N subdepartamentos: entonces podemos hacer N llamadas recursivas para obtener la suma de cada uno de los subdepartamentos y combinar los resultados.

El primer caso es la base de la recursividad, el caso trivial, cuando obtenemos un array.
El segundo caso, cuando obtenemos un objeto, es el paso recursivo. Una tarea compleja se divide en subtareas para departamentos más pequeños. A su vez, pueden dividirse nuevamente, pero tarde o temprano la división terminará en (1).
El algoritmo es probablemente aún más fácil de leer desde el código:

      
        
        
          
            
          
          
            
          
        
        
          let company = { // el mismo objeto, comprimido por brevedad
  sales: [{name: 'John', salary: 1000}, {name: 'Alice', salary: 600 }],
  development: {
    sites: [{name: 'Peter', salary: 2000}, {name: 'Alex', salary: 1800 }],
    internals: [{name: 'Jack', salary: 1300}]
  }
};

// La función para hacer el trabajo
function sumSalaries(department) {
  if (Array.isArray(department)) { // caso (1)
    return department.reduce((prev, current) => prev + current.salary, 0); // suma del Array
  } else { // caso (2)
    let sum = 0;
    for (let subdep of Object.values(department)) {
      sum += sumSalaries(subdep); // llama recursivamente a subdepartamentos, suma los resultados
    }
    return sum;
  }
}

alert(sumSalaries(company)); // 7700
        
      
      
      El código es corto y fácil de entender (¿Quizás?). Ese es el poder de la recursividad. También funciona para cualquier nivel de anidamiento de subdepartamentos.
Aquí está el diagrama de llamadas:

      
      
        
      
      Podemos ver fácilmente el principio: para un objeto {...} se realizan subllamadas, mientras que los Arrays [...] son las “hojas” del árbol recursivo y dan un resultado inmediato.
Tenga en cuenta que el código utiliza funciones inteligentes que hemos cubierto antes:

Método arr.reduce explicado en el capítulo Métodos de arrays para obtener la suma del Array.
Bucle for (val of Object.values (obj)) para iterar sobre los valores del objeto: Object.values devuelve una matriz de ellos.

Estructuras recursivasUna estructura de datos recursiva (definida recursivamente) es una estructura que se replica en partes.
Lo acabamos de ver en el ejemplo de la estructura de la empresa anterior.
Un departamento de la empresa es:

O un array de personas.
O un objeto con departamentos.

Para los desarrolladores web hay ejemplos mucho más conocidos: documentos HTML y XML.
En el documento HTML, una etiqueta HTML puede contener una lista de:

Piezas de texto.
Comentarios HTML.
Otras etiquetas HTML (que a su vez pueden contener textos/comentarios, otras etiquetas, etc…).

Esa es, una vez más, una definición recursiva.
Para una mejor comprensión, cubriremos una estructura recursiva más llamada “Lista enlazada” que podría ser una mejor alternativa para las matrices en algunos casos.
Lista enlazadaImagina que queremos almacenar una lista ordenada de objetos.
La elección natural sería un array:

      
        
        
          let arr = [obj1, obj2, obj3];
        
      
      
      …Pero hay un problema con los Arrays. Las operaciones “eliminar elemento” e “insertar elemento” son costosas. Por ejemplo, la operación arr.unshift(obj) debe renumerar todos los elementos para dejar espacio para un nuevo obj, y si la matriz es grande, lleva tiempo. Lo mismo con arr.shift ().
Las únicas modificaciones estructurales que no requieren renumeración masiva son aquellas que operan con el final del array: arr.push/pop. Por lo tanto, un array puede ser bastante lento para grandes colas si tenemos que trabajar con el principio del mismo.
Como alternativa, si realmente necesitamos una inserción/eliminación rápida, podemos elegir otra estructura de datos llamada lista enlazada.
El elemento de lista enlazada se define de forma recursiva como un objeto con:

value.
propiedad next que hace referencia al siguiente elemento de lista enlazado o null si ese es el final.

Por ejemplo:

      
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
        
      
      
      Representación gráfica de la lista:

      
      
        
      
      Un código alternativo para la creación:

      
        
        
          let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };
list.next.next.next.next = null;
        
      
      
      Aquí podemos ver aún más claramente que hay varios objetos, cada uno tiene su value y un next apuntando al vecino. La variable list es el primer objeto en la cadena, por lo que siguiendo los punterosnext de ella podemos alcanzar cualquier elemento.
La lista se puede dividir fácilmente en varias partes y luego volver a unir:

      
        
        
          let secondList = list.next.next;
list.next.next = null;
        
      
      
      
      
      
        
      
      Para unir:

      
        
        
          list.next.next = secondList;
        
      
      
      Y seguro, podemos insertar o eliminar elementos en cualquier lugar.
Por ejemplo, para anteponer un nuevo valor, necesitamos actualizar el encabezado de la lista:

      
        
        
          let list = { value: 1 };
list.next = { value: 2 };
list.next.next = { value: 3 };
list.next.next.next = { value: 4 };

// anteponer el nuevo valor a la lista
list = { value: "new item", next: list };
        
      
      
      
      
      
        
      
      Para eliminar un valor del medio, cambie el next del anterior:

      
        
        
          list.next = list.next.next;
        
      
      
      
      
      
        
      
      Hicimos que list.next salte sobre 1 al valor 2. El valor 1 ahora está excluido de la cadena. Si no se almacena en ningún otro lugar, se eliminará automáticamente de la memoria.
A diferencia de los arrays, no hay renumeración en masa, podemos reorganizar fácilmente los elementos.
Naturalmente, las listas no siempre son mejores que los Arrays. De lo contrario, todos usarían solo listas.
El principal inconveniente es que no podemos acceder fácilmente a un elemento por su número. En un Array eso es fácil: arr[n] es una referencia directa. Pero en la lista tenemos que comenzar desde el primer elemento e ir siguiente N veces para obtener el enésimo elemento.
… Pero no siempre necesitamos tales operaciones. Por ejemplo, cuando necesitamos una cola o incluso un deque: la estructura ordenada que debe permitir agregar/eliminar elementos muy rápidamente desde ambos extremos.
Las “listas” pueden ser mejoradas:

Podemos agregar la propiedad prev (previo) junto a next (siguiente) para referenciar el elemento previo para mover hacia atrás fácilmente.
Podemos también agregar una variable llamada tail (cola) referenciando el último elemento de la lista (y actualizarla cuando se agregan/remueven elementos del final).
…La estructura de datos puede variar de acuerdo a nuestras necesidades.

ResumenGlosario:


Recursion es concepto de programación que significa que una función se llama a sí misma. Las funciones recursivas se pueden utilizar para resolver ciertas tareas de manera elegante.
Cada vez que una función se llama a sí misma ocurre un paso de recursión. La base de la recursividad se da cuando los argumentos de la función hacen que la tarea sea tan básica que la función no realiza más llamadas.


Una estructura de datos definida recursivamente es una estructura de datos que se puede definir utilizándose a sí misma.
Por ejemplo, la lista enlazada se puede definir como una estructura de datos que consiste en un objeto que hace referencia a una lista (o nulo).

      
        
        
          list = { value, next -> list }
        
      
      
      Los árboles como el árbol de elementos HTML o el árbol de departamentos de este capítulo también son naturalmente recursivos: se ramifican y cada rama puede tener otras ramas.
Las funciones recursivas se pueden usar para recorrerlas como hemos visto en el ejemplo sumSalary.


Cualquier función recursiva puede reescribirse en una iterativa. Y eso a veces es necesario para optimizar las cosas. Pero para muchas tareas, una solución recursiva es lo suficientemente rápida y fácil de escribir y mantener.
TareasSuma todos los números hasta el elegidoimportancia: 5Escribe una función sumTo(n) que calcule la suma de los números 1 + 2 + ... + n.
Por ejemplo:

      
        
        
          sumTo(1) = 1
sumTo(2) = 2 + 1 = 3
sumTo(3) = 3 + 2 + 1 = 6
sumTo(4) = 4 + 3 + 2 + 1 = 10
...
sumTo(100) = 100 + 99 + ... + 2 + 1 = 5050
        
      
      
      Escribe 3 soluciones diferentes:

Utilizando un bucle for.
Usando la recursividad, pues sumTo(n) = n + sumTo(n-1) para n > 1.
Utilizando la fórmula de progresión aritmética.

Un ejemplo del resultado:

      
        
        
          function sumTo(n) { /*... tu código ... */ }

alert( sumTo(100) ); // 5050
        
      
      
      P.D. ¿Qué variante de la solución es la más rápida? ¿Y la más lenta? ¿Por qué?
P.P.D. ¿Podemos usar la recursión para contar sumTo(100000)?
soluciónLa solución usando un bucle:

      
        
        
          
            
          
          
            
          
        
        
          function sumTo(n) {
  let sum = 0;
  for (let i = 1; i <= n; i++) {
    sum += i;
  }
  return sum;
}

alert( sumTo(100) );
        
      
      
      La solución usando recursividad:

      
        
        
          
            
          
          
            
          
        
        
          function sumTo(n) {
  if (n == 1) return 1;
  return n + sumTo(n - 1);
}

alert( sumTo(100) );
        
      
      
      La solución usando la fórmula: sumTo(n) = n*(n+1)/2:

      
        
        
          
            
          
          
            
          
        
        
          function sumTo(n) {
  return n * (n + 1) / 2;
}

alert( sumTo(100) );
        
      
      
      P.D. Naturalmente, la fórmula es la solución más rápida. Utiliza solo 3 operaciones para cualquier número n ¡Las matemáticas ayudan!
La variación con el bucle es la segunda en términos de velocidad. Tanto en la variante recursiva como en el bucle sumamos los mismos números. Pero la recursión implica llamadas anidadas y gestión de la pila de ejecución. Eso también requiere recursos, por lo que es más lento.
P.P.D. Algunos motores admiten la optimización de “tail call”: si una llamada recursiva es la última en la función (como en la función anterior sumTo), entonces la función externa no necesitará reanudar la ejecución, por lo que el motor no necesita recordar su contexto de ejecución. Eso elimina la carga en la memoria, así que contar sumTo(100000) resulta posible. Pero si el motor de JavaScript no soporta la optimización “tail call” (la mayoría no lo hacen), entonces habrá  un error: exceso del tamaño máximo de la pila, porque generalmente hay una limitación en el tamaño total de la pila.
Calcula el factorialimportancia: 4El factorial de un número natural es un número multiplicado por "número menos uno", luego por "número menos dos", y así sucesivamente hasta 1. El factorial de n se denota como n!
Podemos escribir la definición de factorial así:

      
        
        
          n! = n * (n - 1) * (n - 2) * ...*1
        
      
      
      Valores de factoriales para diferentes n:

      
        
        
          1! = 1
2! = 2 * 1 = 2
3! = 3 * 2 * 1 = 6
4! = 4 * 3 * 2 * 1 = 24
5! = 5 * 4 * 3 * 2 * 1 = 120
        
      
      
      La tarea es escribir una función factorial(n) que calcule n! usando llamadas recursivas.

      
        
        
          alert( factorial(5) ); // 120
        
      
      
      P.D. Pista: n! puede ser escrito como n * (n-1)! Por ejemplo: 3! = 3*2! = 3*2*1! = 6
soluciónPor definición, un factorial de n! puede ser escrito como n * (n-1)!.
En otras palabras, el resultado de factorial(n) se puede calcular como n multiplicado por el resultado de factorial(n-1). Y la llamada de n-1 puede descender recursivamente más y más hasta 1.

      
        
        
          
            
          
          
            
          
        
        
          function factorial(n) {
  return (n != 1) ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
        
      
      
      La base de la recursividad es el valor 1. También podemos hacer 0 la base aquí, no tiene mucha importancia, pero da un paso recursivo más:

      
        
        
          
            
          
          
            
          
        
        
          function factorial(n) {
  return n ? n * factorial(n - 1) : 1;
}

alert( factorial(5) ); // 120
        
      
      
      Sucesión de Fibonacciimportancia: 5La secuencia de sucesión de Fibonacci tiene la fórmula Fn = Fn-1 + Fn-2. En otras palabras, el siguiente número es una suma de los dos anteriores.
Los dos primeros números son 1, luego 2(1+1), luego 3(1+2), 5(2+3) y así sucesivamente: 1, 1, 2, 3, 5, 8, 13, 21....
La sucesión de Fibonacci está relacionada la proporción áurea y muchos fenómenos naturales alrededor nuestro.
Escribe una función fib(n) que devuelve la secuencia n-th de Fibonacci.
Un ejemplo de trabajo:

      
        
        
          function fib(n) { /* your code */ }

alert(fib(3)); // 2
alert(fib(7)); // 13
alert(fib(77)); // 5527939700884757
        
      
      
      P.D. La función debería ser rápida. La llamada a fib(77) no debería tardar más de una fracción de segundo.
soluciónLa primera solución que podemos probar aquí es la recursiva.
La secuencia de Fibonacci es recursiva por definición:

      
        
        
          
            
          
          
            
          
        
        
          function fib(n) {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
// fib(77); // ¡Será extremadamente lento!
        
      
      
      …Pero para valores grandes de n es muy lenta. Por ejemplo, fib(77) puede colgar el motor durante un tiempo consumiendo todos los recursos de la CPU.
Eso es porque la función realiza demasiadas sub llamadas. Los mismos valores son evaluados una y otra vez.
Por ejemplo, veamos algunos cálculos para fib(5):

      
        
        
          ...
fib(5) = fib(4) + fib(3)
fib(4) = fib(3) + fib(2)
...
        
      
      
      Aquí podemos ver que el valor de fib(3) es necesario tanto para fib(5) y fib(4). Entonces fib(3) será calculado y evaluado dos veces de forma completamente independiente.
Aquí está el árbol de recursividad completo:

      
      
        
      
      Podemos ver claramente que fib(3) es evaluado dos veces y fib(2) es evaluado tres veces. La cantidad total de cálculos crece mucho más rápido que n, lo que lo hace enorme incluso para n=77.
Podemos optimizarlo recordando los valores ya evaluados: si un valor de por ejemplo fib(3) es calculado una vez, entonces podemos reutilizarlo en cálculos futuros.
Otra variante sería renunciar a la recursión y utilizar un algoritmo basado en bucles totalmente diferente.
En lugar de ir de n a valores más bajos, podemos hacer un bucle que empiece desde 1 y 2, que obtenga fib(3) como su suma, luego fib(4) como la suma de los dos valores anteriores, luego fib(5) y va subiendo hasta llegar al valor necesario. En cada paso solo necesitamos recordar los dos valores anteriores.
Estos son los pasos del nuevo algoritmo en detalle.
El inicio:

      
        
        
          // a = fib(1), b = fib(2), estos valores son por definición 1
let a = 1, b = 1;

// obtener c = fib(3) como su suma
let c = a + b;

/* ahora tenemos fib(1), fib(2), fib(3)
a  b  c
1, 1, 2
*/
        
      
      
      Ahora queremos obtener fib(4) = fib(2) + fib(3).
Cambiemos las variables: a, b obtendrán fib(2),fib(3), y c obtendrá su suma:

      
        
        
          a = b; // now a = fib(2)
b = c; // now b = fib(3)
c = a + b; // c = fib(4)

/* ahora tenemos la secuencia:
   a  b  c
1, 1, 2, 3
*/
        
      
      
      El siguiente paso obtiene otro número de la secuencia:

      
        
        
          a = b; // now a = fib(3)
b = c; // now b = fib(4)
c = a + b; // c = fib(5)

/* ahora la secuencia es (otro número más):
      a  b  c
1, 1, 2, 3, 5
*/
        
      
      
      …Y así sucesivamente hasta obtener el valor necesario. Eso es mucho más rápido que la recursión y no implica cálculos duplicados.
El código completo:

      
        
        
          
            
          
          
            
          
        
        
          function fib(n) {
  let a = 1;
  let b = 1;
  for (let i = 3; i <= n; i++) {
    let c = a + b;
    a = b;
    b = c;
  }
  return b;
}

alert( fib(3) ); // 2
alert( fib(7) ); // 13
alert( fib(77) ); // 5527939700884757
        
      
      
      El bucle comienza con i=3, porque el primer y segundo valor de la secuencia están codificados en las variables a=1 y b=1.
Este enfoque se llama programación dinámica.
Generar una lista de un solo enlaceimportancia: 5Digamos que tenemos una lista de un solo enlace (como se describe en el capítulo Recursión y pila):

      
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};
        
      
      
      Escribe una función printList(list) que genere los elementos de la lista uno por uno.
Haz dos variantes de la solución: utilizando un bucle y utilizando recursividad.
¿Qué es mejor: con recursividad o sin ella?
soluciónSolución basada en el bucleSolución basada en el bucleLa solución basada en el bucle:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {
  let tmp = list;

  while (tmp) {
    alert(tmp.value);
    tmp = tmp.next;
  }

}

printList(list);
        
      
      
      Ten en cuenta que utilizamos una variable temporal tmp para recorrer la lista. Técnicamente, podríamos usar una función con una list de parámetros en su lugar:

      
        
        
          function printList(list) {

  while(list) {
    alert(list.value);
    list = list.next;
  }

}
        
      
      
      …Pero eso no sería prudente. En el futuro, es posible que necesitemos extender la función, hacer algo distinto con la lista. Si cambiamos list, entonces perdemos la habilidad.
Hablando sobre buenos nombres de variables, list aquí es la lista en sí. El primer elemento de la misma. Y debería permanecer así. Eso queda claro y fiable.
Desde el otro lado, el papel de tmp es exclusivamente para recorrer la lista, como i en el bucle for.
Solución recursivaSolución recursivaLa solución recursiva de printList(list) sigue una lógica simple: para generar una lista debemos generar el elemento actual list, luego hacer lo mismo con list.next:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printList(list) {

  alert(list.value); // genera el elemento actual

  if (list.next) {
    printList(list.next); // hace lo mismo para el resto de la lista
  }

}

printList(list);
        
      
      
      Ahora, ¿Qué es mejor?
Técnicamente, el bucle es más efectivo. Estas dos variantes hacen lo mismo, pero el bucle no gasta recursos en llamadas a funciones anidadas.
Por otro lado, la variante recursiva es más corta y a veces más sencilla de entender.
Genere una lista de un solo enlace en orden inversoimportancia: 5Genere una lista de un solo enlace a partir de la tarea anterior Generar una lista de un solo enlace en orden inverso.
Escribe dos soluciones: utilizando un bucle y utilizando recursividad.
soluciónUsando recursividadUsando recursividadLa lógica recursiva es un poco complicada aquí.
Primero necesitamos generar el resto de la lista y entonces generar la lista actual:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {

  if (list.next) {
    printReverseList(list.next);
  }

  alert(list.value);
}

printReverseList(list);
        
      
      
      Usando un bucleUsando un bucleLa variante con bucle también es un poco más complicada que la salida directa.
No hay manera de obtener el último valor en nuestra list. Tampoco podemos ir “hacia atrás”.
Entonces, lo que podemos hacer primero es recorrer los elementos en el orden directo guardándolos en un array, y entonces generar los elementos guardados en el orden inverso:

      
        
        
          
            
          
          
            
          
        
        
          let list = {
  value: 1,
  next: {
    value: 2,
    next: {
      value: 3,
      next: {
        value: 4,
        next: null
      }
    }
  }
};

function printReverseList(list) {
  let arr = [];
  let tmp = list;

  while (tmp) {
    arr.push(tmp.value);
    tmp = tmp.next;
  }

  for (let i = arr.length - 1; i >= 0; i--) {
    alert( arr[i] );
  }
}

printReverseList(list);
        
      
      
      Ten en cuenta que la solución recursiva en realidad hace exactamente lo mismo: recorre la lista, guarda los elementos en la cadena de llamadas anidadas (en la pila de contexto de ejecución), y luego los genera.
",
	"url": "https://es.javascript.info/recursion" 
},
{
	"docs_id": "52",
	"name": "Parámetros Rest y operador Spread",
	"description": "Muchas funciones nativas de JavaScript soportan un número arbitrario de argumentos.",
	"content": "Muchas funciones nativas de JavaScript soportan un número arbitrario de argumentos.
Por ejemplo:

Math.max(arg1, arg2, ..., argN) – devuelve el argumento más grande.
Object.assign(dest, src1, ..., srcN) – copia las propiedades de src1..N en dest.
…y otros más

En este capítulo aprenderemos como hacer lo mismo. Y, además, cómo trabajar cómodamente con dichas funciones y arrays.
Parámetros Rest ...Una función puede ser llamada con cualquier número de argumentos sin importar cómo sea definida.
Por ejemplo::

      
        
        
          
            
          
          
            
          
        
        
          function sum(a, b) {
  return a + b;
}

alert( sum(1, 2, 3, 4, 5) );
        
      
      
      Aquí no habrá ningún error por “exceso” de argumentos. Pero, por supuesto, en el resultado solo los dos primeros serán tomados en cuenta.
El resto de los parámetros pueden ser referenciados en la definición de una función con 3 puntos ... seguidos por el nombre del array que los contendrá. Literalmente significan “Reunir los parámetros restantes en un array”.
Por ejemplo, para reunir todos los parámetros en un array args:

      
        
        
          
            
          
          
            
          
        
        
          function sumAll(...args) { // args es el nombre del array
  let sum = 0;

  for (let arg of args) sum += arg;

  return sum;
}

alert( sumAll(1) ); // 1
alert( sumAll(1, 2) ); // 3
alert( sumAll(1, 2, 3) ); // 6
        
      
      
      Podemos elegir obtener los primeros parámetros como variables, y juntar solo el resto.
Aquí los primeros dos argumentos van a variables y el resto va al array titles:

      
        
        
          
            
          
          
            
          
        
        
          function showName(firstName, lastName, ...titles) {
  alert( firstName + ' ' + lastName ); // Julio Cesar

  // el resto va en el array titles
  // por ejemplo titles = ["Cónsul", "Emperador"]
  alert( titles[0] ); // Cónsul
  alert( titles[1] ); // Emperador
  alert( titles.length ); // 2
}

showName("Julio", "Cesar", "Cónsul", "Emperador");
        
      
      
      
            Los parámetros rest deben ir al final
            Los parámetros rest recogen todos los argumentos sobrantes, por lo que el siguiente código no tiene sentido y causa un error:

      
        
        
          function f(arg1, ...rest, arg2) { // arg2 después de ...rest ?!
  // error
}
        
      
      
      ...rest debe ir siempre último.

La variable “arguments”También existe un objeto símil-array especial llamado arguments que contiene todos los argumentos indexados.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function showName() {
  alert( arguments.length );
  alert( arguments[0] );
  alert( arguments[1] );

  // arguments es iterable
  // for(let arg of arguments) alert(arg);
}

// muestra: 2, Julio, Cesar
showName("Julio", "Cesar");

// muestra: 1, Ilya, undefined (no hay segundo argumento)
showName("Ilya");
        
      
      
      Antiguamente, los parámetros rest no existían en el lenguaje, y usar arguments era la única manera de obtener todos los argumentos de una función. Y aún funciona, podemos encontrarlo en código antiguo.
Pero la desventaja es que a pesar de que arguments es símil-array e iterable, no es un array. No soporta los métodos de array, no podemos ejecutar arguments.map(...) por ejemplo.
Además, siempre contiene todos los argumentos. No podemos capturarlos parcialmente como hicimos con los parámetros rest.
Por lo tanto, cuando necesitemos estas funcionalidades, los parámetros rest son preferidos.

            Las funciones flecha no poseen "arguments"
            Si accedemos el objeto arguments desde una función flecha, toma su valor dela función “normal” externa.
Aquí hay un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function f() {
  let showArg = () => alert(arguments[0]);
  showArg();
}

f(1); // 1
        
      
      
      Como recordamos, las funciones de flecha no tienen su propio this. Ahora sabemos que tampoco tienen el objeto especial arguments.

Sintaxis SpreadAcabamos de ver cómo obtener un array de la lista de parámetros.
Pero a veces necesitamos hacer exactamente lo opuesto.
Por ejemplo, existe una función nativa Math.max que devuelve el número más grande de una lista:

      
        
        
          
            
          
          
            
          
        
        
          alert( Math.max(3, 5, 1) ); // 5
        
      
      
      Ahora bien, supongamos que tenemos un array [3, 5, 1]. ¿Cómo ejecutamos Math.max con él?
Pasando la variable no funcionará, porque Math.max espera una lista de argumentos numéricos, no un único array:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [3, 5, 1];

alert( Math.max(arr) ); // NaN
        
      
      
      Y seguramente no podremos listar manualmente los ítems en el código Math.max(arr[0], arr[1], arr[2]), porque tal vez no sepamos cuántos son. A medida que nuestro script se ejecuta, podría haber muchos elementos, o podría no haber ninguno. Y eso podría ponerse feo.
¡Operador Spread al rescate!  Es similar a los parámetros rest, también usa ..., pero hace exactamente lo opuesto.
Cuando ...arr es usado en el llamado de una función, “expande” el objeto iterable arr en una lista de argumentos.
Para Math.max:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [3, 5, 1];

alert( Math.max(...arr) ); // 5 (spread convierte el array en una lista de argumentos)
        
      
      
      También podemos pasar múltiples iterables de esta manera:

      
        
        
          
            
          
          
            
          
        
        
          let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(...arr1, ...arr2) ); // 8
        
      
      
      Incluso podemos combinar el operador spread con valores normales:

      
        
        
          
            
          
          
            
          
        
        
          let arr1 = [1, -2, 3, 4];
let arr2 = [8, 3, -8, 1];

alert( Math.max(1, ...arr1, 2, ...arr2, 25) ); // 25
        
      
      
      Además, el operador spread puede ser usado para combinar arrays:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [3, 5, 1];
let arr2 = [8, 9, 15];

let merged = [0, ...arr, 2, ...arr2];

alert(merged); // 0,3,5,1,2,8,9,15 (0, luego arr, después 2, después arr2)
        
      
      
      En los ejemplos de arriba utilizamos un array para demostrar el operador spread, pero cualquier iterable funcionará también.
Por ejemplo, aquí usamos el operador spread para convertir la cadena en un array de caracteres:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hola";

alert( [...str] ); // H,o,l,a
        
      
      
      El operador spread utiliza internamente iteradores para iterar los elementos, de la misma manera que for..of hace.
Entonces, para una cadena for..of retorna caracteres y ...str se convierte en "H","o","l","a". La lista de caracteres es pasada a la inicialización del array [...str].
Para esta tarea en particular también podríamos haber usado Array.from, ya que convierte un iterable (como una cadena de caracteres) en un array:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Hola";

// Array.from convierte un iterable en un array
alert( Array.from(str) ); // H,o,l,a
        
      
      
      El resultado es el mismo que [...str].
Pero hay una sutil diferencia entre Array.from(obj) y [...obj]:

Array.from opera con símil-arrays e iterables.
El operador spread solo opera con iterables.

Por lo tanto, para la tarea de convertir algo en un array, Array.from tiende a ser más universal.
Copia de un objeto array¿Recuerdas cuando hablamos acerca de Object.assign() anteriormente?
Es posible hacer lo mismo con la sintaxis de spread

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3];

let arrCopy = [...arr]; // separa el array en una lista de parameters
                        // luego pone el resultado en un nuevo array

// ¿los arrays tienen el mismo contenido?
alert(JSON.stringify(arr) === JSON.stringify(arrCopy)); // true

// ¿los arrays son iguales?
alert(arr === arrCopy); // false (no es la misma referencia)

// modificando nuestro array inicial no modifica la copia:
arr.push(4);
alert(arr); // 1, 2, 3, 4
alert(arrCopy); // 1, 2, 3
        
      
      
      Nota que es posible hacer lo mismo para hacer una copia de un objeto:

      
        
        
          
            
          
          
            
          
        
        
          let obj = { a: 1, b: 2, c: 3 };

let objCopy = { ...obj }; // separa el objeto en una lista de parámetros
                          // luego devuelve el resultado en un nuevo objeto

// ¿tienen los objetos el mismo contenido?
alert(JSON.stringify(obj) === JSON.stringify(objCopy)); // true

// ¿son iguales los objetos?
alert(obj === objCopy); // false (no es la misma referencia)

// modificando el objeto inicial no modifica la copia:
obj.d = 4;
alert(JSON.stringify(obj)); // {"a":1,"b":2,"c":3,"d":4}
alert(JSON.stringify(objCopy)); // {"a":1,"b":2,"c":3}
        
      
      
      Esta manera de copiar un objeto es mucho más corta que let objCopy = Object.assign({}, obj); o para un array let arrCopy = Object.assign([], arr); por lo que preferimos usarla siempre que podemos.
ResumenCuando veamos "..." en el código, son los parámetros rest o el operador spread.
Hay una manera fácil de distinguir entre ellos:

Cuando ... se encuentra al final de los parámetros de una función, son los “parámetros rest” y recogen el resto de la lista de argumentos en un array.
Cuando ... está en el llamado de una función o similar, se llama “operador spread” y expande un array en una lista.

Patrones de uso:

Los parámetros rest son usados para crear funciones que acepten cualquier número de argumentos.
El operador spread es usado para pasar un array a funciones que normalmente requieren una lista de muchos argumentos.

Ambos ayudan a ir entre una lista y un array de parámetros con facilidad.
Todos los argumentos de un llamado a una función están también disponibles en el “viejo” arguments: un objeto símil-array iterable.
",
	"url": "https://es.javascript.info/rest-parameters-spread" 
},
{
	"docs_id": "53",
	"name": "Ámbito de Variable y el concepto "closure"",
	"description": "JavaScript es un lenguaje muy orientado a funciones. Nos da mucha libertad. Una función se puede crear en cualquier momento, pasar como argumento a otra función y luego llamar desde un lugar de código totalmente diferente más tarde.",
	"content": "JavaScript es un lenguaje muy orientado a funciones. Nos da mucha libertad. Una función se puede crear en cualquier momento, pasar como argumento a otra función y luego llamar desde un lugar de código totalmente diferente más tarde.
Ya sabemos que una función puede acceder a variables fuera de ella.
Pero, ¿qué sucede si estas variables “externas” cambian desde que se crea una función? ¿La función verá los valores nuevos o los antiguos?
Y si una función se pasa como parámetro y se llama desde otro lugar del código, ¿tendrá acceso a las variables externas en el nuevo lugar?
Ampliemos nuestro conocimiento para comprender estos escenarios y otros más complejos.

            Aquí hablaremos de variables let/const
            En JavaScript, hay 3 formas de declarar una variable: let, const (las modernas) y var (más antigua).

En este artículo usaremos las variables let en los ejemplos.
Las variables declaradas con const se comportan igual, por lo que este artículo también trata sobre const.
El antiguo var tiene algunas diferencias notables que se tratarán en el artículo La vieja "var".


Bloques de códigoSi una variable se declara dentro de un bloque de código {...}, solo es visible dentro de ese bloque.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          {
  // hacer un trabajo con variables locales que no deberían verse fuera
  let message = "Hello"; // solo visible en este bloque
  alert(message); // Hello
}

alert(message); // Error: el mensaje no se ha definido (undefined)
        
      
      
      Podemos usar esto para aislar un fragmento de código que realiza su propia tarea, con variables que solo le pertenecen a él:

      
        
        
          
            
          
          
            
          
        
        
          {
  // ver mensaje
  let message = "Hello";
  alert(message);
}

{
  // ver otro mensaje
  let message = "Goodbye";
  alert(message);
}
        
      
      
      
            Sin bloques, habría un error
            Tenga en cuenta que, sin bloques separados, habría un error si usáramos ‘let’ con el nombre de la variable existente:

      
        
        
          
            
          
          
            
          
        
        
          // ver mensaje
let message = "Hello";
alert(message);

// ver otro mensaje
let message = "Goodbye"; // Error: la variable ya ha sido declarada
alert(message);
        
      
      
      
Para if,for, while y otros, las variables declaradas dentro de {...} también son solo visibles en su interior:

      
        
        
          
            
          
          
            
          
        
        
          if (true) {
  let phrase = "Hello!";

  alert(phrase); // Hello!
}

alert(phrase); // ¡Error, no hay tal variable!
        
      
      
      Aquí, después de que if termine, laalerta a continuación no verá la phrase, de ahí el error.
Eso es genial, ya que nos permite crear variables locales de bloque, específicas de una rama if.
De la misma manera que para los bucles for y while:

      
        
        
          
            
          
          
            
          
        
        
          for (let i = 0; i < 3; i++) {
  // la variable i solo es visible dentro de este for
  alert(i); // 0, then 1, then 2
}

alert(i); // ¡Error, no hay tal variable!
        
      
      
      Visualmente, let i está fuera de {...}; pero la construcción for es especial aquí: la variable declarada dentro de ella se considera parte del bloque.
Funciones anidadasUna función se llama “anidada” cuando se crea dentro de otra función.
Es fácilmente posible hacer esto con JavaScript.
Podemos usarlo para organizar nuestro código:

      
        
        
          function sayHiBye(firstName, lastName) {

  // función anidada auxiliar para usar a continuación
  function getFullName() {
    return firstName + " " + lastName;
  }

  alert( "Hello, " + getFullName() );
  alert( "Bye, " + getFullName() );

}
        
      
      
      Aquí la función anidada getFullName() se hace por conveniencia. Puede acceder a las variables externas y, por lo tanto, puede devolver el nombre completo. Las funciones anidadas son bastante comunes en JavaScript.
Lo que es mucho más interesante, es que puede devolverse una función anidada: ya sea como propiedad de un nuevo objeto o como resultado en sí mismo. Luego se puede usar en otro lugar. No importa dónde, todavía tiene acceso a las mismas variables externas.
A continuación, makeCounter crea la función “contador” que devuelve el siguiente número en cada invocación:

      
        
        
          
            
          
          
            
          
        
        
          function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1
alert( counter() ); // 2
        
      
      
      A pesar de ser simples, variantes ligeramente modificadas de ese código tienen usos prácticos, como por ejemplo un generador de números aleatorios para pruebas automatizadas.
¿Cómo funciona esto? Si creamos múltiples contadores, ¿serán independientes? ¿Qué está pasando con las variables aquí?
Entender tales cosas es excelente para el conocimiento general de JavaScript y beneficioso para escenarios más complejos. Así que vamos a profundizar un poco.
Ámbito o alcance léxico
            ¡Aquí hay dragones!
            La explicación técnica en profundidad está por venir.
Me gustaría evitar los detalles de lenguaje de bajo nivel, pero cualquier comprensión sin ellos sería insuficiente e incompleta, así que prepárate.

Para mayor claridad, la explicación se divide en múltiples pasos.
Paso 1. VariablesEn JavaScript, todas las funciones en ejecución, el bloque de código {...} y el script en su conjunto tienen un objeto interno (oculto) asociado, conocido como Alcance léxico.
El objeto del alcance léxico consta de dos partes:

Registro de entorno: es un objeto que almacena en sus propiedades todas las variables locales (y alguna otra información, como el valor de this).
Una referencia al entorno léxico externo, asociado con el código externo.

Una “variable” es solo una propiedad del objeto interno especial, el Registro de entorno. “Obtener o cambiar una variable” significa “obtener o cambiar una propiedad de ese objeto”.
En este código simple y sin funciones, solo hay un entorno léxico:

      
      
        
      
      Este es el denominado entorno léxico global, asociado con todo el script.
En la imagen de arriba, el rectángulo significa Registro de entornos (almacén de variables) y la flecha significa la referencia externa. El entorno léxico global no tiene referencia externa, por eso la flecha apunta a nulo.
A medida que el código comienza a ejecutarse y continúa, el entorno léxico cambia.
Aquí hay un código un poco más largo:

      
      
        
      
      Los rectángulos en el lado derecho demuestran cómo cambia el entorno léxico global durante la ejecución:

Cuando se inicia el script, el entorno léxico se rellena previamente con todas las variables declaradas.
     – Inicialmente, están en el estado “No inicializado”. Ese es un estado interno especial, significa que el motor conoce la variable, pero no se puede hacer referencia a ella hasta que se haya declarado con let. Es casi lo mismo que si la variable no existiera.
Luego aparece la definición let phrase.Todavía no hay una asignación, por lo que su valor es undefined. Podemos usar la variable desde este punto en adelante.
phrase se le asigna un valor.
phrase cambia el valor.

Todo parece simple por ahora, ¿verdad?

Una variable es una propiedad de un objeto interno especial que está asociado con el bloque/función/script actualmente en ejecución.
Trabajar con variables es realmente trabajar con las propiedades de ese objeto.


            El entorno léxico es un objeto de especificación
            El “entorno léxico” es un objeto de especificación: solo existe “teóricamente” en la especificación del lenguaje para describir cómo funcionan las cosas. No podemos obtener este objeto en nuestro código y manipularlo directamente.
Los motores de JavaScript también pueden optimizarlo, descartar variables que no se utilizan para ahorrar memoria y realizar otros trucos internos, siempre que el comportamiento visible permanezca como se describe.

Paso 2. Declaración de funcionesUna función también es un valor, como una variable.
La diferencia es que una declaración de función se inicializa completamente al instante.
Cuando se crea un entorno léxico, una declaración de función se convierte inmediatamente en una función lista para usar (a diferencia de let, que no se puede usar hasta la declaración).
Es por eso que podemos usar una función, declarada como declaración de función, incluso antes de la declaración misma.
Por ejemplo, aquí está el estado inicial del entorno léxico global cuando agregamos una función:

      
      
        
      
      Naturalmente, este comportamiento solo se aplica a las declaraciones de funciones, no a las expresiones de funciones, donde asignamos una función a una variable, como let say = function (name) ....
Paso 3. Entorno léxico interno y externoCuando se ejecuta una función, al comienzo de la llamada se crea automáticamente un nuevo entorno léxico para almacenar variables y parámetros locales de la llamada.
Por ejemplo, para say(" John "), se ve así (la ejecución está en la línea etiquetada con una flecha):


      
      
        
      
      Durante la llamada a la función tenemos dos entornos léxicos: el interno (para la llamada a la función) y el externo (global):

El entorno léxico interno corresponde a la ejecución actual de say. Tiene una sola propiedad: name, el argumento de la función. Llamamos a say("John"), por lo que el valor de name es "John".
El entorno léxico externo es el entorno léxico global. Tiene la variable phrase y la función misma.

El entorno léxico interno tiene una referencia al externo.
Cuando el código quiere acceder a una variable: primero se busca el entorno léxico interno, luego el externo, luego el más externo y así sucesivamente hasta el global.
Si no se encuentra una variable en ninguna parte, en el modo estricto se trata de un error (sin use strict, una asignación a una variable no existente crea una nueva variable global, por compatibilidad con el código antiguo).
En este ejemplo la búsqueda procede como sigue:

Para la variable name, la alert dentro de say lo encuentra inmediatamente en el entorno léxico interno.
Cuando quiere acceder a phrase, no existe un phrase local por lo que sigue la referencia al entorno léxico externo y lo encuentra allí.


      
      
        
      
      Paso 4. Devolviendo una funciónVolvamos al ejemplo de makeCounter.

      
        
        
          function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
        
      
      
      Al comienzo de cada llamada a makeCounter(), se crea un nuevo objeto de entorno léxico para almacenar variables para la ejecución makeCounter.
Entonces tenemos dos entornos léxicos anidados, como en el ejemplo anterior:

      
      
        
      
      Lo que es diferente es que, durante la ejecución de makeCounter(), se crea una pequeña función anidada de solo una línea: return count++. Aunque no la ejecutamos, solo la creamos.
Todas las funciones recuerdan el entorno léxico en el que fueron realizadas. Técnicamente, no hay magia aquí: todas las funciones tienen la propiedad oculta llamada [[Environment], que mantiene la referencia al entorno léxico donde se creó la función:

      
      
        
      
      Entonces, counter.[[Environment]] tiene la referencia al Entorno léxico de {count: 0}. Así es como la función recuerda dónde se creó, sin importar dónde se la llame. La referencia [[Environment]] se establece una vez y para siempre en el momento de creación de la función.
Luego, cuando counter() es llamado, un nuevo Entorno Léxico es creado por la llamada, y su referencia externa del entorno léxico se toma de counter.[[Environment]]:

      
      
        
      
      Ahora cuando el código dentro de counter() busca la variable count, primero busca su propio entorno léxico (vacío, ya que no hay variables locales allí), luego el entorno léxico del exterior llama a makeCounter(), donde lo encuentra y lo cambia.
Una variable se actualiza en el entorno léxico donde vive.
Aquí está el estado después de la ejecución:

      
      
        
      
      Si llamamos a counter() varias veces, la variable count se incrementará a 2, 3 y así sucesivamente, en el mismo lugar.

            Closure (clausura)
            Existe un término general de programación “closure” que los desarrolladores generalmente deben conocer.
Una clausura es una función que recuerda sus variables externas y puede acceder a ellas. En algunos lenguajes, eso no es posible, o una función debe escribirse de una manera especial para que suceda. Pero como se explicó anteriormente, en JavaScript todas las funciones son clausuras naturales (solo hay una excepción, que se cubrirá en La sintaxis "new Function").
Es decir: recuerdan automáticamente dónde se crearon utilizando una propiedad oculta [[Environment]], y luego su código puede acceder a las variables externas.
Cuando en una entrevista un desarrollador frontend recibe una pregunta sobre “¿qué es una clausura?”, una respuesta válida sería una definición de clausura y una explicación de que todas las funciones en JavaScript son clausuras, y tal vez algunas palabras más sobre detalles técnicos: la propiedad [[Environment]] y cómo funcionan los entornos léxicos.

Recolector de basuraPor lo general, un entorno léxico se elimina de la memoria con todas las variables una vez que finaliza la llamada a la función. Eso es porque ya no hay referencias a él. Como cualquier objeto de JavaScript, solo se mantiene en la memoria mientras es accesible.
Sin embargo, si hay una función anidada a la que todavía se puede llegar después del final de una función, entonces tiene la propiedad [[Environment]] que hace referencia al entorno léxico.
En ese caso, el entorno léxico aún es accesible incluso después de completar la función, por lo que permanece vigente.
Por ejemplo:

      
        
        
          function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // g.[[Environment]] almacena una referencia al entorno léxico
// de la llamada f() correspondiente
        
      
      
      Tenga en cuenta que si se llama a f() muchas veces y se guardan las funciones resultantes, todos los objetos del entorno léxico correspondientes también se conservarán en la memoria. Veamos las 3 funciones en el siguiente ejemplo:

      
        
        
          function f() {
  let value = Math.random();

  return function() { alert(value); };
}

// 3 funciones en un array, cada una de ellas enlaza con el entorno léxico
// desde la ejecución f() correspondiente
let arr = [f(), f(), f()];
        
      
      
      Un objeto de entorno léxico muere cuando se vuelve inalcanzable (como cualquier otro objeto). En otras palabras, existe solo mientras haya al menos una función anidada que haga referencia a ella.
En el siguiente código, después de eliminar la función anidada, su entorno léxico adjunto (y por lo tanto el value) se limpia de la memoria:

      
        
        
          function f() {
  let value = 123;

  return function() {
    alert(value);
  }
}

let g = f(); // mientras exista la función g, el valor permanece en la memoria

g = null; // ... y ahora la memoria está limpia
        
      
      
      Optimizaciones en la vida realComo hemos visto, en teoría, mientras una función está viva, todas las variables externas también se conservan.
Pero en la práctica, los motores de JavaScript intentan optimizar eso. Analizan el uso de variables y si es obvio que el código no usa una variable externa, la elimina.
Un efecto secundario importante en V8 (Chrome, Edge, Opera) es que dicha variable no estará disponible en la depuración.
Intente ejecutar el siguiente ejemplo en Chrome con las Herramientas para desarrolladores abiertas.
Cuando se detiene, en el tipo de consola alert(value).

      
        
        
          
            
          
          
            
          
        
        
          function f() {
  let value = Math.random();

  function g() {
    debugger; // en console: type alert(value); ¡No hay tal variable!
  }

  return g;
}

let g = f();
g();
        
      
      
      Como puede ver, ¡no existe tal variable! En teoría, debería ser accesible, pero el motor lo optimizó.
Eso puede conducir a problemas de depuración divertidos (si no son muy largos). Uno de ellos: podemos ver una variable externa con el mismo nombre en lugar de la esperada:

      
        
        
          
            
          
          
            
          
        
        
          let value = "Surprise!";

function f() {
  let value = "the closest value";

  function g() {
    debugger; // en la consola escriba: alert(value); Surprise!
  }

  return g;
}

let g = f();
g();
        
      
      
      Es bueno conocer esta característica de V8. Si está depurando con Chrome/Edge/Opera, tarde o temprano la encontrará.
Eso no es un error en el depurador, sino más bien una característica especial de V8. Tal vez en algún momento la cambiarán. Siempre puede verificarlo ejecutando los ejemplos en esta página.
TareasEsta función: ¿recoge los últimos cambios?importancia: 5La función sayHi usa un nombre de variable externo. Cuando se ejecuta la función, ¿qué valor va a utilizar?

      
        
        
          let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete";

sayHi(); // ¿qué mostrará: "John" o "Pete"?
        
      
      
      Tales situaciones son comunes tanto en el desarrollo del navegador como del lado del servidor. Se puede programar que una función se ejecute más tarde de lo que se creó, por ejemplo, después de una acción del usuario o una solicitud de red.
Entonces, la pregunta es: ¿recoge los últimos cambios?
soluciónLa respuesta es: Pete.
Una función obtiene variables externas con su estado actual, y utiliza los valores más recientes.
Los valores de variables anteriores no se guardan en ningún lado. Cuando una función quiere una variable, toma el valor actual de su propio entorno léxico o el externo.
¿Qué variables están disponibles?importancia: 5La función makeWorker a continuación crea otra función y la devuelve. Esa nueva función se puede llamar desde otro lugar.
¿Tendrá acceso a las variables externas desde su lugar de creación, o desde el lugar de invocación, o ambos?

      
        
        
          function makeWorker() {
  let name = "Pete";

  return function() {
    alert(name);
  };
}

let name = "John";

// crea una función
let work = makeWorker();

// la llama
work(); // ¿qué mostrará?
        
      
      
      ¿Qué valor mostrará? “Pete” o “John”?
soluciónLa respuesta es: Pete.
La función work() en el código a continuación obtiene name del lugar de su origen a través de la referencia del entorno léxico externo:

      
      
        
      
      Entonces, el resultado es “Pete”.
Pero si no hubiera let name enmakeWorker (), entonces la búsqueda saldría y tomaría la variable global como podemos ver en la cadena de arriba. En ese caso, el resultado sería John.
¿Son independientes los contadores?importancia: 5Aquí hacemos dos contadores: counter y counter2 usando la misma función makeCounter.
¿Son independientes? ¿Qué va a mostrar el segundo contador? 0,1 o 2,3 o algo más?

      
        
        
          function makeCounter() {
  let count = 0;

  return function() {
    return count++;
  };
}

let counter = makeCounter();
let counter2 = makeCounter();

alert( counter() ); // 0
alert( counter() ); // 1

alert( counter2() ); // ?
alert( counter2() ); // ?
        
      
      
      soluciónLa respuesta: 0,1.
Las funciones counter ycounter2 son creadas por diferentes invocaciones de makeCounter.
Por lo tanto, tienen entornos léxicos externos independientes, cada uno tiene su propio count.
Objeto contadorimportancia: 5Aquí se crea un objeto contador con la ayuda de la función constructora.
¿Funcionará? ¿Qué mostrará?

      
        
        
          function Counter() {
  let count = 0;

  this.up = function() {
    return ++count;
  };
  this.down = function() {
    return --count;
  };
}

let counter = new Counter();

alert( counter.up() ); // ?
alert( counter.up() ); // ?
alert( counter.down() ); // ?
        
      
      
      soluciónSeguramente funcionará bien.
Ambas funciones anidadas se crean dentro del mismo entorno léxico externo, por lo que comparten acceso a la misma variable count:

      
        
        
          
            
          
          
            
          
        
        
          function Counter() {
  let count = 0;

  this.up = function() {
    return ++count;
  };
  this.down = function() {
    return --count;
  };
}

let counter = new Counter();

alert( counter.up() ); // 1
alert( counter.up() ); // 2
alert( counter.down() ); // 1
        
      
      
      Función en ifimportancia: 5Mira el código ¿Cuál será el resultado de la llamada en la última línea?

      
        
        
          
            
          
          
            
          
        
        
          let phrase = "Hello";

if (true) {
  let user = "John";

  function sayHi() {
    alert(`${phrase}, ${user}`);
  }
}

sayHi();
        
      
      
      soluciónEl resultado es un error.
La función sayHi se declara dentro de if, por lo que solo vive dentro de ella. No hay sayHi afuera.
Suma con clausurasimportancia: 4Escriba la función sum que funcione así: sum(a)(b) = a+b.
Sí, exactamente de esta manera, usando paréntesis dobles (no es un error de tipeo).
Por ejemplo:

      
        
        
          sum(1)(2) = 3
sum(5)(-1) = 4
        
      
      
      soluciónPara que funcionen los segundos paréntesis, los primeros deben devolver una función.
Como esto:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a) {

  return function(b) {
    return a + b; // toma "a" del entorno léxico externo
  };
}

alert( sum(1)(2) ); // 3
alert( sum(5)(-1) ); // 4
        
      
      
      ¿Es visible la variable?importancia: 4¿Cuál será el resultado de este código?

      
        
        
          let x = 1;

function func() {
  console.log(x); // ?

  let x = 2;
}

func();
        
      
      
      P.D Hay una trampa en esta tarea. La solución no es obvia.
soluciónEl resultado es: error.
Intenta correr esto:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;

function func() {
  console.log(x); // ReferenceError: No se puede acceder a 'x' antes de la inicialización
  let x = 2;
}
func();
        
      
      
      En este ejemplo podemos observar la diferencia peculiar entre una variable “no existente” y una variable “no inicializada”.
Como habrás leído en el artículo Ámbito de Variable y el concepto "closure", una variable comienza en el estado “no inicializado” desde el momento en que la ejecución entra en un bloque de código (o una función). Y permanece sin inicializar hasta la correspondiente declaración let.
En otras palabras, una variable técnicamente existe, pero no se puede usar antes de let.
El código anterior lo demuestra.

      
        
        
          function func() {

// la variable local x es conocida por el motor desde el comienzo de la función,
// pero "unitialized" (inutilizable) hasta let ("zona muerta")
// de ahí el error

  console.log(x); // ReferenceError: No se puede acceder a 'x' antes de la inicialización

  let x = 2;
}
        
      
      
      Esta zona de inutilización temporal de una variable (desde el comienzo del bloque de código hasta let) a veces se denomina" zona muerta ".
Filtrar a través de una funciónimportancia: 5Tenemos un método incorporado arr.filter(f) para arrays. Filtra todos los elementos a través de la función f. Si devuelve true, entonces ese elemento se devuelve en el array resultante.
Haga un conjunto de filtros “listos para usar”:

inBetween(a, b) – entre a y b o igual a ellos (inclusive).
inArray([...]) – en el array dado

El uso debe ser así:

arr.filter(inBetween(3,6)) – selecciona solo valores entre 3 y 6.
arr.filter(inArray([1,2,3])) – selecciona solo elementos que coinciden con uno de los miembros de [1,2,3].

Por ejemplo:

      
        
        
          /* .. tu código para inBetween y inArray */

let arr = [1, 2, 3, 4, 5, 6, 7];

alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6

alert( arr.filter(inArray([1, 2, 10])) ); // 1,2
        
      
      
      Abrir en entorno controlado con pruebas.soluciónFiltrar inBetweenFiltrar inBetween
      
        
        
          
            
          
          
            
          
        
        
          function inBetween(a, b) {
  return function(x) {
    return x >= a && x <= b;
  };
}

let arr = [1, 2, 3, 4, 5, 6, 7];
alert( arr.filter(inBetween(3, 6)) ); // 3,4,5,6
        
      
      
      Filtrar inArrayFiltrar inArray
      
        
        
          
            
          
          
            
          
        
        
          function inArray(arr) {
  return function(x) {
    return arr.includes(x);
  };
}

let arr = [1, 2, 3, 4, 5, 6, 7];
alert( arr.filter(inArray([1, 2, 10])) ); // 1,2
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Ordenar por campoimportancia: 5Tenemos una variedad de objetos para ordenar:

      
        
        
          let users = [
  { name: "John", age: 20, surname: "Johnson" },
  { name: "Pete", age: 18, surname: "Peterson" },
  { name: "Ann", age: 19, surname: "Hathaway" }
];
        
      
      
      La forma habitual de hacerlo sería:

      
        
        
          // por nombre(Ann, John, Pete)
users.sort((a, b) => a.name > b.name ? 1 : -1);

// por edad (Pete, Ann, John)
users.sort((a, b) => a.age > b.age ? 1 : -1);
        
      
      
      ¿Podemos hacerlo aún menos detallado, como este?

      
        
        
          users.sort(byField('name'));
users.sort(byField('age'));
        
      
      
      Entonces, en lugar de escribir una función, simplemente ponga byField (fieldName).
Escriba la función byField que se pueda usar para eso.
Abrir en entorno controlado con pruebas.solución
      
        
        
          function byField(fieldName){
  return (a, b) => a[fieldName] > b[fieldName] ? 1 : -1;
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Ejército de funcionesimportancia: 5El siguiente código crea una serie de shooters.
Cada función está destinada a generar su número. Pero algo anda mal …

      
        
        
          
            
          
          
            
          
        
        
          function makeArmy() {
  let shooters = [];

  let i = 0;
  while (i < 10) {
    let shooter = function() { // crea la función shooter
      alert( i ); // debería mostrar su número
    };
    shooters.push(shooter); // y agregarlo al array
    i++;
  }

  // ...y  devolver el array de tiradores
  return shooters;
}

let army = makeArmy();

// ... todos los tiradores muestran 10 en lugar de sus 0, 1, 2, 3 ...
army[0](); // 10 del tirador número 0
army[1](); // 10 del tirador número 1
army[2](); // 10 ...y así sucesivamente.
        
      
      
      ¿Por qué todos los tiradores muestran el mismo valor?
Arregle el código para que funcionen según lo previsto.
Abrir en entorno controlado con pruebas.soluciónExaminemos lo que sucede dentro de makeArmy, y la solución será obvia.


Esta crea un array vacío de tiradores, shooters:

      
        
        
          let shooters = [];
        
      
      
      

Lo llena en el bucle a través de shooters.push(function...).
Cada elemento es una función, por lo que el array resultante se ve así:

      
        
        
          shooters = [
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); },
  function () { alert(i); }
];
        
      
      
      

El array se devuelve desde la función.
Más tarde la llamada a cualquier miembro, por ejemplo army[5](), obtendrá el elemento army[5] del array (será una función) y lo llamará.
Ahora, ¿por qué todas esas funciones muestran el mismo valor, 10?
Esto se debe a que no hay una variable local i dentro de las funciones shooter. Cuando se llama a tal función, toma i de su entorno léxico externo.
Entonces ¿cuál será el valor de i?
Si miramos la fuente:

      
        
        
          function makeArmy() {
  ...
  let i = 0;
  while (i < 10) {
    let shooter = function() { // shooter function
      alert( i ); // debería mostrar su número
    };
    shooters.push(shooter); // agrega la función al array
    i++;
  }
  ...
}
        
      
      
      Podemos ver que todas las funciones shooter están creadas en el ambiente léxico asociado a la ejecución de makeArmy().  Pero cuando se llama a army[5](), makeArmy ya ha terminado su trabajo, y el valor final de i es 10 (while finaliza en i=10).
Como resultado, todas las funciones shooter obtienen el mismo valor del mismo entorno léxico externo, que es el último valor i=10.

      
      
        
      
      Como puedes ver arriba, con cada iteración del bloque while {...} un nuevo ambiente léxico es creado. Entonces, para corregir el problema podemos copiar el valor de i en una variable dentro del bloque while {...} como aquí:

      
        
        
          
            
          
          
            
          
        
        
          function makeArmy() {
  let shooters = [];

  let i = 0;
  while (i < 10) {
    let j = i;
    let shooter = function() { // shooter function
      alert( j ); // debería mostrar su número
    };
    shooters.push(shooter);
    i++;
  }

  return shooters;
}

let army = makeArmy();

// Ahora el código funciona correctamente
army[0](); // 0
army[5](); // 5
        
      
      
      Aquí let j = i declara una variable de iteración local j y copia i en ella. Las primitivas son copiadas por valor, así que realmente obtenemos una copia independiente de i, perteneciente a la iteración del bucle actual.
Los shooters funcionan correctamente, porque el valor de i ahora vive más cerca. No en el ambiente léxico de makeArmy() sino en el que corresponde a la iteración del bucle actual:

      
      
        
      
      Tal problema habría sido evitado si hubiéramos usado for desde el principio:

      
        
        
          
            
          
          
            
          
        
        
          function makeArmy() {

  let shooters = [];

  for(let i = 0; i < 10; i++) {
    let shooter = function() { // shooter function
      alert( i ); // debería mostrar su número
    };
    shooters.push(shooter);
  }

  return shooters;
}

let army = makeArmy();

army[0](); // 0
army[5](); // 5
        
      
      
      Esto es esencialmente lo mismo, ya que cada iteración de for genera un nuevo ambiente léxico con su propia variable i. Así el shooter generado en cada iteración hace referencia a su propio i, de esa misma iteración.

      
      
        
      
      

Ahora, como has puesto mucho esfuerzo leyendo esto, y la receta final es tan simple: simplemente usa for, puede que te preguntes: ¿valió la pena?
Bien, si pudiste resolver el problema fácilmente probablemente no habrías necesitado leer la solución, así que esperamos que esta tarea te haya ayudado a entender las cosas mejor.
Además, efectivamente hay casos donde uno prefiere while a for, y otros escenarios donde tales problemas son reales.
Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/closure" 
},
{
	"docs_id": "54",
	"name": "La vieja "var"",
	"description": "La información en este artículo es útil para entender código antiguo.",
	"content": "
            Este artículo es para entender código antiguo
            La información en este artículo es útil para entender código antiguo.
No es así como escribimos código moderno.

En el primer capítulo acerca de variables, mencionamos tres formas de declarar una variable:

let
const
var

La declaración var es similar a let. Casi siempre podemos reemplazar let por var o viceversa y esperar que las cosas funcionen:

      
        
        
          
            
          
          
            
          
        
        
          var message = "Hola";
alert(message); // Hola
        
      
      
      Pero internamente var es una bestia diferente, originaria de muy viejas épocas. Generalmente no se usa en código moderno, pero aún habita en el antiguo.
Si no planeas encontrarte con tal código bien puedes saltar este capítulo o posponerlo, pero hay posibilidades de que esta bestia pueda morderte más tarde.
Por otro lado, es importante entender las diferencias cuando se migra antiguo código de var a let para evitar extraños errores.
“var” no tiene alcance (visibilidad) de bloque.Las variables declaradas con var pueden: tener a la función como entorno de visibilidad, o bien ser globales. Su visibilidad atraviesa los bloques.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          if (true) {
  var test = true; // uso de "var" en lugar de "let"
}

alert(test); // true, la variable vive después del if
        
      
      
      Como var ignora los bloques de código, tenemos una variable global test.
Si usáramos let test en vez de var test, la variable sería visible solamente dentro del if:

      
        
        
          
            
          
          
            
          
        
        
          if (true) {
  let test = true; // uso de "let"
}

alert(test); // ReferenceError: test no está definido
        
      
      
      Lo mismo para los bucles: var no puede ser local en los bloques ni en los bucles:

      
        
        
          for (var i = 0; i < 10; i++) {
  var one = 1;
  // ...
}

alert(i); // 10, "i" es visible después del bucle, es una variable global
alert(one); // 1, "one" es visible después del bucle, es una variable global
        
      
      
      Si un bloque de código está dentro de una función, var se vuelve una variable a nivel de función:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  if (true) {
    var phrase = "Hello";
  }

  alert(phrase); // funciona
}

sayHi();
alert(phrase); // ReferenceError: phrase no está definida
        
      
      
      Como podemos ver, var atraviesa if, for u otros bloques. Esto es porque mucho tiempo atrás los bloques en JavaScript no tenían ambientes léxicos. Y var es un remanente de aquello.
“var” tolera redeclaracionesDeclarar la misma variable con let dos veces en el mismo entorno es un error:

      
        
        
          
            
          
          
            
          
        
        
          let user;
let user; // SyntaxError: 'user' ya fue declarado
        
      
      
      Con var podemos redeclarar una variable muchas veces. Si usamos var con una variable ya declarada, simplemente se ignora:

      
        
        
          
            
          
          
            
          
        
        
          var user = "Pete";

var user = "John"; // este "var" no hace nada (ya estaba declarado)
// ...no dispara ningún error

alert(user); // John
        
      
      
      Las variables “var” pueden ser declaradas debajo del lugar en donde se usanLas declaraciones var son procesadas cuando se inicia la función (o se inicia el script para las globales).
En otras palabras, las variables var son definidas desde el inicio de la función, no importa dónde esté tal definición (asumiendo que la definición no está en una función anidada).
Entonces el código:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  phrase = "Hello";

  alert(phrase);

  var phrase;
}
sayHi();
        
      
      
      …es técnicamente lo mismo que esto (se movió var phrase hacia arriba):

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  var phrase;

  phrase = "Hello";

  alert(phrase);
}
sayHi();
        
      
      
      …O incluso esto (recuerda, los códigos de bloque son ignorados):

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  phrase = "Hello"; // (*)

  if (false) {
    var phrase;
  }

  alert(phrase);
}
sayHi();
        
      
      
      Este comportamiento también se llama “hoisting” (elevamiento), porque todos los var son “hoisted” (elevados) hacia el tope de la función.
Entonces, en el ejemplo anterior, la rama if (false) nunca se ejecuta, pero eso no tiene importancia. El var dentro es procesado al iniciar la función, entonces al momento de (*) la variable existe.
Las declaraciones son “hoisted” (elevadas), pero las asignaciones no lo son.
Es mejor demostrarlo con un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert(phrase);

  var phrase = "Hello";
}

sayHi();
        
      
      
      La línea var phrase = "Hello" tiene dentro dos acciones:

La declaración var
La asignación =.

La declaración es procesada al inicio de la ejecución de la función (“hoisted”), pero la asignación siempre se hace en el lugar donde aparece. Entonces lo que en esencia hace el código es:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  var phrase; // la declaración se hace en el inicio...

  alert(phrase); // undefined

  phrase = "Hello"; // ...asignación - cuando la ejecución la alcanza.
}

sayHi();
        
      
      
      Como todas las declaraciones var son procesadas al inicio de la función, podemos referenciarlas en cualquier lugar. Pero las variables serán indefinidas hasta que alcancen su asignación.
En ambos ejemplos de arriba alert se ejecuta sin un error, porque la variable phrase existe. Pero su valor no fue asignado aún, entonces muestra undefined.
IIFEComo en el pasado solo existía var, y no había visibilidad a nivel de bloque, los programadores inventaron una manera de emularla. Lo que hicieron fue el llamado "expresiones de función inmediatamente invocadas (abreviado IIFE en inglés).
No es algo que debiéramos usar estos días, pero puedes encontrarlas en código antiguo.
Un IIFE se ve así:

      
        
        
          
            
          
          
            
          
        
        
          (function() {

  var message = "Hello";

  alert(message); // Hello

})();
        
      
      
      Aquí la expresión de función es creada e inmediatamente llamada. Entonces el código se ejecuta enseguida y con sus variables privadas propias.
La expresión de función es encerrada entre paréntesis (function {...}), porque cuando JavaScript se encuentra con "function" en el flujo de código principal lo entiende como el principio de una declaración de función. Pero una declaración de función debe tener un nombre, entonces ese código daría error:

      
        
        
          
            
          
          
            
          
        
        
          // Trata de declarar e inmediatamente llamar una función
function() { // <-- SyntaxError: la instrucción de función requiere un nombre de función

  var message = "Hello";

  alert(message); // Hello

}();
        
      
      
      Incluso si decimos: “okay, agreguémosle un nombre”, no funcionaría, porque JavaScript no permite que las declaraciones de función sean llamadas inmediatamente:

      
        
        
          
            
          
          
            
          
        
        
          // error de sintaxis por causa de los paréntesis debajo
function go() {

}(); // <-- no puede llamarse una declaración de función inmediatamente
        
      
      
      Entonces, los paréntesis alrededor de la función es un truco para mostrarle a JavaScript que la función es creada en el contexto de otra expresión, y de allí lo de “expresión de función”, que no necesita un nombre y puede ser llamada inmediatamente.
Existen otras maneras además de los paréntesis para decirle a JavaScript que queremos una expresión de función:

      
        
        
          
            
          
          
            
          
        
        
          // Formas de crear IIFE

(function() {
  alert("Paréntesis alrededor de la función");
})();

(function() {
  alert("Paréntesis alrededor de todo");
}());

!function() {
  alert("Operador 'Bitwise NOT' como comienzo de la expresión");
}();

+function() {
  alert("'más unario' como comienzo de la expresión");
}();
        
      
      
      En todos los casos de arriba declaramos una expresión de función y la ejecutamos inmediatamente. Tomemos nota de nuevo: Ahora no hay motivo para escribir semejante código.
ResumenHay dos diferencias principales entre var y let/const:

Las variables var no tienen alcance de bloque: su visibilidad alcanza a la función, o es global si es declarada fuera de las funciones.
Las declaraciones var son procesadas al inicio de la función (o del script para las globales) .

Hay otra diferencia menor relacionada al objeto global que cubriremos en el siguiente capítulo.
Estas diferencias casi siempre hacen a var peor que let. Las variables a nivel de bloque son mejores. Es por ello que let fue presentado en el estándar mucho tiempo atrás, y es ahora la forma principal (junto con const) de declarar una variable.
",
	"url": "https://es.javascript.info/var" 
},
{
	"docs_id": "55",
	"name": "Objeto Global",
	"description": "El objeto global proporciona variables y funciones que están disponibles en cualquier lugar. Por defecto, aquellas que están integradas en el lenguaje o el entorno.",
	"content": "El objeto global proporciona variables y funciones que están disponibles en cualquier lugar. Por defecto, aquellas que están integradas en el lenguaje o el entorno.
En un navegador se denomina window, para Node.js esglobal, para otros entornos puede tener otro nombre.
Recientemente, se agregó globalThis al lenguaje, como un nombre estandarizado para un objeto global, que debería ser compatible con todos los entornos al igual que con los principales navegadores.
Aquí usaremos window, suponiendo que nuestro entorno sea un navegador. Si su script puede ejecutarse en otros entornos, es mejor usar globalThis en su lugar.
Se puede acceder directamente a todas las propiedades del objeto global:

      
        
        
          
            
          
          
            
          
        
        
          alert("Hello");
// es lo mismo que
window.alert("Hello");
        
      
      
      En un navegador, las funciones y variables globales declaradas con var (¡no con let/const!) se convierten en propiedades del objeto global:

      
        
        
          
            
          
          
            
          
        
        
          var gVar = 5;

alert(window.gVar); // 5 (se convirtió en una propiedad del objeto global)
        
      
      
      El mismo efecto lo tienen las declaraciones de función (sentencias con la palabra clave function en el flujo principal del código, no las expresiones de función).
¡Por favor no te fíes de eso! Este comportamiento existe por razones de compatibilidad. Los scripts modernos hacen uso de Módulos Javascript para que tales cosas no sucedan.
Si usáramos let en su lugar, esto no sucedería:

      
        
        
          
            
          
          
            
          
        
        
          let gLet = 5;

alert(window.gLet); // undefined (no se convierte en una propiedad del objeto global)
        
      
      
      Si un valor es tan importante que desea que esté disponible globalmente, escríbalo directamente como una propiedad:

      
        
        
          
            
          
          
            
          
        
        
          // Hacer que la información actual del usuario sea global, para que todos los scripts puedan acceder a ella
window.currentUser = {
  name: "John"
};

// en otro lugar en el código
alert(currentUser.name);  // John

// o, si tenemos una variable local con el nombre "currentUser"
// obténgalo de la ventana explícitamente (¡más seguro!)
alert(window.currentUser.name); // John
        
      
      
      Dicho esto, generalmente se desaconseja el uso de variables globales. Debería haber la menor cantidad posible de ellas. El diseño del código donde una función obtiene variables de “entrada” y produce cierto “resultado” es más claro, menos propenso a errores y más fácil de probar que si usa variables externas o globales.
Uso para polyfillsPodemos usar el objeto global para probar el soporte de características modernas del lenguaje .
Por ejemplo, probar si existe un objeto Promise incorporado (no existe en navegadores muy antiguos):

      
        
        
          
            
          
          
            
          
        
        
          if (!window.Promise) {
  alert("Your browser is really old!");
}
        
      
      
      Si no lo encuentra (suponiendo que estamos en un navegador antiguo), podemos crear “polyfills”: agregarle funciones que no están soportadas por el entorno, pero que existen en el estándar moderno.

      
        
        
          
            
          
          
            
          
        
        
          if (!window.Promise) {
  window.Promise = ... // implementación personalizada del lenguaje moderno
}
        
      
      
      Resumen

El objeto global contiene variables que deberían estar disponibles en todas partes.
Eso incluye JavaScript incorporado, tales como Array y valores específicos del entorno, o como window.innerHeight: la altura de la ventana en el navegador.


El objeto global tiene un nombre universal: globalThis.
… Pero con mayor frecuencia se hace referencia a nombres específicos del entorno de la “vieja escuela”, como window (en el navegador) y global (en Node.js).


Deberíamos almacenar valores en el objeto global solo si son verdaderamente globales para nuestro proyecto. Y manteniendo su uso al mínimo.


En el navegador, a menos que estemos utilizando módulos, las funciones globales y las variables declaradas con var se convierten en propiedades del objeto global.


Para que nuestro código esté preparado para el futuro y sea más fácil de entender, debemos acceder a las propiedades del objeto global directamente, como window.x.


",
	"url": "https://es.javascript.info/global-object" 
},
{
	"docs_id": "56",
	"name": "Función como objeto, NFE",
	"description": "Como ya sabemos, una función en JavaScript es un valor.",
	"content": "Como ya sabemos, una función en JavaScript es un valor.
Cada valor en JavaScript tiene un tipo. ¿Qué tipo es una función?
En JavaScript, las funciones son objetos.
Una buena manera de imaginar funciones es como “objetos de acción” invocables. No solo podemos llamarlos, sino también tratarlos como objetos: agregar/eliminar propiedades, pasar por referencia, etc.
La propiedad “name”Las funciones como objeto contienen algunas propiedades utilizables.
Por ejemplo, el nombre de una función es accesible mediante la propiedad “name”:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert("Hi");
}

alert(sayHi.name); // sayHi
        
      
      
      Lo que es divertido, es que la lógica de asignación de nombres es inteligente. También da el nombre correcto a una función, incluso si se creó sin uno:

      
        
        
          
            
          
          
            
          
        
        
          let sayHi = function() {
  alert("Hi");
};

alert(sayHi.name); // sayHi (¡hay un nombre!)
        
      
      
      También funciona si la asignación se realiza mediante un valor predeterminado:

      
        
        
          
            
          
          
            
          
        
        
          function f(sayHi = function() {}) {
  alert(sayHi.name); // sayHi (¡funciona!)
}

f();
        
      
      
      En la especificación, esta característica se denomina “nombre contextual”. Si la función no proporciona una, entonces en una asignación se deduce del contexto.
Los métodos de objeto también tienen nombres:

      
        
        
          
            
          
          
            
          
        
        
          let user = {

  sayHi() {
    // ...
  },

  sayBye: function() {
    // ...
  }

}

alert(user.sayHi.name); // sayHi
alert(user.sayBye.name); // sayBye
        
      
      
      Sin embargo, no hay magia. Hay casos en que no hay forma de encontrar el nombre correcto. En ese caso, la propiedad “name” está vacía, como aquí:

      
        
        
          
            
          
          
            
          
        
        
          // función creada dentro de un array
let arr = [function() {}];

alert( arr[0].name ); // <empty string>
// el motor no tiene forma de establecer el nombre correcto, por lo que no asigna ninguno
        
      
      
      En la práctica, sin embargo, la mayoría de las funciones tienen un nombre.
La propiedad “length”Hay una nueva propiedad “length” incorporada  que devuelve el número de parámetros de una función, por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function f1(a) {}
function f2(a, b) {}
function many(a, b, ...more) {}

alert(f1.length); // 1
alert(f2.length); // 2
alert(many.length); // 2
        
      
      
      Aquí podemos ver que los parámetros rest no se cuentan.
La propiedad length a veces se usa para introspección en funciones que operan en otras funciones.
Por ejemplo, en el siguiente código, la función ask , acepta una question  y un número arbitrario de funciones controladoras o handler para llamar.
Una vez que un usuario proporciona su respuesta, la función llama a los controladores. Podemos pasar dos tipos de controladores:

Una función de cero argumentos, que solo se llama cuando el usuario da una respuesta positiva.
Una función con argumentos, que se llama en cualquier caso y devuelve una respuesta.

Para llamar a handler de la manera correcta, examinamos la propiedad handler.length.
La idea es que tenemos una sintaxis de controlador simple y sin argumentos para casos positivos (la variante más frecuente), pero también podemos admitir controladores universales:

      
        
        
          
            
          
          
            
          
        
        
          function ask(question, ...handlers) {
  let isYes = confirm(question);

  for(let handler of handlers) {
    if (handler.length == 0) {
      if (isYes) handler();
    } else {
      handler(isYes);
    }
  }

}

// para una respuesta positiva, se llaman ambos controladores
// para respuesta negativa, solo el segundo
ask("Question?", () => alert('You said yes'), result => alert(result));
        
      
      
      Este es un caso particular llamado polimorfismo – tratar los argumentos de manera diferente según su tipo o, en nuestro caso, según la ‘longitud’. La idea tiene un uso en las bibliotecas de JavaScript.
Propiedades personalizadasTambién podemos agregar nuestras propias propiedades.
Aquí agregamos la propiedad counter para registrar el recuento total de llamadas:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert("Hi");

  //vamos a contar las veces que se ejecuta
  sayHi.counter++;
}
sayHi.counter = 0; // valor inicial

sayHi(); // Hi
sayHi(); // Hi

alert( `Called ${sayHi.counter} times` ); //  Llamamos 2 veces
        
      
      
      
            Una propiedad no es una variable
            Una propiedad asignada a una función como sayHi.counter = 0 no define una variable local counter dentro de ella. En otras palabras, una propiedad counter y una variable let counter son dos cosas no relacionadas.
Podemos tratar una función como un objeto, almacenar propiedades en ella, pero eso no tiene ningún efecto en su ejecución. Las variables no son propiedades de la función y viceversa. Estos solo son dos mundos paralelos.

Las propiedades de la función a veces pueden reemplazar las clausuras o closures. Por ejemplo, podemos reescribir el ejemplo de la función de contador del capítulo Ámbito de Variable y el concepto "closure" para usar una propiedad de función:

      
        
        
          
            
          
          
            
          
        
        
          function makeCounter() {
  // en vez de:
  // let count = 0

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();
alert( counter() ); // 0
alert( counter() ); // 1
        
      
      
      count ahora se almacena en la función directamente, no en su entorno léxico externo.
¿Es mejor o peor que usar una clausura (closure)?
La principal diferencia es que si el valor de count vive en una variable externa, entonces el código externo no puede acceder a él. Solo las funciones anidadas pueden modificarlo. Y si está vinculado a una función, entonces tal cosa es posible:

      
        
        
          
            
          
          
            
          
        
        
          function makeCounter() {

  function counter() {
    return counter.count++;
  };

  counter.count = 0;

  return counter;
}

let counter = makeCounter();

counter.count = 10;
alert( counter() ); // 10
        
      
      
      Por lo tanto, la elección de la implementación depende de nuestros objetivos.
Expresión de Función con NombreNamed Function Expression, o NFE, es un término para Expresiones de funciones que tienen un nombre.
Por ejemplo, tomemos una expresión de función ordinaria:

      
        
        
          let sayHi = function(who) {
  alert(`Hello, ${who}`);
};
        
      
      
      Y agrégale un nombre:

      
        
        
          let sayHi = function func(who) {
  alert(`Hello, ${who}`);
};
        
      
      
      ¿Logramos algo aquí? ¿Cuál es el propósito de ese nombre adicional de "func"?
Primero, tengamos en cuenta que todavía tenemos una Expresión de Función. Agregar el nombre "func" después de function no lo convirtió en una Declaración de Función, porque todavía se crea como parte de una expresión de asignación.
Agregar ese nombre tampoco rompió nada.
La función todavía está disponible como sayHi():

      
        
        
          
            
          
          
            
          
        
        
          let sayHi = function func(who) {
  alert(`Hello, ${who}`);
};

sayHi("John"); // Hello, John
        
      
      
      Hay dos cosas especiales sobre el nombre func, que le hacen útil:

Permite que la función se haga referencia internamente.
No es visible fuera de la función…

Por ejemplo, la función sayHi a continuación se vuelve a llamar a sí misma con "Guest" si no se proporciona who:

      
        
        
          
            
          
          
            
          
        
        
          let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // usa func para volver a llamarse a sí misma
  }
};

sayHi(); // Hello, Guest

// Pero esto no funcionará.
func(); // Error, func no está definido (no visible fuera de la función)
        
      
      
      ¿Por qué usamos func? ¿Quizás solo usa sayHi para la llamada anidada?
En realidad, en la mayoría de los casos podemos:

      
        
        
          let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi("Guest");
  }
};
        
      
      
      El problema con ese código es que sayHi puede cambiar en el código externo. Si la función se asigna a otra variable, el código comenzará a dar errores:

      
        
        
          
            
          
          
            
          
        
        
          let sayHi = function(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    sayHi("Guest"); // Error: sayHi no es una función
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Error, ¡la llamada sayHi anidada ya no funciona!
        
      
      
      Eso sucede porque la función toma sayHi de su entorno léxico externo. No hay sayHi local, por lo que se utiliza la variable externa. Y en el momento de la llamada, ese sayHi externo es nulo.
El nombre opcional que podemos poner en la Expresión de función está destinado a resolver exactamente este tipo de problemas.
Usémoslo para arreglar nuestro código:

      
        
        
          
            
          
          
            
          
        
        
          let sayHi = function func(who) {
  if (who) {
    alert(`Hello, ${who}`);
  } else {
    func("Guest"); // Ahora todo va bien
  }
};

let welcome = sayHi;
sayHi = null;

welcome(); // Hello, Guest (la llamada anidada funciona)
        
      
      
      Ahora funciona, porque el nombre "func" es una función local. No se toma desde el exterior (y no es visible allí). La especificación garantiza que siempre hará referencia a la función actual.
El código externo todavía tiene su variable sayHi o welcome. Y func es el “nombre de función interna” con el que la función puede llamarse a sí misma de manera confiable.

            No existe tal cosa para la Declaración de funciones
            La característica “nombre interno” descrita aquí solo está disponible para Expresiones de funciones, no para Declaraciones de funciones. Para las declaraciones de funciones, no hay sintaxis para agregar un nombre “interno”.
A veces necesitamos un nombre interno confiable, este es un motivo para reescribir una Declaración de función en una Expresión de función con nombre.

ResumenLas funciones son objetos.
Aquí cubrimos sus propiedades:

name – El nombre de la función. Por lo general, se toma de la definición de la función, pero si no hay ninguno, JavaScript intenta adivinarlo por el contexto (por ejemplo, una asignación).
length – El número de argumentos en la definición de la función. Los parámetros rest no se cuentan.

Si la función se declara como una Expresión de función (no en el flujo de código principal), y lleva el nombre, se llama Expresión de Función con Nombre (Named Function Expression). El nombre se puede usar dentro para hacer referencia a sí mismo, para llamadas recursivas o similares.
Además, las funciones pueden tener propiedades adicionales. Muchas bibliotecas de JavaScript conocidas hacen un gran uso de esta función.
Crean una función “principal” y le asignan muchas otras funciones “auxiliares”. Por ejemplo, la biblioteca jQuery crea una función llamada $. La biblioteca  lodash crea una función  _, y luego agrega _.clone, _.keyBy y otras propiedades (mira los docs cuando quieras aprender más sobre ello). En realidad, lo hacen para disminuir su contaminación del espacio global, de modo que una sola biblioteca proporciona solo una variable global. Eso reduce la posibilidad de conflictos de nombres.
Por lo tanto, una función puede hacer un trabajo útil por sí misma y también puede tener muchas otras funcionalidades en las propiedades.
TareasEstablecer y disminuir un contadorimportancia: 5Modifique el código de makeCounter() para que el contador también pueda disminuir y establecer el número:

counter() debe devolver el siguiente número (como antes).
counter.set(value) debe establecer el contador a value.
counter.decrease() debe disminuir el contador en 1.

Consulte el código en el entorno de pruebas para ver el ejemplo de uso completo.
P.D. Puedes usar un “closure” o la propiedad de función para mantener el recuento actual. O escribe ambas variantes.
Abrir en entorno controlado con pruebas.soluciónLa solución usa count en la variable local, pero los métodos de suma se escriben directamente en el counter. Comparten el mismo entorno léxico externo y también pueden acceder al count actual.

      
        
        
          function makeCounter() {
  let count = 0;

  function counter() {
    return count++;
  }

  counter.set = value => count = value;

  counter.decrease = () => count--;

  return counter;
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Suma con una cantidad arbitraria de paréntesisimportancia: 2Escriba la función sum que funcionaría así:

      
        
        
          sum(1)(2) == 3; // 1 + 2
sum(1)(2)(3) == 6; // 1 + 2 + 3
sum(5)(-1)(2) == 6
sum(6)(-1)(-2)(-3) == 0
sum(0)(1)(2)(3)(4)(5) == 15
        
      
      
      P.D. Sugerencia: es posible que deba configurar una conversión personalizada “objeto a primitiva” en su función.
Abrir en entorno controlado con pruebas.solución
Para que todo funcione de cualquier forma, el resultado de sum debe ser una función.
Esa función debe mantener en la memoria el valor actual entre llamadas.
Según la tarea, la función debe convertirse en el número cuando se usa en ==. Las funciones son objetos, por lo que la conversión se realiza como se describe en el capítulo Conversión de objeto a valor primitivo, y podemos proporcionar nuestro propio método para devolver el número.

Ahora el código:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a) {

  let currentSum = a;

  function f(b) {
    currentSum += b;
    return f;
  }

  f.toString = function() {
    return currentSum;
  };

  return f;
}

alert( sum(1)(2) ); // 3
alert( sum(5)(-1)(2) ); // 6
alert( sum(6)(-1)(-2)(-3) ); // 0
alert( sum(0)(1)(2)(3)(4)(5) ); // 15
        
      
      
      Tenga en cuenta que la función sum en realidad solo funciona una vez. Devuelve la función f.
Luego, en cada llamada posterior, f agrega su parámetro a la sumacurrentSum, y se devuelve.
No hay recursividad en la última línea de f.
Así es como se ve la recursividad:

      
        
        
          function f(b) {
  currentSum += b;
  return f(); // <-- llamada recursiva
}
        
      
      
      Y en nuestro caso, solo devolvemos la función, sin llamarla:

      
        
        
          function f(b) {
  currentSum += b;
  return f; // <-- no se llama a sí mismo, se devuelve
}
        
      
      
      Esta f se usará en la próxima llamada, nuevamente se devolverá, tantas veces como sea necesario. Luego, cuando se usa como un número o una cadena, el toString devuelve el currentSum. También podríamos usar Symbol.toPrimitive o valueOf para la conversión.
Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/function-object" 
},
{
	"docs_id": "57",
	"name": "La sintaxis "new Function"",
	"description": "Hay una forma más de crear una función. Raramente se usa, pero a veces no hay alternativa.",
	"content": "Hay una forma más de crear una función. Raramente se usa, pero a veces no hay alternativa.
SintaxisLa sintaxis para crear una función:

      
        
        
          let func = new Function ([arg1, arg2, ...argN], functionBody);
        
      
      
      La función se crea con los argumentos arg1 ... argN y el cuerpo functionBody dado.
Es más fácil entender viendo un ejemplo: Aquí tenemos una función con dos argumentos:

      
        
        
          
            
          
          
            
          
        
        
          let sumar = new Function('a', 'b', 'return a + b');

alert(sumar(1, 2)); // 3
        
      
      
      Y aquí tenemos unaa función sin argumentos, con solo el cuerpo de la función:

      
        
        
          
            
          
          
            
          
        
        
          let diHola = new Function('alert("Hola")');

diHola(); // Hola
        
      
      
      La mayor diferencia sobre las otras maneras de crear funciones que hemos visto, es que la función se crea desde un string y es pasada en tiempo de ejecución.
Las declaraciones anteriores nos obliga a nosotros, los programadores, a escribir el código de la función en el script.
Pero new Function nos permite convertir cualquier string en una función. Por ejemplo, podemos recibir una nueva función desde el servidor y ejecutarlo.

      
        
        
          let str = ... recibir el código de un servidor dinámicamente ...

let func = new Function(str);
func();
        
      
      
      Se utilizan en casos muy específicos, como cuando recibimos código de un servidor, o compilar dinámicamente una función a partir de una plantilla. La necesidad surge en etapas avanzadas de desarrollo.
ClosureNormalmente, una función recuerda dónde nació en una propiedad especial llamada [[Environment]], que hace referencia al entorno léxico desde dónde se creó.
Pero cuando una función es creada usando new Function, su [[Environment]] no hace referencia al entorno léxico actual, sino al global.
Entonces, tal función no tiene acceso a las variables externas, solo a las globales.

      
        
        
          
            
          
          
            
          
        
        
          function getFunc() {
  let valor = "test";

  let func = new Function('alert(valor)');

  return func;
}

getFunc()(); // error: valor is not defined
        
      
      
      Compáralo con el comportamiento normal:

      
        
        
          
            
          
          
            
          
        
        
          function getFunc() {
  let valor = "test";

  let func = function() { alert(valor); };

  return func;
}

getFunc()(); // "test", obtenido del entorno léxico de getFunc
        
      
      
      Esta característica especial de new Function parece extraña, pero resulta muy útil en la práctica.
Imagina que debemos crear una función a partir de una string. El código de dicha función no se conoce al momento de escribir el script (es por eso que no usamos funciones regulares), sino que se conocerá en el proceso de ejecución. Podemos recibirlo del servidor o de otra fuente.
Nuestra nueva función necesita interactuar con el script principal.
¿Qué pasa si pudiera acceder a las variables locales externas?
El problema es que antes de publicar el JavaScript a producción, este es comprimido usando un minifier : un programa especial que comprime código eliminando los comentarios extras, espacios y, lo que es más importante, renombra las variables locales a otras más cortas.
Por ejemplo, si una función tiene let userName, el minifier lo reemplaza con let a (u otra letra si ésta está siendo utilizada), y lo hace en todas partes. Esto normalmente es una práctica segura, porque al ser una variable local, nada de fuera de la función puede acceder a ella. Y dentro de una función, el minifier reemplaza todo lo que la menciona. Los Minificadores son inteligentes, ellos analizan la estructura del código, por lo tanto, no rompen nada. No realizan un simple buscar y reemplazar.
Pero si new Function pudiera acceder a las variables externas, no podría encontrar la variable userName renombrada.
Si new Function tuviera acceso a variables externas, tendríamos problemas con los minificadores
Además, tal código sería una mala arquitectura y propensa a errores.
Para pasar algo a una función creada como new Function, debemos usar sus argumentos.
ResumenLa sintaxis:

      
        
        
          let func = new Function ([arg1, arg2, ...argN], functionBody);
        
      
      
      Por razones históricas, los argumentos también pueden ser pasados como una lista separada por comas.
Estas tres declaraciones significan lo mismo:

      
        
        
          new Function('a', 'b', 'return a + b'); // sintaxis básica
new Function('a,b', 'return a + b'); // separación por comas
new Function('a , b', 'return a + b'); // separación por comas con espacios
        
      
      
      Las funciones creadas con new Function, tienen [[Environment]] haciendo referencia a ambiente léxico global, no al externo. En consecuencia no pueden usar variables externas. Pero eso es en realidad algo bueno, porque nos previene de errores. Pasar parámetros explícitamente es mucho mejor arquitectónicamente y no causa problemas con los minificadores.
",
	"url": "https://es.javascript.info/new-function" 
},
{
	"docs_id": "58",
	"name": "Planificación: setTimeout y setInterval",
	"description": "Podemos decidir ejecutar una función no ahora, sino en un momento posterior. Eso se llama “planificar una llamada”.",
	"content": "Podemos decidir ejecutar una función no ahora, sino en un momento posterior. Eso se llama “planificar una llamada”.
Hay dos métodos para ello:

setTimeout nos permite ejecutar una función una vez después del intervalo de tiempo.
setInterval nos permite ejecutar una función repetidamente, comenzando después del intervalo de tiempo, luego repitiéndose continuamente en ese intervalo.

Estos métodos no son parte de la especificación de JavaScript. Pero la mayoría de los entornos tienen el planificador interno y proporcionan estos métodos. En particular, son compatibles con todos los navegadores y Node.js.
setTimeoutLa sintaxis:

      
        
        
          let timerId = setTimeout(func|código, [retraso], [arg1], [arg2], ...)
        
      
      
      Parámetros:

func|código
Una función o un string con código para ejecutar. Lo normal es que sea una función. Por razones históricas es posible pasar una cadena de código, pero no es recomendable.
retraso
El retraso o delay antes de la ejecución, en milisegundos (1000 ms = 1 segundo), por defecto 0.
arg1, arg2…
Argumentos para la función (no compatible con IE9-)

Por ejemplo, este código llama a sayHi() después de un segundo:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert('Hola');
}

setTimeout(sayHi, 1000);
        
      
      
      Con argumentos:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi(phrase, who) {
  alert( phrase + ', ' + who );
}

setTimeout(sayHi, 1000, "Hola", "John"); // Hello, John
        
      
      
      Si el primer argumento es un string, JavaScript crea una función a partir de él.
Entonces, esto también funcionará:

      
        
        
          
            
          
          
            
          
        
        
          setTimeout("alert('Hola')", 1000);
        
      
      
      Pero no se recomienda usar strings, use funciones de flecha en lugar de ello:

      
        
        
          
            
          
          
            
          
        
        
          setTimeout(() => alert('Hola'), 1000);
        
      
      
      
            Pasa una función, pero no la ejecuta
            Los principiantes a veces cometen un error al agregar paréntesis () después de la función:

      
        
        
          // ¡mal!
setTimeout(sayHi(), 1000);
        
      
      
      Eso no funciona, porque setTimeout espera una referencia a una función. Y aquí sayHi() ejecuta la función, y el resultado de su ejecución se pasa a setTimeout. En nuestro caso, el resultado de sayHi() es undefined (la función no devuelve nada), por lo que no habrá nada planificado.

Cancelando con clearTimeoutUna llamada a setTimeout devuelve un “identificador de temporizador” timerId que podemos usar para cancelar la ejecución.
La sintaxis para cancelar:

      
        
        
          let timerId = setTimeout(...);
clearTimeout(timerId);
        
      
      
      En el siguiente código, planificamos la función y luego la cancelamos (cambiamos de opinión). Como resultado, no pasa nada:

      
        
        
          
            
          
          
            
          
        
        
          let timerId = setTimeout(() => alert("no pasa nada"), 1000);
alert(timerId); // identificador del temporizador

clearTimeout(timerId);
alert(timerId); // mismo identificador (No se vuelve nulo después de cancelar)
        
      
      
      Como podemos ver en la salida alert, en un navegador el identificador del temporizador es un número. En otros entornos, esto puede ser otra cosa. Por ejemplo, Node.js devuelve un objeto de temporizador con métodos adicionales.
Nuevamente, no hay una especificación universal para estos métodos.
Para los navegadores, los temporizadores se describen en la sección timers del estándar HTML5.
setIntervalEl método setInterval tiene la misma sintaxis que setTimeout:

      
        
        
          let timerId = setInterval(func|código, [retraso], [arg1], [arg2], ...)
        
      
      
      Todos los argumentos tienen el mismo significado. Pero a diferencia de setTimeout, ejecuta la función no solo una vez, sino regularmente después del intervalo de tiempo dado.
Para detener las llamadas, debemos llamar a ‘clearInterval (timerId)’.
El siguiente ejemplo mostrará el mensaje cada 2 segundos. Después de 5 segundos, la salida se detiene:

      
        
        
          
            
          
          
            
          
        
        
          // repetir con el intervalo de 2 segundos
let timerId = setInterval(() => alert('tick'), 2000);

// después de 5 segundos parar
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
        
      
      
      
            El tiempo pasa mientras se muestra ‘alerta’
            En la mayoría de los navegadores, incluidos Chrome y Firefox, el temporizador interno continúa “marcando” mientras muestra “alert/confirm/prompt”.
Entonces, si ejecuta el código anterior y no descarta la ventana de ‘alerta’ por un tiempo, la próxima ‘alerta’ se mostrará de inmediato. El intervalo real entre alertas será más corto que 2 segundos.

setTimeout anidadoHay dos formas de ejecutar algo regularmente.
Uno es setInterval. El otro es un setTimeout anidado, como este:

      
        
        
          /** en vez de:
let timerId = setInterval(() => alert('tick'), 2000);
*/

let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);
        
      
      
      El setTimeout anterior planifica la siguiente llamada justo al final de la actual (*).
El setTimeout anidado es un método más flexible que setInterval. De esta manera, la próxima llamada se puede planificar de manera diferente, dependiendo de los resultados de la actual.
Ejemplo: necesitamos escribir un servicio que envíe una solicitud al servidor cada 5 segundos solicitando datos, pero en caso de que el servidor esté sobrecargado, deber aumentar el intervalo a 10, 20, 40 segundos…
Aquí está el pseudocódigo:

      
        
        
          let delay = 5000;

let timerId = setTimeout(function request() {
  ...enviar solicitud...

  if (solicitud fallida debido a sobrecarga del servidor) {
    //aumentar el intervalo en la próxima ejecución
    delay *= 2;
  }

  timerId = setTimeout(request, delay);

}, delay);
        
      
      
      Y si las funciones que estamos planificando requieren mucha CPU, entonces podemos medir el tiempo que tarda la ejecución y planificar la próxima llamada más tarde o más temprano.
setTimeout anidado permite establecer el retraso entre las ejecuciones con mayor precisión que setInterval.
Comparemos dos fragmentos de código. El primero usa setInterval:

      
        
        
          let i = 1;
setInterval(function() {
  func(i++);
}, 100);
        
      
      
      El segundo usa setTimeout anidado:

      
        
        
          let i = 1;
setTimeout(function run() {
  func(i++);
  setTimeout(run, 100);
}, 100);
        
      
      
      Para  setInterval el planificador interno se ejecutará func(i++) cada 100ms:

      
      
        
      
      ¿Te diste cuenta?
¡El retraso real entre las llamadas de func para setInterval es menor que en el código!
Eso es normal, porque el tiempo que tarda la ejecución de func “consume” una parte del intervalo.
Es posible que la ejecución de func sea más larga de lo esperado y demore más de 100 ms.
En este caso, el motor espera a que se complete func, luego verifica el planificador y, si se acabó el tiempo, lo ejecuta de nuevo inmediatamente.
En caso límite, si la ejecución de la función siempre demora más que los ms de retraso, entonces las llamadas se realizarán sin pausa alguna.
Y aquí está la imagen para el setTimeout anidado:

      
      
        
      
      El setTimeout anidado garantiza el retraso fijo (aquí 100ms).
Esto se debe a que se planea una nueva llamada al final de la anterior.

            Recolección de basura y setInterval/setTimeout callback
            Cuando se pasa una función en setInterval / setTimeout, se crea una referencia interna y se guarda en el planificador. Esto evita que la función se recolecte, incluso si no hay otras referencias a ella…

      
        
        
          // la función permanece en la memoria hasta que el planificador la llame
setTimeout(function() {...}, 100);
        
      
      
      Para setInterval, la función permanece en la memoria hasta que se invoca clearInterval.
Hay un efecto secundario. Una función hace referencia al entorno léxico externo, por lo tanto, mientras vive, las variables externas también viven. Pueden tomar mucha más memoria que la función misma. Entonces, cuando ya no necesitamos la función planificada es mejor cancelarla, incluso si es muy pequeña.

Retraso cero en setTimeoutHay un caso de uso especial: setTimeout (func, 0), o simplemente setTimeout (func).
Esto planifica la ejecución de func lo antes posible. Pero el planificador lo invocará solo después de que se complete el script que se está ejecutando actualmente.
Por lo tanto, la función está planificada para ejecutarse “justo después” del script actual.
Por ejemplo, esto genera “Hola”, e inmediatamente después “Mundo”:

      
        
        
          
            
          
          
            
          
        
        
          setTimeout(() => alert("Mundo"));

alert("Hola");
        
      
      
      La primera línea “pone la llamada en el calendario después de 0 ms”. Pero el planificador solo “verificará el calendario” una vez que se haya completado el script actual, por lo que “Hola” es primero y “Mundo” después.
También hay casos de uso avanzados relacionados con el navegador y el tiempo de espera cero (zero-delay), que discutiremos en el capítulo Loop de eventos: microtareas y macrotareas.

            De hecho, el retraso cero no es cero (en un navegador)
            En el navegador, hay una limitación de la frecuencia con la que se pueden ejecutar los temporizadores anidados. EL HTML5 standard dice: “después de cinco temporizadores anidados, el intervalo debe ser de al menos 4 milisegundos”.
Demostremos lo que significa con el siguiente ejemplo. La llamada setTimeout se planifica a sí misma con cero retraso. Cada llamada recuerda el tiempo real de la anterior en el array times. ¿Cómo son los retrasos reales? Veamos:

      
        
        
          
            
          
          
            
          
        
        
          let start = Date.now();
let times = [];

setTimeout(function run() {
  times.push(Date.now() - start); // recuerda el retraso de la llamada anterior

  if (start + 100 < Date.now()) alert(times); // mostrar los retrasos después de 100 ms
  else setTimeout(run); // de lo contrario replanificar
});

// Un ejemplo de la salida:
// 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100
        
      
      
      Los primeros temporizadores se ejecutan inmediatamente (tal como está escrito en la especificación), y luego vemos 9, 15, 20, 24 .... Entra en juego el retraso obligatorio de más de 4 ms entre invocaciones.
Lo mismo sucede si usamos setInterval en lugar de setTimeout: setInterval(f) ejecuta f algunas veces con cero retraso, y luego con 4+ ms de retraso.
Esa limitación proviene de la antigüedad y muchos scripts dependen de ella, por lo que existe por razones históricas.
Para JavaScript del lado del servidor, esa limitación no existe, y existen otras formas de planificar un trabajo asincrónico inmediato, como setImmediate para Node.js. Entonces esta nota es específica del navegador.

Resumen
Los métodos setTimeout(func, delay, ... args) y setInterval(func, delay, ... args) nos permiten ejecutar el func una vez / regularmente después de un retardo (delay) en milisegundos.
Para cancelar la ejecución, debemos llamar a clearTimeout / clearInterval con el valor devuelto por setTimeout / setInterval.
Las llamadas anidadas setTimeout son una alternativa más flexible a setInterval, lo que nos permite establecer el tiempo entre ejecuciones con mayor precisión.
La programación de retardo cero con setTimeout(func, 0)(lo mismo que setTimeout(func)) se usa para programar la llamada “lo antes posible, pero después de que se complete el script actual”.
El navegador limita la demora mínima para cinco o más llamadas anidadas de setTimeout o para setInterval (después de la quinta llamada) a 4 ms. Eso es por razones históricas.

Tenga en cuenta que todos los métodos de planificación no garantizan el retraso exacto.
Por ejemplo, el temporizador en el navegador puede ralentizarse por muchas razones:

La CPU está sobrecargada.
La pestaña del navegador está en modo de “segundo plano”.
El portátil está en modo “ahorro de batería”.

Todo eso puede aumentar la resolución mínima del temporizador (el retraso mínimo) a 300 ms o incluso 1000 ms dependiendo de la configuración de rendimiento del navegador y del nivel del sistema operativo.
TareasSalida cada segundoimportancia: 5Escriba una función printNumbers(from, to) que genere un número cada segundo, comenzando desde from y terminando con to.
Haz dos variantes de la solución.

Usando setInterval.
Usando setTimeout anidado.

soluciónUsando setInterval:

      
        
        
          
            
          
          
            
          
        
        
          function printNumbers(from, to) {
  let current = from;

  let timerId = setInterval(function() {
    alert(current);
    if (current == to) {
      clearInterval(timerId);
    }
    current++;
  }, 1000);
}

// uso:
printNumbers(5, 10);
        
      
      
      Usando setTimeout anidado:

      
        
        
          
            
          
          
            
          
        
        
          function printNumbers(from, to) {
  let current = from;

  setTimeout(function go() {
    alert(current);
    if (current < to) {
      setTimeout(go, 1000);
    }
    current++;
  }, 1000);
}

// uso:
printNumbers(5, 10);
        
      
      
      Tenga en cuenta que en ambas soluciones, hay un retraso inicial antes de la primera salida. La función se llama después de 1000ms la primera vez.
Si también queremos que la función se ejecute inmediatamente, entonces podemos agregar una llamada adicional en una línea separada, como esta:

      
        
        
          
            
          
          
            
          
        
        
          function printNumbers(from, to) {
  let current = from;

  function go() {
    alert(current);
    if (current == to) {
      clearInterval(timerId);
    }
    current++;
  }

  go();
  let timerId = setInterval(go, 1000);
}

printNumbers(5, 10);
        
      
      
      ¿Qué mostrará setTimeout?importancia: 5En el siguiente código hay una llamada programada setTimeout, luego se ejecuta un cálculo pesado que demora más de 100 ms en finalizar.
¿Cuándo se ejecutará la función programada?

Después del bucle.
Antes del bucle.
Al comienzo del bucle.

¿Qué va a mostrar ´alert()´?

      
        
        
          let i = 0;

setTimeout(() => alert(i), 100); // ?

// asumimos que el tiempo para ejecutar esta función es > 100 ms
for(let j = 0; j < 100000000; j++) {
  i++;
}
        
      
      
      soluciónCualquier setTimeout solo se ejecutará después de que el código actual haya finalizado.
La i será la última:100000000.

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

setTimeout(() => alert(i), 100); // 100000000

// asumimos que el tiempo para ejecutar esta función es > 100 ms
for(let j = 0; j < 100000000; j++) {
  i++;
}
        
      
      
      ",
	"url": "https://es.javascript.info/settimeout-setinterval" 
},
{
	"docs_id": "59",
	"name": "Decoradores y redirecciones, call/apply",
	"description": "JavaScript ofrece una flexibilidad excepcional cuando se trata de funciones. Se pueden pasar, usar como objetos, y ahora veremos cómo redirigir las llamadas entre ellas y decorarlas.",
	"content": "JavaScript ofrece una flexibilidad excepcional cuando se trata de funciones. Se pueden pasar, usar como objetos, y ahora veremos cómo redirigir las llamadas entre ellas y decorarlas.
Caché transparenteDigamos que tenemos una función slow(x), que es pesada para la CPU, pero cuyos resultados son “estables”: es decir que con la misma x siempre devuelve el mismo resultado.
Si la función se llama con frecuencia, es posible que queramos almacenar en caché (recordar) los resultados obtenidos para evitar perder tiempo en calcularlos de nuevo.
Pero en lugar de agregar esta funcionalidad en slow(), crearemos una función contenedora (en inglés “wrapper”, envoltorio) que agregue almacenamiento en caché. Como veremos, hacer esto tiene sus beneficios.
Aquí está el código, seguido por su explicación:

      
        
        
          
            
          
          
            
          
        
        
          function slow(x) {
  // puede haber un trabajo pesado de CPU aquí
  alert(`Called with ${x}`);
  return x;
}

function cachingDecorator(func) {
  let cache = new Map();

  return function(x) {
    if (cache.has(x)) {  // si hay tal propiedad en caché
      return cache.get(x); // lee el resultado
    }

    let result = func(x);  // de lo contrario llame a func

    cache.set(x, result);  // y almacenamos en caché (recordamos) el resultado
    return result;
  };
}

slow = cachingDecorator(slow);

alert( slow(1) ); // slow(1) es cacheado y se devuelve el resultado
alert( "Again: " + slow(1) ); // el resultado slow(1) es devuelto desde caché

alert( slow(2) ); // slow(2) es cacheado y devuelve el resultado
alert( "Again: " + slow(2) ); // el resultado slow(2) es devuelto desde caché
        
      
      
      En el código anterior, cachingDecorator es un decorador: una función especial que toma otra función y altera su comportamiento.
La idea es que podemos llamar a cachingDecorator para cualquier función, y devolver el contenedor de almacenamiento en caché. Eso es genial, porque podemos tener muchas funciones que podrían usar dicha función, y todo lo que tenemos que hacer es aplicarles ‘cachingDecorator’.
Al separar el caché del código de la función principal, también permite mantener el código principal más simple.
El resultado de cachingDecorator(func) es un contenedor: function(x) que envuelve la llamada de func(x) en la lógica de almacenamiento en caché:

      
      
        
      
      Desde un código externo, la función slow envuelta sigue haciendo lo mismo. Simplemente se agregó un aspecto de almacenamiento en caché a su comportamiento.
Para resumir, hay varios beneficios de usar un cachingDecorator separado en lugar de alterar el código de slow en sí mismo:

El cachingDecorator es reutilizable. Podemos aplicarlo a otra función.
La lógica de almacenamiento en caché es independiente, no aumentó la complejidad de slow en sí misma (si hubiera alguna).
Podemos combinar múltiples decoradores si es necesario.

Usando “func.call” para el contextoEl decorador de caché mencionado anteriormente no es adecuado para trabajar con métodos de objetos.
Por ejemplo, en el siguiente código, worker.slow() deja de funcionar después de la decoración:

      
        
        
          
            
          
          
            
          
        
        
          // // haremos el trabajo en caché de .slow
let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    // una aterradora tarea muy pesada para la CPU
    alert("Called with " + x);
    return x * this.someMethod(); // (*)
  }
};

// el mismo código de antes
function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func(x); // (**)
    cache.set(x, result);
    return result;
  };
}

alert( worker.slow(1) ); // el método original funciona

worker.slow = cachingDecorator(worker.slow); // ahora hazlo en caché

alert( worker.slow(2) ); // Whoops! Error: Cannot read property 'someMethod' of undefined
        
      
      
      El error ocurre en la línea (*) que intenta acceder a this.someMethod y falla. ¿Puedes ver por qué?
La razón es que el contenedor llama a la función original como func(x) en la línea (**). Y, cuando se llama así, la función obtiene this = undefined.
Observaríamos un síntoma similar si intentáramos ejecutar:

      
        
        
          let func = worker.slow;
func(2);
        
      
      
      Entonces, el contenedor pasa la llamada al método original, pero sin el contexto this. De ahí el error.
Vamos a solucionar esto:
Hay un método de función  especial incorporado func.call(context, …args) que permite llamar a una función que establece explícitamente this.
La sintaxis es:

      
        
        
          func.call(context, arg1, arg2, ...)
        
      
      
      Ejecuta func proporcionando el primer argumento como this, y el siguiente como los argumentos.
En pocas palabras, estas dos llamadas hacen casi lo mismo:

      
        
        
          func(1, 2, 3);
func.call(obj, 1, 2, 3)
        
      
      
      Ambos llaman func con argumentos 1, 2 y 3. La única diferencia es que func.call también establece this en obj.
Como ejemplo, en el siguiente código llamamos a sayHi en el contexto de diferentes objetos: sayHi.call(user) ejecuta sayHi estableciendo this = user, y la siguiente línea establece this = admin:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert(this.name);
}

let user = { name: "John" };
let admin = { name: "Admin" };

// use call para pasar diferentes objetos como "this"
sayHi.call( user ); // John
sayHi.call( admin ); // Admin
        
      
      
      Y aquí usamos call para llamar a say con el contexto y la frase dados:

      
        
        
          
            
          
          
            
          
        
        
          function say(phrase) {
  alert(this.name + ': ' + phrase);
}

let user = { name: "John" };

// user se convierte en this, y "Hello" se convierte en el primer argumento
say.call( user, "Hello" ); // John: Hello
        
      
      
      En nuestro caso, podemos usar call en el contenedor para pasar el contexto a la función original:

      
        
        
          
            
          
          
            
          
        
        
          let worker = {
  someMethod() {
    return 1;
  },

  slow(x) {
    alert("Called with " + x);
    return x * this.someMethod(); // (*)
  }
};

function cachingDecorator(func) {
  let cache = new Map();
  return function(x) {
    if (cache.has(x)) {
      return cache.get(x);
    }
    let result = func.call(this, x); // "this" se pasa correctamente ahora
    cache.set(x, result);
    return result;
  };
}

worker.slow = cachingDecorator(worker.slow); // ahora hazlo en caché

alert( worker.slow(2) ); // funciona
alert( worker.slow(2) ); // funciona, no llama al original (en caché)
        
      
      
      Ahora todo está bien.
Para aclararlo todo, veamos más profundamente cómo se transmite this:

Después del decorador worker.slow, ahora el contenedor es function(x) { ... }.
Entonces, cuando worker.slow(2) se ejecuta, el contenedor toma 2 como un argumento y a this=worker (objeto antes del punto).
Dentro del contenedor, suponiendo que el resultado aún no se haya almacenado en caché, func.call(this, x) pasa el this actual (=worker) y el argumento actual (=2) al método original.

Veamos los multi-argumentosAhora hagamos que cachingDecorator sea aún más universal. Hasta ahora solo funcionaba con funciones de un sólo argumento.
Ahora, ¿cómo almacenar en caché el método multi-argumento worker.slow?

      
        
        
          let worker = {
  slow(min, max) {
    return min + max; // una aterradora tarea muy pesada para la CPU
  }
};

// debería recordar llamadas del mismo argumento
worker.slow = cachingDecorator(worker.slow);
        
      
      
      Anteriormente, para un solo argumento x podríamos simplemente usar cache.set(x, result) para guardar el resultado y cache.get(x) para recuperarlo. Pero ahora necesitamos recordar el resultado para una combinación de argumentos (min, max). El Map nativo toma solo un valor como clave.
Hay muchas posibles soluciones:

Implemente una nueva estructura de datos similar a un mapa (o use una de un tercero) que sea más versátil y permita múltiples propiedades.
Use mapas anidados: cache.set(min) será un Map que almacena el par (max, result). Así podemos obtener result como cache.get(min).get(max).
Una dos valores en uno. En nuestro caso particular, podemos usar un string "min,max" como la propiedad de Map. Por flexibilidad, podemos permitir proporcionar un función hashing para el decorador, que sabe hacer un valor de muchos.

Para muchas aplicaciones prácticas, la tercera variante es lo suficientemente buena, por lo que nos mantendremos en esa opción.
También necesitamos pasar no solo x sino todos los argumentos en func.call. Recordemos que en una función(), con el uso de arguments podemos obtener un pseudo-array de sus argumentos, así que func.call(this, x) debería reemplazarse por func.call(this, ...arguments).
Aquí un mejorado y más potente cachingDecorator:

      
        
        
          
            
          
          
            
          
        
        
          let worker = {
  slow(min, max) {
    alert(`Called with ${min},${max}`);
    return min + max;
  }
};

function cachingDecorator(func, hash) {
  let cache = new Map();
  return function() {
    let key = hash(arguments); // (*)
    if (cache.has(key)) {
      return cache.get(key);
    }

    let result = func.call(this, ...arguments); // (**)

    cache.set(key, result);
    return result;
  };
}

function hash(args) {
  return args[0] + ',' + args[1];
}

worker.slow = cachingDecorator(worker.slow, hash);

alert( worker.slow(3, 5) ); // funciona
alert( "Again " + worker.slow(3, 5) ); // lo mismo (cacheado)
        
      
      
      Ahora funciona con cualquier número de argumentos (aunque la función hash también necesitaría ser ajustada para permitir cualquier número de argumentos. Una forma interesante de manejar esto se tratará a continuación).
Hay dos cambios:

En la línea (*) llama a hash para crear una sola propiedad de arguments. Aquí usamos una simple función de “unión” que convierte los argumentos (3, 5) en la propiedad "3,5". Los casos más complejos pueden requerir otras funciones hash.
Entonces (**) usa func.call(this, ...arguments) para pasar tanto el contexto como todos los argumentos que obtuvo el contenedor (no solo el primero) a la función original.

func.applyEn vez de func.call(this, ...arguments), podríamos usar func.apply(this, arguments).
La sintaxis del método incorporado func.apply es:

      
        
        
          func.apply(context, args)
        
      
      
      Ejecuta la configuración func this = context y usa un objeto tipo array args como lista de argumentos.
La única diferencia de sintaxis entre call y apply es que call espera una lista de argumentos, mientras que apply lleva consigo un objeto tipo matriz.
Entonces estas dos llamadas son casi equivalentes:

      
        
        
          func.call(context, ...args);
func.apply(context, args);
        
      
      
      Estas hacen la misma llamada de func con el contexto y argumento dados.
Solo hay una sutil diferencia con respect○ a args:

La sintaxis con el operador “spread” ... – en call permite pasar una lista iterable args.
La opción apply – acepta solamente args que sean símil-array.

Para los objetos que son iterables y símil-array, como un array real, podemos usar cualquiera de ellos, pero apply probablemente será más rápido porque la mayoría de los motores de JavaScript lo optimizan mejor internamente.
Pasar todos los argumentos junto con el contexto a otra función se llama redirección de llamadas.
Esta es la forma más simple:

      
        
        
          let wrapper = function() {
  return func.apply(this, arguments);
};
        
      
      
      Cuando un código externo llama a tal contenedor wrapper, no se puede distinguir de la llamada de la función original func .
Préstamo de métodoAhora hagamos una pequeña mejora en la función de hash:

      
        
        
          function hash(args) {
  return args[0] + ',' + args[1];
}
        
      
      
      A partir de ahora, funciona solo en dos argumentos. Sería mejor si pudiera adherir (glue) cualquier número de args.
La solución natural sería usar el método arr.join:

      
        
        
          function hash(args) {
  return args.join();
}
        
      
      
      … desafortunadamente, eso no funcionará. Esto es debido a que estamos llamando a hash (arguments), y el objeto arguments es iterable y símil-array (no es un array real).
Por lo tanto, llamar a join en él fallará, como podemos ver a continuación:

      
        
        
          
            
          
          
            
          
        
        
          function hash() {
  alert( arguments.join() ); // Error: arguments.join is not a function
}

hash(1, 2);
        
      
      
      Aún así, hay una manera fácil de usar la unión (join) de arrays:

      
        
        
          
            
          
          
            
          
        
        
          function hash() {
  alert( [].join.call(arguments) ); // 1,2
}

hash(1, 2);
        
      
      
      El truco se llama préstamo de método (method borrowing).
Tomamos (prestado) el método join de un array regular ([].join) y usamos [].join.call para ejecutarlo en el contexto de arguments.
¿Por qué funciona?
Esto se debe a que el algoritmo interno del método nativo arr.join (glue) es muy simple.
Tomado de la especificación casi “tal cual”:

Hacer que glue sea el primer argumento o, si no hay argumentos, entonces una coma ",".
Hacer que result sea una cadena vacía.
Adosar this[0] a result.
Adherir glue y this[1].
Adherir glue y this[2].
…hacerlo hasta que la cantidad this.length de elementos estén adheridos.
Devolver result.

Entonces, técnicamente toma a this y le une this[0], this[1]… etc. Está escrito intencionalmente de una manera que permite cualquier tipo de array this (no es una coincidencia, muchos métodos siguen esta práctica). Es por eso que también funciona con this = arguments
Decoradores y propiedades de funcionesPor lo general, es seguro reemplazar una función o un método con un decorador, excepto por una pequeña cosa. Si la función original tenía propiedades (como func.calledCount o cualquier otra) entonces la función decoradora no las proporcionará. Porque es una envoltura. Por lo tanto, se debe tener cuidado al usarlo.
En el ejemplo anterior, si la función slow tuviera propiedades, cachingDecorator(slow) sería un contenedor sin dichas propiedades.
Algunos decoradores pueden proporcionar sus propias propiedades. P.ej. un decorador puede contar cuántas veces se invocó una función y cuánto tiempo tardó, y exponer esta información por medio de propiedades del contenedor.
Existe una forma de crear decoradores que mantienen el acceso a las propiedades de la función, pero esto requiere el uso de un objeto especial Proxy para ajustar una función. Lo discutiremos más adelante en el artículo  Proxy y Reflect.
ResumenEl decorador es un contenedor alrededor de una función que altera su comportamiento. El trabajo principal todavía lo realiza la función.
Los decoradores se pueden ver como “características” o “aspectos” que se pueden agregar a una función. Podemos agregar uno o agregar muchos. ¡Y todo esto sin cambiar su código!
Para implementar cachingDecorator, hemos estudiado los siguientes métodos:

func.call(context, arg1, arg2…) – llama a func con el contexto y argumentos dados.
func.apply(context, args) – llama a func, pasando context como this, y un símil-array args como lista de argumentos.

La redirección de llamadas genérica generalmente se realiza con apply:

      
        
        
          let wrapper = function() {
  return original.apply(this, arguments);
};
        
      
      
      También vimos un ejemplo de préstamo de método cuando tomamos un método de un objeto y lo “llamamos” (call) en el contexto de otro objeto. Es bastante común tomar métodos de array y aplicarlos al símil-array arguments. La alternativa es utilizar el objeto de parámetros rest, que es un array real.
Hay muchos decoradores a tu alrededor. Verifica qué tan bien los entendiste resolviendo las tareas de este capítulo.
TareasDecorador espíaimportancia: 5Cree un decorador spy(func) que devuelva un contenedor el cual guarde todas las llamadas a la función en su propiedad calls
Cada llamada se guarda como un array de argumentos.
Por ejemplo

      
        
        
          function work(a, b) {
  alert( a + b ); // work es una función o método arbitrario
}

work = spy(work);

work(1, 2); // 3
work(4, 5); // 9

for (let args of work.calls) {
  alert( 'call:' + args.join() ); // "call:1,2", "call:4,5"
}
        
      
      
      P.D Ese decorador a veces es útil para pruebas unitarias. Su forma avanzada es sinon.spy en la librería Sinon.JS.
Abrir en entorno controlado con pruebas.soluciónEl contenedor devuelto por spy(f) debe almacenar todos los argumentos y luego usar f.apply para reenviar la llamada.

      
        
        
          function spy(func) {

  function wrapper(...args) {
    // usamos ...args en lugar de arguments para almacenar un array "real" en wrapper.calls
    wrapper.calls.push(args);
    return func.apply(this, args);
  }

  wrapper.calls = [];

  return wrapper;
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Decorador de retrasoimportancia: 5Cree un decorador delay(f, ms) que retrase cada llamada de f en ms milisegundos.
Por ejemplo

      
        
        
          function f(x) {
  alert(x);
}

// crear contenedores
let f1000 = delay(f, 1000);
let f1500 = delay(f, 1500);

f1000("test"); // mostrar "test" después de 1000ms
f1500("test"); // mostrar "test" después de 1500ms
        
      
      
      En otras palabras, delay (f, ms) devuelve una variante "Retrasada por ms" def.
En el código anterior, f es una función de un solo argumento, pero en esta solución debe pasar todos los argumentos y el contexto this.
Abrir en entorno controlado con pruebas.soluciónSolución:

      
        
        
          
            
          
          
            
          
        
        
          function delay(f, ms) {

  return function() {
    setTimeout(() => f.apply(this, arguments), ms);
  };

}

let f1000 = delay(alert, 1000);

f1000("test"); // mostrar "test" después de 1000ms
        
      
      
      Tenga en cuenta cómo se utiliza una función de flecha aquí. Sabemos que las funciones de flecha no tienen contextos propios this ni arguments, por lo que f.apply(this, arguments) toma this y arguments del contenedor.
Si pasamos una función regular, setTimeout la llamará sin argumentos y, suponiendo que estemos en el navegador, con this = window.
Todavía podemos pasar el this correcto usando una variable intermedia, pero eso es algo más engorroso:

      
        
        
          function delay(f, ms) {

  return function(...args) {
    let savedThis = this; // almacenar esto en una variable intermedia
    setTimeout(function() {
      f.apply(savedThis, args); // úsalo aquí
    }, ms);
  };

}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.Decorador debounceimportancia: 5El resultado del decorador debounce(f, ms) es un contenedor que suspende las llamadas a f hasta que haya ms milisegundos de inactividad (sin llamadas, “período de enfriamiento”), luego invoca f una vez con los últimos argumentos.
En otras palabras, debounce es como una secretaria que acepta “llamadas telefónicas” y espera hasta que haya ms milisegundos de silencio. Y solo entonces transfiere la información de la última llamada al “jefe” (llama a la “f” real).
Por ejemplo, teníamos una función f y la reemplazamos con f = debounce(f, 1000).
Entonces, si la función contenedora se llama a 0ms, 200ms y 500ms, y luego no hay llamadas, entonces la ‘f’ real solo se llamará una vez, a 1500ms. Es decir: después del período de enfriamiento de 1000 ms desde la última llamada.

      
      
        
      
      … Y obtendrá los argumentos de la última llamada, y se ignoran las otras llamadas.
Aquí está el código para ello (usa el decorador debounce del Lodash library:

      
        
        
          let f = _.debounce(alert, 1000);

f("a");
setTimeout( () => f("b"), 200);
setTimeout( () => f("c"), 500);
// la función debounce espera 1000 ms después de la última llamada y luego ejecuta: alert ("c")
        
      
      
      Ahora un ejemplo práctico. Digamos que el usuario escribe algo y nos gustaría enviar una solicitud al servidor cuando finalice la entrada.
No tiene sentido enviar la solicitud para cada carácter escrito. En su lugar, nos gustaría esperar y luego procesar todo el resultado.
En un navegador web, podemos configurar un controlador de eventos, una función que se llama en cada cambio de un campo de entrada. Normalmente, se llama a un controlador de eventos con mucha frecuencia, por cada tecla escrita. Pero si le pasamos debounce por 1000ms, entonces solo se llamará una vez, después de 1000ms después de la última entrada.
En este ejemplo en vivo, el controlador coloca el resultado en un cuadro a continuación, pruébelo:

    
    
  ¿Lo ve? La segunda entrada llama a la función debounce, por lo que su contenido se procesa después de 1000 ms desde la última entrada.
Entonces, debounce es una excelente manera de procesar una secuencia de eventos: ya sea una secuencia de pulsaciones de teclas, movimientos del mouse u otra cosa.
Espera el tiempo dado después de la última llamada y luego ejecuta su función, que puede procesar el resultado.
La tarea es implementar el decorador debounce.
Sugerencia: son solo algunas líneas si lo piensas :)
Abrir en entorno controlado con pruebas.solución
      
        
        
          function debounce(func, ms) {
  let timeout;
  return function() {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, arguments), ms);
  };
}
        
      
      
      Una llamada a debounce devuelve un contenedor “wrapper”. Cuando se lo llama, planifica la llamada a la función original después de los ms dados y cancela el tiempo de espera anterior.
Abrir la solución con pruebas en un entorno controlado.Decorador throttleimportancia: 5Crea un decorador “limitador” o “throttling” throttle(f, ms) que devuelve un contenedor.
Cuando se llama varias veces, pasa la llamada a f como máximo una vez por ms milisegundos.
Comparado con el decorador debounce, el comportamiento es completamente diferente:

debounce ejecuta la función una vez después del período de enfriamiento. Es bueno para procesar el resultado final.
throttle la ejecuta una y no más veces por el tiempo de ms dado. Es bueno para actualizaciones regulares que no deberían ser muy frecuentes.

En otras palabras, “throttle” es como una secretaria que acepta llamadas telefónicas, pero molesta al jefe (llama a la “f” real) no más de una vez por ms milisegundos.
Revisemos una aplicación de la vida real para comprender mejor ese requisito y ver de dónde proviene.
Por ejemplo, queremos registrar los movimientos del mouse.
En un navegador, podemos configurar una función para que se ejecute en cada movimiento del mouse y obtener la ubicación del puntero a medida que se mueve. Durante un uso activo del mouse, esta función generalmente se ejecuta con mucha frecuencia, puede ser algo así como 100 veces por segundo (cada 10 ms).
Nos gustaría actualizar cierta información en la página web cuando se mueve el puntero.
… Pero la función de actualización update() es demasiado pesada para hacerlo en cada micro-movimiento. Tampoco tiene sentido actualizar más de una vez cada 100 ms.
Entonces lo envolveremos en el decorador: para ejecutar en cada movimiento del mouse, usamos throttle(update, 100) en lugar del update() original. Se llamará al decorador con frecuencia, pero este reenviará la llamada a update() como máximo una vez cada 100 ms.
Visualmente, se verá así:

Para el primer movimiento del mouse, la variante decorada pasa inmediatamente la llamada a update. Esto es importante, el usuario ve nuestra reacción a su movimiento de inmediato.
Luego, a medida que el mouse avanza, hasta 100ms no sucede nada. La variante decorada ignora las llamadas.
Al final de 100ms – ocurre un update más con las últimas coordenadas.
Entonces, finalmente, el mouse se detiene en alguna parte. La variante decorada espera hasta que expiren 100ms y luego ejecuta update con las últimas coordenadas. Entonces, y esto es muy importante, se procesan las coordenadas finales del mouse.

Un código de ejemplo:

      
        
        
          function f(a) {
  console.log(a);
}

// f1000 pasa llamadas a f como máximo una vez cada 1000 ms
let f1000 = throttle(f, 1000);

f1000(1); // muestra 1
f1000(2); // (throttling, 1000ms aún no)
f1000(3); // (throttling, 1000ms aún no)

// tiempo de espera de 1000 ms ...
// ...devuelve 3, el valor intermedio 2 fue ignorado
        
      
      
      P.D. Los argumentos y el contexto this pasado a f1000 deben pasarse a la f original.
Abrir en entorno controlado con pruebas.solución
      
        
        
          function throttle(func, ms) {

  let isThrottled = false,
    savedArgs,
    savedThis;

  function wrapper() {

    if (isThrottled) { // (2)
      savedArgs = arguments;
      savedThis = this;
      return;
    }
    isThrottled = true;

    func.apply(this, arguments); // (1)

    setTimeout(function() {
      isThrottled = false; // (3)
      if (savedArgs) {
        wrapper.apply(savedThis, savedArgs);
        savedArgs = savedThis = null;
      }
    }, ms);
  }

  return wrapper;
}
        
      
      
      Una llamada a throttle(func, ms) devuelve el contenedor wrapper.

Durante la primera llamada, el wrapper solo ejecuta func y establece el estado de enfriamiento (isThrottled = true).
En este estado, todas las llamadas se memorizan en savedArgs/savedThis. Tenga en cuenta que tanto el contexto como los argumentos son igualmente importantes y deben memorizarse. Los necesitamos simultáneamente para reproducir la llamada.
Después de que pasan ms milisegundos, se activa setTimeout. El estado de enfriamiento se elimina (isThrottled = false) y, si ignoramos las llamadas, wrapper se ejecuta con los últimos argumentos y contexto memorizados.

El tercer paso no ejecuta func, sino wrapper, porque no solo necesitamos ejecutar func, sino que una vez más ingresamos al estado de enfriamiento y configuramos el tiempo de espera para restablecerlo.
Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/call-apply-decorators" 
},
{
	"docs_id": "60",
	"name": "Función bind: vinculación de funciones",
	"description": "Al pasar métodos de objeto como devoluciones de llamada, por ejemplo a setTimeout, se genera un problema conocido: la "pérdida de this".",
	"content": "Al pasar métodos de objeto como devoluciones de llamada, por ejemplo a setTimeout, se genera un problema conocido: la "pérdida de this".
En este capítulo veremos las formas de solucionarlo.
Pérdida de “this”Ya hemos visto ejemplos de pérdida de this. Una vez que se pasa hacia algún lugar un método separado de su objeto,  this se pierde.
Así es como puede suceder con setTimeout:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(user.sayHi, 1000); // Hello, undefined!
        
      
      
      Como podemos ver, el resultado no muestra “John” como this.firstName ¡sino undefined!
Esto se debe a que setTimeout tiene la función user.sayHi, separada del objeto. La última línea se puede reescribir como:

      
        
        
          let f = user.sayHi;
setTimeout(f, 1000); // user pierde el contexto
        
      
      
      El método setTimeout en el navegador es un poco especial: establece this = window para la llamada a la función (para Node.js, this se convierte en el objeto temporizador (timer), pero realmente no importa aquí). Entonces, en this.firstName intenta obtener window.firstName, que no existe. En otros casos similares, this simplemente se vuelve undefined.
La tarea es bastante típica: queremos pasar un método de objeto a otro lugar (aquí, al planificador) donde se llamará. ¿Cómo asegurarse de que se llamará en el contexto correcto?
Solución 1: un wrapper (envoltura)La solución más simple es usar una función wrapper:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(function() {
  user.sayHi(); // Hello, John!
}, 1000);
        
      
      
      Ahora funciona, porque recibe a user del entorno léxico externo, y luego llama al método normalmente.
Aquí hacemos lo mismo, pero de otra manera:

      
        
        
          setTimeout(() => user.sayHi(), 1000); // Hello, John!
        
      
      
      Se ve bien, pero aparece una ligera vulnerabilidad en nuestra estructura de código…
¿Qué pasa si antes de que se dispare setTimeout (¡hay un segundo retraso!) user cambia el valor? Entonces, de repente, ¡llamará al objeto equivocado!

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

setTimeout(() => user.sayHi(), 1000);

// ...el valor de user cambia en 1 segundo
user = {
  sayHi() { alert("Another user in setTimeout!"); }
};

// Otro user en setTimeout!
        
      
      
      La siguiente solución garantiza que tal cosa no sucederá.
Solución 2: bind (vincular)Las funciones proporcionan un método incorporado bind que permite fijar a this.
La sintaxis básica es:

      
        
        
          // la sintaxis más compleja vendrá un poco más tarde
let boundFunc = func.bind(context);
        
      
      
      El resultado de func.bind(context) es un “objeto exótico”, una función similar a una función regular que se puede llamar como función; esta pasa la llamada de forma transparente a func estableciendo this = context.
En otras palabras, llamar a boundFunc es como func con un this fijo.
Por ejemplo, aquí funcUser pasa una llamada a func con this = user:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  firstName: "John"
};

function func() {
  alert(this.firstName);
}

let funcUser = func.bind(user);
funcUser(); // John
        
      
      
      Aquí func.bind(user) es como una “variante vinculada” de func, con this = user fijo en ella.
Todos los argumentos se pasan al func original “tal cual”, por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  firstName: "John"
};

function func(phrase) {
  alert(phrase + ', ' + this.firstName);
}

// vincula this a user
let funcUser = func.bind(user);

funcUser("Hello"); // Hello, John (argumento "Hello" se pasa, y this=user)
        
      
      
      Ahora intentemos con un método de objeto:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  firstName: "John",
  sayHi() {
    alert(`Hello, ${this.firstName}!`);
  }
};

let sayHi = user.sayHi.bind(user); // (*)

// puede ejecutarlo sin un objeto
sayHi(); // Hello, John!

setTimeout(sayHi, 1000); // Hello, John!

// incluso si el valor del usuario cambia en 1 segundo
// sayHi usa el valor pre-enlazado
user = {
  sayHi() { alert("Another user in setTimeout!"); }
};
        
      
      
      En la línea (*) tomamos el método user.sayHi y lo vinculamos a user. sayHi es una función “vinculada”. No importa si se llama sola o se pasa en setTimeout, el contexto será el correcto.
Aquí podemos ver que los argumentos se pasan “tal cual”, solo que this se fija mediantebind:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  firstName: "John",
  say(phrase) {
    alert(`${phrase}, ${this.firstName}!`);
  }
};

let say = user.say.bind(user);

say("Hello"); // Hello, John! ("Hello" se pasa a say)
say("Bye"); // Bye, John! ("Bye" is passed to say)
        
      
      
      
            Convenience method:bindAll
            Si un objeto tiene muchos métodos y planeamos pasarlo activamente, podríamos vincularlos a todos en un bucle:

      
        
        
          for (let key in user) {
  if (typeof user[key] == 'function') {
    user[key] = user[key].bind(user);
  }
}
        
      
      
      Las bibliotecas de JavaScript también proporcionan funciones para un enlace masivo, e.j. _.bindAll(object, methodNames) en lodash.

Funciones parcialesHasta ahora solo hemos estado hablando de vincular this. Vamos un paso más allá.
Podemos vincular no solo this, sino también argumentos. Es algo que no suele hacerse, pero a veces puede ser útil.
Sintaxis completa de bind:

      
        
        
          let bound = func.bind(context, [arg1], [arg2], ...);
        
      
      
      Permite vincular el contexto como this y los argumentos iniciales de la función.
Por ejemplo, tenemos una función de multiplicación mul(a, b):

      
        
        
          function mul(a, b) {
  return a * b;
}
        
      
      
      Usemos bind para crear una funcióndouble en su base:

      
        
        
          
            
          
          
            
          
        
        
          function mul(a, b) {
  return a * b;
}

let double = mul.bind(null, 2);

alert( double(3) ); // = mul(2, 3) = 6
alert( double(4) ); // = mul(2, 4) = 8
alert( double(5) ); // = mul(2, 5) = 10
        
      
      
      La llamada a mul.bind(null, 2) crea una nueva función double que pasa las llamadas a mul, fijando null como contexto y 2 como primer argumento. Otros argumentos se pasan “tal cual”.
Esto se llama aplicación parcial: creamos una nueva función fijando algunos parámetros a la existente.
Tenga en cuenta que aquí en realidad no usamos this. Pero bind lo requiere, por lo que debemos poner algo como null.
La función triple en el siguiente código triplica el valor:

      
        
        
          
            
          
          
            
          
        
        
          function mul(a, b) {
  return a * b;
}

let triple = mul.bind(null, 3);

alert( triple(3) ); // = mul(3, 3) = 9
alert( triple(4) ); // = mul(3, 4) = 12
alert( triple(5) ); // = mul(3, 5) = 15
        
      
      
      ¿Por qué solemos hacer una función parcial?
El beneficio es que podemos crear una función independiente con un nombre legible (double,triple). Podemos usarlo y no proporcionar el primer argumento cada vez, ya que se fija con bind.
En otros casos, la aplicación parcial es útil cuando tenemos una función muy genérica y queremos una variante menos universal para mayor comodidad.
Por ejemplo, tenemos una función send(from, to, text). Luego, dentro de un objeto user podemos querer usar una variante parcial del mismo: sendTo(to, text) que envía desde el usuario actual.
Parcial sin contexto¿Qué pasa si queremos fijar algunos argumentos, pero no el contexto this? Por ejemplo, para un método de objeto.
El método bind nativo no permite eso. No podemos simplemente omitir el contexto y saltar a los argumentos.
Afortunadamente, se puede implementar fácilmente una función parcial para vincular solo argumentos.
Como esto:

      
        
        
          
            
          
          
            
          
        
        
          function partial(func, ...argsBound) {
  return function(...args) { // (*)
    return func.call(this, ...argsBound, ...args);
  }
}

// Uso:
let user = {
  firstName: "John",
  say(time, phrase) {
    alert(`[${time}] ${this.firstName}: ${phrase}!`);
  }
};

// agregar un método parcial con tiempo fijo
user.sayNow = partial(user.say, new Date().getHours() + ':' + new Date().getMinutes());

user.sayNow("Hello");
// Algo como:
// [10:00] John: Hello!
        
      
      
      El resultado de la llamada parcial(func [, arg1, arg2 ...]) es un contenedor wrapper (*) que llama a func con:

El mismo this (para la llamada a user.sayNow es user)
Luego le da ...argsBound: argumentos desde la llamada a partial ("10:00")
Luego le da ...args: argumentos dados desde la envoltura ("Hello")

Muy fácil de hacer con la sintaxis de propagación, ¿verdad?
También hay una implementación preparada _.partial desde la librería lodash.
ResumenEl método func.bind(context, ... args) devuelve una “variante vinculada” de la función func, fijando el contexto this y los primeros argumentos si estos se dan.
Por lo general, aplicamos bind para fijar this a un método de objeto, de modo que podamos pasarlo en otro lugar. Por ejemplo, en setTimeout.
Cuando fijamos algunos argumentos de una función existente, la función resultante (menos universal) se llama aplicación parcial o parcial.
Los parciales son convenientes cuando no queremos repetir el mismo argumento una y otra vez. Al igual que si tenemos una función send(from, to), y from siempre debe ser igual para nuestra tarea, entonces, podemos obtener un parcial y continuar la tarea con él.
TareasFunción enlazada como métodoimportancia: 5¿Cuál será el resultado?

      
        
        
          function f() {
  alert( this ); // ?
}

let user = {
  g: f.bind(null)
};

user.g();
        
      
      
      soluciónRespuesta: null.

      
        
        
          
            
          
          
            
          
        
        
          function f() {
  alert( this ); // null
}

let user = {
  g: f.bind(null)
};

user.g();
        
      
      
      El contexto de una función enlazada es fijo. Simplemente no hay forma de cambiarlo más.
Entonces, incluso mientras ejecutamos user.g(), la función original se llama con this = null.
Segundo enlaceimportancia: 5¿Podemos cambiar this por un enlace adicional?
¿Cuál será el resultado?

      
        
        
          function f() {
  alert(this.name);
}

f = f.bind( {name: "John"} ).bind( {name: "Ann" } );

f();
        
      
      
      soluciónRespuesta: John.

      
        
        
          
            
          
          
            
          
        
        
          function f() {
  alert(this.name);
}

f = f.bind( {name: "John"} ).bind( {name: "Pete"} );

f(); // John
        
      
      
      El objeto exótico bound function devuelto por f.bind(...) recuerda el contexto (y los argumentos si se proporcionan) solo en el momento de la creación.
Una función no se puede volver a vincular.
Propiedad de función después del enlaceimportancia: 5Hay un valor en la propiedad de una función. ¿Cambiará después de bind? ¿Por qué sí o por qué no?

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert( this.name );
}
sayHi.test = 5;

let bound = sayHi.bind({
  name: "John"
});

alert( bound.test ); // ¿Cuál será la salida? ¿por qué?
        
      
      
      soluciónRespuesta: undefined.
El resultado de bind es otro objeto. No tiene la propiedad test.
Arreglar una función que perdió "this"importancia: 5La llamada a askPassword() en el código a continuación debe verificar la contraseña y luego llamar a user.loginOk/loginFail dependiendo de la respuesta.
Pero lleva a un error. ¿Por qué?
Arregle la línea resaltada para que todo comience a funcionar correctamente (no se deben cambiar otras líneas).

      
        
        
          
            
          
          
            
          
        
        
          function askPassword(ok, fail) {
  let password = prompt("Password?", '');
  if (password == "rockstar") ok();
  else fail();
}

let user = {
  name: 'John',

  loginOk() {
    alert(`${this.name} logged in`);
  },

  loginFail() {
    alert(`${this.name} failed to log in`);
  },

};

askPassword(user.loginOk, user.loginFail);
        
      
      
      soluciónEl error se produce porque ask obtiene las funciones loginOk/loginFail sin el objeto.
Cuando los llama, asumen naturalmente this = undefined.
Vamos a usar bind para enlazar el contexto:

      
        
        
          
            
          
          
            
          
        
        
          function askPassword(ok, fail) {
  let password = prompt("Password?", '');
  if (password == "rockstar") ok();
  else fail();
}

let user = {
  name: 'John',

  loginOk() {
    alert(`${this.name} logged in`);
  },

  loginFail() {
    alert(`${this.name} failed to log in`);
  },

};

askPassword(user.loginOk.bind(user), user.loginFail.bind(user));
        
      
      
      Ahora funciona.
Una solución alternativa podría ser:

      
        
        
          //...
askPassword(() => user.loginOk(), () => user.loginFail());
        
      
      
      Por lo general, eso también funciona y se ve bien.
Aunque es un poco menos confiable en situaciones más complejas donde la variable user podría cambiar después de que se llama a askPassword, antes de que el visitante responde y llame a () => user.loginOk ().
It’s a bit less reliable though in more complex situations where user variable might change after askPassword is called, but before the visitor answers and calls () => user.loginOk().
Aplicación parcial para inicio de sesiónimportancia: 5La tarea es una variante un poco más compleja de Arreglar una función que perdió "this".
El objeto user fue modificado. Ahora, en lugar de dos funciones loginOk/loginFail, tiene una sola función user.login(true/false).
¿Qué deberíamos pasar a askPassword en el código a continuación, para que llame a user.login(true) como ok y user.login(false) como fail?

      
        
        
          function askPassword(ok, fail) {
  let password = prompt("Password?", '');
  if (password == "rockstar") ok();
  else fail();
}

let user = {
  name: 'John',

  login(result) {
    alert( this.name + (result ? ' logged in' : ' failed to log in') );
  }
};

askPassword(?, ?); // ?
        
      
      
      Sus cambios solo deberían modificar el fragmento resaltado.
solución

Utilice una función wrapper (envoltura), de tipo arrow (flecha) para ser conciso:

      
        
        
          askPassword(() => user.login(true), () => user.login(false));
        
      
      
      Ahora obtiene user de variables externas y lo ejecuta de la manera normal.


O cree una función parcial desde user.login que use user como contexto y tenga el primer argumento correcto:

      
        
        
          askPassword(user.login.bind(user, true), user.login.bind(user, false));
        
      
      
      

",
	"url": "https://es.javascript.info/bind" 
},
{
	"docs_id": "61",
	"name": "Funciones de flecha revisadas",
	"description": "Volvamos a revisar las funciones de flecha.",
	"content": "Volvamos a revisar las funciones de flecha.
Las funciones de flecha no son solo una “taquigrafía” para escribir pequeñas cosas. Tienen algunas características muy específicas y útiles.
JavaScript está lleno de situaciones en las que necesitamos escribir una pequeña función que se ejecuta en otro lugar.
Por ejemplo

arr.forEach(func) – func es ejecutado por forEach para cada elemento del array.
setTimeout(func) – func es ejecutado por el planificador incorporado.
…y muchas más.

Está en el espíritu de JavaScript crear una función y pasarla a algún otro lugar.
Y en tales funciones, por lo general, no queremos abandonar el contexto actual. Ahí es donde las funciones de flecha son útiles.
Las funciones de flecha no tienen “this”Como recordamos del capítulo Métodos del objeto, "this", las funciones de flecha no tienen this. Si se accede a this, se toma el contexto del exterior.
Por ejemplo, podemos usarlo para iterar dentro de un método de objeto:

      
        
        
          
            
          
          
            
          
        
        
          let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
    this.students.forEach(
      student => alert(this.title + ': ' + student)
    );
  }
};

group.showList();
        
      
      
      Aquí, en forEach se utiliza la función de flecha, por lo que this.title es exactamente igual que en el método externo showList. Es decir: group.title.
Si usáramos una función “regular”, habría un error:

      
        
        
          
            
          
          
            
          
        
        
          let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
    this.students.forEach(function(student) {
      // Error: Cannot read property 'title' of undefined
      alert(this.title + ': ' + student);
    });
  }
};

group.showList();
        
      
      
      El error se produce porque forEach ejecuta funciones con this = undefined de forma predeterminada, por lo que se intenta acceder a undefined.title.
Eso no afecta las funciones de flecha, porque simplemente no tienen this.

            Las funciones de flecha no pueden ejecutarse con new
            No tener this naturalmente significa otra limitación: las funciones de flecha no pueden usarse como constructores. No se pueden llamar con new.


            Funciones de flecha VS bind
            Hay una sutil diferencia entre una función de flecha => y una función regular llamada con .bind(this):

.bind(this) crea una “versión enlazada” de la función.
La flecha => no crea ningún enlace. La función simplemente no tiene this. La búsqueda de ‘this’ se realiza exactamente de la misma manera que una búsqueda de variable regular: en el entorno léxico externo.


Las flechas no tienen “arguments”Las funciones de flecha tampoco tienen variable arguments.
Eso es genial para los decoradores, cuando necesitamos reenviar una llamada con this y arguments actuales.
Por ejemplo, defer (f, ms) obtiene una función y devuelve un contenedor que retrasa la llamada en ms milisegundos:

      
        
        
          
            
          
          
            
          
        
        
          function defer(f, ms) {
  return function() {
    setTimeout(() => f.apply(this, arguments), ms);
  };
}

function sayHi(who) {
  alert('Hello, ' + who);
}

let sayHiDeferred = defer(sayHi, 2000);
sayHiDeferred("John"); // Hello, John después de 2 segundos
        
      
      
      Lo mismo sin una función de flecha se vería así:

      
        
        
          function defer(f, ms) {
  return function(...args) {
    let ctx = this;
    setTimeout(function() {
      return f.apply(ctx, args);
    }, ms);
  };
}
        
      
      
      Aquí tuvimos que crear las variables adicionales args y ctx para que la función dentro de setTimeout pudiera tomarlas.
ResumenFunciones de flecha:

No tienen this
No tienen arguments
No se pueden llamar con new
Tampoco tienen super, que aún no hemos estudiado. Lo veremos en el capítulo Herencia de clase

Esto se debe a que están diseñadas para piezas cortas de código que no tienen su propio “contexto”, sino que funcionan en el actual. Y realmente brillan en ese caso de uso.
",
	"url": "https://es.javascript.info/arrow-functions" 
},
{
	"docs_id": "62",
	"name": "",
	"description": "Aquí aprenderemos JavaScript, empezando desde cero y llegaremos hasta conceptos avanzados como POO.",
	"content": "Parte 1El lenguaje JavaScriptParte 2El navegador: Documentos, Eventos e InterfacesParte 3Artículos adicionalesEl lenguaje JavaScriptAquí aprenderemos JavaScript, empezando desde cero y llegaremos hasta conceptos avanzados como POO.
Nos concentraremos en el lenguaje mismo con el mínimo de notas específicas del entorno.
Una introducciónUna introducción a JavaScriptManuales y especificacionesEditores de CódigoConsola de desarrolladorFundamentos de JavaScript¡Hola, mundo!Estructura del códigoEl modo moderno, "use strict"VariablesTipos de datosInteracción: alert, prompt, confirmConversiones de TiposOperadores básicos, matemáticasComparacionesEjecución condicional: if, '?'Operadores LógicosOperador Nullish Coalescing '??'Bucles: while y forLa sentencia "switch"FuncionesExpresiones de funciónFunciones Flecha, lo básicoEspeciales JavaScriptMás…Calidad del códigoDebugging en el navegadorEstilo de codificaciónComentariosCódigo ninjaTest automatizados con MochaPolyfills y transpiladoresObjetos: lo básicoObjetosReferencias de objetos y copiaRecolección de basuraMétodos del objeto, "this"Constructor, operador "new"Encadenamiento opcional '?.'Tipo SymbolConversión de objeto a valor primitivoTipos de datosMétodos en tipos primitivosNúmerosStringsArraysMétodos de arraysIterablesMap y SetWeakMap y WeakSetObject.keys, values, entriesAsignación desestructuranteFecha y HoraMétodos JSON, toJSONMás…Trabajo avanzado con funcionesRecursión y pilaParámetros Rest y operador SpreadÁmbito de Variable y el concepto "closure"La vieja "var"Objeto GlobalFunción como objeto, NFELa sintaxis "new Function"Planificación: setTimeout y setIntervalDecoradores y redirecciones, call/applyFunción bind: vinculación de funcionesFunciones de flecha revisadasMás…Configuración de las propiedades de objetosIndicadores y descriptores de propiedad"Getters" y "setters" de propiedadPrototipos y herenciaHerencia prototípicaF.prototypePrototipos nativosMétodos prototipo, objetos sin __proto__ClasesSintaxis básica de `class`Herencia de clasePropiedades y métodos estáticos.Propiedades y métodos privados y protegidos.Ampliación de clases integradasComprobación de clase: "instanceof"Los MixinsManejo de erroresManejo de errores, "try...catch"Errores personalizados, extendiendo ErrorPromesas y async/awaitIntroducción: callbacksPromesaEncadenamiento de promesasManejo de errores con promesasPromise APIPromisificaciónMicrotareas (Microtasks)Async/awaitGeneradores e iteración avanzadaGeneradoresIteradores y generadores asíncronosMódulosMódulos, introducciónExport e ImportImportaciones dinámicasTemas diversosProxy y ReflectEval: ejecutando una cadena de códigoCurrificaciónTipo de ReferenciaBigIntEl navegador: Documentos, Eventos e InterfacesAprenderemos a manejar la página del navegador: agregar elementos, manipular su tamaño y posición, crear interfaces dinámicamente e interactuar con el visitante.
DocumentoEntorno del navegador, especificacionesÁrbol del Modelo de Objetos del Documento (DOM)Recorriendo el DOMBuscar: getElement*, querySelector*Propiedades del nodo: tipo, etiqueta y contenidoAtributos y propiedadesModificando el documentoEstilos y clasesTamaño de elementos y desplazamientoTamaño de ventana y desplazamientoCoordenadasMás…Introducción a los eventosIntroducción a los eventos en el navegadorPropagación y capturaDelegación de eventosAcciones predeterminadas del navegadorEnvío de eventos personalizadosEventos en la UIEventos del MouseMoviendo el mouse: mouseover/out, mouseenter/leaveArrastrar y Soltar con eventos del ratónEventos de punteroTeclado: keydown y keyupDesplazamientoFormularios y controlesPropiedades y Métodos de FormulariosEnfocado: enfoque/desenfoqueEventos: change, input, cut, copy, pasteFormularios: evento y método submitEl documento y carga de recursosPágina: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferCarga de recursos: onload y onerrorTemas diversosMutation observerSelection y RangeLoop de eventos: microtareas y macrotareasArtículos adicionalesLista de temas adicionales que supone que ha cubierto las dos primeras partes del tutorial. Aquí no hay una jerarquía clara, puede leer los artículos en el orden que desee.Marcos y ventanasVentanas emergentes y métodos de ventanaComunicación entre ventanasEl ataque de secuestro de clicsDatos binarios y archivosArrayBuffer, arrays binariosTextDecoder y TextEncoderBlobFile y FileReaderSolicitudes de redFetchFormDataFetch: Progreso de la descargaFetch: AbortFetch: Cross-Origin RequestsFetch APIObjetos URLXMLHttpRequestCarga de archivos reanudableSondeo largoWebSocketEventos enviados por el servidorMás…Almacenando datos en el navegadorCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimacionesCurva de BézierAnimaciones CSSAnimaciones JavaScriptComponentes WebDesde la altura orbitalElementos personalizadosShadow DOMElemento templateShadow DOM slots, composiciónEstilo Shadow DOMShadow DOM y eventosExpresiones RegularesPatrones y banderas (flags)Clases de caracteresUnicode: bandera "u" y clase \p{...}Anclas: inicio ^ y final $ de cadenaModo multilínea de anclas ^ $, bandera "m"Límite de palabra: \bEscapando, caracteres especialesConjuntos y rangos [...]Cuantificadores +, *, ? y {n}Cuantificadores codiciosos y perezososGrupos de capturaReferencias inversas en patrones: \N y \k<nombre>Alternancia (O) |Lookahead y lookbehind (revisar delante/detrás)Backtracking catastróficoIndicador adhesivo “y”, buscando en una posición.Métodos de RegExp y StringMás…{
  "@context": "http://schema.org",
  "@type": "WebSite",
  "url": "https://es.javascript.info/",
  "potentialAction": {
    "@type": "SearchAction",
    "target": "https://es.javascript.info/search?query={search_term_string}",
    "query-input": "required name=search_term_string"
  }
}",
	"url": "https://es.javascript.info#" 
},
{
	"docs_id": "63",
	"name": "Indicadores y descriptores de propiedad",
	"description": "Como ya sabemos, los objetos pueden almacenar propiedades.",
	"content": "Como ya sabemos, los objetos pueden almacenar propiedades.
Hasta ahora, para nosotros una propiedad era un simple par “clave-valor”. Pero una propiedad de un objeto es algo más flexible y poderoso.
En este capítulo vamos a estudiar opciones adicionales de configuración, y en el siguiente veremos como convertirlas invisiblemente en funciones ‘getter/setter’ (obtención y establecimiento).
Indicadores de propiedadLas propiedades de objeto, aparte de un value, tienen tres atributos especiales (también llamados “indicadores”):

writable – si es true, puede ser editado, de otra manera es de solo lectura.
enumerable – si es true, puede ser listado en bucles, de otro modo no puede serlo.
configurable – si es true, la propiedad puede ser borrada y estos atributos pueden ser modificados, de otra forma no.

No los vimos hasta ahora porque generalmente no se muestran. Cuando creamos una propiedad “de la forma usual”, todos ellos son true. Pero podemos cambiarlos en cualquier momento.
Primero, veamos como conseguir estos indicadores.
El método Object.getOwnPropertyDescriptor permite consultar toda la información sobre una propiedad.
La sintaxis es:

      
        
        
          let descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
        
      
      
      
obj
El objeto del que se quiere obtener la información.
propertyName
El nombre de la propiedad.

El valor devuelto es el objeto llamado “descriptor de propiedad”: este contiene el valor de todos los indicadores.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "Juan"
};

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

alert( JSON.stringify(descriptor, null, 2 ) );
/* descriptor de propiedad:
{
  "value": "Juan",
  "writable": true,
  "enumerable": true,
  "configurable": true
}
*/
        
      
      
      Para modificar los indicadores podemos usar Object.defineProperty.
La sintaxis es:

      
        
        
          Object.defineProperty(obj, propertyName, descriptor)
        
      
      
      
obj, propertyName
el objeto y la propiedad con los que se va a trabajar.
descriptor
descriptor de propiedad a aplicar.

Si la propiedad existe, defineProperty actualiza sus indicadores. De otra forma, creará la propiedad con el valor y el indicador dado; en ese caso, si el indicador no es proporcionado, es asumido como false.
En el ejemplo a continuación, se crea una propiedad name con todos los indicadores en false:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};

Object.defineProperty(user, "name", {
  value: "Juan"
});

let descriptor = Object.getOwnPropertyDescriptor(user, 'name');

alert( JSON.stringify(descriptor, null, 2 ) );
/*
{
  "value": "Juan",
  "writable": false,
  "enumerable": false,
  "configurable": false
}
 */
        
      
      
      Comparado con la creada “de la forma usual” user.name: ahora todos los indicadores son false. Si no es lo que queremos, es mejor que los establezcamos en true en el descriptor.
Ahora veamos los efectos de los indicadores con ejemplo.
Non-writableVamos a hacer user.name de solo lectura cambiando el indicador writable:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "Juan"
};

Object.defineProperty(user, "name", {
  writable: false
});

user.name = "Pedro"; // Error: No se puede asignar a la propiedad de solo lectura 'name'...
        
      
      
      Ahora nadie puede cambiar el nombre de nuestro usuario, a menos que le apliquen su propio defineProperty para sobrescribir el nuestro.

            Los errores aparecen solo en modo estricto
            En el modo no estricto, no se producen errores al escribir en propiedades no grabables y demás. Pero la operación aún no tendrá éxito. Las acciones que infringen el indicador se ignoran silenciosamente de forma no estricta.

Aquí está el mismo ejemplo, pero la propiedad se crea desde cero:

      
        
        
          
            
          
          
            
          
        
        
          let user = { };

Object.defineProperty(user, "name", {

  value: "Pedro",
  // para las nuevas propiedades se necesita listarlas explícitamente como true
  enumerable: true,
  configurable: true
});

alert(user.name); // Pedro
user.name = "Alicia"; // Error
        
      
      
      Non-enumerableAhora vamos a añadir un toString personalizado a user.
Normalmente, un toString incorporado en objetos es no enumerable, no se muestra en un bucle for..in. Pero si añadimos nuestro propio toString, por defecto éste se muestra en los bucles for..in:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "Juan",
  toString() {
    return this.name;
  }
};

// Por defecto, nuestras propiedades se listan:
for (let key in user) alert(key); // name, toString
        
      
      
      Si no nos gusta, podemos establecer enumerable:false. Entonces, no aparecerá en bucles for..in, exactamente como el incorporado:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "Juan",
  toString() {
    return this.name;
  }
};

Object.defineProperty(user, "toString", {
  enumerable: false
});

// Ahora nuestro toString desaparece:
for (let key in user) alert(key); // nombre
        
      
      
      Las propiedades no enumerables también se excluyen de Object.keys:

      
        
        
          alert(Object.keys(user)); // name
        
      
      
      Non-configurableEl indicador “no-configurable” (configurable:false) a veces está preestablecido para los objetos y propiedades incorporados.
Una propiedad no configurable no puede ser eliminada, sus atributos no pueden ser modificados.
Por ejemplo, Math.PI es de solo lectura, no enumerable y no configurable:

      
        
        
          
            
          
          
            
          
        
        
          let descriptor = Object.getOwnPropertyDescriptor(Math, 'PI');

alert( JSON.stringify(descriptor, null, 2 ) );
/*
{
  "value": 3.141592653589793,
  "writable": false,
  "enumerable": false,
  "configurable": false
}
*/
        
      
      
      Así, un programador es incapaz de cambiar el valor de Math.PI o sobrescribirlo.

      
        
        
          
            
          
          
            
          
        
        
          Math.PI = 3; // Error, porque tiene writable: false

// delete Math.PI tampoco funcionará
        
      
      
      Tampoco podemos cambiar Math.PIa writable de vuelta:

      
        
        
          
            
          
          
            
          
        
        
          // Error, porque configurable: false
Object.defineProperty(Math, "PI", { writable: true });
        
      
      
      No hay nada en absoluto que podamos hacer con Math.PI.
Convertir una propiedad en no configurable es una calle de un solo sentido. No podremos cambiarla de vuelta con defineProperty.
Observa que “configurable: false” impide cambios en los indicadores de la propiedad y su eliminación, pero permite el cambio de su valor.
Aquí user.name es “non-configurable”, pero aún puede cambiarse (por ser “writable”):

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John"
};

Object.defineProperty(user, "name", {
  configurable: false
});

user.name = "Pete"; // funciona
delete user.name; // Error
        
      
      
      Y aquí hacemos user.name una constante “sellada para siempre”, tal como la incorporada Math.PI:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John"
};

Object.defineProperty(user, "name", {
  writable: false,
  configurable: false
});

// No seremos capaces de cambiar usuario.nombre o sus identificadores
// Nada de esto funcionará:
user.name = "Pedro";
delete user.name;
Object.defineProperty(user, "name", { value: "Pedro" });
        
      
      
      
            Único cambio de atributo posible: writable true → false
            Hay una excepción menor acerca del cambio de indicadores.
Podemos cambiar writable: true a false en una propiedad no configurable, impidiendo en más la modificación de su valor (sumando una capa de protección). Aunque no hay vuelta atrás.

Object.definePropertiesHay un método Object.defineProperties(obj, descriptors) que permite definir varias propiedades de una sola vez.
La sintaxis es:

      
        
        
          Object.defineProperties(obj, {
  prop1: descriptor1,
  prop2: descriptor2
  // ...
});
        
      
      
      Por ejemplo:

      
        
        
          Object.defineProperties(user, {
  name: { value: "Juan", writable: false },
  surname: { value: "Perez", writable: false },
  // ...
});
        
      
      
      Entonces podemos asignar varias propiedades al mismo tiempo.
Object.getOwnPropertyDescriptorsPara obtener todos los descriptores al mismo tiempo, podemos usar el método Object.getOwnPropertyDescriptors(obj).
Junto con Object.defineProperties puede ser usado como una forma “consciente de los indicadores” de clonar un objeto:

      
        
        
          let clone = Object.defineProperties({}, Object.getOwnPropertyDescriptors(obj));
        
      
      
      Normalmente, cuando clonamos un objeto, usamos una asignación para copiar las propiedades:

      
        
        
          for (let key in user) {
  clone[key] = user[key]
}
        
      
      
      … pero esto no copia los identificadores. Así que si queremos un “mejor” clon entonces se prefiere Object.defineProperties.
Otra diferencia es que for..in ignora las propiedades simbólicas y las no enumerables, pero Object.getOwnPropertyDescriptors devuelve todos los descriptores de propiedades incluyendo simbólicas y no enumerables.
Sellando un objeto globalmenteLos descriptores de propiedad trabajan al nivel de propiedades individuales.
También hay métodos que limitan el acceso al objeto completo:

Object.preventExtensions(obj)
Prohíbe añadir propiedades al objeto.
Object.seal(obj)
Prohíbe añadir/eliminar propiedades, establece todas las propiedades existentes como configurable: false.
Object.freeze(obj)
Prohíbe añadir/eliminar/cambiar propiedades, establece todas las propiedades existentes como configurable: false, writable: false.

También tenemos formas de probarlos:

Object.isExtensible(obj)
Devuelve false si esta prohibido añadir propiedades, si no true.
Object.isSealed(obj)
Devuelve true si añadir/eliminar propiedades está prohibido, y todas las propiedades existentes tienen configurable: false.
Object.isFrozen(obj)
Devuelve true si añadir/eliminar/cambiar propiedades está prohibido, y todas las propiedades son configurable: false, writable: false.

Estos métodos son usados rara vez en la práctica.
",
	"url": "https://es.javascript.info/property-descriptors" 
},
{
	"docs_id": "64",
	"name": ""Getters" y "setters" de propiedad",
	"description": "Hay dos tipos de propiedades de objetos.",
	"content": "Hay dos tipos de propiedades de objetos.
El primer tipo son las propiedades de datos. Ya sabemos cómo trabajar con ellas. Todas las propiedades que hemos estado usando hasta ahora eran propiedades de datos.
El segundo tipo de propiedades es algo nuevo. Son las propiedades de acceso o accessors. Son, en esencia, funciones que se ejecutan para obtener (“get”) y asignar (“set”) un valor, pero que para un código externo se ven como propiedades normales.
Getters y settersLas propiedades de acceso se construyen con métodos de obtención “getter” y asignación “setter”. En un objeto literal se denotan con get y set:

      
        
        
          let obj = {
  get propName() {
    // getter, el código ejecutado para obtener obj.propName
  },

  set propName(value) {
    // setter, el código ejecutado para asignar obj.propName = value
  }
};
        
      
      
      El getter funciona cuando se lee obj.propName, y el setter cuando se asigna.
Por ejemplo, tenemos un objeto “usuario” con “nombre” y “apellido”:

      
        
        
          let user = {
  name: "John",
  surname: "Smith"
};
        
      
      
      Ahora queremos añadir una propiedad de “Nombre completo” (fullName), que debería ser "John Smith". Por supuesto, no queremos copiar-pegar la información existente, así que podemos aplicarla como una propiedad de acceso:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

alert(user.fullName); // John Smith
        
      
      
      Desde fuera, una propiedad de acceso se parece a una normal. Esa es la idea de estas propiedades. No llamamos a user.fullName como una función, la leemos normalmente: el “getter” corre detrás de escena.
Hasta ahora, “Nombre completo” sólo tiene un receptor. Si intentamos asignar user.fullName=, habrá un error.

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  get fullName() {
    return `...`;
  }
};

user.fullName = "Test"; // Error (property has only a getter)
        
      
      
      Arreglémoslo agregando un setter para user.fullName:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  surname: "Smith",

  get fullName() {
    return `${this.name} ${this.surname}`;
  },

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  }
};

// set fullName se ejecuta con el valor dado.
user.fullName = "Alice Cooper";

alert(user.name); // Alice
alert(user.surname); // Cooper
        
      
      
      Como resultado, tenemos una propiedad virtual fullName que puede leerse y escribirse.
Descriptores de accesoLos descriptores de propiedades de acceso son diferentes de aquellos para las propiedades de datos.
Para las propiedades de acceso, no hay cosas como “valor” y “escritura”, sino de “get” y “set”.
Así que un descriptor de accesos puede tener:

get – una función sin argumentos, que funciona cuando se lee una propiedad,
set – una función con un argumento, que se llama cuando se establece la propiedad,
enumerable – lo mismo que para las propiedades de datos,
configurable – lo mismo que para las propiedades de datos.

Por ejemplo, para crear un acceso fullName con defineProperty, podemos pasar un descriptor con get y set:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  surname: "Smith"
};

Object.defineProperty(user, 'fullName', {
  get() {
    return `${this.name} ${this.surname}`;
  },

  set(value) {
    [this.name, this.surname] = value.split(" ");
  }
});

alert(user.fullName); // John Smith

for(let key in user) alert(key); // name, surname
        
      
      
      Tenga en cuenta que una propiedad puede ser un acceso (tiene métodos get/set)  o una propiedad de datos (tiene un ‘valor’), no ambas.
Si intentamos poner tanto get como valor en el mismo descriptor, habrá un error:

      
        
        
          
            
          
          
            
          
        
        
          // Error: Descriptor de propiedad inválido.
Object.defineProperty({}, 'prop', {
  get() {
    return 1
  },

  value: 2
});
        
      
      
      Getters y setters más inteligentesGetters y setters pueden ser usados como envoltorios sobre valores de propiedad “reales” para obtener más control sobre ellos.
Por ejemplo, si queremos prohibir nombres demasiado cortos para “usuario”, podemos guardar “nombre” en una propiedad especial “nombre”. Y filtrar las asignaciones en el setter:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  get name() {
    return this._name;
  },

  set name(value) {
    if (value.length < 4) {
      alert("El nombre es demasiado corto, necesita al menos 4 caracteres");
      return;
    }
    this._name = value;
  }
};

user.name = "Pete";
alert(user.name); // Pete

user.name = ""; // El nombre es demasiado corto...
        
      
      
      Entonces, el nombre es almacenado en la propiedad _name, y el acceso se hace a través de getter y setter.
Técnicamente, el código externo todavía puede acceder al nombre directamente usando “usuario.nombre". Pero hay un acuerdo ampliamente conocido de que las propiedades que comienzan con un guión bajo "” son internas y no deben ser manipuladas desde el exterior del objeto.
Uso para compatibilidadUna de los grandes usos de los getters y setters es que permiten tomar el control de una propiedad de datos “normal” y reemplazarla un getter y un setter y así refinar su comportamiento.
Imagina que empezamos a implementar objetos usuario usando las propiedades de datos “nombre” y “edad”:

      
        
        
          function User(name, age) {
  this.name = name;
  this.age = age;
}

let john = new User("John", 25);

alert( john.age ); // 25
        
      
      
      …Pero tarde o temprano, las cosas pueden cambiar. En lugar de “edad” podemos decidir almacenar “cumpleaños”, porque es más preciso y conveniente:

      
        
        
          function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;
}

let john = new User("John", new Date(1992, 6, 1));
        
      
      
      Ahora, ¿qué hacer con el viejo código que todavía usa la propiedad de la “edad”?
Podemos intentar encontrar todos esos lugares y arreglarlos, pero eso lleva tiempo y puede ser difícil de hacer si ese código está escrito por otras personas. Y además, la “edad” es algo bueno para tener en “usuario”, ¿verdad? En algunos lugares es justo lo que queremos.
Pues mantengámoslo.
Añadiendo un getter para la “edad” resuelve el problema:

      
        
        
          
            
          
          
            
          
        
        
          function User(name, birthday) {
  this.name = name;
  this.birthday = birthday;

  // La edad se calcula a partir de la fecha actual y del cumpleaños
  Object.defineProperty(this, "age", {
    get() {
      let todayYear = new Date().getFullYear();
      return todayYear - this.birthday.getFullYear();
    }
  });
}

let john = new User("John", new Date(1992, 6, 1));

alert( john.birthday ); // El cumpleaños está disponible
alert( john.age );      // ...así como la edad
        
      
      
      Ahora el viejo código funciona también y tenemos una buena propiedad adicional.
",
	"url": "https://es.javascript.info/property-accessors" 
},
{
	"docs_id": "65",
	"name": "Herencia prototípica",
	"description": "En programación, a menudo queremos tomar algo y extenderlo.",
	"content": "En programación, a menudo queremos tomar algo y extenderlo.
Por ejemplo, tenemos un objeto user con sus propiedades y métodos, y queremos hacer que admin y guest sean variantes ligeramente modificadas del mismo. Nos gustaría reutilizar lo que tenemos en user, no copiar/reimplementar sus métodos, solo construir un nuevo objeto encima de él.
La herencia de prototipos es una característica del lenguaje que ayuda en eso.
[[Prototype]]En JavaScript, los objetos tienen una propiedad oculta especial [[Prototype]] (como se menciona en la especificación); que puede ser null, o hacer referencia a otro objeto llamado “prototipo”:

      
      
        
      
      Cuando leemos una propiedad de object, si JavaScript no la encuentra allí la toma automáticamente del prototipo. En programación esto se llama “herencia prototípica”. Pronto estudiaremos muchos ejemplos de esta herencia y otras características interesantes del lenguaje que se basan en ella.
La propiedad [[Prototype]] es interna y está oculta, pero hay muchas formas de configurarla.
Una de ellas es usar el nombre especial __proto__, así:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal; // establece rabbit.[[Prototype]] = animal
        
      
      
      Si buscamos una propiedad en rabbit, y no se encuentra, JavaScript la toma automáticamente de animal.
Por ejemplo:

      
        
        
          let animal = {
  eats: true
};
let rabbit = {
  jumps: true
};

rabbit.__proto__ = animal; // (*)

// Ahora podemos encontrar ambas propiedades en conejo:
alert( rabbit.eats ); // verdadero (**)
alert( rabbit.jumps ); // verdadero
        
      
      
      Aquí, la línea (*) establece que animal es el prototipo de rabbit.
Luego, cuando alert intenta leer la propiedad rabbit.eats (**), no la encuentra en rabbit, por lo que JavaScript sigue la referencia [[Prototype]] y la encuentra en animal (mira de abajo hacia arriba):

      
      
        
      
      Aquí podemos decir que "animal es el prototipo de rabbit" o que "rabbit hereda prototípicamente de animal".
Entonces, si animal tiene muchas propiedades y métodos útiles, estos estarán automáticamente disponibles en rabbit. Dichas propiedades se denominan “heredadas”.
Si tenemos un método en animal, se puede llamar en rabbit:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  eats: true,
  walk() {
    alert("Animal da un paseo");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

// walk es tomado del prototipo
rabbit.walk(); // Animal da un paseo
        
      
      
      El método se toma automáticamente del prototipo, así:

      
      
        
      
      La cadena prototipo puede ser más larga:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  eats: true,
  walk() {
    alert("Animal da un paseo");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

let longEar = {
  earLength: 10,
  __proto__: rabbit
};

// walk se toma de la cadena prototipo
longEar.walk(); // Animal da un paseo
alert(longEar.jumps); // verdadero (desde rabbit)
        
      
      
      
      
      
        
      
      Ahora, si leemos algo de longEar y falta, JavaScript lo buscará en rabbit, y luego en animal.
Solo hay dos limitaciones:

No puede haber referencias circulares. JavaScript arrojará un error si intentamos asignar __proto__ en círculo.
El valor de __proto__ puede ser un objeto o null. Otros tipos son ignorados.

También puede ser obvio, pero aún así: solo puede haber un [[Prototype]]. Un objeto no puede heredar desde dos.

            __proto__ es un getter/setter histórico para [[Prototype]]
            Es un error común de principiantes no saber la diferencia entre ambos.
Tenga en cuenta que __proto__ no es lo mismo que [[Prototype]]. __proto__ es un getter/setter para [[Prototype]]. Más adelante veremos situaciones donde esto importa, por ahora solo tengámoslo en cuenta mientras vamos entendiendo el lenguaje JavaScript.
La propiedad __proto__ es algo vetusta. Existe por razones históricas, el JavaScript moderno sugiere el uso de las funciones Object.getPrototypeOf/Object.setPrototypeOf en lugar de get/set del prototipo. Estudiaremos estas funciones más adelante.
Según la especificación, __proto__ solo debe ser soportado por los navegadores. Aunque de hecho, todos los entornos incluyendo los del lado del servidor soportan __proto__, así que bastante seguro usarlo.
Como la notación __proto__ es más intuitiva, la usaremos en los ejemplos.

La escritura no usa prototipoEl prototipo solo se usa para leer propiedades.
Las operaciones de escritura/eliminación funcionan directamente con el objeto.
En el ejemplo a continuación, asignamos su propio método walk a rabbit:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  eats: true,
  walk() {
    /* este método no será utilizado por rabbit */
  }
};

let rabbit = {
  __proto__: animal
};

rabbit.walk = function() {
  alert("¡Conejo! ¡Salta, salta!");
};

rabbit.walk(); // ¡Conejo! ¡Salta, salta!
        
      
      
      De ahora en adelante, la llamada rabbit.walk() encuentra el método inmediatamente en el objeto y lo ejecuta, sin usar el prototipo:

      
      
        
      
      Las propiedades de acceso son una excepción, ya que la asignación es manejada por una función setter. Por lo tanto, escribir en una propiedad de este tipo es en realidad lo mismo que llamar a una función.
Por esa razón, admin.fullName funciona correctamente en el siguiente código:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  surname: "Smith",

  set fullName(value) {
    [this.name, this.surname] = value.split(" ");
  },

  get fullName() {
    return `${this.name} ${this.surname}`;
  }
};

let admin = {
  __proto__: user,
  isAdmin: true
};

alert(admin.fullName); // John Smith (*)

// ¡Dispara el setter!
admin.fullName = "Alice Cooper"; // (**)

alert(admin.fullName); // Alice Cooper , estado de admin modificado
alert(user.fullName); // John Smith , estado de user protegido
        
      
      
      Aquí en la línea (*) la propiedad admin.fullName tiene un getter en el prototipo user, por lo que es llamado. Y en la línea (**) la propiedad tiene un setter en el prototipo, por lo que es llamado.
El valor de “this”Puede surgir una pregunta interesante en el ejemplo anterior: ¿cuál es el valor de this dentro de set fullName(value)? ¿Dónde están escritas las propiedades this.name y this.surname: en user o admin?
La respuesta es simple: “this” no se ve afectado por los prototipos en absoluto.
No importa dónde se encuentre el método: en un objeto o su prototipo. En una llamada al método, this es siempre el objeto antes del punto.
Entonces, la llamada al setter admin.fullName= usa admin comothis, no a user.
Eso es realmente algo muy importante, porque podemos tener un gran objeto con muchos métodos y tener objetos que hereden de él. Y cuando los objetos heredados ejecutan los métodos heredados, modificarán solo sus propios estados, no el estado del gran objeto.
Por ejemplo, aquí animal representa un “método de almacenamiento”, y rabbit lo utiliza.
La llamada rabbit.sleep() establece this.isSleeping en el objeto rabbit:

      
        
        
          
            
          
          
            
          
        
        
          // animal tiene métodos
let animal = {
  walk() {
    if (!this.isSleeping) {
      alert(`Yo camino`);
    }
  },
  sleep() {
    this.isSleeping = true;
  }
};

let rabbit = {
  name: "Conejo Blanco",
  __proto__: animal
};

// modifica rabbit.isSleeping
rabbit.sleep();

alert(rabbit.isSleeping); // Verdadero
alert(animal.isSleeping); // undefined (no existe tal propiedad en el prototipo)
        
      
      
      La imagen resultante:

      
      
        
      
      Si tuviéramos otros objetos, como bird, snake, etc., heredados de animal, también tendrían acceso a los métodos de animal. Pero this en cada llamada al método sería el objeto correspondiente, evaluado en el momento de la llamada (antes del punto), no animal. Entonces, cuando escribimos datos en this, se almacenan en estos objetos.
Como resultado, los métodos se comparten, pero el estado del objeto no.
Bucle for…inEl bucle for..in también itera sobre las propiedades heredadas.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

// Object.keys solo devuelve claves propias
alert(Object.keys(rabbit)); // jumps

// for..in recorre las claves propias y heredadas
for(let prop in rabbit) alert(prop); // jumps, después eats
        
      
      
      Si no queremos eso, y quisiéramos excluir las propiedades heredadas, hay un método incorporado obj.hasOwnProperty(key) (“Own” significa “Propia”): devuelve true si obj tiene la propiedad interna (no heredada) llamada key.
Entonces podemos filtrar las propiedades heredadas (o hacer algo más con ellas):

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  eats: true
};

let rabbit = {
  jumps: true,
  __proto__: animal
};

for(let prop in rabbit) {
  let isOwn = rabbit.hasOwnProperty(prop);

  if (isOwn) {
    alert(`Es nuestro: ${prop}`); // Es nuestro: jumps
  } else {
    alert(`Es heredado: ${prop}`); // Es heredado: eats
  }
}
        
      
      
      Aquí tenemos la siguiente cadena de herencia: rabbit hereda de animal, que hereda de Object.prototype (porque animal es un objeto {...} literal, entonces es por defecto), y luego null encima de él:

      
      
        
      
      Observa algo curioso. ¿De dónde viene el método rabbit.hasOwnProperty? No lo definimos. Mirando la cadena podemos ver que el método es proporcionado por Object.prototype.hasOwnProperty. En otras palabras, se hereda.
…Pero, ¿por qué hasOwnProperty no aparece en el bucle for..in como eats y jumps, si for..in enumera las propiedades heredadas?
La respuesta es simple: no es enumerable. Al igual que todas las demás propiedades de Object.prototype, tiene la bandera enumerable: false. Y for..in solo enumera las propiedades enumerables. Es por eso que este y el resto de las propiedades de Object.prototype no están en la lista.

            Casi todos los demás métodos de obtención de valor/clave ignoran las propiedades heredadas
            Casi todos los demás métodos de obtención de valores/claves, como Object.keys, Object.values, etc., ignoran las propiedades heredadas.
Solo operan en el objeto mismo. Las propiedades del prototipo no se tienen en cuenta.

Resumen
En JavaScript, todos los objetos tienen una propiedad oculta [[Prototype]] que es otro objeto o nulo.
Podemos usar obj.__proto__ para acceder a él (un getter/setter histórico, hay otras formas, que se cubrirán pronto).
El objeto al que hace referencia [[Prototype]] se denomina “prototipo”.
Si queremos leer una propiedad de obj o llamar a un método, y no existe, entonces JavaScript intenta encontrarla en el prototipo.
Las operaciones de escritura/eliminación actúan directamente sobre el objeto, no usan el prototipo (suponiendo que sea una propiedad de datos, no un setter).
Si llamamos a obj.method(), y method se toma del prototipo, this todavía hace referencia a obj. Por lo tanto, los métodos siempre funcionan con el objeto actual, incluso si se heredan.
El bucle for..in itera sobre las propiedades propias y heredadas. Todos los demás métodos de obtención de valor/clave solo operan en el objeto mismo.

TareasTrabajando con prototipoimportancia: 5Aquí está el código que crea un par de objetos, luego los modifica.
¿Qué valores se muestran en el proceso?

      
        
        
          let animal = {
  jumps: null
};
let rabbit = {
  __proto__: animal,
  jumps: true
};

alert( rabbit.jumps ); // ? (1)

delete rabbit.jumps;

alert( rabbit.jumps ); // ? (2)

delete animal.jumps;

alert( rabbit.jumps ); // ? (3)
        
      
      
      Debería haber 3 respuestas.
solución
true, tomado de rabbit.
null, tomado de animal.
undefined, ya no existe tal propiedad.

Algoritmo de búsquedaimportancia: 5La tarea tiene dos partes.
Dados los siguientes objetos:

      
        
        
          let head = {
  glasses: 1
};

let table = {
  pen: 3
};

let bed = {
  sheet: 1,
  pillow: 2
};

let pockets = {
  money: 2000
};
        
      
      
      
Use __proto__ para asignar prototipos de manera que cualquier búsqueda de propiedades siga la ruta: pockets → bed → table →  head. Por ejemplo, pockets.pen debería ser3 (que se encuentra en table), y bed.glasses debería ser 1 (que se encuentra en head).
Responda la pregunta: ¿es más rápido obtener glasses como pockets.glasses o head.glasses? Referencie si es necesario.

solución

Agreguemos __proto__:

      
        
        
          
            
          
          
            
          
        
        
          let head = {
  glasses: 1
};

let table = {
  pen: 3,
  __proto__: head
};

let bed = {
  sheet: 1,
  pillow: 2,
  __proto__: table
};

let pockets = {
  money: 2000,
  __proto__: bed
};

alert( pockets.pen ); // 3
alert( bed.glasses ); // 1
alert( table.money ); // undefined
        
      
      
      

En los motores modernos, en términos de rendimiento, no hay diferencia si tomamos una propiedad de un objeto o su prototipo. Recuerdan dónde se encontró la propiedad y la reutilizan en la siguiente solicitud.
Por ejemplo, para pockets.glasses recuerdan dónde encontraron glasses (en head), y la próxima vez buscarán allí. También son lo suficientemente inteligentes como para actualizar cachés internos si algo cambia, de modo que la optimización sea segura.


¿Donde escribe?importancia: 5Tenemos rabbit heredando de animal.
Si llamamos a rabbit.eat(), ¿qué objeto recibe la propiedad full: animal o rabbit?

      
        
        
          let animal = {
  eat() {
    this.full = true;
  }
};

let rabbit = {
  __proto__: animal
};

rabbit.eat();
        
      
      
      soluciónLa respuesta es: rabbit.
Esto se debe a que this es un objeto antes del punto, por lo que rabbit.eat() modifica rabbit.
La búsqueda y ejecución de propiedades son dos cosas diferentes.
El método rabbit.eat se encuentra primero en el prototipo, luego se ejecuta con this = rabbit.
¿Por qué están llenos los dos hámsters?importancia: 5Tenemos dos hámsters: speedy y lazy heredando del objeto hamster general.
Cuando alimentamos a uno de ellos, el otro también está lleno. ¿Por qué? ¿Cómo podemos arreglarlo?

      
        
        
          
            
          
          
            
          
        
        
          let hamster = {
  stomach: [],

  eat(food) {
    this.stomach.push(food);
  }
};

let speedy = {
  __proto__: hamster
};

let lazy = {
  __proto__: hamster
};

// Este encontró la comida
speedy.eat("manzana");
alert( speedy.stomach ); // manzana

// Este también lo tiene, ¿por qué? arreglar por favor.
alert( lazy.stomach ); // manzana
        
      
      
      soluciónEchemos un vistazo a lo que sucede en la llamada speedy.eat("manzana").


El método speedy.eat se encuentra en el prototipo (=hamster), luego se ejecuta con this=speedy (el objeto antes del punto).


Entonces this.stomach.push() necesita encontrar la propiedad stomach y llamar a push sobre ella. Busca stomach en this (=speedy), pero no se encuentra nada.


Luego sigue la cadena del prototipo y encuentra stomach en hamster.


Luego se llama ‘push’ en él, agregando la comida en el stomach del prototipo.


¡Así que todos los hámsters comparten un solo estómago!
Tanto para lazy.stomach.push(...) como para speedy.stomach.push (), la propiedad stomach se encuentra en el prototipo (ya que no está en el objeto mismo), entonces los nuevos datos son empujado hacia dentro.
Tenga en cuenta que tal cosa no sucede en caso de una asignación simple this.stomach=:

      
        
        
          
            
          
          
            
          
        
        
          let hamster = {
  stomach: [],

  eat(food) {
    // asigna a this.stomach en lugar de this.stomach.push
    this.stomach = [food];
  }
};

let speedy = {
   __proto__: hamster
};

let lazy = {
  __proto__: hamster
};

// Speedy encontró la comida
speedy.eat("manzana");
alert( speedy.stomach ); // manzana

// El estomago de Lazy está vacio
alert( lazy.stomach ); // <nada>
        
      
      
      Ahora todo funciona bien, porque this.stomach = no realiza una búsqueda de stomach. El valor se escribe directamente en el objeto this.
También podemos evitar totalmente el problema asegurándonos de que cada hámster tenga su propio estómago:

      
        
        
          
            
          
          
            
          
        
        
          let hamster = {
  stomach: [],

  eat(food) {
    this.stomach.push(food);
  }
};

let speedy = {
  __proto__: hamster,
  stomach: []
};

let lazy = {
  __proto__: hamster,
  stomach: []
};

// Speedy encontró la comida
speedy.eat("manzana");
alert( speedy.stomach ); // manzana

// El estómago de Lazy está vacio
alert( lazy.stomach ); // <nada>
        
      
      
      Como solución común, todas las propiedades que describen el estado de un objeto en particular, como el “stomach” anterior, deben escribirse en ese objeto. Eso evita tales problemas.
",
	"url": "https://es.javascript.info/prototype-inheritance" 
},
{
	"docs_id": "66",
	"name": "F.prototype",
	"description": "Recuerde, se pueden crear nuevos objetos con una función constructora, como new F().",
	"content": "Recuerde, se pueden crear nuevos objetos con una función constructora, como new F().
Si F.prototype es un objeto, entonces el operador new lo usa para establecerlo como [[Prototype]] en el nuevo objeto.

            Por favor tome nota:
            JavaScript tenía herencia prototípica desde sus comienzos. Era una de las características principales del lenguaje.
Pero en los viejos tiempos no había acceso directo a él. Lo único que funcionaba de manera confiable era una propiedad "prototype" de la función constructora, descrita en este capítulo. Por ello hay muchos scripts que todavía lo usan.

Tenga en cuenta que F.prototype aquí significa una propiedad regular llamada "prototype" en F. Suena algo similar al término “prototype”, pero aquí realmente queremos decir una propiedad regular con este nombre.
Aquí está el ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  eats: true
};

function Rabbit(name) {
  this.name = name;
}

Rabbit.prototype = animal;

let rabbit = new Rabbit("Conejo Blanco"); //  rabbit.__proto__ == animal

alert( rabbit.eats ); // verdadero
        
      
      
      La configuración de Rabbit.prototype = animal literalmente establece lo siguiente: "Cuando se crea un new Rabbit, asigne su [[Prototype]] a animal".
Esta es la imagen resultante:

      
      
        
      
      En la imagen, "prototype" es una flecha horizontal, que significa una propiedad regular, y [[Prototype]] es vertical, que significa la herencia de rabbit desde animal.

            F.prototype solo se usa en el momento new F
            La propiedad F.prototype solo se usa cuando se llama a new F: asigna [[Prototype]] del nuevo objeto.
Si, después de la creación, la propiedad F.prototype cambia (F.prototype = <otro objeto>), los nuevos objetos creados por new F tendrán otro objeto como [[Prototype]], pero los objetos ya existentes conservan el antiguo.

F.prototype predeterminado, propiedad del constructorCada función tiene la propiedad "prototype" incluso si no la suministramos.
El "prototype" predeterminado es un objeto con la única propiedad constructor que apunta de nuevo a la función misma.
Como esto:

      
        
        
          function Rabbit() {}

/* prototipo predeterminado
Rabbit.prototype = { constructor: Rabbit };
*/
        
      
      
      
      
      
        
      
      Lo podemos comprobar:

      
        
        
          
            
          
          
            
          
        
        
          function Rabbit() {}
// por defecto:
// Rabbit.prototype = { constructor: Rabbit }

alert( Rabbit.prototype.constructor == Rabbit ); // verdadero
        
      
      
      Naturalmente, si no hacemos nada, la propiedad constructor está disponible para todos los rabbits a través de [[Prototype]]:

      
        
        
          
            
          
          
            
          
        
        
          function Rabbit() {}
// por defecto:
// Rabbit.prototype = { constructor: Rabbit }

let rabbit = new Rabbit(); // hereda de {constructor: Rabbit}

alert(rabbit.constructor == Rabbit); // verdadero (desde prototype)
        
      
      
      
      
      
        
      
      Podemos usar la propiedad constructor para crear un nuevo objeto usando el constructor ya existente.
Como aqui:

      
        
        
          
            
          
          
            
          
        
        
          function Rabbit(name) {
  this.name = name;
  alert(name);
}

let rabbit = new Rabbit("Conejo Blanco");

let rabbit2 = new rabbit.constructor("Conejo Negro");
        
      
      
      Eso es útil cuando tenemos un objeto, no sabemos qué constructor se usó para él (por ejemplo, proviene de una biblioteca de terceros), y necesitamos crear otro del mismo tipo.
Pero probablemente lo más importante sobre "constructor" es que …
…JavaScript en sí mismo no garantiza el valor correcto de "constructor".
Sí, existe en el "prototipo" predeterminado para las funciones, pero eso es todo. Lo que sucede con eso más tarde, depende totalmente de nosotros.
En particular, si reemplazamos el prototipo predeterminado como un todo, entonces no habrá "constructor" en él.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function Rabbit() {}
Rabbit.prototype = {
  jumps: true
};

let rabbit = new Rabbit();
alert(rabbit.constructor === Rabbit); // falso
        
      
      
      Entonces, para mantener el "constructor" correcto, podemos elegir agregar/eliminar propiedades al "prototipo" predeterminado en lugar de sobrescribirlo como un todo:

      
        
        
          function Rabbit() {}

// No sobrescribir totalmente Rabbit.prototype
// solo agrégale
Rabbit.prototype.jumps = true
// se conserva el Rabbit.prototype.constructor predeterminado
        
      
      
      O, alternativamente, vuelva a crear la propiedad constructor manualmente:

      
        
        
          Rabbit.prototype = {
  jumps: true,
  constructor: Rabbit
};

// ahora el constructor también es correcto, porque lo agregamos
        
      
      
      ResumenEn este capítulo describimos brevemente la forma de establecer un [[Prototype]] para los objetos creados a través de una función de constructor. Más adelante veremos patrones de programación más avanzados que dependen de él.
Todo es bastante simple, solo algunas notas para aclarar las cosas:

La propiedad F.prototype (no la confunda con [[Prototype]]) establece [[Prototype]] de objetos nuevos cuando se llama a new F().
El valor de F.prototype debe ser un objeto o null: otros valores no funcionarán.
La propiedad "prototype" solo tiene un efecto tan especial cuando se establece en una función de constructor, y se invoca con new.

En los objetos normales, el prototype no es nada especial:

      
        
        
          let user = {
  name: "John",
  prototype: "Bla-bla" // sin magia en absoluto
};
        
      
      
      Por defecto, todas las funciones tienen F.prototype = {constructor: F}, por lo que podemos obtener el constructor de un objeto accediendo a su propiedad "constructor".
TareasCambiando "prototype"importancia: 5En el siguiente código creamos new Rabbit, y luego intentamos modificar su prototipo.
Al principio, tenemos este código:

      
        
        
          
            
          
          
            
          
        
        
          function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

let rabbit = new Rabbit();

alert( rabbit.eats ); // verdadero
        
      
      
      

Agregamos una cadena más (enfatizada). ¿Qué mostrará alert ahora?

      
        
        
          function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

let rabbit = new Rabbit();

Rabbit.prototype = {};

alert( rabbit.eats ); // ?
        
      
      
      

…¿Y si el código es así (se reemplazó una línea)?

      
        
        
          function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

let rabbit = new Rabbit();

Rabbit.prototype.eats = false;

alert( rabbit.eats ); // ?
        
      
      
      

¿Y así (se reemplazó una línea)?

      
        
        
          function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

let rabbit = new Rabbit();

delete rabbit.eats;

alert( rabbit.eats ); // ?
        
      
      
      

La última variante:

      
        
        
          function Rabbit() {}
Rabbit.prototype = {
  eats: true
};

let rabbit = new Rabbit();

delete Rabbit.prototype.eats;

alert( rabbit.eats ); // ?
        
      
      
      

soluciónRespuestas:


verdadero.
La asignación a Rabbit.prototype configura [[Prototype]] para objetos nuevos, pero no afecta a los existentes.


falso.
Los objetos se asignan por referencia. El objeto de Rabbit.prototype no está duplicado, sigue siendo un solo objeto referenciado tanto por Rabbit.prototype como por el [[Prototype]] de rabbit.
Entonces, cuando cambiamos su contenido a través de una referencia, es visible a través de la otra.


verdadero.
Todas las operaciones delete se aplican directamente al objeto. Aquí delete rabbit.eats intenta eliminar la propiedad eats de rabbit, pero no la tiene. Entonces la operación no tendrá ningún efecto.


undefined.
La propiedad eats se elimina del prototipo, ya no existe.


Crea un objeto con el mismo constructorimportancia: 5Imagínese, tenemos un objeto arbitrario obj, creado por una función constructora; no sabemos cuál, pero nos gustaría crear un nuevo objeto con él.
¿Podemos hacerlo así?

      
        
        
          let obj2 = new obj.constructor();
        
      
      
      Dé un ejemplo de una función constructora para obj que permita que dicho código funcione correctamente. Y un ejemplo que hace que funcione mal.
soluciónPodemos usar dicho enfoque si estamos seguros de que la propiedad "constructor" tiene el valor correcto.
Por ejemplo, si no tocamos el "prototype" predeterminado, con seguridad el código funciona:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  this.name = name;
}

let user = new User('John');
let user2 = new user.constructor('Pete');

alert( user2.name ); // Pete (funcionó!)
        
      
      
      Funcionó, porque User.prototype.constructor == User.
…Pero si alguien, por así decirlo, sobrescribe User.prototype y olvida recrear constructor para hacer referencia a User, entonces fallaría.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function User(name) {
  this.name = name;
}
User.prototype = {}; // (*)

let user = new User('John');
let user2 = new user.constructor('Pete');

alert( user2.name ); // undefined
        
      
      
      ¿Por qué user2.name es undefined?
Así es como funciona new user.constructor('Pete'):

Primero, busca a constructor en user. Nada.
Sigue la cadena con el prototipo. El prototipo de user es User.prototype, y tampoco tiene constructor (¡porque “olvidamos” configurarlo correctamente!).
Avanzando más en la cadena, User.prototype es un objeto simple, su prototipo es el Object.prototype incorporado.
Finalmente, para el Object.prototype hay un Object.prototype.constructor == Object. Entonces es el que usa.

Como resultado, tenemos let user2 = new Object('Pete').
Probablemente no es lo que queremos. Buscábamos crear new User, no new Object. Este resultado se debe a la falta de  constructor.
(Solo por si eres curioso: la llamada new Object(...) convierte su argumento a un objeto. Esto en teoría, en la práctica nadie llama new Object con un valor, y generalmente no queremos usar new Object para crear objetos en absoluto).
",
	"url": "https://es.javascript.info/function-prototype" 
},
{
	"docs_id": "67",
	"name": "Prototipos nativos",
	"description": "La propiedad "prototype" es ampliamente utilizada por el núcleo de JavaScript mismo. Todas las funciones de constructor integradas lo usan.",
	"content": "La propiedad "prototype" es ampliamente utilizada por el núcleo de JavaScript mismo. Todas las funciones de constructor integradas lo usan.
Primero veremos los detalles, y luego cómo usarlo para agregar nuevas capacidades a los objetos integrados.
Object.prototypeDigamos que tenemos un objeto vacío y lo mostramos:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};
alert( obj ); // "[object Object]" ?
        
      
      
      ¿Dónde está el código que genera la cadena "[objetc Objetc]"? Ese es un método integrado toString, pero ¿dónde está? ¡El obj está vacío!
…Pero la notación corta obj = {} es la misma que obj = new Object(), donde Object es una función de constructor de objeto integrado, con su propio prototype que hace referencia a un objeto enorme con toString y otros métodos
Esto es lo que está pasando:

      
      
        
      
      Cuando se llama a new Object() (o se crea un objeto literal {...}), el [[Prototype]] se establece en Object.prototype de acuerdo con la regla que discutimos en el capitulo anterior:

      
      
        
      
      Entonces, cuando se llama a obj.toString(), el método se toma de Object.prototype.
Lo podemos comprobar así:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};

alert(obj.__proto__ === Object.prototype); // true

alert(obj.toString === obj.__proto__.toString); //true
alert(obj.toString === Object.prototype.toString); //true
        
      
      
      Tenga en cuenta que no hay más [[Prototype]] en la cadena sobre Object.prototype:

      
        
        
          
            
          
          
            
          
        
        
          alert(Object.prototype.__proto__); // null
        
      
      
      Otros prototipos integradosOtros objetos integrados como Array, Date , Function y otros también mantienen métodos en prototipos.
Por ejemplo, cuando creamos una matriz [1, 2, 3], el constructor predeterminado new Array() se usa internamente. Entonces Array.prototype se convierte en su prototipo y proporciona sus métodos. Eso es muy eficiente en memoria.
Por especificación, todos los prototipos integrados tienen Object.prototype en la parte superior. Es por eso que algunas personas dicen que “todo hereda de los objetos”.
Aquí está la imagen general de 3 objetos integrados (3 para que quepan):

      
      
        
      
      Verifiquemos los prototipos manualmente:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3];

// se hereda de Array.prototype?
alert( arr.__proto__ === Array.prototype ); // verdadero

// y despues desde Object.prototype?
alert( arr.__proto__.__proto__ === Object.prototype ); // verdadero

// Y null en la parte superior.
alert( arr.__proto__.__proto__.__proto__ ); // null
        
      
      
      Algunos métodos en prototipos pueden superponerse; por ejemplo, Array.prototype tiene su propio toString que enumera elementos delimitados por comas:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3]
alert(arr); // 1,2,3 <-- el resultado de Array.prototype.toString
        
      
      
      Como hemos visto antes, Object.prototype también tiene toString, pero Array.prototype está más cerca de la cadena, por lo que se utiliza la variante de array.

      
      
        
      
      Las herramientas en el navegador, como la consola de desarrollador de Chrome, también muestran herencia (es posible que deba utilizarse console.dir para los objetos integrados):

      
      
      Otros objetos integrados también funcionan de la misma manera. Incluso las funciones: son objetos de un constructor Function integrado, y sus métodos (call/apply y otros) se toman de Function.prototype. Las funciones también tienen su propio toString.

      
        
        
          
            
          
          
            
          
        
        
          function f() {}

alert(f.__proto__ == Function.prototype); // verdadero
alert(f.__proto__.__proto__ == Object.prototype); // verdadero, hereda de objetos
        
      
      
      PrimitivosLo más intrincado sucede con cadenas, números y booleanos.
Como recordamos, no son objetos. Pero si tratamos de acceder a sus propiedades, se crean los objetos contenedores temporales utilizando los constructores integrados String, Number y Boolean, estos proporcionan los métodos y luego desaparecen.
Estos objetos se crean de manera invisible para nosotros y la mayoría de los motores los optimizan, pero la especificación lo describe exactamente de esta manera. Los métodos de estos objetos también residen en prototipos, disponibles como String.prototype, Number.prototype y Boolean.prototype.

            Los valores null y undefined no tienen objetos contenedores
            Los valores especiales null y undefined se distinguen. No tienen objetos contenedores, por lo que los métodos y propiedades no están disponibles para ellos. Y tampoco hay prototipos correspondientes.

Cambiando prototipos nativosLos prototipos nativos pueden ser modificados. Por ejemplo, si agregamos un método a String.prototype, estará disponible para todas las cadenas:

      
        
        
          
            
          
          
            
          
        
        
          String.prototype.show = function() {
  alert(this);
};

"BOOM!".show(); // BOOM!
        
      
      
      Durante el proceso de desarrollo, podemos tener ideas para nuevos métodos integrados que nos gustaría tener, y podemos sentir la tentación de agregarlos a los prototipos nativos. Pero eso es generalmente una mala idea.

            Importante:
            Los prototipos son globales, por lo que es fácil generar un conflicto. Si dos bibliotecas agregan un método String.prototype.show, entonces una de ellas sobrescribirá el método de la otra.
Por lo tanto, en general, modificar un prototipo nativo se considera una mala idea.

En la programación moderna, solo hay un caso en el que se aprueba la modificación de prototipos nativos: haciendo un polyfill.
Cuando un método existe en la especificación de JavaScript, pero aún no está soportado por un motor de JavaScript en particular, podemos hacer “polyfill” (polirrelleno); esto es, crear un método sustituto.
Luego podemos implementarlo manualmente y llenar el prototipo integrado con él.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          if (!String.prototype.repeat) { // si no hay tal método
  // agregarlo al prototipo

  String.prototype.repeat = function(n) {
    // repite la cadena n veces

    // en realidad, el código debería ser un poco más complejo que eso
    // (el algoritmo completo está en la especificación)
    // pero incluso un polyfill (polirelleno) imperfecto a menudo se considera lo suficientemente bueno
    return new Array(n + 1).join(this);
  };
}

alert( "La".repeat(3) ); // LaLaLa
        
      
      
      Préstamo de prototiposEn el capítulo Decoradores y redirecciones, call/apply hablamos sobre el préstamo de método .
Es cuando tomamos un método de un objeto y lo copiamos en otro.
A menudo se toman prestados algunos métodos de prototipos nativos.
Por ejemplo, si estamos haciendo un objeto tipo array, es posible que queramos copiar algunos métodos de ‘Array’.
P. ej…

      
        
        
          
            
          
          
            
          
        
        
          let obj = {
  0: "Hola",
  1: "mundo!",
  length: 2,
};

obj.join = Array.prototype.join;

alert( obj.join(',') ); // Hola,mundo!
        
      
      
      Funciona porque el algoritmo interno del método integrado join solo se preocupa por los índices correctos y la propiedad length. No comprueba si el objeto es realmente un arreglo. Muchos métodos integrados son así.
Otra posibilidad es heredar estableciendo obj.__proto__ en Array.prototype, de modo que todos los métodos Array estén disponibles automáticamente en obj.
Pero eso es imposible si obj ya hereda de otro objeto. Recuerde, solo podemos heredar de un objeto a la vez.
Los métodos de préstamo son flexibles, permiten mezclar funcionalidades de diferentes objetos si es necesario.
Resumen
Todos los objetos integrados siguen el mismo patrón:

Los métodos se almacenan en el prototipo (Array.prototype, Object.prototype, Date.prototype, etc.)
El objeto en sí solo almacena los datos (elementos de arreglo, propiedades de objeto, la fecha)


Los primitivos también almacenan métodos en prototipos de objetos contenedores: Number.prototype, String.prototype y Boolean.prototype. Solo undefined y null no tienen objetos contenedores.
Los prototipos integrados se pueden modificar o completar con nuevos métodos. Pero no se recomienda cambiarlos. El único caso permitido es probablemente cuando agregamos un nuevo estándar que aún no es soportado por el motor de JavaScript.

TareasAgregue el método "f.defer(ms)" a las funcionesimportancia: 5Agregue al prototipo de todas las funciones el método defer(ms), que ejecuta la función después de ms milisegundos.
Después de hacerlo, dicho código debería funcionar:

      
        
        
          function f() {
  alert("Hola!");
}

f.defer(1000); // muestra "Hola!" después de 1 segundo
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          Function.prototype.defer = function(ms) {
  setTimeout(this, ms);
};

function f() {
  alert("Hola!");
}

f.defer(1000); // muestra "Hola!" después de 1 seg
        
      
      
      Agregue el decorado "defer()" a las funcionesimportancia: 4Agregue el método defer(ms) al prototipo de todas las funciones, que devuelve un contenedor, retrasando la llamada en ms milisegundos.
Aquí hay un ejemplo de cómo debería funcionar:

      
        
        
          function f(a, b) {
  alert( a + b );
}

f.defer(1000)(1, 2); // muestra 3 después de 1 segundo
        
      
      
      Tenga en cuenta que los argumentos deben pasarse a la función original.
solución
      
        
        
          
            
          
          
            
          
        
        
          Function.prototype.defer = function(ms) {
  let f = this;
  return function(...args) {
    setTimeout(() => f.apply(this, args), ms);
  }
};

// revísalo
function f(a, b) {
  alert( a + b );
}

f.defer(1000)(1, 2); // muestra 3 después de 1 seg
        
      
      
      Tenga en cuenta: utilizamos this en f.apply para que nuestro decorado funcione para los métodos de objetos.
Entonces, si la función contenedora es llamada como método de objeto, this se pasa al método original f.

      
        
        
          
            
          
          
            
          
        
        
          Function.prototype.defer = function(ms) {
  let f = this;
  return function(...args) {
    setTimeout(() => f.apply(this, args), ms);
  }
};

let user = {
  name: "John",
  sayHi() {
    alert(this.name);
  }
}

user.sayHi = user.sayHi.defer(1000);

user.sayHi();
        
      
      
      ",
	"url": "https://es.javascript.info/native-prototypes" 
},
{
	"docs_id": "68",
	"name": "Métodos prototipo, objetos sin __proto__",
	"description": "En el primer capítulo de esta sección mencionamos que existen métodos modernos para configurar un prototipo.",
	"content": "En el primer capítulo de esta sección mencionamos que existen métodos modernos para configurar un prototipo.
__proto__ se considera desactualizado y algo obsoleto (en la parte propia del navegador dentro del estándar JavaScript).
Los métodos modernos son:

Object.create(proto, [descriptors]) – crea un objeto vacío con el “proto” dado como [[Prototype]] y descriptores de propiedad opcionales.
Object.getPrototypeOf(obj) – devuelve el [[Prototype]] de obj.
Object.setPrototypeOf(obj, proto) – establece el [[Prototype]] de obj en proto.

Estos deben usarse en lugar de __proto__.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  eats: true
};

// crear un nuevo objeto con animal como prototipo
let rabbit = Object.create(animal);

alert(rabbit.eats); // true

alert(Object.getPrototypeOf(rabbit) === animal); // true

Object.setPrototypeOf(rabbit, {}); // cambia el prototipo de rabbit a {}
        
      
      
      Object.create tiene un segundo argumento opcional: descriptores de propiedad. Podemos proporcionar propiedades adicionales al nuevo objeto allí, así:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  eats: true
};

let rabbit = Object.create(animal, {
  jumps: {
    value: true
  }
});

alert(rabbit.jumps); // true
        
      
      
      Los descriptores están en el mismo formato que se describe en el capítulo Indicadores y descriptores de propiedad.
Podemos usar Object.create para realizar una clonación de objetos más poderosa que copiar propiedades en el ciclo for..in:

      
        
        
          let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
        
      
      
      Esta llamada hace una copia verdaderamente exacta de obj, que incluye todas las propiedades: enumerables y no enumerables, propiedades de datos y setters/getters, todo, y con el [[Prototype]] correcto.
Breve historiaSi contamos todas las formas de administrar [[Prototype]], ¡hay muchas! ¡Muchas maneras de hacer lo mismo!
¿Por qué?
Eso es por razones históricas.

La propiedad “prototipo” de una función de constructor ha funcionado desde tiempos muy antiguos.
Más tarde, en el año 2012, apareció Object.create en el estándar. Le dio la capacidad de crear objetos con un prototipo dado, pero no proporcionó la capacidad de obtenerlo/configurarlo. Entonces, los navegadores implementaron el acceso no estándar __proto__ que permitió al usuario obtener/configurar un prototipo en cualquier momento.
Más tarde, en el año 2015, Object.setPrototypeOf y Object.getPrototypeOf se agregaron al estándar, para realizar la misma funcionalidad que __proto__. Como __proto__ se implementó de facto en todas partes, fue desaprobado y llegó al Anexo B de la norma, es decir: opcional para entornos que no son del navegador.

A partir de ahora tenemos todas estas formas a nuestra disposición.
¿Por qué se reemplazó __proto__ por las funciones getPrototypeOf/setPrototypeOf? Esa es una pregunta interesante, que requiere que comprendamos por qué __proto__ es malo. Sigue leyendo para obtener la respuesta.

            No cambie [[Prototype]] en objetos existentes si la velocidad es importante
            Técnicamente, podemos obtener/configurar [[Prototype]] en cualquier momento. Pero generalmente solo lo configuramos una vez en el momento de creación del objeto y ya no lo modificamos: rabbit hereda de animal, y eso no va a cambiar.
Y los motores de JavaScript están altamente optimizados para esto. Cambiar un prototipo “sobre la marcha” con Object.setPrototypeOf u obj.__ proto __= es una operación muy lenta ya que rompe las optimizaciones internas para las operaciones de acceso a la propiedad del objeto. Por lo tanto, evítelo a menos que sepa lo que está haciendo, o no le importe la velocidad de JavaScript .

Objetos "muy simples"Como sabemos, los objetos se pueden usar como arreglos asociativas para almacenar pares clave/valor.
…Pero si tratamos de almacenar claves proporcionadas por el usuario en él (por ejemplo, un diccionario ingresado por el usuario), podemos ver una falla interesante: todas las claves funcionan bien excepto "__proto __ ".
Mira el ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};

let key = prompt("Cual es la clave?", "__proto__");
obj[key] = "algún valor";

alert(obj[key]); // [object Object], no es "algún valor"!
        
      
      
      Aquí, si el usuario escribe en __proto__, ¡la asignación se ignora!
Eso no debería sorprendernos. La propiedad __proto__ es especial: debe ser un objeto o null. Una cadena no puede convertirse en un prototipo.
Pero no intentamos implementar tal comportamiento, ¿verdad? Queremos almacenar pares clave/valor, y la clave llamada "__proto__" no se guardó correctamente. ¡Entonces eso es un error!
Aquí las consecuencias no son terribles. Pero en otros casos podemos estar asignando valores de objeto, y luego el prototipo puede ser cambiado. Como resultado, la ejecución irá mal de maneras totalmente inesperadas.
Lo que es peor: generalmente los desarrolladores no piensan en tal posibilidad en absoluto. Eso hace que tales errores sean difíciles de notar e incluso los convierta en vulnerabilidades, especialmente cuando se usa JavaScript en el lado del servidor.
También pueden ocurrir cosas inesperadas al asignar a toString, que es una función por defecto, y a otros métodos integrados.
¿Cómo podemos evitar este problema?
Primero, podemos elegir usar Map para almacenamiento en lugar de objetos simples, luego todo queda bien.
Pero ‘Objeto’ también puede servirnos bien aquí, porque los creadores del lenguaje pensaron en ese problema hace mucho tiempo.
__proto__ no es una propiedad de un objeto, sino una propiedad de acceso de Object.prototype:

      
      
        
      
      Entonces, si se lee o establece obj.__ proto__, el getter/setter correspondiente se llama desde su prototipo y obtiene/establece [[Prototype]].
Como se dijo al comienzo de esta sección del tutorial: __proto__ es una forma de acceder a [[Prototype]], no es [[Prototype]] en sí.
Ahora, si pretendemos usar un objeto como una arreglo asociativa y no tener tales problemas, podemos hacerlo con un pequeño truco:

      
        
        
          
            
          
          
            
          
        
        
          let obj = Object.create(null);

let key = prompt("Cual es la clave", "__proto__");
obj[key] = "algún valor";

alert(obj[key]); // "algún valor"
        
      
      
      Object.create(null) crea un objeto vacío sin un prototipo ([[Prototype]] es null):

      
      
        
      
      Entonces, no hay getter/setter heredado para __proto__. Ahora se procesa como una propiedad de datos normal, por lo que el ejemplo anterior funciona correctamente.
Podemos llamar a estos objetos: objetos “muy simples” o “de diccionario puro”, porque son aún más simples que el objeto simple normal {...}.
Una desventaja es que dichos objetos carecen de métodos de objetos integrados, p.ej. toString:

      
        
        
          
            
          
          
            
          
        
        
          let obj = Object.create(null);

alert(obj); // Error (no hay toString)
        
      
      
      …Pero eso generalmente está bien para arreglos asociativas.
Tenga en cuenta que la mayoría de los métodos relacionados con objetos son Object.algo(...), como Object.keys(obj)  y no están en el prototipo, por lo que seguirán trabajando en dichos objetos:

      
        
        
          
            
          
          
            
          
        
        
          let chineseDictionary = Object.create(null);
chineseDictionary.hello = "你好";
chineseDictionary.bye = "再见";

alert(Object.keys(chineseDictionary)); // hola, adiós
        
      
      
      ResumenLos métodos modernos para configurar y acceder directamente al prototipo son:

Object.create(proto, [descriptores]) – crea un objeto vacío con un proto dado como [[Prototype]] (puede ser null) y descriptores de propiedad opcionales.
Object.getPrototypeOf(obj) – devuelve el [[Prototype]] de obj (igual que el getter de __proto__).
Object.setPrototypeOf(obj, proto) – establece el [[Prototype]] de obj en proto (igual que el setter de __proto__).

El getter/setter incorporado de __proto__ no es seguro si queremos poner claves generadas por el usuario en un objeto. Aunque un usuario puede ingresar "__proto __" como clave, y habrá un error, con consecuencias levemente dañinas, pero generalmente impredecibles.
Entonces podemos usar Object.create(null) para crear un objeto “muy simple” sin __proto__, o apegarnos a los objetos Map para eso.
Además, Object.create proporciona una manera fácil de copiar llanamente un objeto con todos los descriptores:

      
        
        
          let clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
        
      
      
      También dejamos en claro que __proto__ es un getter/setter para [[Prototype]]  y reside en Object.prototype, al igual que otros métodos.
Podemos crear un objeto sin prototipo mediante Object.create(null). Dichos objetos se utilizan como “diccionarios puros”, no tienen problemas con "__proto __" como clave.
Otros métodos:

Object.keys(obj) / Object.values(obj) / Object.entries(obj): devuelve un arreglo enumerable de: nombres-de-propiedad / valores / pares-clave-valor.
Object.getOwnPropertySymbols(obj): devuelve un arreglo de todas las claves simbólicas propias.
Object.getOwnPropertyNames(obj): devuelve un arreglo de todas las claves de cadena propias.
Reflect.ownKeys(obj): devuelve un arreglo de todas las claves propias.
obj.hasOwnProperty(key): devuelve true si obj tiene su propia clave (no heredada) llamada key.

Todos los métodos que devuelven propiedades de objeto (como Object.keys y otros) – devuelven propiedades “propias”. Si queremos las heredadas, podemos usar for..in.
TareasAñadir toString al diccionarioimportancia: 5Hay un objeto dictionary, creado como Object.create(null), para almacenar cualquier par clave/valor.
Agrega el método dictionary.toString(), que debería devolver una lista de claves delimitadas por comas. Tu toString no debe aparecer al iterar un for..in sobre el objeto.
Así es como debería funcionar:

      
        
        
          let dictionary = Object.create(null);

// tu código para agregar el método dictionary.toString

// agregar algunos datos
dictionary.apple = "Manzana";
dictionary.__proto__ = "prueba"; // // aquí proto es una propiedad clave común

// solo manzana y __proto__ están en el ciclo
for(let key in dictionary) {
  alert(key); // "manzana", después "__proto__"
}

// tu toString en acción
alert(dictionary); // "manzana,__proto__"
        
      
      
      soluciónEl método puede tomar todas las claves enumerables usando Object.keys y generar su lista.
Para hacer que toString no sea enumerable, definámoslo usando un descriptor de propiedad. La sintaxis de Object.create nos permite proporcionar un objeto con descriptores de propiedad como segundo argumento.

      
        
        
          
            
          
          
            
          
        
        
          let dictionary = Object.create(null, {
  toString: { // define la propiedad toString
    value() { // el valor es una funcion
      return Object.keys(this).join();
    }
  }
});

dictionary.apple = "Manzana";
dictionary.__proto__ = "prueba";

// manzana y __proto__ están en el ciclo
for(let key in dictionary) {
  alert(key); // "manzana", despues "__proto__"
}

// lista de propiedades separadas por comas por toString
alert(dictionary); // "manzana,__proto__"
        
      
      
      Cuando creamos una propiedad usando un descriptor, sus banderas son false por defecto. Entonces, en el código anterior, dictionary.toString no es enumerable.
Consulte el capítulo Indicadores y descriptores de propiedad para su revisión.
La diferencia entre llamadasimportancia: 5Creemos un nuevo objeto rabbit:

      
        
        
          function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.sayHi = function() {
  alert(this.name);
};

let rabbit = new Rabbit("Conejo");
        
      
      
      Estas llamadas hacen lo mismo o no?

      
        
        
          rabbit.sayHi();
Rabbit.prototype.sayHi();
Object.getPrototypeOf(rabbit).sayHi();
rabbit.__proto__.sayHi();
        
      
      
      soluciónLa primera llamada tiene this == rabbit, las otras tienen this igual a Rabbit.prototype, porque en realidad es el objeto antes del punto.
Entonces, solo la primera llamada muestra Rabbit, las otras muestran undefined:

      
        
        
          
            
          
          
            
          
        
        
          function Rabbit(name) {
  this.name = name;
}
Rabbit.prototype.sayHi = function() {
  alert( this.name );
}

let rabbit = new Rabbit("Conejo");

rabbit.sayHi();                        // Conejo
Rabbit.prototype.sayHi();              // undefined
Object.getPrototypeOf(rabbit).sayHi(); // undefined
rabbit.__proto__.sayHi();              // undefined
        
      
      
      ",
	"url": "https://es.javascript.info/prototype-methods" 
},
{
	"docs_id": "69",
	"name": "Sintaxis básica de `class`",
	"description": "En informática, una clase es una plantilla para la creación de objetos de datos según un modelo predefinido. Las clases se utilizan para representar entidades o conceptos, como los sustantivos en el lenguaje. Cada clase es un modelo que define un conjunto de variables —el estado—, y métodos apropiados para operar con dichos datos —el comportamiento—.",
	"content": "En informática, una clase es una plantilla para la creación de objetos de datos según un modelo predefinido. Las clases se utilizan para representar entidades o conceptos, como los sustantivos en el lenguaje. Cada clase es un modelo que define un conjunto de variables —el estado—, y métodos apropiados para operar con dichos datos —el comportamiento—.

        Wikipedia
       En la práctica a menudo necesitamos crear muchos objetos del mismo tipo: usuarios, bienes, lo que sea.
Como ya sabemos del capítulo Constructor, operador "new", new function puede ayudar con eso.
Pero en JavaScript moderno hay un constructor más avanzado, “class”, que introduce características nuevas muy útiles para la programación orientada a objetos.
La sintaxis “class”La sintaxis básica es:

      
        
        
          class MyClass {
  // métodos de clase
  constructor() { ... }
  method1() { ... }
  method2() { ... }
  method3() { ... }
  ...
}
        
      
      
      Entonces usamos new MyClass() para crear un objeto nuevo con todos los métodos listados.
El método constructor() es llamado automáticamente por new, así podemos inicializar el objeto allí.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          class User {

  constructor(name) {
    this.name = name;
  }

  sayHi() {
    alert(this.name);
  }

}

// Uso:
let user = new User("John");
user.sayHi();
        
      
      
      Cuando se llama a new User("John"):

Un objeto nuevo es creado.
El constructor se ejecuta con el argumento dado y lo asigna a this.name.

…Entonces podemos llamar a sus métodos, como user.sayHi().

            No va una coma entre métodos de clase
            Un tropiezo común en desarrolladores principiantes es poner una coma entre los métodos de clase, lo que resulta en un error de sintaxis.
La notación aquí no debe ser confundida con la sintaxis de objeto literal. Dentro de la clase no se requieren comas.

¿Qué es una clase?Entonces, ¿qué es exactamente class? No es una entidad completamente nueva a nivel de lenguaje como uno podría pensar.
Desvelemos la magia y veamos lo que realmente es una clase. Ayudará a entender muchos aspectos complejos.
En JavaScript, una clase es un tipo de función.
Veamos:

      
        
        
          
            
          
          
            
          
        
        
          class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// La prueba: User es una función
alert(typeof User); // function
        
      
      
      Lo que la construcción class User {...} hace realmente es:

Crea una función llamada User, la que se vuelve el resultado de la declaración de la clase. El código de la función es tomado del método constructor (se asume vacío si no se escribe tal método).
Almacena los métodos de clase, tales como sayHi, en User.prototype.

Después de que el objeto new User es creado, cuando llamamos a sus métodos estos son tomados del prototipo, tal como se describe en el capítulo F.prototype. Así el objeto tiene acceso a métodos de clase.
Podemos ilustrar el resultado de la declaración de class User como:

      
      
        
      
      Aquí el código para inspeccionarlo:

      
        
        
          
            
          
          
            
          
        
        
          class User {
  constructor(name) { this.name = name; }
  sayHi() { alert(this.name); }
}

// una clase es una función
alert(typeof User); // function

// ...o, más precisamente, el método constructor
alert(User === User.prototype.constructor); // true

// Los métodos están en User.prototype, por ejemplo:
alert(User.prototype.sayHi); // el código del método sayHi

// Hay exactamente dos métodos en el prototipo
alert(Object.getOwnPropertyNames(User.prototype)); // constructor, sayHi
        
      
      
      No es solamente azúcar sintácticaA veces se dice que class es “azúcar sintáctica” (sintaxis que es diseñada para una lectura más fácil, pero que no introduce nada nuevo), porque en realidad podemos declarar lo mismo sin la palabra clave class en absoluto:

      
        
        
          
            
          
          
            
          
        
        
          // reescribiendo la clase User puramente con funciones

// 1. Crear la función constructor
function User(name) {
  this.name = name;
}
// un prototipo de función tiene la propiedad "constructor" por defecto,
// así que no necesitamos crearla

// 2. Agregar el método al prototipo
User.prototype.sayHi = function() {
  alert(this.name);
};

// Uso:
let user = new User("John");
user.sayHi();
        
      
      
      El resultado de esta definición es el mismo. Así, efectivamente hay razones para que class sea considerada azúcar sintáctica para definir un constructor junto con sus métodos de prototipo.
Aún así hay diferencias importantes.


Primero, una función creada por class es etiquetada por una propiedad interna especial [[IsClassConstructor]]:true. Entones no es exactamente lo mismo que crearla manualmente.
El lenguaje verifica esa propiedad en varios lugares. Por ejemplo, a diferencia de las funciones regulares, esta debe ser llamada con new:

      
        
        
          
            
          
          
            
          
        
        
          class User {
  constructor() {}
}

alert(typeof User); // function
User(); // Error: El constructor de clase User no puede ser invocado sin 'new'
        
      
      
      Además una representación string de un constructor de clase en la mayoría de los motores JavaScript comienzan con “class…”

      
        
        
          
            
          
          
            
          
        
        
          class User {
  constructor() {}
}

alert(User); // class User { ... }
        
      
      
      Hay otras diferencias que veremos pronto.


Los métodos de clase no son enumerables.
La definición de clase establece la bandera enumerable a false para todos los métodos en "prototype".
Esto es bueno porque si hacemos for..in a un objeto usualmente no queremos sus métodos de clase.


Las clases siempre asumen use strict.
Todo el código dentro del constructor de clase está automáticamente en modo estricto.


Además la sintaxis de class brinda muchas otras características que exploraremos luego.
Expresión de clasesAl igual que las funciones, las clases pueden ser definidas dentro de otra expresión, pasadas, devueltas, asignadas, etc.
Aquí hay un ejemplo de una expresión de clase:

      
        
        
          let User = class {
  sayHi() {
    alert("Hello");
  }
};
        
      
      
      Al igual que las expresiones de función, las expresiones de clase pueden tener un nombre.
Si una expresión de clase tiene un nombre, este es visible solamente dentro de la clase.

      
        
        
          
            
          
          
            
          
        
        
          // Expresiones de clase con nombre
// ("Named Class Expression" no figura así en la especificación, pero es equivalente a "Named Function Expression")
let User = class MyClass {
  sayHi() {
    alert(MyClass); // El nombre de MyClass solo es visible dentro de la clase
  }
};

new User().sayHi(); // Funciona, muestra la definición de MyClass

alert(MyClass); // error, el nombre de MyClass no es visible fuera de la clase
        
      
      
      Podemos inclusive crear clases dinámicamente “a pedido”, como esto:

      
        
        
          
            
          
          
            
          
        
        
          function makeClass(phrase) {
  // declara una clase y la devuelve
  return class {
    sayHi() {
      alert(phrase);
    }
  };
}

// Crea una nueva clase
let User = makeClass("Hello");

new User().sayHi(); // Hello
        
      
      
      Getters/settersAl igual que los objetos literales, las clases pueden incluir getters/setters, propiedades calculadas, etc.
Aquí hay un ejemplo de user.name, implementado usando get/set:

      
        
        
          
            
          
          
            
          
        
        
          class User {

  constructor(name) {
    // invoca el setter
    this.name = name;
  }

  get name() {
    return this._name;
  }

  set name(value) {
    if (value.length < 4) {
      alert("Nombre demasiado corto.");
      return;
    }
    this._name = value;
  }

}

let user = new User("John");
alert(user.name); // John

user = new User(""); // Nombre demasiado corto.
        
      
      
      Técnicamente, la declaración de clase funciona creando getters y setters en User.prototype.
Nombres calculados […]Aquí hay un ejemplo con un nombre de método calculado usando corchetes [...]:

      
        
        
          
            
          
          
            
          
        
        
          class User {

  ['say' + 'Hi']() {
    alert("Hello");
  }

}

new User().sayHi();
        
      
      
      Es una característica fácil de recordar porque se asemeja a la de los objetos literales.
Campos de clase (Class fields)
            Los navegadores viejos pueden necesitar polyfill
            Los campos de clase son un agregado reciente al lenguaje.

Antes, nuestras clases tenían solamente métodos.
“Campos de clase” es una sintaxis que nos permite agregar una propiedad cualquiera.
Por ejemplo, agreguemos la propiedad name a la clase User:

      
        
        
          
            
          
          
            
          
        
        
          class User {
  name = "John";

  sayHi() {
    alert(`Hello, ${this.name}!`);
  }
}

new User().sayHi(); // Hello, John!
        
      
      
      Así, simplemente escribimos " = " en la declaración, y eso es todo.
La diferencia importante de las propiedades definidas como “campos de clase” es que estas son establecidas en los objetos individuales, no compartidas en User.prototype:

      
        
        
          
            
          
          
            
          
        
        
          class User {
  name = "John";
}

let user = new User();
alert(user.name); // John
alert(User.prototype.name); // undefined
        
      
      
      También podemos asignar valores usando expresiones más complejas y llamados a función:

      
        
        
          
            
          
          
            
          
        
        
          class User {
  name = prompt("Name, please?", "John");
}

let user = new User();
alert(user.name); // John
        
      
      
      Vinculación de métodos (binding) usando campos de claseComo se demostró en el capítulo Función bind: vinculación de funciones, las funciones en JavaScript tienen un this dinámico. Este depende del contexto del llamado.
Entonces si un método de objeto es pasado y llamado en otro contexto, this ya no será una referencia a su objeto.
Por ejemplo, este código mostrará undefined:

      
        
        
          
            
          
          
            
          
        
        
          class Button {
  constructor(value) {
    this.value = value;
  }

  click() {
    alert(this.value);
  }
}

let button = new Button("hello");

setTimeout(button.click, 1000); // undefined
        
      
      
      Este problema es denominado "pérdida de this".
Hay dos enfoques para solucionarlo, como se discute en el capítulo Función bind: vinculación de funciones:

Pasar un contenedor o wrapper-function como: setTimeout(() => button.click(), 1000).
Vincular el método al objeto, por ejemplo en el constructor.

Los campos de clase brindan otra sintaxis, bastante elegante:

      
        
        
          
            
          
          
            
          
        
        
          class Button {
  constructor(value) {
    this.value = value;
  }
  click = () => {
    alert(this.value);
  }
}

let button = new Button("hello");

setTimeout(button.click, 1000); // hello
        
      
      
      Un campo de clase click = () => {...} es creado para cada objeto. Hay una función para cada objeto Button, con this dentro referenciando ese objeto. Podemos pasar button.click a cualquier lado y el valor de this siempre será el correcto.
Esto es especialmente práctico, en el ambiente de los navegadores, para los “event listeners”.
ResumenLa sintaxis básica de clase se ve así:

      
        
        
          class MyClass {
  prop = value; // propiedad

  constructor(...) { // constructor
    // ...
  }

  method(...) {} // método

  get something(...) {} // método getter
  set something(...) {} // método setter

  [Symbol.iterator]() {} // método con nombre calculado (aquí, symbol)
  // ...
}
        
      
      
      MyClass es técnicamente una función (la que proveemos como constructor), mientras que los métodos, getters y setters son escritos en MyClass.prototype.
En los siguientes capítulos aprenderemos más acerca de clases, incluyendo herencia y otras características.
TareasReescribir como classimportancia: 5La clase Clock (ver en el sandbox) está escrita en estilo funcional. Reescríbela en sintaxis de clase.
P.D. El reloj anda en la consola, ábrela para verlo.
Abrir un entorno controlado para la tarea.solución
      
        
        
          class Clock {
  constructor({ template }) {
    this.template = template;
  }

  render() {
    let date = new Date();

    let hours = date.getHours();
    if (hours < 10) hours = '0' + hours;

    let mins = date.getMinutes();
    if (mins < 10) mins = '0' + mins;

    let secs = date.getSeconds();
    if (secs < 10) secs = '0' + secs;

    let output = this.template
      .replace('h', hours)
      .replace('m', mins)
      .replace('s', secs);

    console.log(output);
  }

  stop() {
    clearInterval(this.timer);
  }

  start() {
    this.render();
    this.timer = setInterval(() => this.render(), 1000);
  }
}


let clock = new Clock({template: 'h:m:s'});
clock.start();
        
      
      
      Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/class" 
},
{
	"docs_id": "70",
	"name": "Herencia de clase",
	"description": "La herencia de clase es el modo para que una clase extienda a otra.",
	"content": "La herencia de clase es el modo para que una clase extienda a otra.
De esta manera podemos añadir nueva funcionalidad a la ya existente.
La palabra clave “extends”Digamos que tenemos la clase Animal:

      
        
        
          class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  run(speed) {
    this.speed = speed;
    alert(`${this.name} corre a una velocidad de ${this.speed}.`);
  }
  stop() {
    this.speed = 0;
    alert(`${this.name} se queda quieto.`);
  }
}

let animal = new Animal("Mi animal");
        
      
      
      Así es como podemos representar gráficamente el objeto animal y la clase Animal:

      
      
        
      
      …Y nos gustaría crear otra clase Rabbit.
Como los conejos son animales, la clase ‘Rabbit’ debería basarse en ‘Animal’ y así tener acceso a métodos animales, para que los conejos puedan hacer lo que los animales “genéricos” pueden hacer.
La sintaxis para extender otra clase es: class Hijo extends Padre.
Construyamos la clase Rabbit que herede de Animal:

      
        
        
          class Rabbit extends Animal {
  hide() {
    alert(`¡${this.name} se esconde!`);
  }
}

let rabbit = new Rabbit("Conejo Blanco");

rabbit.run(5); // Conejo Blanco corre a una velocidad de 5.
rabbit.hide(); // ¡Conejo Blanco se esconde!
        
      
      
      Los objetos de la clase Rabbit tienen acceso a los métodos de Rabbit, como rabbit.hide(), y también a los métodos Animal, como rabbit.run().
Internamente, la palabra clave extends funciona con la buena mecánica de prototipo: establece Rabbit.prototype.[[Prototype]] a Animal.prototype. Entonces, si no se encuentra un método en Rabbit.prototype, JavaScript lo toma de Animal.prototype.

      
      
        
      
      Por ejemplo, para encontrar el método rabbit.run, el motor revisa (en la imagen, de abajo hacia arriba):

El objeto rabbit: no tiene el método run.
Su prototipo, que es Rabbit.prototype: tiene el método hide, pero no el método run.
Su prototipo, que es Animal.prototype (debido a extends): Este finalmente tiene el método run.

Como podemos recordar del capítulo Prototipos nativos, JavaScript usa la misma herencia prototípica para los objetos incorporados. Por ejemplo, Date.prototype.[[Prototype]] es Object.prototype. Es por esto que “Date” tiene acceso a métodos de objeto genéricos.

            Cualquier expresión está permitida después de extends
            La sintaxis de clase permite especificar no solo una clase, sino cualquier expresión después de extends.
Por ejemplo, una llamada a función que genera la clase padre:

      
        
        
          
            
          
          
            
          
        
        
          function f(phrase) {
  return class {
    sayHi() { alert(phrase); }
  };
}

class User extends f("Hola") {}

new User().sayHi(); // Hola
        
      
      
      Observa que class User hereda del resultado de f("Hola").
Eso puede ser útil para patrones de programación avanzados cuando usamos funciones para generar clases dependiendo de muchas condiciones y podamos heredar de ellas.

Sobrescribir un métodoAhora avancemos y sobrescribamos un método. Por defecto, todos los métodos que no están especificados en la clase Rabbit se toman directamente “tal cual” de la clase Animal.
Pero Si especificamos nuestro propio método stop() en Rabbit, es el que se utilizará en su lugar:

      
        
        
          class Rabbit extends Animal {
  stop() {
    // ...esto se usará para rabbit.stop()
    // en lugar de stop() de la clase Animal
  }
}
        
      
      
      Sin embargo, no siempre queremos reemplazar totalmente un método padre sino construir sobre él, modificarlo o ampliar su funcionalidad. Hacemos algo con nuestro método, pero queremos llamar al método padre antes, después o durante el proceso.
Las clases proporcionan la palabra clave "super" para eso.

super.metodo(...) llama un método padre.
super(...) llama un constructor padre (solo dentro de nuestro constructor).

Por ejemplo, hagamos que nuestro conejo se oculte automáticamente cuando se detenga:

      
        
        
          
            
          
          
            
          
        
        
          class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  run(speed) {
    this.speed = speed;
    alert(`${this.name} corre a una velocidad de ${this.speed}.`);
  }

  stop() {
    this.speed = 0;
    alert(`${this.name} se queda quieto.`);
  }

}

class Rabbit extends Animal {
  hide() {
    alert(`¡${this.name} se esconde!`);
  }

  stop() {
    super.stop(); // llama el stop padre
    this.hide(); // y luego hide
  }
}

let rabbit = new Rabbit("Conejo Blanco");

rabbit.run(5); // Conejo Blanco corre a una velocidad de 5.
rabbit.stop(); // Conejo Blanco se queda quieto. ¡Conejo Blanco se esconde!
        
      
      
      Ahora Rabbit tiene el método stop que llama al padre super.stop() en el proceso.

            Las funciones de flecha no tienen super
            Como se mencionó en el capítulo Funciones de flecha revisadas, las funciones de flecha no tienen super.
Si se lo accede, lo toma de la función externa. Por ejemplo:

      
        
        
          class Rabbit extends Animal {
  stop() {
    setTimeout(() => super.stop(), 1000); // llama al stop() padre después de 1 segundo
  }
}
        
      
      
      El método super en la función de flecha es el mismo que en stop(), y funciona según lo previsto. Si aquí especificáramos una función “regular”, habría un error:

      
        
        
          // super inesperado
setTimeout(function() { super.stop() }, 1000);
        
      
      
      
Sobrescribir un constructorCon los constructores se pone un poco complicado.
Hasta ahora, Rabbit no tenía su propio constructor.
De acuerdo con la especificación, si una clase extiende otra clase y no tiene constructor, se genera el siguiente constructor “vacío”:

      
        
        
          class Rabbit extends Animal {
  // es generado por extender la clase sin constructor propio
  constructor(...args) {
    super(...args);
  }
}
        
      
      
      Como podemos ver, básicamente llama al constructor padre pasándole todos los argumentos. Esto sucede si no escribimos un constructor propio.
Ahora agreguemos un constructor personalizado a Rabbit. Especificará earLength además de name:

      
        
        
          
            
          
          
            
          
        
        
          class Animal {
  constructor(name) {
    this.speed = 0;
    this.name = name;
  }
  // ...
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    this.speed = 0;
    this.name = name;
    this.earLength = earLength;
  }

  // ...
}

// No funciona!
let rabbit = new Rabbit("Conejo Blanco", 10); // Error: this no está definido.
        
      
      
      ¡Vaya! Tenemos un error. Ahora no podemos crear conejos. ¿Qué salió mal?
La respuesta corta es:

Los constructores en las clases heredadas deben llamar a super(...), y (¡!) hacerlo antes de usar this.

…¿Pero por qué? ¿Qué está pasando aquí? De hecho, el requisito parece extraño.
Por supuesto, hay una explicación. Vamos a entrar en detalles, para que realmente entiendas lo que está pasando.
En JavaScript, hay una distinción entre una función constructora de una clase heredera (llamada “constructor derivado”) y otras funciones. Un constructor derivado tiene una propiedad interna especial [[ConstructorKind]]:"derived". Esa es una etiqueta interna especial.
Esa etiqueta afecta su comportamiento con new.

Cuando una función regular se ejecuta con new, crea un objeto vacío y lo asigna a this.
Pero cuando se ejecuta un constructor derivado, no hace esto. Espera que el constructor padre haga este trabajo.

Entonces un constructor derivado debe llamar a super para ejecutar su constructor padre (base), de lo contrario no se creará el objeto para this. Y obtendremos un error.
Para que el constructor Rabbit funcione, necesita llamar a super() antes de usar this, como aquí:

      
        
        
          
            
          
          
            
          
        
        
          class Animal {

  constructor(name) {
    this.speed = 0;
    this.name = name;
  }

  // ...
}

class Rabbit extends Animal {

  constructor(name, earLength) {
    super(name);
    this.earLength = earLength;
  }

  // ...
}

// todo bien ahora
let rabbit = new Rabbit("Conejo Blanco", 10);
alert(rabbit.name); // Conejo Blanco
alert(rabbit.earLength); // 10
        
      
      
      Sobrescribiendo campos de clase: una nota con trampa
            Nota avanzada
            Esta nota asume que tienes cierta experiencia con clases, quizás en otros lenguajes de programación.
Brinda una visión más profunda al lenguaje y también explica el comportamiento que podría causar errores (pero no muy a menudo).
Si lo encuentras difícil de entender, simplemente sigue adelante, continúa leyendo y vuelve aquí más adelante.

Podemos sobrescribir no solo métodos, sino también los campos de la clase.
Pero hay un comportamiento peculiar cuando accedemos a los campos sobrescritos en el constructor padre, muy diferente a de la mayoría de los demás lenguajes de programación.
Considera este ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          class Animal {
  name = 'animal';

constructor() {
    alert(this.name); // (*)
  }
}

class Rabbit extends Animal {
  name = 'rabbit';
}

new Animal(); // animal
new Rabbit(); // animal
        
      
      
      Aquí, la clase Rabbit extiende Animal y sobrescribe el campo name con un valor propio.
Rabbit no tiene su propio constructor, entonces es llamado el de Animal.
Lo interesante es que en ambos casos: new Animal() y new Rabbit(), el alert en la línea (*) muestra animal.
En otras palabras, el constructor padre siempre usa el valor de su propio campo de clase, no el sobrescrito.
¿Qué es lo extraño de esto?
Si esto aún no está claro, comparáralo con lo que ocurre con los métodos.
Aquí está el mismo código, pero en lugar del campo this.name llamamos el método this.showName():

      
        
        
          
            
          
          
            
          
        
        
          class Animal {
  showName() {  // en vez de this.name = 'animal'
    alert('animal');
  }

  constructor() {
    this.showName(); // en vez de alert(this.name);
  }
}

class Rabbit extends Animal {
  showName() {
    alert('rabbit');
  }
}

new Animal(); // animal
new Rabbit(); // rabbit
        
      
      
      Observa que ahora la salida es diferente.
Y es lo que esperamos naturalmente. Cuando el constructor padre es llamado en la clase derivada, usa el método sobrescrito.
…Pero con los campos esto no es así. Como dijimos antes, el constructor padre siempre utiliza el campo padre.
¿Por que existe la diferencia?
Bien, la razón está en el orden de inicialización, El campo de clase es inicializado:

Antes del constructor para la clase de base (que no extiende nada),
Inmediatamente después de super() para la clase derivada.

En nuestro caso, Rabbit es la clase derivada. No hay constructor() en ella. Como establecimos previamente, es lo mismo que si hubiera un constructor vacío con solamente super(...args).
Entonces, new Rabbit() llama a super() y se ejecuta el constructor padre, y (por la regla de la clase derivada) solamente después de que sus campos de clase sean inicializados. En el momento de la ejecución del constructor padre, todavía no existen los campos de clase de Rabbit, por ello los campos de Animal son los usados.
Esta sutil diferencia entre campos y métodos es particular de JavaScript
Afortunadamente este comportamiento solo se revela si los campos sobrescritos son usados en el constructor padre. En tal caso puede ser difícil entender qué es lo que está pasando, por ello lo explicamos aquí.
Si esto se vuelve un problema, uno puede corregirlo usando métodos o getters/setters en lugar de campos.
Super: internamente, [[HomeObject]]
            Información avanzada
            Si está leyendo el tutorial por primera vez, esta sección puede omitirse.
Esta sección trata de los mecanismos internos detrás de la herencia y el método super.

Vamos a profundizar un poco más el tema de super. Veremos algunas cosas interesantes en el camino.
En primer lugar, de todo lo que hemos aprendido hasta ahora, ¡es imposible que super funcione en absoluto!
Entonces, preguntémonos: ¿cómo debería funcionar técnicamente? Cuando se ejecuta un método de objeto, obtiene el objeto actual como this. Si llamamos a super.method() entonces, el motor necesita obtener el method del prototipo del objeto actual. ¿Pero cómo?
La tarea puede parecer simple, pero no lo es. El motor conoce el objeto actual this, por lo que podría obtener el method padre como this.__proto __.method. Desafortunadamente, una solución tan “ingenua” no funcionará.
Demostremos el problema. Sin clases, usando objetos puros por simplicidad.
Puedes omitir esta parte e ir a la subsección [[HomeObject]] si no deseas conocer los detalles. Eso no hará daño. O sigue leyendo si estás interesado en comprender las cosas en profundidad.
En el siguiente ejemplo, se hace la asignación rabbit.__ proto__ = animal. Ahora intentemos: en rabbit.eat() llamaremos a animal.eat(), usando this.__proto__:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  name: "Animal",
  eat() {
    alert(`${this.name} come.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: "Conejo",
  eat() {
    // así es como supuestamente podría funcionar super.eat()
    this.__proto__.eat.call(this); // (*)
  }
};

rabbit.eat(); // Conejo come.
        
      
      
      En la línea (*) tomamos eat del prototipo (animal) y lo llamamos en el contexto del objeto actual. Tenga en cuenta que .call(this) es importante aquí, porque un simple this.__ proto __.eat() ejecutaría al padre eat en el contexto del prototipo, no del objeto actual.
Y en el código anterior, funciona según lo previsto: tenemos el alert correcto.
Ahora agreguemos un objeto más a la cadena. Veremos cómo se rompen las cosas:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  name: "Animal",
  eat() {
    alert(`${this.name} come.`);
  }
};

let rabbit = {
  __proto__: animal,
  eat() {
    // ...rebota al estilo de conejo y llama al método padre (animal)
    this.__proto__.eat.call(this); // (*)
  }
};

let longEar = {
  __proto__: rabbit,
  eat() {
    // ...haz algo con orejas largas y llama al método padre (rabbit)
    this.__proto__.eat.call(this); // (**)
  }
};

longEar.eat(); // Error: Se excedió el número máximo de llamadas a la pila
        
      
      
      ¡El código ya no funciona! Podemos ver el error al intentar llamar a longEar.eat().
Puede que no sea tan obvio, pero si depuramos la llamada longEar.eat(), podremos ver por qué. En ambas líneas (*) y (**) el valor de this es el objeto actual (longEar). Eso es esencial: todos los métodos de objeto obtienen el objeto actual como this, no un prototipo o algo así.
Entonces, en ambas líneas (*) y (**) el valor de this.__proto__ es exactamente el mismo: rabbit. Ambos llaman a  rabbit.eat sin subir la cadena en el bucle sin fin.
Aquí está la imagen de lo que sucede:

      
      
        
      
      

Dentro de longEar.eat(), la línea (**) llama a rabbit.eat proporcionándole this=longEar.

      
        
        
          // dentro de longEar.eat() tenemos this = longEar
this.__proto__.eat.call(this) // (**)
// se convierte en
longEar.__proto__.eat.call(this)
// es decir
rabbit.eat.call(this);
        
      
      
      

Luego, en la línea (*) de rabbit.eat, queremos pasar la llamada aún más arriba en la cadena; pero como this=longEar, entonces this.__ proto__.eat ¡es nuevamente rabbit.eat!

      
        
        
          // dentro de rabbit.eat () también tenemos this = longEar
this.__proto__.eat.call(this) // (*)
// se convierte en
longEar.__proto__.eat.call(this)
// o (de nuevo)
rabbit.eat.call(this);
        
      
      
      

…Entonces rabbit.eat se llama a sí mismo en el bucle sin fin, porque no puede ascender más.


El problema no se puede resolver usando solamente this.
[[HomeObject]]Para proporcionar la solución, JavaScript agrega una propiedad interna especial para las funciones: [[HomeObject]].
Cuando una función se especifica como un método de clase u objeto, su propiedad [[HomeObject]] se convierte en ese objeto.
Entonces super lo usa para resolver el problema del prototipo padre y sus métodos.
Veamos cómo funciona, primero con objetos simples:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  name: "Animal",
  eat() {         // animal.eat.[[HomeObject]] == animal
    alert(`${this.name} come.`);
  }
};

let rabbit = {
  __proto__: animal,
  name: "Conejo",
  eat() {         // rabbit.eat.[[HomeObject]] == rabbit
    super.eat();
  }
};

let longEar = {
  __proto__: rabbit,
  name: "Oreja Larga",
  eat() {         // longEar.eat.[[HomeObject]] == longEar
    super.eat();
  }
};

// funciona correctamente
longEar.eat();  // Oreja Larga come.
        
      
      
      Funciona según lo previsto, debido a la mecánica de [[HomeObject]]. Un método, como longEar.eat, conoce su [[HomeObject]] y toma el método padre de su prototipo. Sin el uso de this.
Los métodos no son “libres”Como aprendimos antes, generalmente las funciones son “libres”, es decir que no están vinculadas a objetos en JavaScript. Esto es para que puedan copiarse entre objetos y llamarse con otro 'this`.
La existencia misma de [[HomeObject]] viola ese principio, porque los métodos recuerdan sus objetos. [[HomeObject]] no se puede cambiar, por lo que este vínculo es para siempre.
El único lugar en el lenguaje donde se usa [[HomeObject]] es en super. Si un método no usa super, entonces todavía podemos considerarlo “libre” y copiarlo entre objetos. Pero con super las cosas pueden salir mal.
Aquí está la demostración de un resultado incorrecto de super después de copiarlo:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  sayHi() {
    alert(`Soy un animal`);
  }
};

// rabbit hereda de animal
let rabbit = {
  __proto__: animal,
  sayHi() {
    super.sayHi();
  }
};

let plant = {
  sayHi() {
    alert("Soy una planta");
  }
};

// tree hereda de plant
let tree = {
  __proto__: plant,
  sayHi: rabbit.sayHi // (*)
};

tree.sayHi();  // Soy un animal (?!?)
        
      
      
      Una llamada a tree.sayHi() muestra “Soy un animal”. Definitivamente mal.
La razón es simple:

En la línea (*), el método tree.sayHi se copió de rabbit. ¿Quizás solo queríamos evitar la duplicación de código?
Su [[HomeObject]] es rabbit, ya que fue creado en rabbit. No hay forma de cambiar [[HomeObject]].
El código de tree.sayHi() tiene dentro a super.sayHi(). Sube desde ‘rabbit’ y toma el método de ‘animal’.

Aquí está el diagrama de lo que sucede:

      
      
        
      
      Métodos, no propiedades de función[[HomeObject]] se define para métodos tanto en clases como en objetos simples. Pero para los objetos, los métodos deben especificarse exactamente como method(), no como "method: function()".
La diferencia puede no ser esencial para nosotros, pero es importante para JavaScript.
En el siguiente ejemplo, se utiliza una sintaxis sin método para la comparación. La propiedad [[HomeObject]] no está establecida y la herencia no funciona:

      
        
        
          
            
          
          
            
          
        
        
          let animal = {
  eat: function() { // escrito así intencionalmente en lugar de eat() {...
    // ...
  }
};

let rabbit = {
  __proto__: animal,
  eat: function() {
    super.eat();
  }
};

rabbit.eat();  // Error al llamar a super (porque no hay [[HomeObject]])
        
      
      
      Resumen
Para extender una clase: class Hijo extends Padre:
     – Eso significa que Hijo.prototype.__proto__ será Padre.prototype, por lo que los métodos se heredan.
Al sobrescribir un constructor:
     – Debemos llamar al constructor del padre super() en el constructor de Hijo antes de usar this.
Al sobrescribir otro método:
     – Podemos usar super.method() en un método Hijo para llamar al método Padre.
Características internas:
     – Los métodos recuerdan su clase/objeto en la propiedad interna [[HomeObject]]. Así es como super resuelve los métodos padres.
     – Por lo tanto, no es seguro copiar un método con super de un objeto a otro.

También:

Las funciones de flecha no tienen su propio this o super, por lo que se ajustan de manera transparente al contexto circundante.

TareasError al crear una instanciaimportancia: 5Aquí está el código de la clase Rabbit que extiende a Animal.
Desafortunadamente, los objetos Rabbit no se pueden crear. ¿Que pasa? Arréglalo.

      
        
        
          
            
          
          
            
          
        
        
          class Animal {

  constructor(name) {
    this.name = name;
  }

}

class Rabbit extends Animal {
  constructor(name) {
    this.name = name;
    this.created = Date.now();
  }
}

let rabbit = new Rabbit("Conejo Blanco"); // Error: this no está definido
alert(rabbit.name);
        
      
      
      soluciónEso es porque el constructor hijo debe llamar a super().
Aquí el código corregido:

      
        
        
          
            
          
          
            
          
        
        
          class Animal {

  constructor(name) {
    this.name = name;
  }

}

class Rabbit extends Animal {
  constructor(name) {
    super(name);
    this.created = Date.now();
  }
}

let rabbit = new Rabbit("Conejo Blanco"); // ahora funciona
alert(rabbit.name); // Conejo Blanco
        
      
      
      Reloj extendidoimportancia: 5Tenemos una clase ‘Clock’. Por ahora, muestra la hora cada segundo.

      
        
        
          class Clock {
  constructor({ template }) {
    this.template = template;
  }

  render() {
    let date = new Date();

    let hours = date.getHours();
    if (hours < 10) hours = '0' + hours;

    let mins = date.getMinutes();
    if (mins < 10) mins = '0' + mins;

    let secs = date.getSeconds();
    if (secs < 10) secs = '0' + secs;

    let output = this.template
      .replace('h', hours)
      .replace('m', mins)
      .replace('s', secs);

    console.log(output);
  }

  stop() {
    clearInterval(this.timer);
  }

  start() {
    this.render();
    this.timer = setInterval(() => this.render(), 1000);
  }
}
        
      
      
      Crea una nueva clase ExtendedClock que herede de Clock y agrega el parámetro precision: este es el número de milisegundos entre “tics”. Debe ser 1000 (1 segundo) por defecto.

Tu código debe estar en el archivo extended-clock.js
No modifiques el clock.js original. Extiéndelo.

Abrir un entorno controlado para la tarea.solución
      
        
        
          class ExtendedClock extends Clock {
  constructor(options) {
    super(options);
    let { precision = 1000 } = options;
    this.precision = precision;
  }

  start() {
    this.render();
    this.timer = setInterval(() => this.render(), this.precision);
  }
};
        
      
      
      Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/class-inheritance" 
},
{
	"docs_id": "71",
	"name": "Propiedades y métodos estáticos.",
	"description": "También podemos asignar un método a la clase como un todo. Dichos métodos se llaman estáticos.",
	"content": "También podemos asignar un método a la clase como un todo. Dichos métodos se llaman estáticos.
En la declaración de una clase, se preceden por la palabra clave static:

      
        
        
          
            
          
          
            
          
        
        
          class User {
  static staticMethod() {
    alert(this === User);
  }
}

User.staticMethod(); // verdadero
        
      
      
      Eso realmente hace lo mismo que asignarlo como una propiedad directamente:

      
        
        
          
            
          
          
            
          
        
        
          class User { }

User.staticMethod = function() {
  alert(this === User);
};

User.staticMethod(); // verdadero
        
      
      
      El valor de this en la llamada User.staticMethod() es el mismo constructor de clase User (la regla “objeto antes de punto”).
Por lo general, los métodos estáticos se utilizan para implementar funciones que pertenecen a la clase como un todo, no a un objeto particular de la misma.
Por ejemplo, tenemos objetos Article y necesitamos una función para compararlos.
Una solución natural sería agregar el método Article.compare:

      
        
        
          
            
          
          
            
          
        
        
          class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static compare(articleA, articleB) {
    return articleA.date - articleB.date;
  }
}

// uso
let articles = [
  new Article("HTML", new Date(2019, 1, 1)),
  new Article("CSS", new Date(2019, 0, 1)),
  new Article("JavaScript", new Date(2019, 11, 1))
];

articles.sort(Article.compare);

alert( articles[0].title ); // CSS
        
      
      
      Aquí el método Article.compare se encuentra “encima” de los artículos, como un medio para compararlos. No es el método de un artículo sino de toda la clase.
Otro ejemplo sería un método llamado “factory”.
Digamos que necesitamos múltiples formas de crear un artículo:

Crearlo por parámetros dados (title,date etc.).
Crear un artículo vacío con la fecha de hoy.
… o cualquier otra manera.

La primera forma puede ser implementada por el constructor. Y para la segunda podemos hacer un método estático de la clase.
Tal como Article.createTodays() aquí:

      
        
        
          
            
          
          
            
          
        
        
          class Article {
  constructor(title, date) {
    this.title = title;
    this.date = date;
  }

  static createTodays() {
    // recuerda, this = Article
    return new this("Resumen de hoy", new Date());
  }
}

let article = Article.createTodays();

alert( article.title ); // Resumen de hoy
        
      
      
      Ahora, cada vez que necesitamos crear un resumen de hoy, podemos llamar a Article.createTodays(). Una vez más, ese no es el método de un objeto artículo, sino el método de toda la clase.
Los métodos estáticos también se utilizan en clases relacionadas con base de datos para buscar/guardar/eliminar entradas de la misma, como esta:

      
        
        
          // suponiendo que Article es una clase especial para gestionar artículos
// método estático para eliminar el artículo por id:
Article.remove({id: 12345});
        
      
      
      
            Los métodos estáticos no están disponibles para objetos individuales
            Los métodos estáticos son llamados sobre las clases, no sobre los objetos individuales.
Por ejemplo, este código no funcionará:

      
        
        
          // ...
article.createTodays(); /// Error: article.createTodays is not a function
        
      
      
      
Propiedades estáticas
            Una adición reciente
            
            Esta es una adición reciente al lenguaje.
            Los ejemplos funcionan en el Chrome reciente.
            
Las propiedades estáticas también son posibles, se ven como propiedades de clase regular, pero precedidas por static:

      
        
        
          
            
          
          
            
          
        
        
          class Article {
  static publisher = "Ilya Kantor";
}

alert( Article.publisher ); // Ilya Kantor
        
      
      
      Eso es lo mismo que una asignación directa a Article:

      
        
        
          Article.publisher = "Ilya Kantor";
        
      
      
      Herencia de propiedades y métodos estáticosLas propiedades y métodos estáticos son heredados.
Por ejemplo, Animal.compare y Animal.planet en el siguiente código son heredados y accesibles como Rabbit.compare y Rabbit.planet:

      
        
        
          
            
          
          
            
          
        
        
          class Animal {
  static planet = "Tierra";
  constructor(name, speed) {
    this.speed = speed;
    this.name = name;
  }

  run(speed = 0) {
    this.speed += speed;
    alert(`${this.name} corre a una velocidad de ${this.speed}.`);
  }

  static compare(animalA, animalB) {
    return animalA.speed - animalB.speed;
  }

}

// Hereda de Animal
class Rabbit extends Animal {
  hide() {
    alert(`${this.name} se esconde!`);
  }
}

let rabbits = [
  new Rabbit("Conejo Blanco", 10),
  new Rabbit("Conejo Negro", 5)
];

rabbits.sort(Rabbit.compare);

rabbits[0].run(); // Conejo Negro corre a una velocidad de 5.

alert(Rabbit.planet); // Tierra
        
      
      
      Ahora, cuando llamemos a Rabbit.compare, se llamará a Animal.compare heredado.
¿Como funciona? Nuevamente, usando prototipos. Como ya habrás adivinado, extends da a Rabbit el [[Prototype]] referente a Animal.

      
      
        
      
      Entonces, Rabbit extends Animal crea dos referencias [[Prototype]]:

La función de Rabbit se hereda prototípicamente de la función de Animal.
Rabbit.prototype prototípicamente hereda de Animal.prototype.

Como resultado, la herencia funciona tanto para métodos regulares como estáticos.
Verifiquemos eso por código, aquí:

      
        
        
          
            
          
          
            
          
        
        
          class Animal {}
class Rabbit extends Animal {}

// para la estática
alert(Rabbit.__proto__ === Animal); // verdadero

// para métodos regulares
alert(Rabbit.prototype.__proto__ === Animal.prototype); // verdadero
        
      
      
      ResumenLos métodos estáticos se utilizan en la funcionalidad propia de la clase “en su conjunto”. No se relaciona con una instancia de clase concreta.
Por ejemplo, un método para comparar Article.compare (article1, article2) o un método de fábrica Article.createTodays().
Están etiquetados por la palabra static en la declaración de clase.
Las propiedades estáticas se utilizan cuando queremos almacenar datos a nivel de clase, también no vinculados a una instancia.
La sintaxis es:

      
        
        
          class MyClass {
  static property = ...;

  static method() {
    ...
  }
}
        
      
      
      Técnicamente, la declaración estática es lo mismo que asignar a la clase misma:

      
        
        
          MyClass.property = ...
MyClass.method = ...
        
      
      
      Las propiedades y métodos estáticos se heredan.
Para class B extends A el prototipo de la clase B en sí mismo apunta a A: B.[[Prototipo]] = A. Entonces, si no se encuentra un campo en B, la búsqueda continúa en A.
Tareas¿La clase extiende el objeto?importancia: 3Como sabemos, todos los objetos normalmente heredan de Object.prototype y obtienen acceso a métodos de objeto “genéricos” como hasOwnProperty etc.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          class Rabbit {
  constructor(name) {
    this.name = name;
  }
}

let rabbit = new Rabbit("Rab");

// el método hasOwnProperty proviene de Object.prototype
alert( rabbit.hasOwnProperty('name') ); // verdadero
        
      
      
      Pero si lo escribimos explícitamente como "class Rabbit extends Object", entonces ¿el resultado sería diferente de una simple "class Rabbit"?
¿Cuál es la diferencia?
Aquí un ejemplo de dicho código (no funciona – ¿por qué? ¿Arréglalo?):

      
        
        
          class Rabbit extends Object {
  constructor(name) {
    this.name = name;
  }
}

let rabbit = new Rabbit("Rab");

alert( rabbit.hasOwnProperty('name') ); // Error
        
      
      
      soluciónPrimero, veamos por qué el código anterior no funciona.
La razón se vuelve evidente si intentamos ejecutarlo. Un constructor de clase heredado tiene que llamar a super(). De lo contrario "this" no será “definido”.
Así que aquí está la solución:

      
        
        
          
            
          
          
            
          
        
        
          class Rabbit extends Object {
  constructor(name) {
    super(); // necesita llamar al constructor padre cuando se hereda
    this.name = name;
  }
}

let rabbit = new Rabbit("Rab");

alert( rabbit.hasOwnProperty('name') ); // verdadero
        
      
      
      Pero eso no es todo.
Incluso después de arreglarlo, aún existe una diferencia importante entre "class Rabbit extends Object" y class Rabbit.
Como sabemos, la sintaxis “extends” configura dos prototipos:

Entre "prototype" de las funciones del constructor (para métodos).
Entre las propias funciones del constructor (para métodos estáticos).

En el caso de class Rabbit extends Object significa:

      
        
        
          
            
          
          
            
          
        
        
          class Rabbit extends Object {}

alert( Rabbit.prototype.__proto__ === Object.prototype ); // (1) verdadero
alert( Rabbit.__proto__ === Object ); // (2) verdadero
        
      
      
      Entonces Rabbit ahora proporciona acceso a los métodos estáticos de Object a través de Rabbit, así:

      
        
        
          
            
          
          
            
          
        
        
          class Rabbit extends Object {}

// normalmente llamamos a Object.getOwnPropertyNames
alert ( Rabbit.getOwnPropertyNames({a: 1, b: 2})); // a,b
        
      
      
      Pero si no tenemos extends Object, entonces Rabbit.__proto__ no está definido como Object.
Aquí está la demostración:

      
        
        
          
            
          
          
            
          
        
        
          class Rabbit {}

alert( Rabbit.prototype.__proto__ === Object.prototype ); // (1) verdadero
alert( Rabbit.__proto__ === Object ); // (2) falso (!)
alert( Rabbit.__proto__ === Function.prototype ); // como cualquier función por defecto

// error, no existe esta función en Rabbit
alert ( Rabbit.getOwnPropertyNames({a: 1, b: 2})); // Error
        
      
      
      Entonces Rabbit no proporciona acceso a métodos estáticos de Object en este caso.
Por cierto, Function.prototype también tiene métodos de función “genéricos”, como call, bind etc. Finalmente, están disponibles en ambos casos, por el Object que tiene el constructor incorporado Object.__proto__ === Function.prototype.
Aquí está la imagen:

      
      
        
      
      Por lo tanto, en pocas palabras, existen dos diferencias:



class Rabbit
class Rabbit extends Object




–
necesita llamar a super() en el constructor


Rabbit.__proto__ === Function.prototype
Rabbit.__proto__ === Object



",
	"url": "https://es.javascript.info/static-properties-methods" 
},
{
	"docs_id": "72",
	"name": "Propiedades y métodos privados y protegidos.",
	"description": "Uno de los principios más importantes de la programación orientada a objetos: delimitar la interfaz interna de la externa.",
	"content": "Uno de los principios más importantes de la programación orientada a objetos: delimitar la interfaz interna de la externa.
Esa es una práctica “imprescindible” en el desarrollo de algo más complejo que una aplicación “hola mundo”.
Para entender esto, alejémonos del desarrollo y volvamos nuestros ojos al mundo real…
Por lo general, los dispositivos que estamos usando son bastante complejos. Pero delimitar la interfaz interna de la externa permite usarlas sin problemas.
Un ejemplo de la vida realPor ejemplo, una máquina de café. Simple desde el exterior: un botón, una pantalla, algunos agujeros … Y, seguramente, el resultado: ¡excelente café! :)

      
      
      Pero adentro … (una imagen del manual de reparación)

      
      
      Muchos detalles. Pero podemos usarlo sin saber nada.
Las cafeteras son bastante confiables, ¿no es así? Podemos usarlos por años, y solo si algo sale mal, tráigalo para repararlo.
El secreto de la fiabilidad y la simplicidad de una máquina de café: todos los detalles están bien ajustados y ocultos en su interior.
Si retiramos la cubierta protectora de la cafetera, su uso será mucho más complejo (¿dónde presionar?) Y peligroso (puedes electrocutarte).
Como veremos, en la programación los objetos son como máquinas de café.
Pero para ocultar detalles internos, no utilizaremos una cubierta protectora, sino una sintaxis especial del lenguaje y las convenciones.
Interfaz interna y externaEn la programación orientada a objetos, las propiedades y los métodos se dividen en dos grupos:

Interfaz interna – métodos y propiedades, accesibles desde otros métodos de la clase, pero no desde el exterior.
Interfaz externa – métodos y propiedades, accesibles también desde fuera de la clase.

Si continuamos la analogía con la máquina de café, lo que está oculto en su interior: un tubo de caldera, un elemento calefactor, etc., es su interfaz interna.
Se utiliza una interfaz interna para que el objeto funcione, sus detalles se utilizan entre sí. Por ejemplo, un tubo de caldera está unido al elemento calefactor.
Pero desde afuera, una máquina de café está cerrada por la cubierta protectora, para que nadie pueda alcanzarlos. Los detalles están ocultos e inaccesibles. Podemos usar sus funciones a través de la interfaz externa.
Entonces, todo lo que necesitamos para usar un objeto es conocer su interfaz externa. Es posible que no seamos completamente conscientes de cómo funciona dentro, y eso es genial.
Esa fue una introducción general.
En JavaScript, hay dos tipos de campos de objeto (propiedades y métodos):

Público: accesible desde cualquier lugar. Comprenden la interfaz externa. Hasta ahora solo estábamos usando propiedades y métodos públicos.
Privado: accesible solo desde dentro de la clase. Estos son para la interfaz interna.

En muchos otros lenguajes también existen campos “protegidos”: accesibles solo desde dentro de la clase y aquellos que lo extienden (como privado, pero más acceso desde clases heredadas). También son útiles para la interfaz interna. En cierto sentido, están más extendidos que los privados, porque generalmente queremos que las clases heredadas tengan acceso a ellas.
Los campos protegidos no se implementan en JavaScript a nivel de lenguaje, pero en la práctica son muy convenientes, por lo que se emulan.
Ahora haremos una máquina de café en JavaScript con todos estos tipos de propiedades. Una máquina de café tiene muchos detalles, no los modelaremos todos, seremos simples (aunque podríamos).
Proteger “waterAmount”Hagamos primero una clase de cafetera simple:

      
        
        
          
            
          
          
            
          
        
        
          class CoffeeMachine {
  waterAmount = 0; // la cantidad de agua adentro

  constructor(power) {
    this.power = power;
    alert( `Se creó una máquina de café, poder: ${power}` );
  }

}

// se crea la máquina de café
let coffeeMachine = new CoffeeMachine(100);

// agregar agua
coffeeMachine.waterAmount = 200;
        
      
      
      En este momento las propiedades waterAmount ypower son públicas. Podemos obtenerlos/configurarlos fácilmente desde el exterior a cualquier valor.
Cambiemos la propiedad waterAmount a protegida para tener más control sobre ella. Por ejemplo, no queremos que nadie lo ponga por debajo de cero.
Las propiedades protegidas generalmente tienen el prefijo de subrayado _.
Eso no se aplica a nivel de lenguaje, pero existe una convención bien conocida entre los programadores de que no se debe acceder a tales propiedades y métodos desde el exterior.
Entonces nuestra propiedad se llamará _waterAmount:

      
        
        
          
            
          
          
            
          
        
        
          class CoffeeMachine {
  _waterAmount = 0;

  set waterAmount(value) {
    if (value < 0) {
      value = 0;
    }
    this._waterAmount = value;
  }

  get waterAmount() {
    return this._waterAmount;
  }

  constructor(power) {
    this._power = power;
  }

}

// se crea la máquina de café
let coffeeMachine = new CoffeeMachine(100);

// agregar agua
coffeeMachine.waterAmount = -10; // _waterAmount se vuelve 0, no -10
        
      
      
      Ahora el acceso está bajo control, por lo que establecer una cantidad de agua por debajo de cero se volvió imposible.
“Power” de solo lecturaPara la propiedad power, hagámoslo de solo lectura. A veces sucede que una propiedad debe establecerse solo en el momento de la creación y nunca modificarse.
Ese es exactamente el caso de una máquina de café: la potencia nunca cambia.
Para hacerlo, solo necesitamos hacer getter, pero no setter:

      
        
        
          
            
          
          
            
          
        
        
          class CoffeeMachine {
  // ...

  constructor(power) {
    this._power = power;
  }

  get power() {
    return this._power;
  }

}

// se crea la máquina de café
let coffeeMachine = new CoffeeMachine(100);

alert(`La potencia es: ${coffeeMachine.power}W`); // Potencia es: 100W

coffeeMachine.power = 25; // Error (sin setter)
        
      
      
      
            Funciones getter/setter
            Aquí usamos la sintaxis getter/setter.
Pero la mayoría de las veces las funciones get.../set... son preferidas, como esta:

      
        
        
          class CoffeeMachine {
  _waterAmount = 0;

  setWaterAmount(value) {
    if (value < 0) value = 0;
    this._waterAmount = value;
  }

  getWaterAmount() {
    return this._waterAmount;
  }
}

new CoffeeMachine().setWaterAmount(100);
        
      
      
      Eso parece un poco más largo, pero las funciones son más flexibles. Pueden aceptar múltiples argumentos (incluso si no los necesitamos en este momento).
Por otro lado, la sintaxis get/set es más corta, por lo que, en última instancia, no existe una regla estricta, depende de usted decidir.


            Los campos protegidos son heredados.
            Si heredamos class MegaMachine extends CoffeeMachine, entonces nada nos impide acceder a this._waterAmount o this._power desde los métodos de la nueva clase.
Por lo tanto, los campos protegidos son naturalmente heredables. A diferencia de los privados que veremos a continuación.

“#waterLimit” Privada
            Una adición reciente
            
            Esta es una adición reciente al lenguaje.
            No es compatible con motores de JavaScript, o es compatible parcialmente todavía, requiere polyfilling.
            
Hay una propuesta de JavaScript terminada, casi en el estándar, que proporciona soporte a nivel de lenguaje para propiedades y métodos privados.
Los privados deberían comenzar con #. Solo son accesibles desde dentro de la clase.
Por ejemplo, aquí hay una propiedad privada #waterLimit y el método privado de control de agua #fixWaterAmount:

      
        
        
          
            
          
          
            
          
        
        
          class CoffeeMachine {
  #waterLimit = 200;

  #fixWaterAmount(value) {
    if (value < 0) return 0;
    if (value > this.#waterLimit) return this.#waterLimit;
  }

  setWaterAmount(value) {
    this.#waterLimit = this.#fixWaterAmount(value);
  }

}

let coffeeMachine = new CoffeeMachine();

// no puede acceder a privados desde fuera de la clase
coffeeMachine.#fixWaterAmount(123); // Error
coffeeMachine.#waterLimit = 1000; // Error
        
      
      
      A nivel de lenguaje, # es una señal especial de que el campo es privado. No podemos acceder desde fuera o desde clases heredadas.
Los campos privados no entran en conflicto con los públicos. Podemos tener campos privados #waterAmount y públicos waterAmount al mismo tiempo.
Por ejemplo, hagamos que waterAmount sea un accesorio para #waterAmount:

      
        
        
          
            
          
          
            
          
        
        
          class CoffeeMachine {

  #waterAmount = 0;

  get waterAmount() {
    return this.#waterAmount;
  }

  set waterAmount(value) {
    if (value < 0) value = 0;
    this.#waterAmount = value;
  }
}

let machine = new CoffeeMachine();

machine.waterAmount = 100;
alert(machine.#waterAmount); // Error
        
      
      
      A diferencia de los protegidos, los campos privados son aplicados por el propio lenguaje. Eso es bueno.
Pero si heredamos de CoffeeMachine, entonces no tendremos acceso directo a #waterAmount. Tendremos que confiar en el getter/setter de waterAmount:

      
        
        
          class MegaCoffeeMachine extends CoffeeMachine {
  method() {
    alert( this.#waterAmount ); // Error: solo se puede acceder desde CoffeeMachine
  }
}
        
      
      
      En muchos escenarios, esta limitación es demasiado severa. Si ampliamos una CoffeeMachine, es posible que tengamos razones legítimas para acceder a sus componentes internos. Es por eso que los campos protegidos se usan con más frecuencia, aunque no sean compatibles con la sintaxis del lenguaje.

            Los campos privados no están disponibles como this[name]
            Los campos privados son especiales.
Como sabemos, generalmente podemos acceder a los campos usando this[name]:

      
        
        
          class User {
  ...
  sayHi() {
    let fieldName = "nombre";
    alert(`Hello, ${this[fieldName]}`);
  }
}
        
      
      
      Con campos privados eso es imposible: this['#name'] no funciona. Esa es una limitación de sintaxis para garantizar la privacidad.

ResumenEn términos de POO, la delimitación de la interfaz interna de la externa se llama encapsulamiento.
Ofrece los siguientes beneficios:

Protección para los usuarios, para que no se disparen en el pie

Imagínese, hay un equipo de desarrolladores que usan una máquina de café. Fue hecho por la compañía “Best CoffeeMachine” y funciona bien, pero se quitó una cubierta protectora. Entonces la interfaz interna está expuesta.
Todos los desarrolladores son civilizados: usan la máquina de café según lo previsto. Pero uno de ellos, John, decidió que él era el más inteligente e hizo algunos ajustes en el interior de la máquina de café. Entonces la máquina de café falló dos días después.
Seguramente no es culpa de John, sino de la persona que quitó la cubierta protectora y dejó que John hiciera sus manipulaciones.
Lo mismo en programación. Si un usuario de una clase cambiará cosas que no están destinadas a ser cambiadas desde el exterior, las consecuencias son impredecibles.

Soportable

La situación en la programación es más compleja que con una máquina de café de la vida real, porque no solo la compramos una vez. El código se somete constantemente a desarrollo y mejora.
Si delimitamos estrictamente la interfaz interna, el desarrollador de la clase puede cambiar libremente sus propiedades y métodos internos, incluso sin informar a los usuarios.
Si usted es un desarrollador de tal clase, es bueno saber que los métodos privados se pueden renombrar de forma segura, sus parámetros se pueden cambiar e incluso eliminar, porque ningún código externo depende de ellos.
Para los usuarios, cuando sale una nueva versión, puede ser una revisión total internamente, pero aún así es simple de actualizar si la interfaz externa es la misma.

Ocultando complejidad

La gente adora usar cosas que son simples. Al menos desde afuera. Lo que hay dentro es algo diferente.
Los programadores no son una excepción.
Siempre es conveniente cuando los detalles de implementación están ocultos, y hay disponible una interfaz externa simple y bien documentada.


Para ocultar una interfaz interna utilizamos propiedades protegidas o privadas:

Los campos protegidos comienzan con _. Esa es una convención bien conocida, no aplicada a nivel de lenguaje. Los programadores solo deben acceder a un campo que comience con _ de su clase y las clases que hereden de él.
Los campos privados comienzan con #. JavaScript se asegura de que solo podamos acceder a los que están dentro de la clase.

En este momento, los campos privados no son compatibles entre los navegadores, pero se puede usar “polyfill”.
",
	"url": "https://es.javascript.info/private-protected-properties-methods" 
},
{
	"docs_id": "73",
	"name": "Ampliación de clases integradas",
	"description": "Las clases integradas como Array, Map y otras también son extensibles.",
	"content": "Las clases integradas como Array, Map y otras también son extensibles.
Por ejemplo, aquí PowerArray hereda del nativo Array:

      
        
        
          
            
          
          
            
          
        
        
          // se agrega un método más (puedes hacer más)
class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // falso

let filteredArr = arr.filter(item => item >= 10);
alert(filteredArr); // 10, 50
alert(filteredArr.isEmpty()); // falso
        
      
      
      Tenga en cuenta una cosa muy interesante. Métodos incorporados como filter, map y otros: devuelven nuevos objetos exactamente del tipo heredado PowerArray. Su implementación interna utiliza la propiedad constructor del objeto para eso.
En el ejemplo anterior,

      
        
        
          arr.constructor === PowerArray
        
      
      
      Cuando se llama a arr.filter(), crea internamente la nueva matriz de resultados usando exactamente arr.constructor, no el básico Array. En realidad, eso es muy bueno, porque podemos seguir usando métodos PowerArray más adelante en el resultado.
Aún más, podemos personalizar ese comportamiento.
Podemos agregar un getter estático especial Symbol.species a la clase. Si existe, debería devolver el constructor que JavaScript usará internamente para crear nuevas entidades en map, filter y así sucesivamente.
Si queremos que los métodos incorporados como map o filter devuelvan matrices regulares, podemos devolver Array en Symbol.species, como aquí:

      
        
        
          
            
          
          
            
          
        
        
          class PowerArray extends Array {
  isEmpty() {
    return this.length === 0;
  }

  // los métodos incorporados usarán esto como el constructor
  static get [Symbol.species]() {
    return Array;
  }
}

let arr = new PowerArray(1, 2, 5, 10, 50);
alert(arr.isEmpty()); // falso

// filter crea una nueva matriz usando arr.constructor[Symbol.species] como constructor
let filteredArr = arr.filter(item => item >= 10);

// filterArr no es PowerArray, sino Array
alert(filteredArr.isEmpty()); // Error: filteredArr.isEmpty no es una función
        
      
      
      Como puede ver, ahora .filter devuelve Array. Por lo tanto, la funcionalidad extendida ya no se pasa.

            Other collections trabaja similarmente
            Otras colecciones, como Map y Set, funcionan igual. También usan Symbol.species.

Sin herencia estática en incorporadosLos objetos incorporados tienen sus propios métodos estáticos, por ejemplo, Object.keys, Array.isArray, etc.
Como ya sabemos, las clases nativas se extienden entre sí. Por ejemplo, Array extiende Object.
Normalmente, cuando una clase extiende a otra, se heredan los métodos estáticos y no estáticos. Eso se explicó a fondo en el artículo Propiedades y métodos estáticos..
Pero las clases integradas son una excepción. No heredan estáticos el uno del otro.
Por ejemplo, tanto Array como Date heredan de Object, por lo que sus instancias tienen métodos de Object.prototype. Pero Array.[[Prototype]] no hace referencia a Object, por lo que no existe, por ejemplo, el método estático Array.keys() (o Date.keys()).
Aquí está la imagen, estructura para Date y Object:

      
      
        
      
      Como puede ver, no hay un vínculo entre Date y Object. Son independientes, solo Date.prototype hereda de Object.prototype.
Esa es una diferencia importante de herencia entre los objetos integrados en comparación con lo que obtenemos con 'extends`.
",
	"url": "https://es.javascript.info/extend-natives" 
},
{
	"docs_id": "74",
	"name": "Comprobación de clase: "instanceof"",
	"description": "El operador instanceof permite verificar si un objeto pertenece a una clase determinada. También tiene en cuenta la herencia.",
	"content": "El operador instanceof permite verificar si un objeto pertenece a una clase determinada. También tiene en cuenta la herencia.
Tal verificación puede ser necesaria en muchos casos. Aquí lo usaremos para construir una función polimórfica, la que trata los argumentos de manera diferente dependiendo de su tipo.
El operador instanceofLa sintaxis es:

      
        
        
          obj instanceof Class
        
      
      
      Devuelve true si obj pertenece a la Class o una clase que hereda de ella.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          class Rabbit {}
let rabbit = new Rabbit();

// ¿Es un objeto de la clase Rabbit?
alert( rabbit instanceof Rabbit ); // verdadero
        
      
      
      También funciona con funciones de constructor:

      
        
        
          
            
          
          
            
          
        
        
          // en lugar de clase
function Rabbit() {}

alert( new Rabbit() instanceof Rabbit ); // verdadero
        
      
      
      …Y con clases integradas como Array:

      
        
        
          
            
          
          
            
          
        
        
          let arr = [1, 2, 3];
alert( arr instanceof Array ); // verdadero
alert( arr instanceof Object ); // verdadero
        
      
      
      Tenga en cuenta que arr también pertenece a la clase Object. Esto se debe a que Array hereda prototípicamente de Object.
Normalmente, instanceof examina la cadena de prototipos para la verificación. También podemos establecer una lógica personalizada en el método estático Symbol.hasInstance.
El algoritmo de obj instanceof Class funciona más o menos de la siguiente manera:


Si hay un método estático Symbol.hasInstance, simplemente llámelo: Class[Symbol.hasInstance](obj). Debería devolver true o false, y hemos terminado. Así es como podemos personalizar el comportamiento de instanceof.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // Instalar instancia de verificación que asume que
// cualquier cosa con propiedad canEat es un animal

class Animal {
  static [Symbol.hasInstance](obj) {
    if (obj.canEat) return true;
  }
}

let obj = { canEat: true };

alert(obj instanceof Animal); // verdadero: Animal[Symbol.hasInstance](obj) es llamada
        
      
      
      

La mayoría de las clases no tienen Symbol.hasInstance. En ese caso, se utiliza la lógica estándar: obj instanceOf Class comprueba si Class.prototype es igual a uno de los prototipos en la cadena de prototipos obj.
En otras palabras, compara uno tras otro:

      
        
        
          obj.__proto__ === Class.prototype?
obj.__proto__.__proto__ === Class.prototype?
obj.__proto__.__proto__.__proto__ === Class.prototype?
...
// si alguna respuesta es verdadera, devuelve true
// de lo contrario, si llegamos al final de la cadena, devuelve false
        
      
      
      En el ejemplo anterior rabbit.__ proto__ === Rabbit.prototype, por lo que da la respuesta de inmediato.
En el caso de una herencia, la coincidencia será en el segundo paso:

      
        
        
          
            
          
          
            
          
        
        
          class Animal {}
class Rabbit extends Animal {}

let rabbit = new Rabbit();
alert(rabbit instanceof Animal); // verdadero

// rabbit.__proto__ === Animal.prototype (no match)
// rabbit.__proto__.__proto__ === Animal.prototype (iguala!)
        
      
      
      

Aquí está la ilustración de lo que rabbit instanceof Animal compara con Animal.prototype:

      
      
        
      
      Por cierto, también hay un método objA.isPrototypeOf(objB), que devuelve true si objA está en algún lugar de la cadena de prototipos para objB. Por lo tanto, la prueba de obj instanceof Class se puede reformular como Class.prototype.isPrototypeOf(obj).
Es divertido, ¡pero el constructor Class en sí mismo no participa en el chequeo! Solo importa la cadena de prototipos y Class.prototype.
Eso puede llevar a consecuencias interesantes cuando se cambia una propiedad prototype después de crear el objeto.
Como aquí:

      
        
        
          
            
          
          
            
          
        
        
          function Rabbit() {}
let rabbit = new Rabbit();

// cambió el prototipo
Rabbit.prototype = {};

// ...ya no es un conejo!
alert( rabbit instanceof Rabbit ); // falso
        
      
      
      Bonificación: Object.prototype.toString para el tipoYa sabemos que los objetos simples se convierten en cadenas como [objetc Objetc]:

      
        
        
          
            
          
          
            
          
        
        
          let obj = {};

alert(obj); // [object Object]
alert(obj.toString()); // lo mismo
        
      
      
      Esa es su implementación de toString. Pero hay una característica oculta que hace que toString sea mucho más poderoso que eso. Podemos usarlo como un typeof extendido y una alternativa para instanceof.
¿Suena extraño? En efecto. Vamos a desmitificar.
Por esta especificación, el toString incorporado puede extraerse del objeto y ejecutarse en el contexto de cualquier otro valor. Y su resultado depende de ese valor.

Para un número, será [object Number]
Para un booleano, será [objetc Boolean]
Para null: [objetc Null]
Para undefined: [objetc Undefined]
Para matrices: [Object Array]
… etc (personalizable).

Demostremos:

      
        
        
          
            
          
          
            
          
        
        
          // copie el método toString en una variable a conveniencia
let objectToString = Object.prototype.toString;

// ¿que tipo es este?
let arr = [];

alert( objectToString.call(arr) ); // [object Array]
        
      
      
      Aquí usamos call como se describe en el capítulo Decoradores y redirecciones, call/apply para ejecutar la función objectToString en el contexto this=arr.
Internamente, el algoritmo toString examina this y devuelve el resultado correspondiente. Más ejemplos:

      
        
        
          
            
          
          
            
          
        
        
          let s = Object.prototype.toString;

alert( s.call(123) ); // [object Number]
alert( s.call(null) ); // [object Null]
alert( s.call(alert) ); // [object Function]
        
      
      
      Symbol.toStringTagEl comportamiento del objeto toString se puede personalizar utilizando una propiedad de objeto especial Symbol.toStringTag.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  [Symbol.toStringTag]: "User"
};

alert( {}.toString.call(user) ); // [object User]
        
      
      
      Para la mayoría de los objetos específicos del entorno, existe dicha propiedad. Aquí hay algunos ejemplos específicos del navegador:

      
        
        
          
            
          
          
            
          
        
        
          // toStringTag para el objeto y clase específicos del entorno:
alert( window[Symbol.toStringTag]); // ventana
alert( XMLHttpRequest.prototype[Symbol.toStringTag] ); // XMLHttpRequest

alert( {}.toString.call(window) ); // [object Window]
alert( {}.toString.call(new XMLHttpRequest()) ); // [object XMLHttpRequest]
        
      
      
      Como puedes ver, el resultado es exactamente Symbol.toStringTag (si existe), envuelto en [object ...].
Al final tenemos “typeof con esteroides” que no solo funciona para tipos de datos primitivos, sino también para objetos incorporados e incluso puede personalizarse.
Podemos usar {}.toString.call en lugar de instanceof para los objetos incorporados cuando deseamos obtener el tipo como una cadena en lugar de solo verificar.
ResumenResumamos los métodos de verificación de tipos que conocemos:




trabaja para
retorna




typeof
primitivos
cadena


{}.toString
primitivos, objetos incorporados, objetos con Symbol.toStringTag
cadena


instanceof
objetos
true/false



Como podemos ver, {}.toString es técnicamente un typeof “más avanzado”.
Y el operador instanceof realmente brilla cuando estamos trabajando con una jerarquía de clases y queremos verificar si la clase tiene en cuenta la herencia.
TareasExtraño instanceofimportancia: 5En el siguiente código, ¿por qué instanceof devuelve true? Podemos ver fácilmente que a no es creado por B().

      
        
        
          
            
          
          
            
          
        
        
          function A() {}
function B() {}

A.prototype = B.prototype = {};

let a = new A();

alert( a instanceof B ); // verdadero
        
      
      
      soluciónSí, se ve extraño de hecho.
Pero a instanceof no le importa la función, sino más bien su prototype, que coincide con la cadena del prototipo.
Y aquí a.__ proto__ == B.prototype, entonces instanceof devuelve true.
Entonces, según la lógica de instanceof, el prototype en realidad define el tipo, no la función constructora.
",
	"url": "https://es.javascript.info/instanceof" 
},
{
	"docs_id": "75",
	"name": "Los Mixins",
	"description": "En JavaScript podemos heredar de un solo objeto. Solo puede haber un [[Prototype]] para un objeto. Y una clase puede extender únicamente otra clase.",
	"content": "En JavaScript podemos heredar de un solo objeto. Solo puede haber un [[Prototype]] para un objeto. Y una clase puede extender únicamente otra clase.
Pero a veces eso se siente restrictivo. Por ejemplo, tenemos una clase StreetSweeper y una clase Bicycle, y queremos hacer su combinación: un StreetSweepingBicycle.
O tenemos una clase User y una clase EventEmitter que implementa la generación de eventos, y nos gustaría agregar la funcionalidad de EventEmitter a User, para que nuestros usuarios puedan emitir eventos.
Hay un concepto que puede ayudar aquí, llamado “mixins”.
Como se define en Wikipedia, un mixin es una clase que contiene métodos que pueden ser utilizados por otras clases sin necesidad de heredar de ella.
En otras palabras, un mixin proporciona métodos que implementan cierto comportamiento, pero su uso no es exclusivo, lo usamos para agregar el comportamiento a otras clases.
Un ejemplo de mixinLa forma más sencilla de implementar un mixin en JavaScript es hacer un objeto con métodos útiles, para que podamos combinarlos fácilmente en un prototipo de cualquier clase.
Por ejemplo, aquí el mixin sayHiMixin se usa para agregar algo de “diálogo” a User:

      
        
        
          
            
          
          
            
          
        
        
          // mixin
let sayHiMixin = {
  sayHi() {
    alert(`Hola ${this.name}`);
  },
  sayBye() {
    alert(`Adiós ${this.name}`);
  }
};

// uso:
class User {
  constructor(name) {
    this.name = name;
  }
}

// copia los métodos
Object.assign(User.prototype, sayHiMixin);

// Ahora el User puede decir hola
new User("tío").sayHi(); // Hola tío!
        
      
      
      No hay herencia, sino un simple método de copia. Entonces, User puede heredar de otra clase y también incluir el mixin para “mezclar” los métodos adicionales, como este:

      
        
        
          class User extends Person {
  // ...
}

Object.assign(User.prototype, sayHiMixin);
        
      
      
      Los mixins pueden hacer uso de la herencia dentro de sí mismos.
Por ejemplo, aquí sayHiMixin hereda de sayMixin:

      
        
        
          
            
          
          
            
          
        
        
          let sayMixin = {
  say(phrase) {
    alert(phrase);
  }
};

let sayHiMixin = {
  __proto__: sayMixin, // (o podríamos usar Object.setPrototypeOf para configurar el prototype aquí)

  sayHi() {
    // llama al método padre
    super.say(`Hola ${this.name}`); // (*)
  },
  sayBye() {
    super.say(`Adios ${this.name}`); // (*)
  }
};

class User {
  constructor(name) {
    this.name = name;
  }
}

// copia los métodos
Object.assign(User.prototype, sayHiMixin);

// User ahora puede decir hola
new User("tío").sayHi(); // Hola tío!
        
      
      
      Ten en cuenta que la llamada al método padre super.say() de sayHiMixin (en las líneas etiquetadas con (*)) busca el método en el prototipo de ese mixin, no en la clase.
Aquí está el diagrama (ver la parte derecha):

      
      
        
      
      Esto se debe a que los métodos sayHi y sayBye se crearon inicialmente en sayHiMixin. Entonces, a pesar de que se copiaron, su propiedad interna [[[HomeObject]] hace referencia a sayHiMixin, como se muestra en la imagen de arriba.
Como super busca métodos primarios en [[HomeObject]].[[Prototype]],  significa que busca sayHiMixin.[[Prototype]], no User.[[Prototype]].
EventMixinAhora hagamos un mixin para la vida real.
Una característica importante de muchos objetos del navegador (por ejemplo) es que pueden generar eventos. Los eventos son una excelente manera de “transmitir información” a cualquiera que lo desee. Así que hagamos un mixin que nos permita agregar fácilmente funciones relacionadas con eventos a cualquier clase/objeto.

El mixin proporcionará un método .trigger(name, [...data]) para “generar un evento” cuando le ocurra algo importante. El argumento name es un nombre del evento, opcionalmente seguido de argumentos adicionales con datos del evento.
También el método .on(name, handler) que agrega la función handler como listener a eventos con el nombre dado. Se llamará cuando se desencadene un evento con el nombre name dado, y obtenga los argumentos de la llamada .trigger.
…Y el método .off(name, handler) que elimina el listener handler.

Después de agregar el mixin, un objeto user podrá generar un evento "login" cuando el visitante inicie sesión. Y otro objeto, por ejemplo, calendar puede querer escuchar dichos eventos para cargar el calendario para el persona registrada.
O bien, un menu puede generar el evento "seleccionar" cuando se selecciona un elemento del menú, y otros objetos pueden asignar controladores para reaccionar ante ese evento. Y así.
Aquí está el código:

      
        
        
          
            
          
          
            
          
        
        
          let eventMixin = {
  /**
   * Suscribe al evento, uso:
   *  menu.on('select', function(item) { ... }
  */
  on(eventName, handler) {
    if (!this._eventHandlers) this._eventHandlers = {};
    if (!this._eventHandlers[eventName]) {
      this._eventHandlers[eventName] = [];
    }
    this._eventHandlers[eventName].push(handler);
  },

  /**
   * Cancelar la suscripción, uso:
   *  menu.off('select', handler)
   */
  off(eventName, handler) {
    let handlers = this._eventHandlers?.[eventName];
    if (!handlers) return;
    for (let i = 0; i < handlers.length; i++) {
      if (handlers[i] === handler) {
        handlers.splice(i--, 1);
      }
    }
  },

  /**
   * Generar un evento con el nombre y los datos
   *  this.trigger('select', data1, data2);
   */
  trigger(eventName, ...args) {
   if (!this._eventHandlers?.[eventName]) {
      return; // no hay controladores para ese nombre de evento
    }

    // Llama al controlador
    this._eventHandlers[eventName].forEach(handler => handler.apply(this, args));
  }
};
        
      
      
      
.on(eventName, handler): asigna la función handler para que se ejecute cuando se produce el evento con ese nombre. Técnicamente, hay una propiedad _eventHandlers que almacena una matriz de controladores para cada nombre de evento, y simplemente la agrega a la lista.
.off(eventName, handler) – elimina la función de la lista de controladores.
.trigger(eventName, ...args) – genera el evento: se llama a todos los controladores de _eventHandlers[eventName], con una lista de argumentos ...args.

Uso:

      
        
        
          
            
          
          
            
          
        
        
          // Construir una clase
class Menu {
  choose(value) {
    this.trigger("select", value);
  }
}
// Agrega el mixin con métodos relacionados con eventos
Object.assign(Menu.prototype, eventMixin);

let menu = new Menu();

// agrega un controlador, que se llamará en la selección:
menu.on("select", value => alert(`Valor seleccionado: ${value}`));

// desencadena el evento => el controlador anterior se ejecuta y muestra:
// Valor seleccionado: 123
menu.choose("123");
        
      
      
      Ahora, si queremos que el código reaccione a una selección de menú, podemos escucharlo con menu.on(...).
Y el mixin de eventMixin  hace que sea fácil agregar ese comportamiento a tantas clases como queramos, sin interferir con la cadena de herencia.
ResumenMixin – es un término genérico de programación orientado a objetos: una clase que contiene métodos para otras clases.
Algunos lenguajes permiten la herencia múltiple. JavaScript no admite la herencia múltiple, pero los mixins se pueden implementar copiando métodos en el prototipo.
Podemos usar mixins como una forma de expandir una clase agregando múltiples comportamientos, como el manejo de eventos que hemos visto anteriormente.
Los mixins pueden convertirse en un punto de conflicto si sobrescriben accidentalmente los métodos de clase existentes. Por lo tanto, generalmente debes planificar correctamente la definición de métodos de un mixin, para minimizar la probabilidad de que suceda.
",
	"url": "https://es.javascript.info/mixins" 
},
{
	"docs_id": "76",
	"name": "Manejo de errores, "try...catch"",
	"description": "No importa lo buenos que seamos en la programación, a veces nuestros scripts tienen errores. Pueden ocurrir debido a nuestros descuidos, una entrada inesperada del usuario, una respuesta errónea del servidor y por otras razones más.",
	"content": "No importa lo buenos que seamos en la programación, a veces nuestros scripts tienen errores. Pueden ocurrir debido a nuestros descuidos, una entrada inesperada del usuario, una respuesta errónea del servidor y por otras razones más.
Por lo general, un script “muere” (se detiene inmediatamente) en caso de error, imprimiéndolo en la consola.
Pero hay una construcción sintáctica try...catch que nos permite “atrapar” errores para que el script pueda, en lugar de morir, hacer algo más razonable.
La sintaxis “try…catch”La construcción try...catch tiene dos bloques principales: try, y luego catch:

      
        
        
          try {

  // código...

} catch (err) {

  // manipulación de error

}
        
      
      
      Funciona así:

Primero, se ejecuta el código en try {...}.
Si no hubo errores, se ignora catch (err): la ejecución llega al final de try y continúa, omitiendo catch.
Si se produce un error, la ejecución de try se detiene y el control fluye al comienzo de catch (err). La variable err (podemos usar cualquier nombre para ella) contendrá un objeto de error con detalles sobre lo que sucedió.


      
      
        
      
      Entonces, un error dentro del bloque try {...} no mata el script; tenemos la oportunidad de manejarlo en catch.
Veamos algunos ejemplos.


Un ejemplo sin errores: muestra alert (1) y (2):

      
        
        
          
            
          
          
            
          
        
        
          try {

  alert('Inicio de intentos de prueba');  // (1) <--

  // ...no hay errores aquí

  alert('Fin de las ejecuciones de try');   // (2) <--

} catch (err) {

  alert('Se ignora catch porque no hay errores'); // (3)

}
        
      
      
      

Un ejemplo con un error: muestra (1) y (3):

      
        
        
          
            
          
          
            
          
        
        
          try {

  alert('Inicio de ejecuciones try');  // (1) <--

  lalala; // error, variable no está definida!

  alert('Fin de try (nunca alcanzado)');  // (2)

} catch (err) {

  alert(`¡Un error ha ocurrido!`); // (3) <--

}
        
      
      
      


            try...catch solo funciona para errores de tiempo de ejecución
            Para que try..catch funcione, el código debe ser ejecutable. En otras palabras, debería ser JavaScript válido.
No funcionará si el código es sintácticamente incorrecto, por ejemplo, si hay llaves sin cerrar:

      
        
        
          
            
          
          
            
          
        
        
          try {
  {{{{{{{{{{{{
} catch(err) {
  alert("El motor no puede entender este código, no es válido.");
}
        
      
      
      El motor de JavaScript primero lee el código y luego lo ejecuta. Los errores que ocurren en la fase de lectura se denominan errores de “tiempo de análisis” y son irrecuperables (desde dentro de ese código). Eso es porque el motor no puede entender el código.
Entonces, try...catch solo puede manejar errores que ocurren en un código válido. Dichos errores se denominan “errores de tiempo de ejecución” o, a veces, “excepciones”.


            try...catch trabaja sincrónicamente
            Si ocurre una excepción en el código “programado”, como en setTimeout, entonces try..catch no lo detectará:

      
        
        
          
            
          
          
            
          
        
        
          try {
  setTimeout(function() {
    noSuchVariable; // el script morirá aquí
  }, 1000);
} catch (err) {
  alert( "no funcionará" );
}
        
      
      
      Esto se debe a que la función en sí misma se ejecuta más tarde, cuando el motor ya ha abandonado la construcción try...catch.
Para detectar una excepción dentro de una función programada, try...catch debe estar dentro de esa función:

      
        
        
          
            
          
          
            
          
        
        
          setTimeout(function() {
  try {
    noSuchVariable; // try...catch maneja el error!
  } catch {
    alert( "El error se detecta aquí!" );
  }
}, 1000);
        
      
      
      
Objeto ErrorCuando se produce un error, JavaScript genera un objeto que contiene los detalles al respecto. El objeto se pasa como argumento para catch:

      
        
        
          try {
  // ...
} catch(err) { // <-- el "objeto error", podría usar otra palabra en lugar de err
  // ...
}
        
      
      
      Para todos los errores integrados, el objeto error tiene dos propiedades principales:

name
Nombre de error. Por ejemplo, para una variable indefinida que es "ReferenceError".
message
Mensaje de texto sobre detalles del error.

Hay otras propiedades no estándar disponibles en la mayoría de los entornos. Uno de los más utilizados y compatibles es:

stack
Pila de llamadas actual: una cadena con información sobre la secuencia de llamadas anidadas que condujeron al error. Utilizado para fines de depuración.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          try {
  lalala; // error, la variable no está definida!
} catch (err) {
  alert(err.name); // ReferenceError
  alert(err.message); // lalala no está definida!
  alert(err.stack); // ReferenceError: lalala no está definida en (...call stack)

  // También puede mostrar un error como un todo
  // El error se convierte en cadena como "nombre: mensaje"
alert(err); // ReferenceError: lalala no está definido
}
        
      
      
      Omitiendo el “catch” asociado
            Una adición reciente
            
            Esta es una adición reciente al lenguaje.
            Los navegadores antiguos pueden necesitar polyfills.
            
Si no necesitamos detalles del error, catch puede omitirlo:

      
        
        
          try {
  // ...
} catch { // <-- sin (err)
  // ...
}
        
      
      
      Usando “try…catch”Exploremos un caso de uso de la vida real de try...catch.
Como ya sabemos, JavaScript admite el método JSON.parse(str) para leer valores codificados con JSON.
Por lo general, se utiliza para decodificar datos recibidos a través de la red, desde el servidor u otra fuente.
Lo recibimos y llamamos a JSON.parse así:

      
        
        
          
            
          
          
            
          
        
        
          let json = '{"name":"John", "age": 30}'; // datos del servidor

let user = JSON.parse(json); // convierte la representación de texto a objeto JS

// ahora user es un objeto con propiedades de la cadena
alert( user.name ); // John
alert( user.age );  // 30
        
      
      
      Puede encontrar información más detallada sobre JSON en el capítulo Métodos JSON, toJSON.
Si json está mal formado, JSON.parse genera un error, por lo que el script “muere”.
¿Deberíamos estar satisfechos con eso? ¡Por supuesto no!
De esta manera, si algo anda mal con los datos, el visitante nunca lo sabrá (a menos que abra la consola del desarrollador). Y a la gente realmente no le gusta cuando algo “simplemente muere” sin ningún mensaje de error.
Usemos try...catch para manejar el error:

      
        
        
          
            
          
          
            
          
        
        
          let json = "{ json malo }";

try {

  let user = JSON.parse(json); // <-- cuando ocurre un error ...
  alert( user.name ); // no funciona

} catch (err) {
  // ...la ejecución salta aquí
  alert( "Nuestras disculpas, los datos tienen errores, intentaremos solicitarlos una vez más." );
  alert( err.name );
  alert( err.message );
}
        
      
      
      Aquí usamos el bloque catch solo para mostrar el mensaje, pero podemos hacer mucho más: enviar una nueva solicitud de red, sugerir una alternativa al visitante, enviar información sobre el error a una instalación de registro, …. Todo mucho mejor que solo morir.
Lanzando nuestros propios errores¿Qué sucede si json es sintácticamente correcto, pero no tiene una propiedad requerida de name?
Como este:

      
        
        
          
            
          
          
            
          
        
        
          let json = '{ "age": 30 }'; // dato incompleto

try {

  let user = JSON.parse(json); // <-- sin errores
  alert( user.name ); // sin nombre!

} catch (err) {
  alert( "no se ejecuta" );
}
        
      
      
      Aquí JSON.parse se ejecuta normalmente, pero la ausencia de name es en realidad un error nuestro.
Para unificar el manejo de errores, usaremos el operador throw.
El operador “throw”El operador throw genera un error.
La sintaxis es:

      
        
        
          throw <error object>
        
      
      
      Técnicamente, podemos usar cualquier cosa como un objeto error. Eso puede ser incluso un primitivo, como un número o una cadena, pero es mejor usar objetos, preferiblemente con propiedades name y message (para mantenerse algo compatible con los errores incorporados).
JavaScript tiene muchos constructores integrados para manejar errores estándar: Error, SyntaxError, ReferenceError, TypeError y otros. Podemos usarlos para crear objetos de error también.
Su sintaxis es:

      
        
        
          let error = new Error(message);
// or
let error = new SyntaxError(message);
let error = new ReferenceError(message);
// ...
        
      
      
      Para errores incorporados (no para cualquier objeto, solo para errores), la propiedad name es exactamente el nombre del constructor. Y mensaje se toma del argumento.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let error = new Error("Estas cosas pasan... o_O");

alert(error.name); // Error
alert(error.message); // Estas cosas pasan... o_O
        
      
      
      Veamos qué tipo de error genera JSON.parse:

      
        
        
          
            
          
          
            
          
        
        
          try {
  JSON.parse("{ json malo o_O }");
} catch (err) {
  alert(err.name); // SyntaxError
  alert(err.message); // Token b inesperado en JSON en la posición 2
}
        
      
      
      Como podemos ver, ese es un SyntaxError.
Y en nuestro caso, la ausencia de name es un error, ya que los usuarios deben tener un name.
Así que vamos a lanzarlo:

      
        
        
          
            
          
          
            
          
        
        
          let json = '{ "age": 30 }'; // dato incompleto

try {

  let user = JSON.parse(json); // <-- sin errores

  if (!user.name) {
    throw new SyntaxError("dato incompleto: sin nombre"); // (*)
  }

  alert( user.name );

} catch (err) {
  alert( "Error en JSON: " + e.message ); // Error en JSON: dato incompleto: sin nombre
}
        
      
      
      En la línea (*), el operador throw genera un SyntaxError con el message dado, de la misma manera que JavaScript lo generaría él mismo. La ejecución de try se detiene inmediatamente y el flujo de control salta a catch.
Ahora catch se convirtió en un lugar único para todo el manejo de errores: tanto para JSON.parse como para otros casos.
Relanzando (rethrowing)En el ejemplo anterior usamos try...catch para manejar datos incorrectos. Pero, ¿es posible que ocurra otro error inesperado dentro del bloque try{...}? Como un error de programación (la variable no está definida) o algo más, no solo “datos incorrectos”.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let json = '{ "age": 30 }'; // dato incompleto

try {
  user = JSON.parse(json); // <-- olvidé poner "let" antes del usuario

  // ...
} catch (err) {
  alert("Error en JSON: " + err); // Error en JSON: ReferenceError: user no está definido
  // (no es error JSON)
}
        
      
      
      ¡Por supuesto, todo es posible! Los programadores cometen errores. Incluso en las utilidades de código abierto utilizadas por millones durante décadas, de repente se puede descubrir un error que conduce a hacks terribles.
En nuestro caso, try...catch está destinado a detectar errores de “datos incorrectos”. Pero por su naturaleza, catch obtiene todos los errores de try. Aquí recibe un error inesperado, pero aún muestra el mismo mensaje de “Error en JSON”. Eso está mal y también hace que el código sea más difícil de depurar.
Para evitar tales problemas, podemos emplear la técnica de “rethrowing”. La regla es simple:
Catch solo debe procesar los errores que conoce y “volver a lanzar” (rethrow) a todos los demás.
La técnica de “rethrowing” puede explicarse con más detalle:

Catch captura todos los errores.
En el bloque catch (err) {...} analizamos el objeto error err.
Si no sabemos cómo manejarlo, hacemos 'throw err`.

Por lo general, podemos verificar el tipo de error usando el operador instanceof:

      
        
        
          
            
          
          
            
          
        
        
          try {
  user = { /*...*/ };
} catch (err) {
  if (err instanceof ReferenceError) {
    alert('ReferenceError'); // "ReferenceError" para acceder a una variable indefinida
  }
}
        
      
      
      También podemos obtener el nombre de la clase error con la propiedad err.name. Todos los errores nativos lo tienen. Otra opción es leer err.constructor.name.
En el siguiente código, usamos el rethrowing para que catch solo maneje SyntaxError:

      
        
        
          
            
          
          
            
          
        
        
          let json = '{ "age": 30 }'; // dato incompleto
try {

  let user = JSON.parse(json);

  if (!user.name) {
    throw new SyntaxError("dato incompleto: sin nombre");
  }

  blabla(); // error inesperado

  alert( user.name );

} catch (err) {

  if (err instanceof SyntaxError) {
    alert( "Error en JSON: " + err.message );
  } else {
    throw err; // rethrow (*)
  }

}
        
      
      
      El error lanzado en la línea (*) desde el interior del bloque catch cae desde try...catch y puede ser atrapado por una construcción externa try...catch (si existe), o mata al script.
Por lo tanto, el bloque catch en realidad maneja solo los errores con los que sabe cómo lidiar y “omite” todos los demás.
El siguiente ejemplo demuestra cómo dichos errores pueden ser detectados por un nivel más de try...catch:

      
        
        
          
            
          
          
            
          
        
        
          function readData() {
  let json = '{ "age": 30 }';

  try {
    // ...
    blabla(); // error!
  } catch (err) {
    // ...
    if (!(err instanceof SyntaxError)) {
      throw err; // rethrow (no sé cómo lidiar con eso)
    }
  }
}

try {
  readData();
} catch (err) {
  alert( "La captura externa tiene: " + err ); // capturado!
}
        
      
      
      Aquí readData solo sabe cómo manejar SyntaxError, mientras que el try...catch externo sabe cómo manejar todo.
try…catch…finallyEspera, eso no es todo.
La construcción try...catch puede tener una cláusula de código más: finally.
Si existe, se ejecuta en todos los casos:

después de try, si no hubo errores,
después de catch, si hubo errores.

La sintaxis extendida se ve así:

      
        
        
          try {
   ... intenta ejecutar el código ...
} catch (err) {
   ... manejar errores ...
} finally {
   ... ejecutar siempre ...
}
        
      
      
      Intenta ejecutar este código:

      
        
        
          
            
          
          
            
          
        
        
          try {
  alert( 'intenta (try)' );
  if (confirm('¿Cometer un error?')) BAD_CODE();
} catch (err) {
  alert( 'atrapa (catch)' );
} finally {
  alert( 'finalmente (finally)' );
}
        
      
      
      El código tiene dos formas de ejecución:

Si responde “Sí” a “¿Cometer un error?”, Entonces try -> catch -> finally.
Si dice “No”, entonces try -> finally.

La cláusula finally a menudo se usa cuando comenzamos a hacer algo y queremos finalizarlo en cualquier resultado.
Por ejemplo, queremos medir el tiempo que tarda una función de números de Fibonacci fib(n). Naturalmente, podemos comenzar a medir antes de que se ejecute y terminar después. ¿Pero qué pasa si hay un error durante la llamada a la función? En particular, la implementación de fib(n) en el código siguiente devuelve un error para números negativos o no enteros.
La cláusula finally es un excelente lugar para terminar las mediciones, pase lo que pase.
Aquí finally garantiza que el tiempo se medirá correctamente en ambas situaciones, en caso de una ejecución exitosa de fib y en caso de error:

      
        
        
          
            
          
          
            
          
        
        
          let num = +prompt("Ingrese un número entero positivo?", 35)

let diff, result;

function fib(n) {
  if (n < 0 || Math.trunc(n) != n) {
    throw new Error("Debe ser un número positivo y entero.");
  }
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}

let start = Date.now();

try {
  result = fib(num);
} catch (err) {
  result = 0;
} finally {
  diff = Date.now() - start;
}

alert(result || "error ocurrido");

alert( `la ejecución tomó ${diff}ms` );
        
      
      
      Puede verificar ejecutando el código e ingresando 35 en prompt; se ejecuta normalmente, finally después de try. Y luego ingrese -1 – habrá un error inmediato, y la ejecución tomará 0ms. Ambas mediciones se realizan correctamente.
En otras palabras, la función puede terminar con return o throw, eso no importa. La cláusula finally se ejecuta en ambos casos.

            Las variables son locales dentro de try...catch...finally
            Tenga en cuenta que las variables result y diff en el código anterior se declaran antes de try..catch.
De lo contrario, si declaramos let en el bloque try, solo sería visible dentro de él.


            finally y return
            La cláusula finally funciona para cualquier salida de try...catch. Eso incluye un return explícito.
En el ejemplo a continuación, hay un return en try. En este caso, finally se ejecuta justo antes de que el control regrese al código externo.

      
        
        
          
            
          
          
            
          
        
        
          function func() {

  try {
    return 1;

  } catch (err) {
    /* ... */
  } finally {
    alert( 'finally' );
  }
}

alert( func() ); // primero funciona la alerta de "finally", y luego este
        
      
      
      

            try...finally
            La construcción try...finally, sin la cláusula catch, también es útil. Lo aplicamos cuando no queremos manejar los errores (se permite que se pierdan), pero queremos asegurarnos de que los procesos que comenzamos estén finalizados.

      
        
        
          function func() {
  // comenzar a hacer algo que necesita ser completado (como mediciones)
  try {
    // ...
  } finally {
    // completar esto si todo muere
  }
}
        
      
      
      En el código anterior, siempre se produce un error dentro de try, porque no hay catch. Pero finally funciona antes de que el flujo de ejecución abandone la función.

Captura global
            Específico del entorno
            La información de esta sección no es parte del núcleo de JavaScript.

Imaginemos que tenemos un error fatal fuera de try...catch, y el script murió. Como un error de programación o alguna otra cosa terrible.
¿Hay alguna manera de reaccionar ante tales ocurrencias? Es posible que queramos registrar el error, mostrarle algo al usuario (normalmente no ve mensajes de error), etc.
No hay ninguna en la especificación, pero los entornos generalmente lo proporcionan, porque es realmente útil. Por ejemplo, Node.js tiene process.on("uncaughtException") para eso. Y en el navegador podemos asignar una función a la propiedad especial window.onerror, que se ejecutará en caso de un error no detectado.
La sintaxis:

      
        
        
          window.onerror = function(message, url, line, col, error) {
  // ...
};
        
      
      
      
message
Mensaje de error.
url
URL del script donde ocurrió el error.
line, col
Números de línea y columna donde ocurrió el error.
error
El objeto error.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <script>
  window.onerror = function(message, url, line, col, error) {
    alert(`${message}\n At ${line}:${col} of ${url}`);
  };

  function readData() {
    badFunc(); // ¡Vaya, algo salió mal!
  }

  readData();
</script>
        
      
      
      El rol del controlador global window.onerror generalmente no es recuperar la ejecución del script, probablemente sea imposible en caso de errores de programación, pero sí enviar el mensaje de error a los desarrolladores.
También hay servicios web que proporcionan registro de errores para tales casos, como https://errorception.com o http://www.muscula.com.
Estos servicios funcionan así:

Nos registramos en el servicio y obtenemos un fragmento de JS (o la URL de un script) para insertar en las páginas.
Ese script JS establece una función personalizada window.onerror.
Cuando se produce un error, se envía una solicitud de red al servicio.
Podemos iniciar sesión en la interfaz web del servicio y ver los errores registrados.

ResumenLa construcción try...catch permite manejar errores de tiempo de ejecución. Literalmente permite “intentar (try)” ejecutar el código y “atrapar (catch)” errores que pueden ocurrir en él.
La sintaxis es:

      
        
        
          try {
  // ejecuta este código
} catch (err) {
  // si ocurrió un error, entonces salta aquí
  // err es el objeto error
} finally {
  // hacer en cualquier caso después de try/catch
}
        
      
      
      Puede que no haya una sección catch o finally, por lo que las construcciones más cortas try...catch y try...finally también son válidas.
Los objetos Error tienen las siguientes propiedades:

message – el mensaje de error legible por humanos.
name – la cadena con el nombre del error (nombre del constructor de error).
stack (No estándar, pero bien soportado) – la pila en el momento de la creación del error.

Si no se necesita un objeto error, podemos omitirlo usando catch { en lugar de catch (err) {.
También podemos generar nuestros propios errores utilizando el operador throw. Técnicamente, el argumento de throw puede ser cualquier cosa, pero generalmente es un objeto error heredado de la clase incorporada Error. Más sobre la extensión de errores en el próximo capítulo.
Relanzado (rethrowing) es un patrón muy importante de manejo de errores: un bloque catch generalmente espera y sabe cómo manejar el tipo de error en particular, por lo que debería relanzar errores que no conoce.
Incluso si no tenemos try...catch, la mayoría de los entornos nos permiten configurar un controlador de errores “global” para detectar los errores que caigan. En el navegador, eso es window.onerror.
TareasFinally o solo el código?importancia: 5Compara los dos fragmentos de código.


El primero usa finally para ejecutar el código después de try..catch:

      
        
        
          try {
  trabajo trabajo
} catch (err) {
  maneja errores
} finally {
  limpiar el espacio de trabajo
}
        
      
      
      

El segundo fragmento coloca la limpieza justo después de try..catch:

      
        
        
          try {
  trabajo trabajo
} catch (err) {
  manejo de errores
}

limpiar el espacio de trabajo
        
      
      
      

Definitivamente necesitamos la limpieza después del trabajo, no importa si hubo un error o no.
¿Hay alguna ventaja aquí en usar finally o ambos fragmentos de código son iguales? Si existe tal ventaja, entonces da un ejemplo cuando sea importante.
soluciónLa diferencia se hace evidente cuando miramos el código dentro de una función.
El comportamiento es diferente si hay un “salto fuera” de try..catch.
Por ejemplo, cuando hay un return en el interior de try..catch. La cláusula finally funciona en el caso de cualquier salida de  try..catch, incluso a través de la declaración return: justo después de que try..catch haya terminado, pero antes de que el código de llamada obtenga el control.

      
        
        
          
            
          
          
            
          
        
        
          function f() {
  try {
    alert('inicio');
    return "resultado";
  } catch (err) {
    /// ...
  } finally {
    alert('limpieza!');
  }
}

f(); // limpieza!
        
      
      
      … O cuando hay un throw (lanzamiento de excepción), como aquí:

      
        
        
          
            
          
          
            
          
        
        
          function f() {
  try {
    alert('inicio');
    throw new Error("un error");
  } catch (err) {
    // ...
    if("no puede manejar el error") {
      throw err;
    }

  } finally {
    alert('limpieza!')
  }
}

f(); // limpieza!
        
      
      
      Es “finally” el que garantiza la limpieza aquí. Si acabamos de poner el código al final de f, no se ejecutará en estas situaciones.
",
	"url": "https://es.javascript.info/try-catch" 
},
{
	"docs_id": "77",
	"name": "Errores personalizados, extendiendo Error",
	"description": "Cuando desarrollamos algo, a menudo necesitamos nuestras propias clases de error para reflejar cosas específicas que pueden salir mal en nuestras tareas. Para errores en las operaciones de red, podemos necesitar HttpError, para las operaciones de la base de datos DbError, para las operaciones de búsqueda NotFoundError, etc.",
	"content": "Cuando desarrollamos algo, a menudo necesitamos nuestras propias clases de error para reflejar cosas específicas que pueden salir mal en nuestras tareas. Para errores en las operaciones de red, podemos necesitar HttpError, para las operaciones de la base de datos DbError, para las operaciones de búsqueda NotFoundError, etc.
Nuestros errores deben admitir propiedades de error básicas como message, name y, preferiblemente, stack. Pero también pueden tener otras propiedades propias, por ejemplo, los objetos HttpError pueden tener una propiedad statusCode con un valor como 404 o 403 o 500.
JavaScript permite usar throw con cualquier argumento, por lo que técnicamente nuestras clases de error personalizadas no necesitan heredarse de Error. Pero si heredamos, entonces es posible usar obj instanceof Error para identificar objetos error. Entonces es mejor heredar de él.
A medida que la aplicación crece, nuestros propios errores forman naturalmente una jerarquía. Por ejemplo, HttpTimeoutError puede heredar de HttpError, y así sucesivamente.
Extendiendo ErrorComo ejemplo, consideremos una función readUser(json) que debería leer JSON con los datos del usuario.
Aquí hay un ejemplo de cómo puede verse un json válido:

      
        
        
          let json = `{ "name": "John", "age": 30 }`;
        
      
      
      Internamente, usaremos JSON.parse. Si recibe json mal formado, entonces arroja SyntaxError. Pero incluso si json es sintácticamente correcto, eso no significa que sea un usuario válido, ¿verdad? Puede perder los datos necesarios. Por ejemplo, puede no tener propiedades de nombre y edad que son esenciales para nuestros usuarios.
Nuestra función readUser(json) no solo leerá JSON, sino que verificará (“validará”) los datos. Si no hay campos obligatorios, o el formato es incorrecto, entonces es un error. Y eso no es un “SyntaxError”, porque los datos son sintácticamente correctos, sino otro tipo de error. Lo llamaremos ValidationError y crearemos una clase para ello. Un error de ese tipo también debe llevar la información sobre el campo infractor.
Nuestra clase ValidationError debería heredar de la clase incorporada Error.
Esa clase está incorporada, pero aquí está su código aproximado para que podamos entender lo que estamos extendiendo:

      
        
        
          // El "pseudocódigo" para la clase Error incorporada definida por el propio JavaScript
class Error {
  constructor(message) {
    this.message = message;
    this.name = "Error"; // (diferentes nombres para diferentes clases error incorporadas)
    this.stack = <call stack>; // no estándar, pero la mayoría de los entornos lo admiten
  }
}
        
      
      
      Ahora heredemos ValidationError y probémoslo en acción:

      
        
        
          
            
          
          
            
          
        
        
          class ValidationError extends Error {
  constructor(message) {
    super(message); // (1)
    this.name = "ValidationError"; // (2)
  }
}

function test() {
  throw new ValidationError("Vaya!");
}

try {
  test();
} catch(err) {
  alert(err.message); // Vaya!
  alert(err.name); // ValidationError
  alert(err.stack); // una lista de llamadas anidadas con números de línea para cada una
}
        
      
      
      Tenga en cuenta: en la línea (1) llamamos al constructor padre. JavaScript requiere que llamemos super en el constructor hijo, por lo que es obligatorio. El constructor padre establece la propiedad message.
El constructor principal también establece la propiedad name en "Error", por lo que en la línea (2) la restablecemos al valor correcto.
Intentemos usarlo en readUser(json):

      
        
        
          
            
          
          
            
          
        
        
          class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

// Uso
function readUser(json) {
  let user = JSON.parse(json);

  if (!user.age) {
    throw new ValidationError("Sin campo: age");
  }
  if (!user.name) {
    throw new ValidationError("Sin campo: name");
  }

  return user;
}

// Ejemplo de trabajo con try..catch

try {
  let user = readUser('{ "age": 25 }');
} catch (err) {
  if (err instanceof ValidationError) {
    alert("Dato inválido: " + err.message); // Dato inválido: sin campo: nombre
  } else if (err instanceof SyntaxError) { // (*)
    alert("Error de sintaxis JSON: " + err.message);
  } else {
    throw err; // error desconocido, vuelva a lanzarlo (**)
  }
}
        
      
      
      El bloque try..catch en el código anterior maneja tanto nuestro ValidationError como el SyntaxError incorporado de JSON.parse.
Observe cómo usamos instanceof para verificar el tipo de error específico en la línea (*).
También podríamos mirar err.name, así:

      
        
        
          // ...
// en lugar de (err instanceof SyntaxError)
} else if (err.name == "SyntaxError") { // (*)
// ...
        
      
      
      La versión instanceof es mucho mejor, porque en el futuro vamos a extender ValidationError, haremos subtipos de ella, como PropertyRequiredError. Y el control instanceof continuará funcionando para las nuevas clases heredadas. Entonces eso es a prueba de futuro.
También es importante que si catch encuentra un error desconocido, entonces lo vuelva a lanzar en la línea (**). El bloque catch solo sabe cómo manejar los errores de validación y sintaxis, otros tipos de error (como los tipográficos en el código u otros desconocidos) deben “pasar a través” y ser relanzados.
Herencia adicionalLa clase ValidationError es demasiado genérica. Son muchas las cosas que pueden salir mal. La propiedad podría estar ausente, o puede estar en un formato incorrecto (como un valor de cadena para age en lugar de un número). Hagamos una clase más concreta PropertyRequiredError específicamente para propiedades ausentes. Esta clase llevará información adicional sobre la propiedad que falta.

      
        
        
          
            
          
          
            
          
        
        
          class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = "ValidationError";
  }
}

class PropertyRequiredError extends ValidationError {
  constructor(property) {
    super("Sin propiedad: " + property);
    this.name = "PropertyRequiredError";
    this.property = property;
  }
}

// Uso
function readUser(json) {
  let user = JSON.parse(json);

  if (!user.age) {
    throw new PropertyRequiredError("age");
  }
  if (!user.name) {
    throw new PropertyRequiredError("name");
  }

  return user;
}

// Ejemplo de trabajo con try..catch

try {
  let user = readUser('{ "age": 25 }');
} catch (err) {
  if (err instanceof ValidationError) {
    alert("Dato inválido: " + err.message); // Dato inválido: Sin propiedad: name
    alert(err.name); // PropertyRequiredError
    alert(err.property); // name
  } else if (err instanceof SyntaxError) {
    alert("Error de sintaxis JSON: " + err.message);
  } else {
    throw err; // error desconocido, vuelva a lanzarlo
  }
}
        
      
      
      La nueva clase PropertyRequiredError es fácil de usar: solo necesitamos pasar el nombre de la propiedad: new PropertyRequiredError(property). El message legible para humanos es generado por el constructor.
Tenga en cuenta que this.name en el constructor PropertyRequiredError se asigna de nuevo manualmente. Eso puede volverse un poco tedioso: asignar this.name = <class name> en cada clase de error personalizada. Podemos evitarlo haciendo nuestra propia clase “error básico” que asigna this.name = this.constructor.name. Y luego herede todos nuestros errores personalizados.
Llamémosla MyError.
Aquí está el código con MyError y otras clases error personalizadas, simplificadas:

      
        
        
          
            
          
          
            
          
        
        
          class MyError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
}

class ValidationError extends MyError { }

class PropertyRequiredError extends ValidationError {
  constructor(property) {
    super("sin propiedad: " + property);
    this.property = property;
  }
}

// name es incorrecto
alert( new PropertyRequiredError("campo").name ); // PropertyRequiredError
        
      
      
      Ahora los errores personalizados son mucho más cortos, especialmente ValidationError, ya que eliminamos la línea "this.name = ..." en el constructor.
Empacado de ExcepcionesEl propósito de la función readUser en el código anterior es “leer los datos del usuario”. Puede haber diferentes tipos de errores en el proceso. En este momento tenemos SyntaxError y ValidationError, pero en el futuro la función readUser puede crecer y probablemente generar otros tipos de errores.
El código que llama a readUser debe manejar estos errores. En este momento utiliza múltiples if en el bloque catch, que verifican la clase y manejan los errores conocidos y vuelven a arrojar los desconocidos.
El esquema es así:

      
        
        
          try {
  ...
  readUser()  // la fuente potencial de error
  ...
} catch (err) {
  if (err instanceof ValidationError) {
    // manejar errores de validación
  } else if (err instanceof SyntaxError) {
    // manejar errores de sintaxis
  } else {
    throw err; // error desconocido, vuelva a lanzarlo
  }
}
        
      
      
      En el código anterior podemos ver dos tipos de errores, pero puede haber más.
Si la función readUser genera varios tipos de errores, entonces debemos preguntarnos: ¿realmente queremos verificar todos los tipos de error uno por uno cada vez?
A menudo, la respuesta es “No”: nos gustaría estar “un nivel por encima de todo eso”. Solo queremos saber si hubo un “error de lectura de datos”: el por qué ocurrió exactamente es a menudo irrelevante (el mensaje de error lo describe). O, mejor aún, nos gustaría tener una forma de obtener los detalles del error, pero solo si es necesario.
La técnica que describimos aquí se llama “empacado de excepciones”.

Crearemos una nueva clase ReadError para representar un error genérico de “lectura de datos”.
La función readUser detectará los errores de lectura de datos que ocurren dentro de ella, como ValidationError y SyntaxError, y generará un ReadError en su lugar.
El objeto ReadError mantendrá la referencia al error original en su propiedad cause.

Entonces, el código que llama a readUser solo tendrá que verificar ReadError, no todos los tipos de errores de lectura de datos. Y si necesita más detalles de un error, puede verificar su propiedad cause.
Aquí está el código que define ReadError y demuestra su uso en readUser y try..catch:

      
        
        
          
            
          
          
            
          
        
        
          class ReadError extends Error {
  constructor(message, cause) {
    super(message);
    this.cause = cause;
    this.name = 'ReadError';
  }
}

class ValidationError extends Error { /*...*/ }
class PropertyRequiredError extends ValidationError { /* ... */ }

function validateUser(user) {
  if (!user.age) {
    throw new PropertyRequiredError("age");
  }

  if (!user.name) {
    throw new PropertyRequiredError("name");
  }
}

function readUser(json) {
  let user;

  try {
    user = JSON.parse(json);
  } catch (err) {
    if (err instanceof SyntaxError) {
      throw new ReadError("Error de sintaxis", err);
    } else {
      throw err;
    }
  }

  try {
    validateUser(user);
  } catch (err) {
    if (err instanceof ValidationError) {
      throw new ReadError("Error de validación", err);
    } else {
      throw err;
    }
  }

}

try {
  readUser('{json malo}');
} catch (e) {
  if (e instanceof ReadError) {
    alert(e);
    // Error original: SyntaxError: inesperado token b en JSON en la posición 1
    alert("Error original: " + e.cause);
  } else {
    throw e;
  }
}
        
      
      
      En el código anterior, readUser funciona exactamente como se describe: detecta los errores de sintaxis y validación y arroja los errores ReadError en su lugar (los errores desconocidos se vuelven a generar como de costumbre).
Entonces, el código externo verifica instanceof ReadError y eso es todo. No es necesario enumerar todos los tipos de error posibles.
El enfoque se llama “empacado de excepciones”, porque tomamos excepciones de “bajo nivel” y las “ajustamos” en ReadError que es más abstracto. Es ampliamente utilizado en la programación orientada a objetos.
Resumen
Podemos heredar de Error y otras clases de error incorporadas normalmente. Solo necesitamos cuidar la propiedad name y no olvidemos llamar super.
Podemos usar instanceof para verificar errores particulares. También funciona con herencia. Pero a veces tenemos un objeto error que proviene de una biblioteca de terceros y no hay una manera fácil de obtener su clase. Entonces la propiedad name puede usarse para tales controles.
Empacado de excepciones es una técnica generalizada: una función maneja excepciones de bajo nivel y crea errores de alto nivel en lugar de varios errores de bajo nivel. Las excepciones de bajo nivel a veces se convierten en propiedades de ese objeto como err.cause en los ejemplos anteriores, pero eso no es estrictamente necesario.

TareasHeredar de SyntaxErrorimportancia: 5Cree una clase FormatError que herede de la clase incorporada SyntaxError.
Debería admitir las propiedades message, name y stack.
Ejemplo de uso:

      
        
        
          let err = new FormatError("error de formato");

alert( err.message ); // error de formato
alert( err.name ); // FormatError
alert( err.stack ); // pila

alert( err instanceof FormatError ); // true
alert( err instanceof SyntaxError ); // true (porque hereda de SyntaxError)
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          class FormatError extends SyntaxError {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
}

let err = new FormatError("error de formato");

alert( err.message ); // error de formato
alert( err.name ); // FormatError
alert( err.stack ); // pila

alert( err instanceof SyntaxError ); // true
        
      
      
      ",
	"url": "https://es.javascript.info/custom-errors" 
},
{
	"docs_id": "78",
	"name": "Introducción: callbacks",
	"description": "Para demostrar el uso de callbacks, promesas y otros conceptos abstractos, utilizaremos algunos métodos de navegador: específicamente, carga de scripts y simples manipulaciones de documentos.",
	"content": "
            Usamos métodos de navegador en estos ejemplos
            Para demostrar el uso de callbacks, promesas y otros conceptos abstractos, utilizaremos algunos métodos de navegador: específicamente, carga de scripts y simples manipulaciones de documentos.
Si no estás familiarizado con estos métodos, y los ejemplos son confusos, puedes leer algunos capítulos de esta sección del tutorial.
Sin embargo, intentaremos aclarar las cosas de todos modos. No habrá nada en cuanto al navegador realmente complejo.

Muchas funciones son proporcionadas por el entorno de host de Javascript que permiten programar acciones asíncronas. En otras palabras, acciones que iniciamos ahora, pero que terminan más tarde.
Por ejemplo, una de esas funciones es la función setTimeout.
Hay otros ejemplos del mundo real de acciones asincrónicas, p. ej.: la carga de scripts y módulos (a cubrirse en capítulos posteriores).
Echa un vistazo a la función loadScript(src), que carga un código script src dado:

      
        
        
          function loadScript(src) {
  // crea una etiqueta <script> y la agrega a la página
  // esto hace que el script dado: src comience a cargarse y ejecutarse cuando se complete
  let script = document.createElement('script');
  script.src = src;
  document.head.append(script);
}
        
      
      
      Esto inserta en el documento una etiqueta nueva, creada dinámicamente, <script src =" ... "> con el código src dado. El navegador comienza a cargarlo automáticamente y lo ejecuta cuando la carga se completa.
Esta función la podemos usar así:

      
        
        
          // cargar y ejecutar el script en la ruta dada
loadScript('/my/script.js');
        
      
      
      El script se ejecuta “asincrónicamente”, ya que comienza a cargarse ahora, pero se ejecuta más tarde, cuando la función ya ha finalizado.
El código debajo de loadScript (...), no espera que finalice la carga del script.

      
        
        
          loadScript('/my/script.js');
// el código debajo de loadScript
// no espera a que finalice la carga del script
// ...
        
      
      
      Digamos que necesitamos usar el nuevo script tan pronto como se cargue. Declara nuevas funciones, y queremos ejecutarlas.
Si hacemos eso inmediatamente después de llamar a loadScript (...), no funcionará:

      
        
        
          loadScript('/my/script.js'); // el script tiene a "function newFunction() {…}"

newFunction(); // no hay dicha función!
        
      
      
      Naturalmente, el navegador probablemente no tuvo tiempo de cargar el script. Hasta el momento, la función loadScript no proporciona una forma de rastrear la finalización de la carga. El script se carga y finalmente se ejecuta, eso es todo. Pero nos gustaría saber cuándo sucede, para usar las funciones y variables nuevas de dicho script.
Agreguemos una función callback como segundo argumento para loadScript que debería ejecutarse cuando se carga el script:

      
        
        
          function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(script);

  document.head.append(script);
}
        
      
      
      El evento onload, que se describe en el artículo Carga de recursos: onload y onerror, básicamente ejecuta una función después de que el script es cargado y ejecutado.
Ahora, si queremos llamar las nuevas funciones desde el script, deberíamos escribirlo en la callback:

      
        
        
          loadScript('/my/script.js', function() {
  // la callback se ejecuta luego que se carga el script
  newFunction(); // ahora funciona
  ...
});
        
      
      
      Esa es la idea: el segundo argumento es una función (generalmente anónima) que se ejecuta cuando se completa la acción.
Aquí un ejemplo ejecutable con un script real:

      
        
        
          
            
          
          
            
          
        
        
          function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);
  document.head.append(script);
}

loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {
  alert(`Genial, el script ${script.src} está cargado`);
  alert( _ ); // _ es una función declarada en el script cargado
});
        
      
      
      Eso se llama programación asincrónica “basado en callback”. Una función que hace algo de forma asincrónica debería aceptar un argumento de callback donde ponemos la función por ejecutar después de que se complete.
Aquí lo hicimos en loadScript, pero por supuesto es un enfoque general.
Callback en una callback¿Cómo podemos cargar dos scripts secuencialmente: el primero y después el segundo al cargarse el primero?
La solución natural sería poner la segunda llamada loadScript dentro de la callback, así:

      
        
        
          loadScript('/my/script.js', function(script) {

  alert(`Genial, el ${script.src} está cargado, carguemos uno más`);

  loadScript('/my/script2.js', function(script) {
    alert(`Genial, el segundo script está cargado`);
  });

});
        
      
      
      Una vez que se completa el loadScript externo, la callback inicia el interno.
¿Qué pasa si queremos un script más …?

      
        
        
          loadScript('/my/script.js', function(script) {

  loadScript('/my/script2.js', function(script) {

    loadScript('/my/script3.js', function(script) {
      // ...continua después que se han cargado todos los scripts
    });

  });

});
        
      
      
      Entonces, cada nueva acción está dentro de una callback. Eso está bien para algunas acciones, pero no es bueno para todas, así que pronto veremos otras variantes.
Manejo de erroresEn los ejemplos anteriores no consideramos los errores. ¿Qué pasa si falla la carga del script? Nuestra callback debería poder reaccionar ante eso.
Aquí una versión mejorada de loadScript que rastrea los errores de carga:

      
        
        
          function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Error de carga de script con ${src}`));

  document.head.append(script);
}
        
      
      
      Para una carga exitosa llama a callback(null, script) y de lo contrario a callback(error).
El uso:

      
        
        
          loadScript('/my/script.js', function(error, script) {
  if (error) {
    // maneja el error
  } else {
    // script cargado satisfactoriamente
  }
});
        
      
      
      Una vez más, la receta que usamos para loadScript es bastante común. Se llama el estilo de “callback error primero”.
La convención es:

El primer argumento de la ‘callback’ está reservado para un error, si ocurre. Entonces se llama a callback(err).
El segundo argumento (y los siguientes si es necesario) son para el resultado exitoso. Entonces se llama a callback(null, result1, result2 ...).

Así usamos una única función de ‘callback’ tanto para informar errores como para transferir resultados.
Pirámide infernalA primera vista, es una forma viable de codificación asincrónica. Y de hecho lo es. Para una o quizás dos llamadas anidadas, se ve bien.
Pero para múltiples acciones asincrónicas que van una tras otra, tendremos un código como este:

      
        
        
          loadScript('1.js', function(error, script) {

  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', function(error, script) {
      if (error) {
        handleError(error);
      } else {
        // ...
        loadScript('3.js', function(error, script) {
          if (error) {
            handleError(error);
          } else {
            // ...continua después de que se han cargado todos los script (*)
          }
        });

      }
    });
  }
});
        
      
      
      En el código de arriba:

Cargamos 1.js, entonces si no hay error…
Cargamos 2.js, entonces si no hay error…
Cargamos 3.js, entonces, si no hay ningún error: haga otra cosa (*).

A medida que las llamadas se anidan más, el código se vuelve más profundo y difícil de administrar, especialmente si tenemos un código real en lugar de ‘…’ que puede incluir más bucles, declaraciones condicionales, etc.
A esto se le llama “infierno de callbacks” o “pirámide infernal” (“callback hell”, “pyramid of doom”).


      
      
        
      
      La “pirámide” de llamadas anidadas crece hacia la derecha con cada acción asincrónica. Pronto se sale de control.
Entonces esta forma de codificación no es tan buena.
Podemos tratar de aliviar el problema haciendo, para cada acción, una función independiente:

      
        
        
          loadScript('1.js', step1);

function step1(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', step2);
  }
}

function step2(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('3.js', step3);
  }
}

function step3(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...continua después de que se han cargado todos los scripts (*)
  }
}
        
      
      
      ¿Lo Ves? Hace lo mismo, y ahora no hay anidamiento profundo porque convertimos cada acción en una función de nivel superior separada.
Funciona, pero el código parece una hoja de cálculo desgarrada. Es difícil de leer, y habrás notado que hay que saltar de un lado a otro mientras lees. Es un inconveniente, especialmente si el lector no está familiarizado con el código y no sabe dónde dirigir la mirada.
Además, las funciones llamadas step* son de un solo uso, son para evitar la “Pirámide de callbacks”. Nadie los reutilizará fuera de la cadena de acción. Así que hay muchos nombres abarrotados aquí.
Nos gustaría tener algo mejor.
Afortunadamente, hay otras formas de evitar tales pirámides. Una de las mejores formas es usando “promesas”, descritas en el próximo capítulo.
",
	"url": "https://es.javascript.info/callbacks" 
},
{
	"docs_id": "79",
	"name": "Promesa",
	"description": "Imagina que eres un gran cantante y los fanáticos te preguntan día y noche por tu próxima canción.",
	"content": "Imagina que eres un gran cantante y los fanáticos te preguntan día y noche por tu próxima canción.
Para obtener algo de alivio, prometes enviárselos cuando se publique. Le das a tus fans una lista. Ellos pueden registrar allí sus direcciones de correo electrónico, de modo que cuando la canción esté disponible, todas las partes suscritas la reciban instantáneamente. E incluso si algo sale muy mal, digamos, un incendio en el estudio tal que no puedas publicar la canción, aún se les notificará.
Todos están felices: tú, porque la gente ya no te abruma, y los fanáticos, porque no se perderán la canción.
Esta es una analogía de la vida real para las cosas que a menudo tenemos en la programación:

Un “código productor” que hace algo y toma tiempo. Por ejemplo, algún código que carga los datos a través de una red. Eso es un “cantante”.
Un “código consumidor” que quiere el resultado del “código productor” una vez que está listo. Muchas funciones pueden necesitar ese resultado. Estos son los “fans”.
Una promesa es un objeto JavaScript especial que une el “código productor” y el “código consumidor”. En términos de nuestra analogía: esta es la “lista de suscripción”. El “código productor” toma el tiempo que sea necesario para producir el resultado prometido, y la “promesa” hace que ese resultado esté disponible para todo el código suscrito cuando esté listo.

La analogía no es terriblemente precisa, porque las promesas de JavaScript son más complejas que una simple lista de suscripción: tienen características y limitaciones adicionales. Pero está bien para empezar.
La sintaxis del constructor para un objeto promesa es:

      
        
        
          let promise = new Promise(function(resolve, reject) {
  // Ejecutor (el código productor, "cantante")
});
        
      
      
      La función pasada a new Promise se llama ejecutor. Cuando se crea new Promise, el ejecutor corre automáticamente. Este contiene el código productor que a la larga debería producir el resultado. En términos de la analogía anterior: el ejecutor es el “cantante”.
Sus argumentos resolve y reject son callbacks proporcionadas por el propio JavaScript. Nuestro código solo está dentro del ejecutor.
Cuando el ejecutor, más tarde o más temprano, eso no importa, obtiene el resultado, debe llamar a una de estos callbacks:

resolve(value) – si el trabajo finalizó con éxito, con el resultado value.
reject(error) – si ocurrió un error, error es el objeto error.

Para resumir: el ejecutor corre automáticamente e intenta realizar una tarea. Cuando termina con el intento, llama a resolve si fue exitoso o reject si hubo un error.
El objeto promise devuelto por el constructor new Promise tiene estas propiedades internas:

state – inicialmente "pendiente", luego cambia a "cumplido" cuando se llama a resolve o "rechazado" cuando se llama a reject.
result – inicialmente undefined, luego cambia a valor cuando se llama a resolve(valor) o error cuando se llama a reject(error).

Entonces el ejecutor, en algún momento, pasa la promise a uno de estos estados:

      
      
        
      
      Después veremos cómo los “fanáticos” pueden suscribirse a estos cambios.
Aquí hay un ejemplo de un constructor de promesas y una función ejecutora simple con “código productor” que toma tiempo (a través de setTimeout):

      
        
        
          
            
          
          
            
          
        
        
          let promise = new Promise(function(resolve, reject) {
  // la función se ejecuta automáticamente cuando se construye la promesa

  // después de 1 segundo, indica que la tarea está hecha con el resultado "hecho"
  setTimeout(() => resolve("hecho"), 1000);
});
        
      
      
      Podemos ver dos cosas al ejecutar el código anterior:


Se llama al ejecutor de forma automática e inmediata (por new Promise).


El ejecutor recibe dos argumentos: resolve y reject. Estas funciones están predefinidas por el motor de JavaScript, por lo que no necesitamos crearlas. Solo debemos llamar a uno de ellos cuando esté listo.
Después de un segundo de “procesamiento”, el ejecutor llama a resolve("hecho") para producir el resultado. Esto cambia el estado del objeto promise:

      
      
        
      
      

Ese fue un ejemplo de finalización exitosa de la tarea, una “promesa cumplida”.
Y ahora un ejemplo del ejecutor rechazando la promesa con un error:

      
        
        
          let promise = new Promise(function(resolve, reject) {
  // después de 1 segundo, indica que la tarea ha finalizado con un error
  setTimeout(() => reject(new Error("¡Vaya!")), 1000);
});
        
      
      
      La llamada a reject(...) mueve el objeto promise al estado  "rechazado":

      
      
        
      
      Para resumir, el ejecutor debe realizar una tarea (generalmente algo que toma tiempo) y luego llamar a “resolve” o “reject” para cambiar el estado del objeto promise correspondiente.
Una promesa que se resuelve o se rechaza se denomina “resuelta”, en oposición a una promesa inicialmente “pendiente”.

            Solo puede haber un único resultado, o un error
            El ejecutor debe llamar solo a un ‘resolve’ o un ‘reject’. Cualquier cambio de estado es definitivo.
Se ignoran todas las llamadas adicionales de ‘resolve’ y ‘reject’:

      
        
        
          let promise = new Promise(function(resolve, reject) {
  resolve("hecho");

  reject(new Error("…")); // ignorado
  setTimeout(() => resolve("…")); // ignorado
});
        
      
      
      La idea es que una tarea realizada por el ejecutor puede tener solo un resultado o un error.
Además, resolve/reject espera solo un argumento (o ninguno) e ignorará argumentos adicionales.


            Rechazar con objetos Error
            En caso de que algo salga mal, el ejecutor debe llamar a ‘reject’. Eso se puede hacer con cualquier tipo de argumento (al igual que resolve). Pero se recomienda usar objetos Error (u objetos que hereden de Error). El razonamiento para eso pronto se hará evidente.


            Inmediatamente llamando a resolve/reject
            En la práctica, un ejecutor generalmente hace algo de forma asíncrona y llama a resolve/reject después de un tiempo, pero no está obligado a hacerlo así. También podemos llamar a resolve o reject inmediatamente:

      
        
        
          let promise = new Promise(function(resolve, reject) {
  // sin que nos quite tiempo para hacer la tarea
  resolve(123); // dar inmediatamente el resultado: 123
});
        
      
      
      Por ejemplo, esto puede suceder cuando comenzamos una tarea, pero luego vemos que todo ya se ha completado y almacenado en caché.
Está bien. Inmediatamente tenemos una promesa resuelta.


            state y result son internos
            Las propiedades state y result del objeto Promise son internas. No podemos acceder directamente a ellas. Podemos usar los métodos .then/.catch/.finally para eso. Se describen a continuación.

Consumidores: then y catchUn objeto Promise sirve como enlace entre el ejecutor (el “código productor” o el “cantante”) y las funciones consumidoras (los “fanáticos”), que recibirán un resultado o un error. Las funciones de consumo pueden registrarse (suscribirse) utilizando los métodos .then y .catch.
thenEl más importante y fundamental es .then.
La sintaxis es:

      
        
        
          promise.then(
  function(result) { /* manejar un resultado exitoso */ },
  function(error) { /* manejar un error */ }
);
        
      
      
      El primer argumento de .then es una función que se ejecuta cuando se resuelve la promesa y recibe el resultado.
El segundo argumento de .then es una función que se ejecuta cuando se rechaza la promesa y recibe el error.
Por ejemplo, aquí hay una reacción a una promesa resuelta con éxito:

      
        
        
          
            
          
          
            
          
        
        
          let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("hecho!"), 1000);
});

// resolve ejecuta la primera función en .then
promise.then(
  result => alert(result), // muestra "hecho!" después de 1 segundo
  error => alert(error) // no se ejecuta
);
        
      
      
      La primera función fue ejecutada.
Y en el caso de un rechazo, el segundo:

      
        
        
          
            
          
          
            
          
        
        
          let promise = new Promise(function(resolve, reject) {
  setTimeout(() => reject(new Error("Vaya!")), 1000);
});

// reject ejecuta la segunda función en .then
promise.then(
  result => alert(result), // no se ejecuta
  error => alert(error) // muestra "Error: ¡Vaya!" después de 1 segundo
);
        
      
      
      Si solo nos interesan las terminaciones exitosas, entonces podemos proporcionar solo un argumento de función para .then:

      
        
        
          
            
          
          
            
          
        
        
          let promise = new Promise(resolve => {
  setTimeout(() => resolve("hecho!"), 1000);
});

promise.then(alert); // muestra "hecho!" después de 1 segundo
        
      
      
      catchSi solo nos interesan los errores, entonces podemos usar null como primer argumento: .then(null, errorHandlingFunction). O podemos usar .catch(errorHandlingFunction), que es exactamente lo mismo:

      
        
        
          
            
          
          
            
          
        
        
          let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Vaya!")), 1000);
});

// .catch(f) es lo mismo que promise.then(null, f)
promise.catch(alert); // muestra "Error: ¡Vaya!" después de 1 segundo
        
      
      
      La llamada .catch(f) es un análogo completo de .then(null, f), es solo una abreviatura.
Limpieza: finallyAl igual que hay una cláusula finally en un try {...} catch {...} normal, hay un finally en las promesas.
La llamada .finally(f) es similar a .then(f, f) en el sentido de que f siempre se ejecuta cuando se resuelve la promesa: ya sea que se resuelva o rechace.
La idea de finally es establecer un manejador para realizar la limpieza y finalización después de que las operaciones se hubieran completado.
Por ejemplo, detener indicadores de carga, cerrar conexiones que ya no son necesarias, etc.
Puedes pensarlo como el finalizador de la fiesta. No importa si la fiesta fue buena o mala ni cuántos invitados hubo, aún necesitamos (o al menos deberíamos) hacer la limpieza después.
El código puede verse como esto:

      
        
        
          new Promise((resolve, reject) => {
  /* hacer algo para tomar tiempo y luego llamar a resolve o reject */
})
  // se ejecuta cuando se cumple la promesa, no importa con éxito o no
  .finally(() => stop loading indicator)
  // así el indicador de carga siempre es detenido antes de que sigamos adelante
  .then(result => show result, err => show error)
        
      
      
      Sin embargo, note que finally(f) no es exactamente un alias dethen(f, f)`.
Hay diferencias importantes:
`


Un manejador finally no tiene argumentos. En finally no sabemos si la promesa es exitosa o no. Eso está bien, ya que usualmente nuestra tarea es realizar procedimientos de finalización “generales”.
Por favor observe el ejemplo anterior: como puede ver, el manejador de finally no tiene argumentos, y lo que sale de la promesa es manejado en el siguiente manejador.


Resultados y errores pasan “a través” del manejador de finally. Estos pasan al siguiente manejador que se adecúe.
Por ejemplo, aquí el resultado se pasa a través de finally a then:

      
        
        
          
            
          
          
            
          
        
        
          new Promise((resolve, reject) => {
  setTimeout(() => resolve("valor"), 2000)
})
  .finally(() => alert("Promesa lista")) // se dispara primero
  .then(result => alert(result)); // <-- .luego muestra "valor"
        
      
      
      Como puede ver, el “valor” devuelto por la primera promesa es pasado a través de finally al siguiente then.
Esto es muy conveniente, porque finally no está destinado a procesar el resultado de una promesa. Como dijimos antes, es el lugar para hacer la limpieza general sin importar cuál haya sido el resultado.
Y aquí, el ejemplo de un error para que veamos cómo se pasa, a través de finally, a catch:

      
        
        
          
            
          
          
            
          
        
        
          new Promise((resolve, reject) => {
  throw new Error("error");
})
  .finally(() => alert("Promesa lista"))  // primero dispara
  .catch(err => alert(err));  // <-- .catch muestra el error
        
      
      
      

Un manejador de finally tampoco debería devolver nada. Y si lo hace, el valor devuelto es ignorado silenciosamente.
La única excepción a esta regla se da cuando el manejador mismo de finally dispara un error. En ese caso, este error pasa al siguiente manejador de error en lugar del resultado previo al finally.


Para summarizar:

Un manejador finally no obtiene lo que resultó del manejador previo (no tiene argumentos). Ese resultado es pasado a través de él al siguiente manejador.
Si el manejador de finally devuelve algo, será ignorado.
Cuando es finally el que dispara el error, la ejecución pasa al manejador de error más cercano.

Estas características son de ayuda y hacen que las cosas funcionen tal como corresponde si “finalizamos” con finally como se supone: con procedimientos de limpieza genéricos.

            Podemos adjuntar manejadores a promesas ya establecidas
            Si una promesa está pendiente, los manejadores .then/catch/finally esperan por su resolución.
Podría pasar a veces que, cuando agregamos un manejador, la promesa ya se encuentre establecida.
Em tal caso, estos manejadores simplemente se ejecutarán de inmediato:

      
        
        
          
            
          
          
            
          
        
        
          // la promesa se resuelve inmediatamente después de la creación
let promise = new Promise(resolve => resolve("hecho!"));

promise.then(alert); // ¡hecho! (aparece ahora)
        
      
      
      Ten en cuenta que esto es diferente y más poderoso que el escenario de la “lista de suscripción” de la vida real. Si el cantante ya lanzó su canción y luego una persona se registra en la lista de suscripción, probablemente no recibirá esa canción. Las suscripciones en la vida real deben hacerse antes del evento.
Las promesas son más flexibles. Podemos agregar manejadores en cualquier momento: si el resultado ya está allí, nuestros manejadores lo obtienen de inmediato.

Ejemplo: loadScriptA continuación, veamos ejemplos más prácticos de cómo las promesas pueden ayudarnos a escribir código asincrónico.
Tenemos, del capítulo anterior, la función loadScript para cargar un script.
Aquí está la variante basada callback, solo para recordarnos:

      
        
        
          function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Error de carga de script para $ {src}`));

  document.head.append(script);
}
        
      
      
      Reescribámoslo usando Promesas.
La nueva función loadScript no requerirá una callback. En su lugar, creará y devolverá un objeto Promise que se resuelve cuando se completa la carga. El código externo puede agregar manejadores (funciones de suscripción) usando .then:

      
        
        
          
            
          
          
            
          
        
        
          function loadScript(src) {
  return new Promise(function(resolve, reject) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`Error de carga de script para $ {src}`));

    document.head.append(script);
  });
}
        
      
      
      Uso:

      
        
        
          
            
          
          
            
          
        
        
          let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

promise.then(
  script => alert(`${script.src} está cargado!`),
  error => alert(`Error: ${error.message}`)
);

promise.then(script => alert('Otro manejador...'));
        
      
      
      Podemos ver inmediatamente algunos beneficios sobre el patrón basado en callback:



Promesas
Callbacks




Las promesas nos permiten hacer las cosas en el orden natural. Primero, ejecutamos loadScript (script), y .then escribimos qué hacer con el resultado.
Debemos tener una función callback a nuestra disposición al llamar a ‘loadScript(script, callback)’. En otras palabras, debemos saber qué hacer con el resultado antes de llamar a loadScript.


Podemos llamar a “.then” en una promesa tantas veces como queramos. Cada vez, estamos agregando un nuevo “fan”, una nueva función de suscripción, a la “lista de suscripción”. Más sobre esto en el próximo capítulo: Encadenamiento de promesas.
Solo puede haber un callback.



Entonces, las promesas nos dan un mejor flujo de código y flexibilidad. Pero hay más. Lo veremos en los próximos capítulos.
Tareas¿Volver a resolver una promesa?¿Cuál es el resultado del código a continuación?

      
        
        
          let promise = new Promise(function(resolve, reject) {
  resolve(1);

  setTimeout(() => resolve(2), 1000);
});

promise.then(alert);
        
      
      
      soluciónLa salida es: 1.
La segunda llamada a ‘resolve’ se ignora, porque solo se tiene en cuenta la primera llamada de ‘reject/resolve’. Otras llamadas son ignoradas.
Demora con una promesaLa función incorporada setTimeout utiliza callbacks. Crea una alternativa basada en promesas.
La función delay(ms) debería devolver una promesa. Esa promesa debería resolverse después de ms milisegundos, para que podamos agregarle .then, así:

      
        
        
          function delay(ms) {
  // tu código
}

delay(3000).then(() => alert('se ejecuta después de 3 segundos'));
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

delay(3000).then(() => alert('runs after 3 seconds'));
        
      
      
      Please note that in this task resolve is called without arguments. We don’t return any value from delay, just ensure the delay.
Círculo animado con promesaVuelva a escribir la función showCircle en la solución de la tarea Círculo animado con función de callback para que devuelva una promesa en lugar de aceptar un callback.
Nueva forma de uso:

      
        
        
          showCircle(150, 150, 100).then(div => {
  div.classList.add('message-ball');
  div.append("Hola, mundo!");
});
        
      
      
      Tome la solución de la tarea Círculo animado con función de callback como base.
soluciónAbrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/promise-basics" 
},
{
	"docs_id": "80",
	"name": "Encadenamiento de promesas",
	"description": "Volvamos al problema mencionado en el capítulo Introducción: callbacks: tenemos una secuencia de tareas asincrónicas que deben realizarse una tras otra, por ejemplo, cargar scripts. ¿Cómo podemos codificarlo correctamente?",
	"content": "Volvamos al problema mencionado en el capítulo Introducción: callbacks: tenemos una secuencia de tareas asincrónicas que deben realizarse una tras otra, por ejemplo, cargar scripts. ¿Cómo podemos codificarlo correctamente?
Las promesas proporcionan un par de maneras para hacerlo.
En este capítulo cubrimos el encadenamiento de promesas.
Se ve así:

      
        
        
          
            
          
          
            
          
        
        
          new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000); // (*)

}).then(function(result) { // (**)

  alert(result); // 1
  return result * 2;

}).then(function(result) { // (***)

  alert(result); // 2
  return result * 2;

}).then(function(result) {

  alert(result); // 4
  return result * 2;

});
        
      
      
      La idea es que el resultado pase a través de la cadena de manejadores .then.
Aquí el flujo es:

La promesa inicial se resuelve en 1 segundo (*),
Entonces se llama el manejador .then  (**), que a su vez crea una nueva promesa (resuelta con el valor 2).
El siguiente .then (***) obtiene el resultado del anterior, lo procesa (duplica) y lo pasa al siguiente manejador.
…y así sucesivamente.

A medida que el resultado se pasa a lo largo de la cadena de controladores, podemos ver una secuencia de llamadas de alerta: 1 → 2 → 4.

      
      
        
      
      Todo funciona, porque cada llamada a promise.then devuelve una nueva promesa, para que podamos llamar al siguiente .then con ella.
Cuando un controlador devuelve un valor, se convierte en el resultado de esa promesa, por lo que se llama al siguiente .then.
Un error clásico de principiante: técnicamente también podemos agregar muchos ‘.then’ a una sola promesa: eso no es encadenamiento.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve(1), 1000);
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});
        
      
      
      Lo que hicimos aquí fue varios controladores para una sola promesa. No se pasan el resultado el uno al otro; en su lugar lo procesan de forma independiente.
Aquí está la imagen (compárala con el encadenamiento anterior):

      
      
        
      
      Todos los ‘.then’ en la misma promesa obtienen el mismo resultado: el resultado de esa promesa. Entonces, en el código sobre todo alert muestra lo mismo: 1.
En la práctica, rara vez necesitamos múltiples manejadores para una promesa. El encadenamiento se usa mucho más a menudo.
Retornando promesasUn controlador, utilizado en .then(handler) puede crear y devolver una promesa.
En ese caso, otros manejadores esperan hasta que se estabilice (resuelva o rechace) y luego obtienen su resultado.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000);

}).then(function(result) {

  alert(result); // 1

  return new Promise((resolve, reject) => { // (*)
    setTimeout(() => resolve(result * 2), 1000);
  });

}).then(function(result) { // (**)

  alert(result); // 2

  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(result * 2), 1000);
  });

}).then(function(result) {

  alert(result); // 4

});
        
      
      
      En este código el primer .then muestra 1 y devuelve new Promise(...) en la línea (*). Después de un segundo, se resuelve, y el resultado (el argumento de resolve, aquí es result * 2) se pasa al controlador del segundo .then. Ese controlador está en la línea (**), muestra 2 y hace lo mismo.
Por lo tanto, la salida es la misma que en el ejemplo anterior: 1 → 2 → 4, pero ahora con 1 segundo de retraso entre las llamadas de alerta.
Devolver las promesas nos permite construir cadenas de acciones asincrónicas.
El ejemplo: loadScriptUsemos esta función con el loadScript promisificado, definido en el capítulo anterior, para cargar los scripts uno por uno, en secuencia:

      
        
        
          
            
          
          
            
          
        
        
          loadScript("/article/promise-chaining/one.js")
  .then(function(script) {
    return loadScript("/article/promise-chaining/two.js");
  })
  .then(function(script) {
    return loadScript("/article/promise-chaining/three.js");
  })
  .then(function(script) {
    // usamos las funciones declaradas en los scripts
    // para demostrar que efectivamente se cargaron
    one();
    two();
    three();
  });
        
      
      
      Este código se puede acortar un poco con las funciones de flecha:

      
        
        
          
            
          
          
            
          
        
        
          loadScript("/article/promise-chaining/one.js")
  .then(script => loadScript("/article/promise-chaining/two.js"))
  .then(script => loadScript("/article/promise-chaining/three.js"))
  .then(script => {
    // los scripts se cargaron, podemos usar las funciones declaradas en ellos
    one();
    two();
    three();
  });
        
      
      
      Aquí cada llamada a loadScript devuelve una promesa, y el siguiente .then se ejecuta cuando se resuelve. Luego inicia la carga del siguiente script. Entonces los scripts se cargan uno tras otro.
Podemos agregar más acciones asincrónicas a la cadena. Tenga en cuenta que el código sigue siendo “plano”: crece hacia abajo, no a la derecha. No hay signos de la “pirámide del destino”.
Técnicamente, podríamos agregar .then directamente a cada loadScript, así:

      
        
        
          
            
          
          
            
          
        
        
          loadScript("/article/promise-chaining/one.js").then(script1 => {
  loadScript("/article/promise-chaining/two.js").then(script2 => {
    loadScript("/article/promise-chaining/three.js").then(script3 => {
      // esta función tiene acceso a las variables script1, script2 y script3
      one();
      two();
      three();
    });
  });
});
        
      
      
      Este código hace lo mismo: carga 3 scripts en secuencia. Pero “crece hacia la derecha”. Entonces tenemos el mismo problema que con los callbacks.
Las personas que comienzan a usar promesas pueden desconocer el encadenamiento, y por ello escribirlo de esta manera. En general, se prefiere el encadenamiento.
A veces es aceptable escribir .then directamente, porque la función anidada tiene acceso al ámbito externo. En el ejemplo anterior, el callback más anidado tiene acceso a todas las variables script1, script2, script3. Pero eso es una excepción más que una regla.

            Objetos Thenables
            Para ser precisos, un controlador puede devolver no exactamente una promesa, sino un objeto llamado “thenable”, un objeto arbitrario que tiene un método .then. Será tratado de la misma manera que una promesa.
La idea es que las librerías de terceros puedan implementar sus propios objetos “compatibles con la promesa”. Pueden tener un conjunto extendido de métodos, pero también ser compatibles con las promesas nativas, porque implementan .then.
Aquí hay un ejemplo de un objeto que se puede guardar:

      
        
        
          
            
          
          
            
          
        
        
          class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve); // function() { código nativo }
    // resolve con this.num*2 después de 1 segundo
    setTimeout(() => resolve(this.num * 2), 1000); // (**)
  }
}

new Promise(resolve => resolve(1))
  .then(result => {
    return new Thenable(result); // (*)
  })
  .then(alert); // muestra 2 después de 1000 ms
        
      
      
      JavaScript comprueba el objeto devuelto por el controlador .then en la línea (*): si tiene un método invocable llamado then, entonces llama a ese método que proporciona funciones nativas resolve, accept como argumentos (similar a un ejecutor) y espera hasta que se llame a uno de ellos. En el ejemplo anterior, se llama a resolve(2) después de 1 segundo (**). Luego, el resultado se pasa más abajo en la cadena.
Esta característica nos permite integrar objetos personalizados con cadenas de promesa sin tener que heredar de Promise.

Ejemplo más grande: fetchEn la interfaz de programación, las promesas a menudo se usan para solicitudes de red. Así que veamos un ejemplo extendido de eso.
Utilizaremos el método fetch para cargar la información sobre el usuario desde el servidor remoto. Tiene muchos parámetros opcionales cubiertos en capítulos separados, pero la sintaxis básica es bastante simple:

      
        
        
          let promise = fetch(url);
        
      
      
      Esto hace una solicitud de red a la url y devuelve una promesa. La promesa se resuelve con un objeto ‘response’ cuando el servidor remoto responde con encabezados, pero  antes de que se descargue la respuesta completa.
Para leer la respuesta completa, debemos llamar al método response.text(): devuelve una promesa que se resuelve cuando se descarga el texto completo del servidor remoto, con ese texto como resultado.
El siguiente código hace una solicitud a user.json y carga su texto desde el servidor:

      
        
        
          
            
          
          
            
          
        
        
          fetch('/article/promise-chaining/user.json')
  // .a continuación, se ejecuta cuando el servidor remoto responde
  .then(function(response) {
    // response.text() devuelve una nueva promesa que se resuelve con el texto de respuesta completo
    // cuando se carga
    return response.text();
  })
  .then(function(text) {
    // ...y aquí está el contenido del archivo remoto
    alert(text); // {"name": "iliakan", isAdmin: true}
  });
        
      
      
      El objeto response devuelto por fetch también incluye el método response.json() que lee los datos remotos y los analiza como JSON. En nuestro caso, eso es aún más conveniente, así que pasemos a ello.
También usaremos las funciones de flecha por brevedad:

      
        
        
          
            
          
          
            
          
        
        
          // igual que el anterior, pero response.json() analiza el contenido remoto como JSON
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => alert(user.name)); // iliakan, tengo nombre de usuario
        
      
      
      Ahora hagamos algo con el usuario cargado.
Por ejemplo, podemos hacer una solicitud más a GitHub, cargar el perfil de usuario y mostrar el avatar:

      
        
        
          
            
          
          
            
          
        
        
          // Hacer una solicitud para user.json
fetch('/article/promise-chaining/user.json')
  // Cárgalo como json
  .then(response => response.json())
  // Hacer una solicitud a GitHub
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  // Carga la respuesta como json
  .then(response => response.json())
  // Mostrar la imagen de avatar (githubUser.avatar_url) durante 3 segundos (tal vez animarla)
  .then(githubUser => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => img.remove(), 3000); // (*)
  });
        
      
      
      El código funciona; ver comentarios sobre los detalles. Sin embargo, hay un problema potencial, un error típico para aquellos que comienzan a usar promesas.
Mire la línea (*): ¿cómo podemos hacer algo después de que el avatar haya terminado de mostrarse y se elimine? Por ejemplo, nos gustaría mostrar un formulario para editar ese usuario u otra cosa. A partir de ahora, no hay manera.
Para que la cadena sea extensible, debemos devolver una promesa que se resuelva cuando el avatar termine de mostrarse.
Como esto:

      
        
        
          
            
          
          
            
          
        
        
          fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise(function(resolve, reject) { // (*)
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser); // (**)
    }, 3000);
  }))
  // se dispara después de 3 segundos
  .then(githubUser => alert(`Terminado de mostrar ${githubUser.name}`));
        
      
      
      Es decir, el controlador .then en la línea (*) ahora devuelve new Promise, que se resuelve solo después de la llamada de resolve(githubUser) en setTimeout (**). El siguiente ‘.then’ en la cadena esperará eso.
Como buena práctica, una acción asincrónica siempre debe devolver una promesa. Eso hace posible planificar acciones posteriores; incluso si no planeamos extender la cadena ahora, es posible que la necesitemos más adelante.
Finalmente, podemos dividir el código en funciones reutilizables:

      
        
        
          
            
          
          
            
          
        
        
          function loadJson(url) {
  return fetch(url)
    .then(response => response.json());
}

function loadGithubUser(name) {
  return loadJson(`https://api.github.com/users/${name}`);
}

function showAvatar(githubUser) {
  return new Promise(function(resolve, reject) {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  });
}

// Úsalos:
loadJson('/article/promise-chaining/user.json')
  .then(user => loadGithubUser(user.name))
  .then(showAvatar)
  .then(githubUser => alert(`Finished showing ${githubUser.name}`));
  // ...
        
      
      
      ResumenSi un controlador .then (o catch/finally, no importa) devuelve una promesa, el resto de la cadena espera hasta que se asiente. Cuando lo hace, su resultado (o error) se pasa más allá.
Aquí hay una imagen completa:

      
      
        
      
      TareasPromesa: then versus catch¿Son iguales estos fragmentos de código? En otras palabras, ¿se comportan de la misma manera en cualquier circunstancia, para cualquier función de controlador?

      
        
        
          promise.then(f1).catch(f2);
        
      
      
      Versus:

      
        
        
          promise.then(f1, f2);
        
      
      
      soluciónLa respuesta corta es: no, no son iguales:
La diferencia es que si ocurre un error en f1, entonces aqui es manejado por .catch:

      
        
        
          
            
          
          
            
          
        
        
          promise
  .then(f1)
  .catch(f2);
        
      
      
      …Pero no aquí:

      
        
        
          
            
          
          
            
          
        
        
          promise
  .then(f1, f2);
        
      
      
      Esto se debe a que se pasa un error por la cadena y en la segunda pieza del código no hay una cadena debajo de f1.
En otras palabras, .then pasa los resultados/errores al siguiente .then/catch. Entonces, en el primer ejemplo, hay un catch debajo, y en el segundo no lo hay, por lo que el error no se maneja.
",
	"url": "https://es.javascript.info/promise-chaining" 
},
{
	"docs_id": "81",
	"name": "Manejo de errores con promesas",
	"description": "Las promesas encadenadas son excelentes manejando los errores. Cuando una promesa es rechazada, el control salta al manejador de rechazos más cercano. Esto es muy conveniente en la práctica.",
	"content": "Las promesas encadenadas son excelentes manejando los errores. Cuando una promesa es rechazada, el control salta al manejador de rechazos más cercano. Esto es muy conveniente en la práctica.
Por ejemplo, en el código de abajo, la URL a la cual se le hace fetch es incorrecta (no existe el sitio) y al ser rechazada.catch maneja el error:

      
        
        
          
            
          
          
            
          
        
        
          fetch('https://no-such-server.blabla') // Promesa rechazada
  .then(response => response.json())
  .catch(err => alert(err)) // TypeError: failed to fetch (El texto puede variar, dependiendo del error)
        
      
      
      Como puedes ver, el .catch no tiene que escribirse inmediatamente después de la promesa. Este puede aparecer después de uno o quizás varios .then.
O, puede ocurrir, que todo en el sitio se encuentre bien, pero la respuesta no es un JSON válido. La forma más fácil de detectar todos los errores es agregando .catch al final de la cadena de promesas:

      
        
        
          
            
          
          
            
          
        
        
          fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise((resolve, reject) => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  }))
  .catch(error => alert(error.message));
        
      
      
      Lo normal es que tal .catch no se dispare en absoluto. Pero si alguna de las promesas anteriores es rechazada (por un error de red, un JSON inválido or cualquier otra razón), entonces el error es capturado.
try…catch implícitoEl código de un ejecutor de promesas y de manejadores de promesas tiene embebido un " try..catch invisible". Si ocurre una excepción, esta es atrapada y es tratada como un rechazo.
Por ejemplo, este código:

      
        
        
          
            
          
          
            
          
        
        
          new Promise((resolve, reject) => {
  throw new Error("Whoops!");
}).catch(alert); // Error: Whoops!
        
      
      
      …Hace exactamente lo mismo que este:

      
        
        
          
            
          
          
            
          
        
        
          new Promise((resolve, reject) => {
  reject(new Error("Whoops!"));
}).catch(alert); // Error: Whoops!
        
      
      
      El "try..catch invisible" embebido en el ejecutor detecta automáticamente el error y lo convierte en una promesa rechazada.
Esto sucede no solo en la función ejecutora, sino también en sus manejadores. Si hacemos throw dentro de una llamada a .then, esto devolverá una promesa rechazada, por lo que el control salta al manejador de errores más cercano.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          new Promise((resolve, reject) => {
  resolve("ok");
}).then((result) => {
  throw new Error("Whoops!"); // rechaza la promesa
}).catch(alert); // Error: Whoops!
        
      
      
      Esto sucede con todos los errores, no solo los causados por la sentencia de excepción throw. Por ejemplo, un error de programación:

      
        
        
          
            
          
          
            
          
        
        
          new Promise((resolve, reject) => {
  resolve("ok");
}).then((result) => {
  blabla(); // Función inexistente
}).catch(alert); // ReferenceError: blabla is not defined
        
      
      
      El .catch del final no solo detecta rechazos explícitos, sino también los errores accidentales en los manejadores anteriores.
Rethrowing (relanzamiento de errores)Como ya vimos, el .catch del final es similar a try..catch. Podemos tener tantos manejadores .then como queramos, y luego usar un solo .catch al final para manejar los errores en todos ellos.
En un try..catch normal, podemos analizar el error y quizá volver a lanzarlo si no se puede manejar. Lo mismo podemos hacer con las promesas.
Si hacemos throw dentro de .catch, el control pasa a otro manejador de errores más cercano. Y, si manejamos el error y terminamos de forma correcta, entonces se continúa con el siguiente manejador .then exitoso.
En el ejemplo de abajo, el .catch maneja el error de forma exitosa:

      
        
        
          
            
          
          
            
          
        
        
          // Ejecución: catch -> then
new Promise((resolve, reject) => {

  throw new Error("Whoops!");

}).catch(function(error) {

  alert("Error manejado, se continuará con la ejecución del código");

}).then(() => alert("El siguiente manejador exitoso se ejecuta"));
        
      
      
      Aquí el .catch termina de forma correcta. Entonces se ejecuta el siguiente manejador exitoso .then.
En el siguiente ejemplo podemos ver otra situación con .catch. El manejador (*) detecta el error y simplemente no puede manejarlo (en el ejemplo solo sabe que hacer con un URIError), por lo que lo lanza nuevamente:

      
        
        
          
            
          
          
            
          
        
        
          // Ejecución: catch -> catch
new Promise((resolve, reject) => {

  throw new Error("Whoops!");

}).catch(function(error) { // (*)

  if (error instanceof URIError) {
    // Aquí se manejaría el error
  } else {
    alert("No puedo manejar este error");

    throw error; // Lanza este error u otro error que salte en el siguiente catch.
  }

}).then(function() {
  /* Esto no se ejecuta */
}).catch(error => { // (**)

  alert(`Ocurrió un error desconocido: ${error}`);
  // No se devuelve nada => La ejecución continúa de forma normal

});
        
      
      
      La ejecución salta del primer .catch (*) al siguiente (**) en la cadena.
Rechazos no manejados¿Que sucede cuanto un error no es manejado? Por ejemplo, si olvidamos agregar .catch al final de una cadena de promesas, como aquí:

      
        
        
          
            
          
          
            
          
        
        
          new Promise(function() {
  noSuchFunction(); // Aquí hay un error (no existe la función)
})
  .then(() => {
    // manejador de una o más promesas exitosas
  }); // sin .catch al final!
        
      
      
      En caso de que se genere un error, la promesa se rechaza y la ejecución salta al manejador de rechazos más cercano. Pero aquí no hay ninguno. Entonces el error se “atasca”, ya que no hay código para manejarlo.
En la práctica, al igual que con los errores comunes no manejados en el código, esto significa que algo ha salido terriblemente mal.
¿Que sucede cuando ocurre un error regular y no es detectado por try..catch? El script muere con un mensaje en la consola. Algo similar sucede con los rechazos de promesas no manejadas.
En este caso, el motor de JavaScript rastrea el rechazo y lo envía al ámbito global. Puedes ver en consola el error generado si ejecutas el ejemplo anterior.
En el navegador podemos detectar tales errores usando el evento unhandledrejection:

      
        
        
          
            
          
          
            
          
        
        
          window.addEventListener('unhandledrejection', function(event) {
  // el objeto event tiene dos propiedades especiales:
  alert(event.promise); // [objeto Promesa] - La promesa que fue rechazada
  alert(event.reason); // Error: Whoops! - Motivo por el cual se rechaza la promesa
});

new Promise(function() {
  throw new Error("Whoops!");
}); // No hay un .catch final para manejar el error
        
      
      
      Este evento es parte del standard HTML.
Si se produce un error, y no hay un .catch, se dispara unhandledrejection, y se obtiene el objeto event el cual contiene información sobre el error, por lo que podemos hacer algo con el error (manejar el error).
Usualmente estos errores no son recuperables, por lo que la mejor salida es informar al usuario sobre el problema y probablemente reportar el incidente al servidor.
En entornos fuera del navegador como Node.js existen otras formas de rastrear errores no manejados.
Resumen
.catch maneja errores de todo tipo: ya sea una llamada a reject(), o un error que arroja un manejador.
.then también atrapa los errores de la misma manera si se le da el segundo argumento (que es el manejador de error).
Debemos colocar .catch exactamente en los lugares donde queremos manejar los errores y saber cómo manejarlos. El manejador debe analizar los errores (los errores personalizados ayudan), y relanzar los errores desconocidos (tal vez sean errores de programación).
Es correcto no usar .catch en absoluto si no hay forma de recuperarse de un error.
En cualquier caso, deberíamos tener el evento unhandledrejection (para navegadores, o el equivalente en otros entornos) para monitorear errores no manejados e informar al usuario (y probablemente al servidor) para que nuestra aplicación nunca “simplemente muera”.

TareasError en setTimeout¿Qué crees que pasará? ¿Se disparará el .catch? Explica tu respuesta.

      
        
        
          new Promise(function(resolve, reject) {
  setTimeout(() => {
    throw new Error("Whoops!");
  }, 1000);
}).catch(alert);
        
      
      
      soluciónLa respuesta es: no, no lo hará:

      
        
        
          
            
          
          
            
          
        
        
          new Promise(function(resolve, reject) {
  setTimeout(() => {
    throw new Error("Whoops!");
  }, 1000);
}).catch(alert);
        
      
      
      Como vimos en el capítulo, hay un "try..catch implícito" en el código de la función. Así se manejan todos los errores síncronos.
Pero aquí el error no se genera mientras el ejecutor está corriendo, sino más tarde. Entonces la promesa no puede manejarlo.
",
	"url": "https://es.javascript.info/promise-error-handling" 
},
{
	"docs_id": "82",
	"name": "Promise API",
	"description": "Hay 6 métodos estáticos en la clase Promise. Veremos sus casos de uso aquí.",
	"content": "Hay 6 métodos estáticos en la clase Promise. Veremos sus casos de uso aquí.
Promise.allDigamos que queremos que muchas promesas se ejecuten en paralelo y esperar hasta que todas ellas estén listas.
Por ejemplo, descargar varias URLs en paralelo y procesar su contenido en cuanto todas ellas finalicen.
Para ello es Promise.all.
La sintaxis es:

      
        
        
          let promise = Promise.all(iterable);
        
      
      
      Promise.all toma un iterable (usualmente un array de promesas) y devuelve una nueva promesa.
Esta nueva promesa es resuelta en cuanto todas las promesas listadas se resuelven, y el array de aquellos resultados se vuelve su resultado.
Por ejemplo, el Promise.all debajo se resuelve después de 3 segundos, y su resultado es un array [1, 2, 3]:

      
        
        
          
            
          
          
            
          
        
        
          Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(alert); // 1,2,3 cuando las promesas están listas: cada promesa constituye un miembro del array
        
      
      
      Ten en cuenta que el orden de los miembros del array es el mismo que el de las promesas que los originan. Aunque la primera promesa es la que toma más tiempo en resolverse, es aún la primera en el array de resultados.
Un truco común es mapear un array de datos de trabajo dentro de un array de promesas, y entonces envolverlos dentro de un Promise.all.
Por ejemplo, si tenemos un array de URLs, podemos usar fetch en todos ellos así:

      
        
        
          
            
          
          
            
          
        
        
          let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://api.github.com/users/jeresig'
];

// "mapear" cada url a la promesa de su fetch
let requests = urls.map(url => fetch(url));

// Promise.all espera hasta que todas la tareas estén resueltas
Promise.all(requests)
  .then(responses => responses.forEach(
    response => alert(`${response.url}: ${response.status}`)
  ));
        
      
      
      Un mayor ejemplo con fetch: la búsqueda de información de usuario para un array de usuarios de GitHub por sus nombres (o podríamos buscar un array de bienes por sus “id”, la lógica es idéntica):

      
        
        
          
            
          
          
            
          
        
        
          let names = ['iliakan', 'remy', 'jeresig'];

let requests = names.map(name => fetch(`https://api.github.com/users/${name}`));

Promise.all(requests)
  .then(responses => {
    // todas las respuestas son resueltas satisfactoriamente
    for(let response of responses) {
      alert(`${response.url}: ${response.status}`); // muestra 200 por cada url
    }

    return responses;
  })
  // mapea el array de resultados dentro de un array de response.json() para leer sus contenidos
  .then(responses => Promise.all(responses.map(r => r.json())))
  // todas las respuestas JSON son analizadas: "users" es el array de ellas
  .then(users => users.forEach(user => alert(user.name)));
        
      
      
      Si cualquiera de las promesas es rechazada, la promesa devuelta por Promise.all inmediatamente rechaza: “reject” con ese error.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          Promise.all([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).catch(alert); // Error: Whoops!
        
      
      
      Aquí la segunda promesa se rechaza en dos segundos. Esto lleva a un rechazo inmediato de Promise.all, entonces .catch se ejecuta: el error del rechazo se vuelve la salida del Promise.all entero.

            En caso de error, las demás promesas son ignoradas
            Si una promesa se rechaza, Promise.all se rechaza inmediatamente, olvidando completamente las otras de la lista. Aquellos resultados son ignorados.
Por ejemplo: si hay múltiples llamados fetch, como en el ejemplo arriba, y uno falla, los demás aún continuarán en ejecución, pero Promise.all no las observará más. Ellas probablemente respondan, pero sus resultados serán ignorados.
Promise.all no hace nada para cancelarlas, no existe un concepto de “cancelación” en las promesas. En otro capítulo veremos AbortController, que puede ayudar con ello pero no es parte de la API de las promesas.


            Promise.all(iterable) permite valores “comunes” que no sean promesas en iterable 
            Normalmente, Promise.all(...) acepta un iterable (array en la mayoría de los casos) de promesas. Pero si alguno de esos objetos no es una promesa, es pasado al array resultante “tal como está”.
Por ejemplo, aquí los resultados son [1, 2, 3]:

      
        
        
          
            
          
          
            
          
        
        
          Promise.all([
  new Promise((resolve, reject) => {
    setTimeout(() => resolve(1), 1000)
  }),
  2,
  3
]).then(alert); // 1, 2, 3
        
      
      
      Entonces podemos pasar valores listos a Promise.all donde sea conveniente.

Promise.allSettled
            Una adición reciente
            
            Esta es una adición reciente al lenguaje.
            Los navegadores antiguos pueden necesitar polyfills.
            
Promise.all rechaza como un todo si cualquiera de sus promesas es rechazada. Esto es bueno para los casos de “todo o nada”, cuando necesitamos que todos los resultados sean exitosos para proceder:

      
        
        
          Promise.all([
  fetch('/template.html'),
  fetch('/style.css'),
  fetch('/data.json')
]).then(render); // el método render necesita los resultados de todos los fetch
        
      
      
      Promise.allSettled solo espera que todas las promesas se resuelvan sin importar sus resultados. El array resultante tiene:

{status:"fulfilled", value:result} para respuestas exitosas,
{status:"rejected", reason:error} para errores.

Por ejemplo, quisiéramos hacer “fetch” de la información de múltiples usuarios. Incluso si uno falla, aún estaremos interesados en los otros.
Usemos Promise.allSettled:

      
        
        
          
            
          
          
            
          
        
        
          let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://no-such-url'
];

Promise.allSettled(urls.map(url => fetch(url)))
  .then(results => { // (*)
    results.forEach((result, num) => {
      if (result.status == "fulfilled") {
        alert(`${urls[num]}: ${result.value.status}`);
      }
      if (result.status == "rejected") {
        alert(`${urls[num]}: ${result.reason}`);
      }
    });
  });
        
      
      
      El results de la línea (*) de arriba será:

      
        
        
          [
  {status: 'fulfilled', value: ...response...},
  {status: 'fulfilled', value: ...response...},
  {status: 'rejected', reason: ...error object...}
]
        
      
      
      Entonces para cada promesa obtendremos su estado y value/error.
PolyfillSi el browser no soporta Promise.allSettled, es fácil implementarlo:

      
        
        
          if (!Promise.allSettled) {
  const rejectHandler = reason => ({ status: 'rejected', reason });

  const resolveHandler = value => ({ status: 'fulfilled', value });

  Promise.allSettled = function (promises) {
    const convertedPromises = promises.map(p => Promise.resolve(p).then(resolveHandler, rejectHandler));
    return Promise.all(convertedPromises);
  };
}
        
      
      
      En este código, promises.map toma los valores de entrada, los transforma en promesas (por si no lo eran) con p => Promise.resolve(p), entonces agrega un manejador .then a cada una.
Este manejador (“handler”) transforma un resultado exitoso value en {status:'fulfilled', value}, y un error reason en {status:'rejected', reason}. Ese es exactamente el formato de Promise.allSettled.
Ahora podemos usar Promise.allSettled para obtener el resultado de todas las promesas dadas incluso si algunas son rechazadas.
Promise.raceSimilar a Promise.all, pero espera solamente por la primera respuesta y obtiene su resultado (o error).
Su sintaxis es:

      
        
        
          let promise = Promise.race(iterable);
        
      
      
      Por ejemplo, aquí el resultado será 1:

      
        
        
          
            
          
          
            
          
        
        
          Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
        
      
      
      La primera promesa fue la más rápida, por lo que se vuelve resultado. En cuanto una promesa responde, “gana la carrera”, y todos los resultados o errores posteriores son ignorados.
Promise.anyEs similar a Promise.race, pero espera solamente por la primera promesa cumplida y obtiene su resultado. Si todas la promesas fueron rechazadas, entonces la promesa que devuelve es rechazada con AggregateError, un error especial que almacena los errores de todas las promesas en su propiedad errors.
La sintaxis es:

      
        
        
          let promise = Promise.any(iterable);
        
      
      
      Por ejemplo, aquí el resultado será 1:

      
        
        
          
            
          
          
            
          
        
        
          Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Whoops!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
        
      
      
      La primera promesa fue la más rápida, pero fue rechazada entonces devuelve el resultado de la segunda. Una vez que la primera promesa cumplida “gana la carrera”, los demás resultados serán ignorados.
Aquí hay un ejemplo donde todas la promesas fallan:

      
        
        
          
            
          
          
            
          
        
        
          Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ouch!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Error!")), 2000))
]).catch(error => {
  console.log(error.constructor.name); // AggregateError
  console.log(error.errors[0]); // Error: Ouch!
  console.log(error.errors[1]); // Error: Error!
});
        
      
      
      Como puedes ver, los objetos de error de las promesas que fallaron están disponibles en la propiedad errors del objeto AggregateError.
Promise.resolve/rejectLos métodos Promise.resolve y Promise.reject son raramente necesitados en código moderno porque la sintaxis async/await (que veremos luego) las hace algo obsoletas.
Las tratamos aquí para completar la cobertura y por aquellos casos que por algún motivo no puedan usar async/await.
Promise.resolvePromise.resolve(value) crea una promesa resuelta con el resultado value.
Tal como:

      
        
        
          let promise = new Promise(resolve => resolve(value));
        
      
      
      El método es usado por compatibilidad, cuando se espera que una función devuelva una promesa.
Por ejemplo, la función loadCached abajo busca una URL y recuerda (en caché) su contenido. Futuros llamados con la misma URL devolverá el contenido de caché, pero usa Promise.resolve para hacer una promesa de él y así el valor devuelto es siempre una promesa:

      
        
        
          let cache = new Map();

function loadCached(url) {
  if (cache.has(url)) {
    return Promise.resolve(cache.get(url)); // (*)
  }

  return fetch(url)
    .then(response => response.text())
    .then(text => {
      cache.set(url,text);
      return text;
    });
}
        
      
      
      Podemos escribir loadCached(url).then(…) porque se garantiza que la función devuelve una promesa. Siempre podremos usar .then después de loadCached. Ese es el propósito de Promise.resolve en la línea (*).
Promise.rejectPromise.reject(error) crea una promesa rechazada con error.
Tal como:

      
        
        
          let promise = new Promise((resolve, reject) => reject(error));
        
      
      
      En la práctica este método casi nunca es usado.
ResumenExisten 6 métodos estáticos de la clase Promise:

Promise.all(promises) – espera que todas las promesas se resuelvan y devuelve un array de sus resultados. Si cualquiera es rechazada se vuelve el error de Promise.all y los demás resultados son ignorados.
Promise.allSettled(promises) (método recientemente añadido) – espera que toda las promesas respondan y devuelve sus resultados como un array de objetos con:

status: "fulfilled" o "rejected"
value (si fulfilled) o reason (si rejected).


Promise.race(promises) – espera a la primera promesa que responda y aquel resultado o error se vuelve su resultado o error.
Promise.any(promises) (método recientemente añadido) – espera por la primera promesa que se cumpla y devuelve su resultado. Si todas las promesas son rechazadas, AggregateError se vuelve el error de Promise.any.
Promise.resolve(value) – crea una promesa resuelta con el “value” dado.
Promise.reject(error) – crea una promesa rechazada con el “error” dado.

Promise.all es probablemente el más común en la práctica.
",
	"url": "https://es.javascript.info/promise-api" 
},
{
	"docs_id": "83",
	"name": "Promisificación",
	"description": "“Promisificación” es una simple transformación. Es la conversión de una función que acepta un callback a una función que devuelve una promesa.",
	"content": "“Promisificación” es una simple transformación. Es la conversión de una función que acepta un callback a una función que devuelve una promesa.
A menudo estas transformaciones son necesarias en la vida real ya que muchas funciones y librerías están basadas en callbacks, pero las promesas son más convenientes así que tiene sentido promisificarlas.
Veamos un ejemplo.
Aquí tenemos loadScript(src, callback) del artículo Introducción: callbacks.

      
        
        
          
            
          
          
            
          
        
        
          function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Error de carga de script ${src}`));

  document.head.append(script);
}

// uso:
// loadScript('path/script.js', (err, script) => {...})
        
      
      
      La función carga un script con el src dado, y llama a callback(err) en caso de error o callback(null, script) en caso de carga exitosa. Esto está ampliamente acordado en el uso de callbacks, lo hemos visto antes.
Vamos a promisificarla.
Haremos una función nueva loadScriptPromise(src) que va a hacer lo mismo (carga el script), pero devuelve una promesa en vez de usar callbacks.
Es decir: pasamos solamente src (sin callback) y obtenemos una promesa de vuelta, que resuelve con script cuando la carga fue exitosa y rechaza con error en caso contrario.
Aquí está:

      
        
        
          let loadScriptPromise = function(src) {
  return new Promise((resolve, reject) => {
    loadScript(src, (err, script) => {
      if (err) reject(err);
      else resolve(script);
    });
  });
};

// uso:
// loadScriptPromise('path/script.js').then(...)
        
      
      
      Como podemos ver, la nueva función es un “wrapper” (una función contenedora) que envuelve la función loadScript original. La llama proveyendo su propio callback y la traduce a una promesa resolve/reject.
Ahora loadScriptPromise se adapta bien a un código basado en promesas. Si nos gustan más las promesas que los callbacks (y pronto veremos más motivos para ello), la usaremos en su lugar.
En la práctica podemos necesitar promisificar más de una función, así que tiene sentido usar un ayudante.
Lo llamamos promisify(f): esta acepta la función a promisificar f y devuelve una función contenedora (wrapper).

      
        
        
          function promisify(f) {
  return function (...args) { // devuelve una función contenedora (*)
    return new Promise((resolve, reject) => {
      function callback(err, result) { // nuestro callback personalizado para f (**)
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      }

      args.push(callback); // adjunta nuestro callback personalizado al final de los argumentos

      f.call(this, ...args); // llama a la función original
    });
  };
}

// uso:
let loadScriptPromise = promisify(loadScript);
loadScriptPromise(...).then(...);
        
      
      
      El código puede verse complicado, pero es esencialmente lo mismo que escribimos arriba al promisificar la función loadScript.
Una llamada a promisify(f) devuelve una función contenedora que envuelve a f (*). Este contenedor devuelve una promesa y redirige el llamado a la f original, siguiendo el resultado en el callback personalizado (**).
Aquí promisify asume que la función original espera un callback con dos argumentos (err, result). Eso es lo que usualmente encontramos. Entonces nuestro callback personalizado está exactamente en el formato correcto, y promisify funciona muy bien para tal caso.
¿Y si la f original espera un callback con más argumentos callback(err, res1, res2)?
Podemos mejorar el ayudante. Hagamos una versión de promisify más avanzada.

Cuando la llamamos como promisify(f), debe funcionar igual que en la versión previa.
Cuando la llamamos como promisify(f, true), debe devolver una promesa que resuelve con el array de resultados del callback. Esto es para callbacks con muchos argumentos.


      
        
        
          // promisify(f, true) para conseguir array de resultados
function promisify(f, manyArgs = false) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(err, ...results) { // Nuestro callback personalizado para f
        if (err) {
          reject(err);
        } else {
          // Devolver todos los resultados del callback si "manyArgs" es especificado
          resolve(manyArgs ? results : results[0]);
        }
      }

      args.push(callback);

      f.call(this, ...args);
    });
  };
}

// Uso:
f = promisify(f, true);
f(...).then(arrayOfResults => ..., err => ...);
        
      
      
      Como puedes ver es esencialmente lo mismo de antes, pero resolve es llamado con solo uno o con todos los argumentos dependiendo del valor de manyArgs.
Para formatos más exóticos de callback, como aquellos sin err en absoluto: callback(result), podemos promisificarlos manualmente sin usar el ayudante.
También hay módulos con funciones de promisificación un poco más flexibles, ej. es6-promisify. En Node.js, hay una función integrada util.promisify para ello.

            Por favor tome nota:
            La promisificación es un excelente enfoque, especialmente cuando usas async/await (revisa el siguiente artículo), pero no es un substituto completo para los callbacks.
Recuerda, una promesa puede tener sólo un resultado, pero un callback puede ser técnicamente llamado muchas veces.
Así que la promisificación está solo pensada para funciones que llaman al callback una vez. Las llamadas adicionales serán ignoradas.

",
	"url": "https://es.javascript.info/promisify" 
},
{
	"docs_id": "84",
	"name": "Microtareas (Microtasks)",
	"description": "Los manejadores o controladores (en adelante controladores) de promesas .then/.catch/.finally son siempre asincrónicos.",
	"content": "Los manejadores o controladores (en adelante controladores) de promesas .then/.catch/.finally son siempre asincrónicos.
Incluso cuando una promesa es inmediatamente resuelta, el código en las líneas debajo de .then/.catch/.finally se ejecutará antes que estos controladores.
Veamos una demostración:

      
        
        
          
            
          
          
            
          
        
        
          let promise = Promise.resolve();

promise.then(() => alert("¡Promesa realizada!"));

alert("código finalizado"); // esta alerta se muestra primero
        
      
      
      Si ejecutas esto, verás código finalizado primero, y después ¡promesa realizada!.
Es algo extraño, porque la promesa se realiza por completo desde el principio.
¿Por qué .then se disparó después? ¿Qué está pasando?
Cola de microtareas (Microtasks queue)Las tareas asincrónicas necesitan una gestión adecuada. Para ello, el estándar ECMA especifica una cola interna PromiseJobs, en ocasiones más conocida como “cola de microtareas” (término de V8).
Como se indica en la especificación:

La cola es first-in-first-out (FIFO), es decir, primero en entrar primero en salir: la tarea que entró primero en la cola, será la primera en ejecutarse.
La ejecución de una tarea se inicia sólo cuando no se está ejecutando nada más.

O, en palabras más simples, cuando una promesa está lista, sus controladores .then/catch/finally se ponen en la cola; ellos aún no se ejecutan. Cuando el motor de Javascript se libera del código actual, toma una tarea de la cola y la ejecuta.
Es por eso que el “código finalizado” en el ejemplo anterior se muestra primero.

      
      
        
      
      Los controladores de promesas siempre pasan por esta cola interna.
Si hay una cadena con múltiples .then/catch/finally, entonces cada uno de ellos se ejecuta de forma asincrónica. Es decir, primero se pone en la cola, luego se ejecuta cuando se completa el código actual y se finalizan los controladores previamente en la cola.
¿y si el orden es importante para nosotros? ¿Cómo podemos hacer que código finalizado se ejecute después de ¡promesa realizada!?
Fácil, solo ponlo en la cola con .then:

      
        
        
          
            
          
          
            
          
        
        
          Promise.resolve()
  .then(() => alert("promesa realizada!"))
  .then(() => alert("código finalizado"));
        
      
      
      Ahora el orden es el previsto.
Rechazo no controladoRecuerdas el evento unhandledrejection del artículo Manejo de errores con promesas?
Ahora podemos ver exactamente cómo Javascript descubre que hubo un rechazo no controlado o unhandled rejection
Se produce un “rechazo no controlado” cuando no se maneja un error de promesa al final de la cola de microtareas.
Normalmente, si esperamos un error, agregamos .catch a la cadena de promesa para manejarlo:

      
        
        
          
            
          
          
            
          
        
        
          let promise = Promise.reject(new Error("¡Promesa fallida!"));
promise.catch(err => alert('atrapado'));

// no se ejecuta: error controlado
window.addEventListener('unhandledrejection', event => alert(event.reason));
        
      
      
      Pero si olvidas añadir el .catch, entonces, después de que la cola de microtareas esté vacía, el motor activa el evento:

      
        
        
          
            
          
          
            
          
        
        
          let promise = Promise.reject(new Error("¡Promesa fallida!"));

// Promesa fallida!
window.addEventListener('unhandledrejection', event => alert(event.reason));
        
      
      
      ¿Qué pasa si controlamos el error más tarde? Como esto:

      
        
        
          
            
          
          
            
          
        
        
          let promise = Promise.reject(new Error("¡Promesa fallida!"));
setTimeout(() => promise.catch(err => alert('atrapado')), 1000);

// Error: ¡Promesa fallida!
window.addEventListener('unhandledrejection', event => alert(event.reason));
        
      
      
      Ahora si lo ejecutamos, veremos ¡Promesa fallida! primero y después atrapado.
Si no supiéramos acerca de la cola de microtareas podríamos preguntarnos: "¿Por qué se ejecutó el controlador unhandledrejection? ¡Capturamos y manejamos el error!
Pero ahora entendemos que unhandledrejection se genera cuando se completa la cola de microtareas: el motor examina las promesas y, si alguna de ellas está en el estado “rechazado”, entonces el evento se dispara.
En el ejemplo anterior, .catch agregado por setTimeout también se dispara. Pero lo hace más tarde, después de que unhandledrejection ya ha ocurrido, por lo que no cambia nada.
ResumenEl control de promesas siempre es asíncrono, ya que todas las acciones de promesa pasan por la cola interna de “PromiseJobs”, también llamada “cola de microtareas” (término de V8).
Entonces, los controladores .then/catch/finally siempre se llaman después de que el código actual ha finalizado.
Si necesitamos garantizar que un código se ejecute después de .then/catch/finally, podemos agregarlo a una llamada encadenada .then.
En la mayoría de los motores de Javascript, incluidos los navegadores y Node.js, el concepto de microtareas está estrechamente relacionado con el “bucle de eventos” o “event loop” y “macrotareas” o “macrotasks”. Como estos no tienen relación directa con las promesas, están cubiertos en otra parte del tutorial, en el artículo Loop de eventos: microtareas y macrotareas.
",
	"url": "https://es.javascript.info/microtask-queue" 
},
{
	"docs_id": "85",
	"name": "Async/await",
	"description": "Existe una sintaxis especial para trabajar con promesas de una forma más confortable, llamada “async/await”. Es sorprendentemente fácil de entender y usar.",
	"content": "Existe una sintaxis especial para trabajar con promesas de una forma más confortable, llamada “async/await”. Es sorprendentemente fácil de entender y usar.
Funciones asyncComencemos con la palabra clave async. Puede ser ubicada delante de una función como aquí:

      
        
        
          async function f() {
  return 1;
}
        
      
      
      La palabra “async” ante una función significa solamente una cosa: que la función siempre devolverá una promesa. Otros valores serán envueltos y resueltos en una promesa automáticamente.
Por ejemplo, esta función devuelve una promesa resuelta con el resultado de 1; Probémosla:

      
        
        
          
            
          
          
            
          
        
        
          async function f() {
  return 1;
}

f().then(alert); // 1
        
      
      
      …Podríamos explícitamente devolver una promesa, lo cual sería lo mismo:

      
        
        
          
            
          
          
            
          
        
        
          async function f() {
  return Promise.resolve(1);
}

f().then(alert); // 1
        
      
      
      Entonces, async se asegura de que la función devuelva una promesa, o envuelve las no promesas y las transforma en una. Bastante simple, ¿correcto? Pero no solo eso. Hay otra palabra, await, que solo trabaja dentro de funciones async y es muy interesante.
AwaitLa sintaxis:

      
        
        
          // funciona solamente dentro de funciones async
let value = await promise;
        
      
      
      await hace que JavaScript espere hasta que la promesa responda y devuelve su resultado.
Aquí hay un ejemplo con una promesa que resuelve en 1 segundo:

      
        
        
          
            
          
          
            
          
        
        
          async function f() {

  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("¡Hecho!"), 1000)
  });

  let result = await promise; // espera hasta que la promesa se resuelva (*)

  alert(result); // "¡Hecho!"
}

f();
        
      
      
      La ejecución de la función es pausada en la línea (*) y se reanuda cuando la promesa responde, con result volviéndose su resultado. Entonces el código arriba muestra “¡Hecho!” en un segundo.
Enfaticemos: await literalmente suspende la ejecución de la función hasta que se establezca la promesa, y luego la reanuda con el resultado de la promesa. Eso no cuesta ningún recurso de CPU, porque el motor de JavaScript puede hacer otros trabajos mientras tanto: ejecutar otros scripts, manejar eventos, etc.
Es simplemente una sintaxis más elegante para tener el resultado de una promesa que promise.then, es más fácil de leer y de escribir.

            No se puede usar await en funciones comunes
            Si tratamos de usar await en una función no async, tendremos un error de sintaxis:

      
        
        
          
            
          
          
            
          
        
        
          function f() {
  let promise = Promise.resolve(1);
  let result = await promise; // Syntax error
}
        
      
      
      Es posible que obtengamos este error si olvidamos poner async antes de una función. Como se dijo, “await” solo funciona dentro de una función async.

Tomemos el ejemplo showAvatar() del capítulo Encadenamiento de promesas y rescribámoslo usando async/await:

Necesitaremos reemplazar los llamados .then con await.
También debemos hacer que la función sea async para que aquellos funcionen.


      
        
        
          
            
          
          
            
          
        
        
          async function showAvatar() {

  // leer nuestro JSON
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();

  // leer usuario github
  let githubResponse = await fetch(`https://api.github.com/users/${user.name}`);
  let githubUser = await githubResponse.json();

  // muestra el avatar
  let img = document.createElement('img');
  img.src = githubUser.avatar_url;
  img.className = "promise-avatar-example";
  document.body.append(img);

  // espera 3 segundos
  await new Promise((resolve, reject) => setTimeout(resolve, 3000));

  img.remove();

  return githubUser;
}

showAvatar();
        
      
      
      Bien limpio y fácil de leer, ¿no es cierto? Mucho mejor que antes.

            Los navegadores modernos permiten await en el nivel superior de los módulos
            En los navegadores modernos, await de nivel superior funciona, siempre que estamos dentro de un módulo. Cubriremos módulos en el artículo Módulos, introducción.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // asumimos que este código se ejecuta en el nivel superior dentro de un módulo
let response = await fetch('/article/promise-chaining/user.json');
let user = await response.json();

console.log(user);
        
      
      
      Si no estamos usando módulos, o necesitamos soportar navegadores antiguos, tenemos una receta universal: envolverlos en una función async anónima.
Así:

      
        
        
          (async () => {
  let response = await fetch('/article/promise-chaining/user.json');
  let user = await response.json();
  ...
})();
        
      
      
      

            await acepta “thenables”
            Tal como promise.then, await nos permite el uso de objetos “thenable” (aquellos con el método then). La idea es que un objeto de terceras partes pueda no ser una promesa, sino compatible con una: si soporta .then, es suficiente para el uso con await.
Aquí hay una demostración de la clase Thenable; el await debajo acepta sus instancias:

      
        
        
          
            
          
          
            
          
        
        
          class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve);
    // resuelve con this.num*2 después de 1000ms
    setTimeout(() => resolve(this.num * 2), 1000); // (*)
  }
}

async function f() {
  // espera durante 1 segundo, entonces el resultado se vuelve 2
  let result = await new Thenable(1);
  alert(result);
}

f();
        
      
      
      Si await obtiene un objeto no-promesa con .then, llama tal método proveyéndole con las funciones incorporadas resolve y reject como argumentos (exactamente como lo hace con ejecutores Promise regulares). Entonce await espera hasta que une de ellos es llamado (en el ejemplo previo esto pasa en la línea (*)) y entonces procede con el resultado.


            Métodos de clase Async
            Para declarar un método de clase async, simplemente se le antepone async:

      
        
        
          
            
          
          
            
          
        
        
          class Waiter {
  async wait() {
    return await Promise.resolve(1);
  }
}

new Waiter()
  .wait()
  .then(alert); // 1 (lo mismo que (result => alert(result)))
        
      
      
      El significado es el mismo: Asegura que el valor devuelto es una promesa y habilita await.

Manejo de ErrorSi una promesa se resuelve normalmente, entonces await promise devuelve el resultado. Pero en caso de rechazo, dispara un error, tal como si hubiera una instrucción throw en aquella línea.
Este código:

      
        
        
          async function f() {
  await Promise.reject(new Error("Whoops!"));
}
        
      
      
      …es lo mismo que esto:

      
        
        
          async function f() {
  throw new Error("Whoops!");
}
        
      
      
      En situaciones reales, la promesa tomará algún tiempo antes del rechazo.  En tal caso habrá un retardo antes de que await dispare un error.
Podemos atrapar tal error usando try..catch, de la misma manera que con un throw normal:

      
        
        
          
            
          
          
            
          
        
        
          async function f() {

  try {
    let response = await fetch('http://no-such-url');
  } catch(err) {
    alert(err); // TypeError: failed to fetch
  }
}

f();
        
      
      
      En el caso de un error, el control salta al bloque catch. Podemos también envolver múltiples líneas:

      
        
        
          
            
          
          
            
          
        
        
          async function f() {

  try {
    let response = await fetch('/no-user-here');
    let user = await response.json();
  } catch(err) {
    // atrapa errores tanto en fetch como en response.json
    alert(err);
  }
}

f();
        
      
      
      Si no tenemos try..catch, entonces la promesa generada por el llamado de la función async f() se vuelve rechazada. Podemos añadir .catch para manejarlo:

      
        
        
          
            
          
          
            
          
        
        
          async function f() {
  let response = await fetch('http://no-such-url');
}

// f() se vuelve una promesa rechazada
f().catch(alert); // TypeError: failed to fetch // (*)
        
      
      
      Si olvidamos añadir .catch allí, obtendremos un error de promesa no manejado (visible en consola). Podemos atrapar tales errores usando un manejador de evento global unhandledrejection como está descrito en el capítulo Manejo de errores con promesas.

            async/await y promise.then/catch
            Cuando usamos async/await, raramente necesitamos .then, porque await maneja la espera por nosotros. Y podemos usar un try..catch normal en lugar de .catch. Esto usualmente (no siempre) es más conveniente.
Pero en el nivel superior del código, cuando estamos fuera de cualquier función async, no estamos sintácticamente habilitados para usar await, entonces es práctica común agregar .then/catch para manejar el resultado final o errores que caigan a través, como en la línea (*) del ejemplo arriba.


            async/await funciona bien con Promise.all
            Cuando necesitamos esperar por múltiples promesas, podemos envolverlas en un Promise.all y luego await:

      
        
        
          // espera por el array de resultados
let results = await Promise.all([
  fetch(url1),
  fetch(url2),
  ...
]);
        
      
      
      En caso de error, se propaga como es usual, desde la promesa que falla a Promise.all, y entonces se vuelve una excepción que podemos atrapar usando try..catch alrededor del llamado.

ResumenEl comando async antes de una función tiene dos efectos:

Hace que siempre devuelva una promesa.
Permite que sea usado await dentro de ella.

El comando await antes de una promesa hace que JavaScript espere hasta que la promesa responda. Entonces:

Si es un error, la excepción es generada — lo mismo que si throw error fuera llamado en ese mismo lugar.
De otro modo, devuelve el resultado.

Juntos proveen un excelente marco para escribir código asincrónico que es fácil de leer y escribir.
Con async/await raramente necesitamos escribir promise.then/catch, pero aún no deberíamos olvidar que están basados en promesas porque a veces (ej. como en el nivel superior de código) tenemos que usar esos métodos. También Promise.all es adecuado cuando esperamos por varias tareas simultáneas.
TareasRescribir usando async/awaitRescribir este código de ejemplo del capítulo Encadenamiento de promesas usando async/await en vez de .then/catch:

      
        
        
          
            
          
          
            
          
        
        
          function loadJson(url) {
  return fetch(url)
    .then(response => {
      if (response.status == 200) {
        return response.json();
      } else {
        throw new Error(response.status);
      }
    });
}

loadJson('https://javascript.info/no-such-user.json')
  .catch(alert); // Error: 404
        
      
      
      soluciónLas notas están bajo el código:

      
        
        
          
            
          
          
            
          
        
        
          async function loadJson(url) { // (1)
  let response = await fetch(url); // (2)

  if (response.status == 200) {
    let json = await response.json(); // (3)
    return json;
  }

  throw new Error(response.status);
}

loadJson('https://javascript.info/no-such-user.json')
  .catch(alert); // Error: 404 (4)
        
      
      
      Notas:


La función loadJson se vuelve async.


Todo lo que está dentro de .then es reemplazado por await.


Podemos devolver return response.json() en lugar de esperar por él, como esto:

      
        
        
          if (response.status == 200) {
  return response.json(); // (3)
}
        
      
      
      Entonces el código externo tendría que esperar que la promesa se resuelva. En nuestro caso eso no importa.


El error arrojado por loadJson es manejado por .catch. No podemos usar await loadJson(…) allí, porque no estamos en una función async.


Reescribir "rethrow" con async/awaitDebajo puedes encontrar el ejemplo “rethrow”. Rescríbelo usando async/await en vez de .then/catch.
Y deshazte de la recursión en favor de un bucle en demoGithubUser: con async/await, que se vuelve fácil de hacer.

      
        
        
          
            
          
          
            
          
        
        
          class HttpError extends Error {
  constructor(response) {
    super(`${response.status} for ${response.url}`);
    this.name = 'HttpError';
    this.response = response;
  }
}

function loadJson(url) {
  return fetch(url)
    .then(response => {
      if (response.status == 200) {
        return response.json();
      } else {
        throw new HttpError(response);
      }
    });
}

// Pide nombres hasta que github devuelve un usuario válido
function demoGithubUser() {
  let name = prompt("Ingrese un nombre:", "iliakan");

  return loadJson(`https://api.github.com/users/${name}`)
    .then(user => {
      alert(`Nombre completo: ${user.name}.`);
      return user;
    })
    .catch(err => {
      if (err instanceof HttpError && err.response.status == 404) {
        alert("No existe tal usuario, por favor reingrese.");
        return demoGithubUser();
      } else {
        throw err;
      }
    });
}

demoGithubUser();
        
      
      
      soluciónNo hay trampas aquí. Simplemente reemplaza .catch con try...catch dentro de demoGithubUser y agrega async/await donde sea necesario:

      
        
        
          
            
          
          
            
          
        
        
          class HttpError extends Error {
  constructor(response) {
    super(`${response.status} for ${response.url}`);
    this.name = 'HttpError';
    this.response = response;
  }
}

async function loadJson(url) {
  let response = await fetch(url);
  if (response.status == 200) {
    return response.json();
  } else {
    throw new HttpError(response);
  }
}

// Pregunta por un nombre de usuario hasta que github devuelve un usuario válido
async function demoGithubUser() {

  let user;
  while(true) {
    let name = prompt("Ingrese un nombre:", "iliakan");

    try {
      user = await loadJson(`https://api.github.com/users/${name}`);
      break; // sin error, salir del bucle
    } catch(err) {
      if (err instanceof HttpError && err.response.status == 404) {
        // bucle continúa después del alert
        alert("No existe tal usuario, por favor reingrese.");
      } else {
        // error desconocido, lo relanza
        throw err;
      }
    }
  }


  alert(`Nombre completo: ${user.name}.`);
  return user;
}

demoGithubUser();
        
      
      
      Llamado async desde un non-asyncTenemos una función “regular” llamada f. ¿Cómo llamar la función async, wait() y usar su  resultado dentro de f?

      
        
        
          async function wait() {
  await new Promise(resolve => setTimeout(resolve, 1000));

  return 10;
}

function f() {
  // ¿...qué escribir aquí?
  // Necesitamos llamar async wait() y esperar a obtener 10
  // recuerda, no podemos usar "await"
}
        
      
      
      P.D. La tarea es técnicamente muy simple, pero la pregunta es muy común en desarrolladores nuevos en async/await.
soluciónEste es el caso cuando saber cómo trabaja por dentro es útil.
Simplemente trata el llamado async como una promesa y añádele .then:

      
        
        
          
            
          
          
            
          
        
        
          async function wait() {
  await new Promise(resolve => setTimeout(resolve, 1000));

  return 10;
}

function f() {
  // muestra 10 después de 1 segundo
  wait().then(result => alert(result));
}

f();
        
      
      
      ",
	"url": "https://es.javascript.info/async-await" 
},
{
	"docs_id": "86",
	"name": "Generadores",
	"description": "Las funciones regulares devuelven solo un valor único (o nada).",
	"content": "Las funciones regulares devuelven solo un valor único (o nada).
Los generadores pueden producir (“yield”) múltiples valores, uno tras otro, a pedido. Funcionan muy bien con los iterables, permitiendo crear flujos de datos con facilidad.
Funciones GeneradorasPara crear un generador, necesitamos una construcción de sintaxis especial: function*, la llamada “función generadora”.
Se parece a esto:

      
        
        
          function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}
        
      
      
      Las funciones generadoras se comportan de manera diferente a las normales. Cuando se llama a dicha función, no ejecuta su código. En su lugar, devuelve un objeto especial, llamado “objeto generador”, para gestionar la ejecución.
Echa un vistazo aquí:

      
        
        
          
            
          
          
            
          
        
        
          function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

// "función generadora" crea "objeto generador"
let generator = generateSequence();
alert(generator); // [object Generator]
        
      
      
      La ejecución del código de la función aún no ha comenzado:

      
      
        
      
      El método principal de un generador es next(). Cuando se llama, se ejecuta hasta la declaración yield <value> más cercana (se puede omitir value, entonces será undefined). Luego, la ejecución de la función se detiene y el value obtenido se devuelve al código externo.
El resultado de next() es siempre un objeto con dos propiedades:

value: el valor de yield.
done: true si el código de la función ha terminado, de lo contrario false.

Por ejemplo, aquí creamos el generador y obtenemos su primer valor yield:

      
        
        
          
            
          
          
            
          
        
        
          function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

let one = generator.next();

alert(JSON.stringify(one)); // {value: 1, done: false}
        
      
      
      A partir de ahora, obtuvimos solo el primer valor y la ejecución de la función está en la segunda línea:

      
      
        
      
      Llamemos a generator.next() nuevamente. Reanuda la ejecución del código y devuelve el siguiente yield:

      
        
        
          let two = generator.next();

alert(JSON.stringify(two)); // {value: 2, done: false}
        
      
      
      
      
      
        
      
      Y, si lo llamamos por tercera vez, la ejecución llega a la declaración return que finaliza la función:

      
        
        
          let three = generator.next();

alert(JSON.stringify(three)); // {value: 3, done: true}
        
      
      
      
      
      
        
      
      Ahora el generador está listo. Deberíamos verlo desde done: true y procesar value: 3 como el resultado final.
Las nuevas llamadas a generator.next() ya no tienen sentido. Si las hacemos, devuelven el mismo objeto: {done: true}.

            ¿function* f(…) o function *f(…)?
            Ambas sintaxis son correctas.
Pero generalmente se prefiere la primera sintaxis, ya que la estrella * denota que es una función generadora, describe el tipo, no el nombre, por lo que debería seguir a la palabra clave function.

Los Generadores son iterablesComo probablemente ya adivinó mirando el método next(), los generadores son iterables.
Podemos recorrer sus valores usando for..of:

      
        
        
          
            
          
          
            
          
        
        
          function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

let generator = generateSequence();

for(let value of generator) {
  alert(value); // 1, then 2
}
        
      
      
      Parece mucho mejor que llamar a .next().value, ¿verdad?
… Pero tenga en cuenta: el ejemplo anterior muestra 1, luego2, y eso es todo. ¡No muestra 3!
Es porque la iteración for..of ignora el último value, cuando done: true. Entonces, si queremos que todos los resultados se muestren con for..of, debemos devolverlos con yield:

      
        
        
          
            
          
          
            
          
        
        
          function* generateSequence() {
  yield 1;
  yield 2;
  yield 3;
}

let generator = generateSequence();

for(let value of generator) {
  alert(value); // 1, luego 2, luego 3
}
        
      
      
      Como los generadores son iterables, podemos llamar a todas las funciones relacionadas, p. Ej. la sintaxis de propagación ...:

      
        
        
          
            
          
          
            
          
        
        
          function* generateSequence() {
  yield 1;
  yield 2;
  yield 3;
}

let sequence = [0, ...generateSequence()];

alert(sequence); // 0, 1, 2, 3
        
      
      
      En el código anterior, ... generateSequence () convierte el objeto generador iterable en un array de elementos (lea más sobre la sintaxis de propagación en el capítulo Parámetros Rest y operador Spread)
Usando generadores para iterablesHace algún tiempo, en el capítulo Iterables creamos un objeto iterable range que devuelve valores from..to.
Recordemos el código aquí:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5,

  // for..of range llama a este método una vez al principio
  [Symbol.iterator]() {
    // ...devuelve el objeto iterador:
    // en adelante, for..of funciona solo con ese objeto, solicitándole los siguientes valores
    return {
      current: this.from,
      last: this.to,

      // next() es llamado en cada iteración por el bucle for..of
      next() {
        // debería devolver el valor como un objeto {done:.., value :...}
        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

// iteración sobre range devuelve números desde range.from  a range.to
alert([...range]); // 1,2,3,4,5
        
      
      
      Podemos utilizar una función generadora para la iteración proporcionándola como Symbol.iterator.
Este es el mismo range, pero mucho más compacto:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5,

  *[Symbol.iterator]() { // una taquigrafía para [Symbol.iterator]: function*()
    for(let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};

alert( [...range] ); // 1,2,3,4,5
        
      
      
      Eso funciona, porque range[Symbol.iterator]() ahora devuelve un generador, y los métodos de generador son exactamente lo que espera for..of:

tiene un método .next()
que devuelve valores en la forma {value: ..., done: true/false}

Eso no es una coincidencia, por supuesto. Los generadores se agregaron al lenguaje JavaScript con iteradores en mente, para implementarlos fácilmente.
La variante con un generador es mucho más concisa que el código iterable original de range y mantiene la misma funcionalidad.

            Los generadores pueden generar valores para siempre
            En los ejemplos anteriores, generamos secuencias finitas, pero también podemos hacer un generador que produzca valores para siempre. Por ejemplo, una secuencia interminable de números pseudoaleatorios.
Eso seguramente requeriría un break (o return) en for..of sobre dicho generador. De lo contrario, el bucle se repetiría para siempre y se colgaría.

Composición del generadorLa composición del generador es una característica especial de los generadores que permite “incrustar” generadores entre sí de forma transparente.
Por ejemplo, tenemos una función que genera una secuencia de números:

      
        
        
          function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}
        
      
      
      Ahora nos gustaría reutilizarlo para generar una secuencia más compleja:

primero, dígitos 0..9 (con códigos de caracteres 48…57),
seguido de letras mayúsculas del alfabeto A..Z (códigos de caracteres 65…90)
seguido de letras del alfabeto en minúscula a..z (códigos de carácter 97…122)

Podemos usar esta secuencia, p. Ej. para crear contraseñas seleccionando caracteres de él (también podría agregar caracteres de sintaxis), pero vamos a generarlo primero.
En una función regular, para combinar los resultados de muchas otras funciones, las llamamos, almacenamos los resultados y luego nos unimos al final.
Para los generadores, hay una sintaxis especial yield* para “incrustar” (componer) un generador en otro.
El generador compuesto:

      
        
        
          
            
          
          
            
          
        
        
          function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* generatePasswordCodes() {

  // 0..9
  yield* generateSequence(48, 57);

  // A..Z
  yield* generateSequence(65, 90);

  // a..z
  yield* generateSequence(97, 122);

}

let str = '';

for(let code of generatePasswordCodes()) {
  str += String.fromCharCode(code);
}

alert(str); // 0..9A..Za..z
        
      
      
      La directiva yield* delega la ejecución a otro generador. Este término significa que yield* gen itera sobre el generador gen y reenvía de forma transparente sus yields al exterior. Como si los valores fueran proporcionados por el generador externo.
El resultado es el mismo que si insertamos el código de los generadores anidados:

      
        
        
          
            
          
          
            
          
        
        
          function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) yield i;
}

function* generateAlphaNum() {

  // yield* generateSequence(48, 57);
  for (let i = 48; i <= 57; i++) yield i;

  // yield* generateSequence(65, 90);
  for (let i = 65; i <= 90; i++) yield i;

  // yield* generateSequence(97, 122);
  for (let i = 97; i <= 122; i++) yield i;

}

let str = '';

for(let code of generateAlphaNum()) {
  str += String.fromCharCode(code);
}

alert(str); // 0..9A..Za..z
        
      
      
      La composición de un generador es una forma natural de insertar un flujo de un generador en otro. No usa memoria adicional para almacenar resultados intermedios.
“yield” es una calle de doble sentidoHasta este momento, los generadores eran similares a los objetos iterables, con una sintaxis especial para generar valores. Pero de hecho son mucho más potentes y flexibles.
Eso es porque yield es una calle de doble sentido: no solo devuelve el resultado al exterior, sino que también puede pasar el valor dentro del generador.
Para hacerlo, deberíamos llamar a generator.next (arg), con un argumento. Ese argumento se convierte en el resultado de yield.
Veamos un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          function* gen() {
  // Pasar una pregunta al código externo y esperar una respuesta
  let result = yield "2 + 2 = ?"; // (*)

  alert(result);
}

let generator = gen();

let question = generator.next().value; // <-- yield devuelve el valor

generator.next(4); // --> pasar el resultado al generador
        
      
      
      
      
      
        
      
      
La primera llamada a generator.next () debe hacerse siempre sin un argumento (el argumento se ignora si se pasa). Inicia la ejecución y devuelve el resultado del primer yield "2 + 2 = ?". En este punto, el generador detiene la ejecución, mientras permanece en la línea (*).
Luego, como se muestra en la imagen de arriba, el resultado de yield entra en la variable question en el código de llamada.
En generator.next(4), el generador se reanuda y 4 entra como resultado: let result = 4.

Tenga en cuenta que el código externo no tiene que llamar inmediatamente a next(4). Puede que lleve algún tiempo. Eso no es un problema: el generador esperará.
Por ejemplo:

      
        
        
          // reanudar el generador después de algún tiempo
setTimeout(() => generator.next(4), 1000);
        
      
      
      Como podemos ver, a diferencia de las funciones regulares, un generador y el código de llamada pueden intercambiar resultados pasando valores en next/yield.
Para hacer las cosas más obvias, aquí hay otro ejemplo, con más llamadas:

      
        
        
          
            
          
          
            
          
        
        
          function* gen() {
  let ask1 = yield "2 + 2 = ?";

  alert(ask1); // 4

  let ask2 = yield "3 * 3 = ?"

  alert(ask2); // 9
}

let generator = gen();

alert( generator.next().value ); // "2 + 2 = ?"

alert( generator.next(4).value ); // "3 * 3 = ?"

alert( generator.next(9).done ); // true
        
      
      
      Imagen de la ejecución:

      
      
        
      
      
El primer .next() inicia la ejecución … Llega al primer yield.
El resultado se devuelve al código externo.
El segundo .next(4) pasa 4 de nuevo al generador como resultado del primer yield y reanuda la ejecución.
…Alcanza el segundo yield, que se convierte en el resultado de la llamada del generador.
El tercer next(9) pasa 9 al generador como resultado del segundo yield y reanuda la ejecución que llega al final de la función, así que done: true.

Es como un juego de “ping-pong”. Cada next(value) (excluyendo el primero) pasa un valor al generador, que se convierte en el resultado del yield actual, y luego recupera el resultado del siguiente yield.
generator.throwComo observamos en los ejemplos anteriores, el código externo puede pasar un valor al generador, como resultado de yield.
…Pero también puede iniciar (lanzar) un error allí. Eso es natural, ya que un error es una especie de resultado.
Para pasar un error a un yield, deberíamos llamar a generator.throw(err). En ese caso, el err se coloca en la línea con ese yield.
Por ejemplo, aquí el yield de "2 + 2 = ?" conduce a un error:

      
        
        
          
            
          
          
            
          
        
        
          function* gen() {
  try {
    let result = yield "2 + 2 = ?"; // (1)

    alert("La ejecución no llega aquí, porque la excepción se lanza arriba");
  } catch(e) {
    alert(e); // muestra el error
  }
}

let generator = gen();

let question = generator.next().value;

generator.throw(new Error("The answer is not found in my database")); // (2)
        
      
      
      El error, arrojado al generador en la línea (2) conduce a una excepción en la línea (1) con yield. En el ejemplo anterior, try..catch lo captura y lo muestra.
Si no lo detectamos, al igual que cualquier excepción, “cae” del generador en el código de llamada.
La línea actual del código de llamada es la línea con generator.throw, etiquetada como (2). Entonces podemos atraparlo aquí, así:

      
        
        
          
            
          
          
            
          
        
        
          function* generate() {
  let result = yield "2 + 2 = ?"; // Error en esta linea
}

let generator = generate();

let question = generator.next().value;

try {
  generator.throw(new Error("La respuesta no se encuentra en mi base de datos"));
} catch(e) {
  alert(e); // mostrar el error
}
        
      
      
      Si no detectamos el error allí, entonces, como de costumbre, pasa al código de llamada externo (si lo hay) y, si no se detecta, mata el script.
generator.returngenerator.return(value) detiene la ejecución de generator y devuelve el valor value dado.

      
        
        
          function* gen() {
  yield 1;
  yield 2;
  yield 3;
}

const g = gen();

g.next();        // { value: 1, done: false }
g.return('foo'); // { value: "foo", done: true }
g.next();        // { value: undefined, done: true }
        
      
      
      Si volvemos a usar generator.return() en un generator finalizado, devolverá ese valor nuevamente (MDN).
No lo usamos a menudo, ya que la mayor parte del tiempo queremos todos los valores, pero puede ser útil cuando queremos detener el generador en una condición específica.
Resumen
Los generadores son creados por funciones generadoras function* f(…) {…}.
Dentro de los generadores (solo) existe un operador yield.
El código externo y el generador pueden intercambiar resultados a través de llamadas next/yield.

En JavaScript moderno, los generadores rara vez se utilizan. Pero a veces son útiles, porque la capacidad de una función para intercambiar datos con el código de llamada durante la ejecución es bastante única. Y, seguramente, son geniales para hacer objetos iterables.
Además, en el próximo capítulo aprenderemos los generadores asíncronos, que se utilizan para leer flujos de datos generados asincrónicamente (por ejemplo, recuperaciones paginadas a través de una red) en bucles for await ... of.
En la programación web, a menudo trabajamos con datos transmitidos, por lo que ese es otro caso de uso muy importante.
TareasGenerador pseudoaleatorioHay muchas áreas en las que necesitamos datos aleatorios.
Uno de ellos es para testeo. Es posible que necesitemos datos aleatorios: texto, números, etc. para probar bien las cosas.
En JavaScript, podríamos usar Math.random(). Pero si algo sale mal, nos gustaría poder repetir la prueba utilizando exactamente los mismos datos.
Para eso, se utilizan los denominados “generadores pseudoaleatorios con semilla”. Toman una “semilla” como primer valor, y luego generan los siguientes utilizando una fórmula; a partir de la misma semilla se produce la misma secuencia y así todo el flujo es fácilmente reproducible. Solo necesitamos recordar la semilla para repetirla.
Un ejemplo de dicha fórmula, que genera valores distribuidos de manera algo uniforme:

      
        
        
          next = previous * 16807 % 2147483647
        
      
      
      Si nosotros usamos 1 como semilla, los valores serán:

16807
282475249
1622650073
…y así…

La tarea es crear una función generadora pseudoRandom (seed) que toma seed y crea el generador con esta fórmula.
Ejemplo de uso

      
        
        
          let generator = pseudoRandom(1);

alert(generator.next().value); // 16807
alert(generator.next().value); // 282475249
alert(generator.next().value); // 1622650073
        
      
      
      Abrir en entorno controlado con pruebas.solución
      
        
        
          
            
          
          
            
          
        
        
          function* pseudoRandom(seed) {
  let value = seed;

  while(true) {
    value = value * 16807 % 2147483647
    yield value;
  }

};

let generator = pseudoRandom(1);

alert(generator.next().value); // 16807
alert(generator.next().value); // 282475249
alert(generator.next().value); // 1622650073
        
      
      
      Tenga en cuenta que se puede hacer lo mismo con una función regular, como esta:

      
        
        
          
            
          
          
            
          
        
        
          function pseudoRandom(seed) {
  let value = seed;

  return function() {
    value = value * 16807 % 2147483647;
    return value;
  }
}

let generator = pseudoRandom(1);

alert(generator()); // 16807
alert(generator()); // 282475249
alert(generator()); // 1622650073
        
      
      
      Eso también funciona. Pero entonces perdemos la capacidad de iterar con for..of y usar la composición del generador, que puede ser útil en otros lugares.
Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/generators" 
},
{
	"docs_id": "87",
	"name": "Iteradores y generadores asíncronos",
	"description": "Los iteradores asíncronos nos permiten iterar sobre los datos que vienen de forma asíncrona, en una petición. Como, por ejemplo, cuando descargamos algo por partes a través de una red. Y los generadores asíncronos lo hacen aún más conveniente.",
	"content": "Los iteradores asíncronos nos permiten iterar sobre los datos que vienen de forma asíncrona, en una petición. Como, por ejemplo, cuando descargamos algo por partes a través de una red. Y los generadores asíncronos lo hacen aún más conveniente.
Veamos primero un ejemplo simple, para comprender la sintaxis y luego revisar un caso de uso de la vida real.
Repaso de iterablesRepasemos el tópico acerca de iterables.
La idea es que tenemos un objeto, tal como range aquí:

      
        
        
          let range = {
  from: 1,
  to: 5
};
        
      
      
      …Y queremos usar un bucle for..of en él, tal como for(value of range), para obtener valores desde 1 hasta 5.
En otras palabras, queremos agregar la habilidad de iteración al objeto.
Eso puede ser implementado usando un método especial con el nombre Symbol.iterator:

Este método es llamado por la construcción for..of cuando comienza el bucle, y debe devolver un objeto con el método next.
Para cada iteración, el método next() es invocado para el siguiente valor.
El next() debe devolver un valor en el formato {done: true/false, value:<loop value>}, donde done:true significa el fin del bucle.

Aquí hay una implementación de range iterable:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5,

  [Symbol.iterator]() { // llamado una vez, en el principio de for..of
    return {
      current: this.from,
      last: this.to,

      next() { // llamado en cada iteración, para obtener el siguiente valor
        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

for(let value of range) {
  alert(value); // 1 luego 2, luego 3, luego 4, luego 5
}
        
      
      
      Si es necesario, consulte el capitulo Iterables para ver más detalles sobre iteradores normales.
Iteradores asíncronosLa iteración asincrónica es necesaria cuando los valores vienen asincrónicamente: después de setTimeout u otra clase de retraso.
El caso más común es un objeto que necesita hacer un pedido sobre la red para enviar el siguiente valor, veremos un ejemplo de la vida real algo más adelante.
Para hacer un objeto iterable asincrónicamente:

Use Symbol.asyncIterator en lugar de Symbol.iterator.
El método next() debe devolver una promesa (a ser cumplida con el siguiente valor).

La palabra clave async lo maneja, nosotros simplemente hacemos async next().


Para iterar sobre tal objeto, debemos usar un bucle for await (let item of iterable).

Note la palabra await.



Como ejemplo inicial, hagamos iterable un objeto range object, similar al anterior, pero ahora devolverá valores asincrónicamente, uno por segundo.
Todo lo que necesitamos hacer es algunos reemplazos en el código de abajo:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5,

  [Symbol.asyncIterator]() { // (1)
    return {
      current: this.from,
      last: this.to,

      async next() { // (2)

        // nota: podemos usar "await" dentro de el async next:
        await new Promise(resolve => setTimeout(resolve, 1000)); // (3)

        if (this.current <= this.last) {
          return { done: false, value: this.current++ };
        } else {
          return { done: true };
        }
      }
    };
  }
};

(async () => {

  for await (let value of range) { // (4)
    alert(value); // 1,2,3,4,5
  }

})()
        
      
      
      Como podemos ver, la estructura es similar a un iterador normal:

Para hacer que un objeto sea asincrónicamente iterable, debe tener un método Symbol.asyncIterator (1).
Este método debe devolver el objeto con el método next() retornando una promesa (2).
El método next() no tiene que ser async, puede ser un método normal que devuelva una promesa, pero async nos permite usar await, entonces, es más conveniente. Aquí solo nos demoramos un segundo. (3).
Para iterar, nosotros usamos for await(let value of range) (4), es decir, agregar “await” y después “for”. Llama range[Symbol.asyncIterator]() una vez, y luego next() para los valores.

Aquí hay una pequeña tabla con las diferencias:




Iteradores
Iteradores asíncronos




Método de objeto para proporcionar el iterador
Symbol.iterator
Symbol.asyncIterator


next() el valor de retorno es
cualquier valor
Promise


en bucle, usar
for..of
for await..of




            La sintaxis de propagación o spread (…) no funciona de forma asíncrona
            Las características que requieren iteradores normales y sincrónicos no funcionan con los asincrónicos.
Por ejemplo, una sintaxis de propagación no funciona:

      
        
        
          alert( [...range] ); // Error, no Symbol.iterator
        
      
      
      Eso es natural, ya que espera encontrar Symbol.iterator, no Symbol.asyncIterator.
También es el caso de for..of: la sintaxis sin await necesita Symbol.iterator.

Repaso de generatorsAhora repasemos generators, que permiten una iteración mucho más corta. La mayoría de las veces, cuando queramos hacer un iterable, usaremos generators.
Para simplicidad, omitiendo cosas importantes, son “funciones que generan (yield) valores”. Son explicados en detalle en el capítulo Generadores.
Los generators son etiquetados con function* (nota el asterisco) y usa yield para generar un valor, entonces podemos usar el bucle for..of en ellos.
Este ejemplo genera una secuencia de valores desde start hasta end:

      
        
        
          
            
          
          
            
          
        
        
          function* generateSequence(start, end) {
  for (let i = start; i <= end; i++) {
    yield i;
  }
}

for(let value of generateSequence(1, 5)) {
  alert(value); // 1, luego 2, luego 3, luego 4, luego 5
}
        
      
      
      Como ya sabemos, para hacer un objeto iterable, debemos agregarle Symbol.iterator.

      
        
        
          let range = {
  from: 1,
  to: 5,
  [Symbol.iterator]() {
    return <objeto con next para hacer el range iterable>
  }
}
        
      
      
      Una práctica común para Symbol.iterator es devolver un generador, este hace el código más corto como puedes ver:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5,

  *[Symbol.iterator]() { // forma abreviada de [Symbol.iterator]: function*()
    for(let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }
};

for(let value of range) {
  alert(value); // 1, luego 2, luego 3, luego 4, luego 5
}
        
      
      
      Puedes revisar el capítulo Generadores si quieres más detalles.
En generadores regulares no podemos usar await. Todos los valores deben venir sincrónicamente como son requeridos por la construcción for..of.
Pero, ¿qué pasa si necesitamos usar await en el cuerpo del generador? Para realizar solicitudes de red, por ejemplo.
Cambiemos a generadores asincrónicos para hacerlo posible.
Generadores asíncronos (finalmente)Para aplicaciones más prácticas, cuando queremos hacer un objeto que genere una secuencia de valores asincrónicamente, podemos usar un generador asincrónico.
La sintaxis es simple: anteponga async a function*. Esto hace al generador asincrónico.
Entonce usamos for await (...) para iterarlo, como esto:

      
        
        
          
            
          
          
            
          
        
        
          async function* generateSequence(start, end) {

  for (let i = start; i <= end; i++) {

    // si, ¡puede usar await!
    await new Promise(resolve => setTimeout(resolve, 1000));

    yield i;
  }

}

(async () => {

  let generator = generateSequence(1, 5);
  for await (let value of generator) {
    alert(value); // 1, luego 2, luego 3, luego 4, luego 5 (con retraso entre ellos)
  }

})();
        
      
      
      Como el generador es asincrónico, podemos usar await dentro de él, contar con promesas, hacer solicitudes de red y así.

            Diferencia bajo la capa
            Técnicamente, si eres un lector avanzado que recuerda los detalles de los generadores, hay una diferencia interna.
En los generadores asincrónicos, el método generator.next() es asincrónico, devuelve promesas.
En un generador normal usaríamos result = generator.next() para obtener valores. En un generador asíncrono debemos agregar await, así:

      
        
        
          result = await generator.next(); // resultado = {value: ..., done: true/false}
        
      
      
      Por ello los generadores async funcionan con for await...of.

Range asincrónico iterableGeneradores regulares pueden ser usados como Symbol.iterator para hacer la iteración más corta.
Similarmente los generadores async pueden ser usados como Symbol.asyncIterator para implementar iteración asincrónica.
Por ejemplo, podemos hacer que el objeto range genere valores asincrónicamente, una vez por segundo, reemplazando el Symbol.iterator sincrónico con el asincrónico Symbol.asyncIterator:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  from: 1,
  to: 5,

  // esta línea es la misma que [Symbol.asyncIterator]: async function*() {
  async *[Symbol.asyncIterator]() {
    for(let value = this.from; value <= this.to; value++) {

      // hacer una pausa entre valores, esperar algo
      await new Promise(resolve => setTimeout(resolve, 1000));

      yield value;
    }
  }
};

(async () => {

  for await (let value of range) {
    alert(value); // 1, luego 2, luego 3, luego 4, luego 5
  }

})();
        
      
      
      Ahora los valores vienen con retraso de 1 segundo entre ellos.

            Por favor tome nota:
            Técnicamente podemos agregar al objeto ambos, Symbol.iterator y Symbol.asyncIterator, así será ambas cosas: sincrónicamente (for..of) y asincrónicamente (for await..of) iterables.
Aunque en la práctica es una cosa extraña para hacer.

Ejemplo de la vida real: datos paginadosHasta ahora hemos visto ejemplos simples, para obtener una comprensión básica. Ahora revisemos un caso de uso de la vida real.
Hay muchos servicios en línea que entregan datos paginados. Por ejemplo, cuando necesitamos una lista de usuarios, una solicitud devuelve un recuento predefinido (por ejemplo, 100 usuarios): “una página” y proporciona una URL a la página siguiente.
Este patrón es muy común. No se trata de usuarios, sino de cualquier cosa.
Por ejemplo, GitHub nos permite recuperar commits de la misma manera paginada:

Deberíamos realizar una solicitud de URL en el formulario https://api.github.com/repos/<repo>/commits.
Esto responde con un JSON de 30 commits, y también proporciona un enlace a la siguiente página en la cabecera.
Entonces podemos usar ese enlace para la próxima solicitud, para obtener más commits, y así sucesivamente.

Para nuestro código querríamos una manera más simple de obtener commits.
Hagamos una función fetchCommits(repo) que tome commits por nosotros, haciendo solicitudes cuando sea necesario. Y dejar que se preocupe por todas las cosas de paginación. Para nosotros un simple for await..of.
Su uso será como esto:

      
        
        
          for await (let commit of fetchCommits("username/repository")) {
  // process commit
}
        
      
      
      Esta es la función implementada con generadores asíncronos:

      
        
        
          async function* fetchCommits(repo) {
  let url = `https://api.github.com/repos/${repo}/commits`;

  while (url) {
    const response = await fetch(url, { // (1)
      headers: {'User-Agent': 'Our script'}, // github requiere encabezado de user-agent
    });

    const body = await response.json(); // (2) la respuesta es un JSON (array de commits)

    // (3) la URL de la página siguiente está en los encabezados, extráigala
    let nextPage = response.headers.get('Link').match(/<(.*?)>; rel="next"/);
    nextPage = nextPage?.[1];

    url = nextPage;

    for(let commit of body) { // (4) concede commits uno por uno, hasta que termine la página
      yield commit;
    }
  }
}
        
      
      
      Explayando más sobre cómo funciona:


Usamos el método del navegador fetch para descargar los commits.

La URL inicial es https://api.github.com/repos/<repo>/commits, y la siguiente página estará en la cabecera de Link de la respuesta.
El método fetch nos permite suministrar autorización y otras cabeceras si lo necesitamos, aquí GitHub requiere User-Agent.



Los commits son devueltos en formato JSON.


Deberíamos obtener la siguiente URL de la página del enlace en el encabezado de la respuesta. Esto tiene un formato especial, por lo que usamos una expresión regular para eso (aprenderemos esta característica en Regular expressions).

La URL de la página siguiente puede verse así https://api.github.com/repositories/93253246/commits?page=2. Eso es generado por el propio Github.



Luego entregamos uno por uno todos los “commit” recibidos y, cuando finalizan, se activará la siguiente iteración while(url) haciendo una solicitud más.


Un ejemplo de uso (muestra autores de commit en la consola):

      
        
        
          
            
          
          
            
          
        
        
          (async () => {

  let count = 0;

  for await (const commit of fetchCommits('javascript-tutorial/en.javascript.info')) {

    console.log(commit.author.login);

    if (++count == 100) { // paremos a los 100 commits
      break;
    }
  }

})();

// Nota: Si ejecutas este código en una caja de pruebas externa, necesitas copiar aquí la función fetchCommits descrita más arriba
        
      
      
      Eso es justo lo que queríamos.
La mecánica interna de las solicitudes paginadas es invisible desde el exterior. Para nosotros es solo un generador asíncrono que devuelve commits.
ResumenLos iteradores y generadores normales funcionan bien con los datos que no llevan tiempo para ser generados.
Cuando esperamos que los datos lleguen de forma asíncrona, con demoras, se pueden usar sus contrapartes asíncronas, y for await..of en lugar de for..of.
Diferencias sintácticas entre iteradores asíncronos y normales:




Iterador
Iterador asíncrono




Método para proporcionar un iterador
Symbol.iterator
Symbol.asyncIterator


next() el valor de retorno es
{value:…, done: true/false}
Promise que resuelve como {value:…, done: true/false}



Diferencias sintácticas entre generadores asíncronos y normales:




Generadores
Generadores asíncronos




Declaración
function*
async function*


next() el valor de retorno es
{value:…, done: true/false}
Promise que resuelve como {value:…, done: true/false}



En el desarrollo web, a menudo nos encontramos con flujos de datos que fluyen trozo a trozo. Por ejemplo, descargar o cargar un archivo grande.
Podemos usar generadores asíncronos para procesar dichos datos. También es digno de mencionar que en algunos entornos, como en los navegadores, también hay otra API llamada Streams, que proporciona interfaces especiales para trabajar con tales flujos, para transformar los datos y pasarlos de un flujo a otro (por ejemplo, descargar de un lugar e inmediatamente enviar a otra parte).
",
	"url": "https://es.javascript.info/async-iterators-generators" 
},
{
	"docs_id": "88",
	"name": "Módulos, introducción",
	"description": "A medida que nuestra aplicación crece, queremos dividirla en múltiples archivos, llamados “módulos”. Un módulo puede contener una clase o una biblioteca de funciones para un propósito específico.",
	"content": "A medida que nuestra aplicación crece, queremos dividirla en múltiples archivos, llamados “módulos”. Un módulo puede contener una clase o una biblioteca de funciones para un propósito específico.
Durante mucho tiempo, JavaScript existió sin una sintaxis de módulo a nivel de lenguaje. Eso no fue un problema, porque inicialmente los scripts eran pequeños y simples, por lo que no era necesario.
Pero con el tiempo los scripts se volvieron cada vez más complejos, por lo que la comunidad inventó una variedad de formas de organizar el código en módulos, bibliotecas especiales para cargar módulos a pedido.
Para nombrar algunos (por razones históricas):

AMD – uno de los sistemas de módulos más antiguos, implementado inicialmente por la biblioteca require.js.
CommonJS – el sistema de módulos creado para el servidor Node.js.
UMD – un sistema de módulos más, sugerido como universal, compatible con AMD y CommonJS.

Ahora, todo esto se convierte lentamente en una parte de la historia, pero aún podemos encontrarlos en viejos scripts.
El sistema de módulos a nivel de idioma apareció en el estándar en 2015, evolucionó gradualmente desde entonces y ahora es compatible con todos los principales navegadores y en Node.js. Así que estudiaremos los módulos modernos de Javascript de ahora en adelante.
Qué es un módulo?Un módulo es solo un archivo. Un script es un módulo. Tan sencillo como eso.
Los módulos pueden cargarse entre sí y usar directivas especiales export e import para intercambiar funcionalidad, llamar a funciones de un módulo de otro:

La palabra clave export etiqueta las variables y funciones que deberían ser accesibles desde fuera del módulo actual.
import permite importar funcionalidades desde otros módulos.

Por ejemplo, si tenemos un archivo sayHi.js que exporta una función:

      
        
        
          // 📁 sayHi.js
export function sayHi(user) {
  alert(`Hello, ${user}!`);
}
        
      
      
      …Luego, otro archivo puede importarlo y usarlo:

      
        
        
          // 📁 main.js
import {sayHi} from './sayHi.js';

alert(sayHi); // function...
sayHi('John'); // Hello, John!
        
      
      
      La directiva import carga el módulo por la ruta ./sayHi.js relativo con el archivo actual, y asigna la función exportada sayHi a la variable correspondiente.
Ejecutemos el ejemplo en el navegador.
Como los módulos admiten palabras clave y características especiales, debemos decirle al navegador que un script debe tratarse como un módulo, utilizando el atributo <script type =" module ">.
Asi:
Resultadosay.jsindex.htmlexport function sayHi(user) {
  return `Hello, ${user}!`;
}<!doctype html>
<script type="module">
  import {sayHi} from './say.js';

  document.body.innerHTML = sayHi('John');
</script>El navegador busca y evalúa automáticamente el módulo importado (y sus importaciones si es necesario), y luego ejecuta el script.

            Los módulos funcionan solo a través de HTTP(s), no localmente
            Si intenta abrir una página web localmente a través del protocolo file://, encontrará que las directivas import y export no funcionan. Use un servidor web local, como static-server  o use la capacidad de “servidor en vivo” de su editor, como VS Code Live Server Extension para probar los módulos.

Características del módulo central¿Qué hay de diferente en los módulos en comparación con los scripts “normales”?
Hay características principales, válidas tanto para el navegador como para JavaScript del lado del servidor.
Siempre en modo estrictoLos módulos siempre trabajan en modo estricto. Por ejemplo, asignar a una variable sin declarar nos dará un error.

      
        
        
          
            
          
          
            
          
        
        
          <script type="module">
  a = 5; // error
</script>
        
      
      
      Alcance a nivel de móduloCada módulo tiene su propio alcance de nivel superior. En otras palabras, las variables y funciones de nivel superior de un módulo no se ven en otros scripts.
En el siguiente ejemplo, se importan dos scripts y hello.js intenta usar la variable user declarada en user.js. Falla, porque es un módulo separado (puedes ver el error en la consola):
Resultadohello.jsuser.jsindex.htmlalert(user); // no existe tal variable (cada módulo tiene variables independientes)let user = "John";<!doctype html>
<script type="module" src="user.js"></script>
<script type="module" src="hello.js"></script>Los módulos deben hacer export a lo que ellos quieren que esté accesible desde afuera y hacer import de lo que necesiten.

user.js debe exportar la variable user .
hello.js debe importarla desde el módulo user.js.

En otra palabras, con módulos usamos import/export en lugar de depender de variables globales.
Esta es la variante correcta:
Resultadohello.jsuser.jsindex.htmlimport {user} from './user.js';

document.body.innerHTML = user; // Johnexport let user = "John";<!doctype html>
<script type="module" src="hello.js"></script>En el navegador, hablando de páginas HTML, también existe el alcance independiente de nivel superior para cada <script type="module">:
Aquí hay dos scripts en la misma página, ambos type="module". No ven entre sí sus variables de nivel superior:

      
        
        
          
            
          
          
            
          
        
        
          <script type="module">
  // La variable sólo es visible en éste script de módulo
  let user = "John";
</script>

<script type="module">
  alert(user); // Error: user no está definido
</script>
        
      
      
      
            Por favor tome nota:
            En el navegador, podemos hacer que una variable sea global a nivel window si explícitamente la asignamos a la propiedad window, por ejemplo window.user = "John".
Así todos los scripts la verán, con o sin type="module".
Dicho esto, hacer este tipo de variables globales está muy mal visto. Por favor evítalas.

Un código de módulo se evalúa solo la primera vez cuando se importaSi el mismo módulo se importa en varios otros módulos, su código se ejecuta solo una vez: en el primer import. Luego, sus exportaciones se otorgan a todos los importadores que siguen.
Eso tiene consecuencias importantes para las que debemos estar prevenidos.
Echemos un vistazo usando ejemplos:
Primero, si ejecutar un código de módulo trae efectos secundarios, como mostrar un mensaje, importarlo varias veces lo activará solo una vez, la primera vez:

      
        
        
          // 📁 alert.js
alert("Módulo es evaluado!");
        
      
      
      
      
        
        
          // Importar el mismo módulo desde archivos distintos

// 📁 1.js
import `./alert.js`; // Módulo es evaluado!

// 📁 2.js
import `./alert.js`; // (no muestra nada)
        
      
      
      El segundo import no muestra nada, porque el módulo ya fue evaluado.
Existe una regla: el código de módulos del nivel superior debe ser usado para la inicialización y creación de estructuras de datos internas específicas del módulo. Si necesitamos algo que pueda ser llamado varias veces debemos exportarlo como una función, como hicimos con el sayHi de arriba.
Consideremos un ejemplo más avanzado.
Digamos que un módulo exporta un objeto:

      
        
        
          // 📁 admin.js
export let admin = {
  name: "John"
};
        
      
      
      Si este módulo se importa desde varios archivos, el módulo solo se evalúa la primera vez, se crea el objeto admin y luego se pasa a todos los importadores adicionales.
Todos los importadores obtienen exactamente el único objeto admin:

      
        
        
          // 📁 1.js
import {admin} from './admin.js';
admin.name = "Pete";

// 📁 2.js
import {admin} from './admin.js';
alert(admin.name); // Pete

// Ambos 1.js y 2.js hacen referencia al mismo objeto admin
// Los cambios realizados en 1.js son visibles en 2.js
        
      
      
      Como puedes ver, cuando 1.js cambia la propiedad name en el admin importado, entonces 2.js puede ver el nuevo admin.name.
Esto es porque el modulo se ejecuta solo una vez. Los exports son generados y luego compartidos entre importadores, entonces si algo cambia en el objeto admin, otros importadores lo verán.
Tal comportamiento es en verdad muy conveniente, porque nos permite configurar módulos.
En otras palabras, un módulo puede brindar una funcionalidad genérica que necesite ser configurada. Por ejemplo, la autenticación necesita credenciales. Entonces se puede exportar un objeto de configuración esperando que el código externo se lo asigne.
Aquí está el patrón clásico:

Un módulo exporta algún medio de configuración, por ejemplo un  objeto configuración.
En el primer import lo inicializamos, escribimos en sus propiedades. Los scripts de la aplicación de nivel superior pueden hacerlo.
Importaciones posteriores usan el módulo.

Por ejemplo, el módulo admin.js puede proporcionar cierta funcionalidad (ej. autenticación), pero espera que las credenciales entren al objeto admin desde afuera:

      
        
        
          // 📁 admin.js
export let config = { };

export function sayHi() {
  alert(`Ready to serve, ${config.user}!`);
}
        
      
      
      Aquí admin.js exporta el objeto config (inicialmente vacío, pero podemos tener propiedades por defecto también).
Entonces en init.js, el primer script de nuestra app, importamos config de él y establecemos config.user:

      
        
        
          // 📁 init.js
import {config} from './admin.js';
config.user = "Pete";
        
      
      
      …Ahora el módulo admin.js está configurado.
Importadores posteriores pueden llamarlo, y él muestra correctamente el usuario actual:

      
        
        
          // 📁 another.js
import {sayHi} from './admin.js';

sayHi(); // Ready to serve, Pete!
        
      
      
      import.metaEl objeto import.meta contiene la información sobre el módulo actual.
Su contenido depende del entorno. En el navegador, contiene la URL del script, o la URL de una página web actual si está dentro de HTML:

      
        
        
          
            
          
          
            
          
        
        
          <script type="module">
  alert(import.meta.url); // script URL
  // para un script inline es la URL de la página HTML actual
</script>
        
      
      
      En un módulo, “this” es indefinido (undefined).Esa es una característica menor, pero para completar, debemos mencionarla.
En un módulo, el nivel superior this no está definido.
Compárelo con scripts que no sean módulos, donde this es un objeto global:

      
        
        
          
            
          
          
            
          
        
        
          <script>
  alert(this); // window
</script>

<script type="module">
  alert(this); // undefined
</script>
        
      
      
      Funciones específicas del navegadorTambién hay varias diferencias de scripts específicas del navegador con type =" module " en comparación con las normales.
Es posible que desee omitir esta sección por ahora si está leyendo por primera vez o si no usa JavaScript en un navegador.
Los módulos son diferidosLos módulos están siempre diferidos, el mismo efecto que el atributo defer (descrito en el capítulo Scripts: async, defer), para ambos scripts externos y en línea.
En otras palabras:

descargar módulos externo <script type="module" src="..."> no bloquea el procesamiento de HTML, se cargan en paralelo con otros recursos.
los módulos esperan hasta que el documento HTML esté completamente listo (incluso si son pequeños y cargan más rápido que HTML), y luego lo ejecuta.
se mantiene el orden relativo de los scripts: los scripts que van primero en el documento, se ejecutan primero.

Como efecto secundario, los módulos siempre “ven” la página HTML completamente cargada, incluidos los elementos HTML debajo de ellos.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <script type="module">
  alert(typeof button); // objeto: el script puede 'ver' el botón de abajo
  // debido que los módulos son diferidos, el script se ejecuta después de que la página entera se haya cargado
</script>

Abajo compare con un script normal:

<script>
  alert(typeof button); // button es indefinido, el script no puede ver los elementos de abajo
  // los scripts normales corren inmediatamente, antes que el resto de la página sea procesada
</script>

<button id="button">Button</button>
        
      
      
      Note que: ¡el segundo script se ejecuta antes que el primero! Entonces vemos primero undefined, y después object.
Esto se debe a que los módulos están diferidos, por lo que esperamos a que se procese el documento. El script normal se ejecuta inmediatamente, por lo que vemos su salida primero.
Al usar módulos, debemos tener en cuenta que la página HTML se muestra a medida que se carga, y los módulos JavaScript se ejecutan después de eso, por lo que el usuario puede ver la página antes de que la aplicación JavaScript esté lista. Es posible que algunas funciones aún no funcionen. Deberíamos poner “indicadores de carga”, o asegurarnos de que el visitante no se confunda con eso.
Async funciona en scripts en líneaPara los scripts que no son módulos, el atributo async solo funciona en scripts externos. Los scripts asíncronos se ejecutan inmediatamente cuando están listos, independientemente de otros scripts o del documento HTML.
Para los scripts de módulo, también funciona en scripts en línea.
Por ejemplo, el siguiente script en línea tiene async, por lo que no espera nada.
Realiza la importación (extrae ./Analytics.js) y se ejecuta cuando está listo, incluso si el documento HTML aún no está terminado o si aún hay otros scripts pendientes.
Eso es bueno para la funcionalidad que no depende de nada, como contadores, anuncios, detectores de eventos a nivel de documento.

      
        
        
          <!-- todas las dependencias se extraen (analytics.js), y el script se ejecuta -->
<!-- no espera por el documento u otras etiquetas <script> -->
<script async type="module">
  import {counter} from './analytics.js';

  counter.count();
</script>
        
      
      
      Scripts externosLos scripts externos que tengan type="module" son diferentes en dos aspectos:


Los scripts externos con el mismo src sólo se ejecutan una vez:

      
        
        
          <!-- el script my.js se extrae y ejecuta sólo una vez -->
<script type="module" src="my.js"></script>
<script type="module" src="my.js"></script>
        
      
      
      

Los scripts externos que se buscan desde otro origen (p.ej. otra sitio web) require encabezados CORS, como se describe en el capítulo Fetch: Cross-Origin Requests. En otras palabras, si un script de módulo es extraído desde otro origen, el servidor remoto debe proporcionar un encabezado Access-Control-Allow-Origin permitiendo la búsqueda.

      
        
        
          <!-- otro-sitio-web.com debe proporcionar Access-Control-Allow-Origin -->
<!-- si no, el script no se ejecutará -->
<script type="module" src="http://otro-sitio-web.com/otro.js"></script>
        
      
      
      Esto asegura mejor seguridad de forma predeterminada.


No se permiten módulos sueltosEn el navegador, import debe obtener una URL relativa o absoluta. Los módulos sin ninguna ruta se denominan módulos sueltos. Dichos módulos no están permitidos en import.
Por ejemplo, este import no es válido:

      
        
        
          import {sayHi} from 'sayHi'; // Error, módulo suelto
// el módulo debe tener una ruta, por ejemplo './sayHi.js' o dondequiera que el módulo esté
        
      
      
      Ciertos entornos, como Node.js o herramientas de paquete permiten módulos simples sin ninguna ruta, ya que tienen sus propias formas de encontrar módulos y hooks para ajustarlos. Pero los navegadores aún no admiten módulos sueltos.
Compatibilidad, “nomodule”Los navegadores antiguos no entienden type = "module". Los scripts de un tipo desconocido simplemente se ignoran. Para ellos, es posible proporcionar un respaldo utilizando el atributo nomodule:

      
        
        
          
            
          
          
            
          
        
        
          <script type="module">
  alert("Ejecuta en navegadores modernos");
</script>

<script nomodule>
  alert("Los navegadores modernos conocen tanto type=module como nomodule, así que omita esto")
  alert("Los navegadores antiguos ignoran la secuencia de comandos con type=module desconocido, pero ejecutan esto.");
</script>
        
      
      
      Herramientas de EnsamblajeEn la vida real, los módulos de navegador rara vez se usan en su forma “pura”. Por lo general, los agrupamos con una herramienta especial como Webpack y los implementamos en el servidor de producción.
Uno de los beneficios de usar empaquetadores – dan más control sobre cómo se resuelven los módulos, permitiendo módulos simples y mucho más, como los módulos CSS/HTML.
Las herramientas de compilación hacen lo siguiente:

Toman un módulo “principal”, el que se pretende colocar en <script type="module"> en HTML.
Analiza sus dependencias: las importa y luego importaciones de importaciones etcétera.
Compila un único archivo con todos los módulos (o múltiples archivos, eso es ajustable), reemplazando los llamados nativos de import con funciones del empaquetador para que funcione. Los módulos de tipo “Especial” como módulos HTML/CSS también son supported.
Durante el proceso, otras transformaciones y optimizaciones se pueden aplicar:

Se elimina código inaccesible.
Se elimina exportaciones sin utilizar (“tree-shaking”).
Sentencias específicas de desarrollo tales como console y debugger se eliminan.
La sintaxis JavaScript moderna puede transformarse en una sintaxis más antigua con una funcionalidad similar utilizando Babel.
El archivo resultante se minimiza. (se eliminan espacios, las variables se reemplazan con nombres cortos, etc).



Si utilizamos herramientas de ensamblaje, entonces, a medida que los scripts se agrupan en un solo archivo (o pocos archivos), las declaraciones import/export dentro de esos scripts se reemplazan por funciones especiales de ensamblaje. Por lo tanto, el script “empaquetado” resultante no contiene ninguna import/export, no requiere type="module", y podemos ponerla en un script normal:

      
        
        
          <!-- Asumiendo que obtenemos bundle.js desde una herramienta como Webpack -->
<script src="bundle.js"></script>
        
      
      
      Dicho esto, los módulos nativos también se pueden utilizar. Por lo tanto no estaremos utilizando Webpack aquí: tú lo podrás configurar más adelante.
ResumenPara resumir, los conceptos centrales son:

Un módulo es un archivo. Para que funcione import/export, los navegadores necesitan <script type="module">. Los módulos tienen varias diferencias:

Diferido por defecto.
Async funciona en scripts en línea.
Para cargar scripts externos de otro origen (dominio/protocolo/puerto), se necesitan encabezados CORS.
Se ignoran los scripts externos duplicados.


Los módulos tienen su propio alcance local de alto nivel y funcionalidad de intercambio a través de ‘import/export’.
Los módulos siempre usan use strict.
El código del módulo se ejecuta solo una vez. Las exportaciones se crean una vez y se comparten entre los importadores.

Cuando usamos módulos, cada módulo implementa la funcionalidad y la exporta. Luego usamos import para importarlo directamente donde sea necesario. El navegador carga y evalúa los scripts automáticamente.
En la producción, las personas a menudo usan paquetes como Webpack para agrupar módulos por rendimiento y otras razones.
En el próximo capítulo veremos más ejemplos de módulos y cómo se pueden exportar/importar cosas.
",
	"url": "https://es.javascript.info/modules-intro" 
},
{
	"docs_id": "89",
	"name": "Export e Import",
	"description": "Las directivas export e import tienen varias variantes de sintaxis.",
	"content": "Las directivas export e import tienen varias variantes de sintaxis.
En el artículo anterior vimos un uso simple, ahora exploremos más ejemplos.
Export antes de las sentenciasPodemos etiquetar cualquier sentencia como exportada colocando ‘export’ antes, ya sea una variable, función o clase.
Por ejemplo, aquí todas las exportaciones son válidas:

      
        
        
          // exportar un array
export let months = ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

// exportar una constante
export const MODULES_BECAME_STANDARD_YEAR = 2015;

// exportar una clase
export clase User {
  constructor(name) {
    this.name = name;
  }
}
        
      
      
      
            Sin punto y coma después de export clase/función
            Tenga en cuenta que export antes de una clase o una función no la hace una expresión de función. Sigue siendo una declaración de función, aunque exportada.
La mayoría de las guías de estilos JavaScript no recomiendan los punto y comas después de declarar funciones y clases.
Es por esto que no hay necesidad de un punto y coma al final de export class y export function:

      
        
        
          export function sayHi(user) {
  alert(`Hello, ${user}!`);
}  // no ; at the end
        
      
      
      
Export separado de la declaraciónTambién podemos colocar export por separado.
Aquí primero declaramos y luego exportamos:

      
        
        
          // 📁 say.js
function sayHi(user) {
  alert(`Hello, ${user}!`);
}

function sayBye(user) {
  alert(`Bye, ${user}!`);
}

export {sayHi, sayBye}; // una lista de variables exportadas
        
      
      
      …O, técnicamente podemos colocar export arriba de las funciones también.
Import *Generalmente, colocamos una lista de lo que queremos importar en llaves import {...}, de esta manera:

      
        
        
          // 📁 main.js
import {sayHi, sayBye} from './say.js';

sayHi('John'); // Hello, John!
sayBye('John'); // Bye, John!
        
      
      
      Pero si hay mucho para importar, podemos importar todo como un objeto utilizando import * as <obj>, por ejemplo:

      
        
        
          // 📁 main.js
import * as say from './say.js';

say.sayHi('John');
say.sayBye('John');
        
      
      
      A primera vista, “importar todo” parece algo tan genial, corto de escribir, por qué deberíamos listar explícitamente lo que necesitamos importar?
Pues hay algunas razones.


Las herramientas de ensamblaje modernas (webpack y otras) empaquetan los módulos juntos, los optimiza para acelerar la carga y quitan las cosas que no se usan.
Digamos que agregamos una librería externa say.js a nuestro proyecto con varias funciones:

      
        
        
          // 📁 say.js
export function sayHi() { ... }
export function sayBye() { ... }
export function becomeSilent() { ... }
        
      
      
      Ahora si solamente utilizamos una de las funciones de say.js en nuestro proyecto:

      
        
        
          // 📁 main.js
import {sayHi} from './say.js';
        
      
      
      …Entonces el optimizador lo verá y eliminará las otras funciones del código empaquetado, por lo tanto la compilación es más pequeña. Esto se llama “tree-shaking”.


Listar explícitamente qué importar da nombres más cortos: sayHi() en lugar de say.sayHi().


La lista explícita de importaciones ofrece una mejor visión general de la estructura del código: qué se usa y dónde. Facilita el soporte de código y la refactorización.


Importar “as”También podemos utilizar as para importar bajo nombres diferentes.
Por ejemplo, importemos sayHi en la variable local hi para brevedad, e importar sayBye como bye:

      
        
        
          // 📁 main.js
import {sayHi as hi, sayBye as bye} from './say.js';

hi('John'); // Hello, John!
bye('John'); // Bye, John!
        
      
      
      Exportar “as”Existe un sintaxis similar para export.
Exportemos funciones como hi y bye:

      
        
        
          // 📁 say.js
...
export {sayHi as hi, sayBye as bye};
        
      
      
      Ahora hi y bye son los nombres oficiales para desconocidos, a ser utilizados en importaciones:

      
        
        
          // 📁 main.js
import * as say from './say.js';

say.hi('John'); // Hello, John!
say.bye('John'); // Bye, John!
        
      
      
      Export defaultEn la práctica, existen principalmente dos tipos de módulos.

Módulos que contienen una librería, paquete de funciones, como say.js de arriba.
Módulos que declaran una entidad simple, por ejemplo un módulo user.js exporta únicamente class User.

Principalmente, se prefiere el segundo enfoque, de modo que cada “cosa” reside en su propio módulo.
Naturalmente, eso requiere muchos archivos, ya que todo quiere su propio módulo, pero eso no es un problema en absoluto. En realidad, la navegación de código se vuelve más fácil si los archivos están bien nombrados y estructurados en carpetas.
Los módulos proporcionan una sintaxis especial ‘export default’ (“la exportación predeterminada”) para que la forma de “una cosa por módulo” se vea mejor.
Poner export default antes de la entidad a exportar:

      
        
        
          // 📁 user.js
export default class User { // sólo agregar "default"
  constructor(name) {
    this.name = name;
  }
}
        
      
      
      Sólo puede existir un sólo export default por archivo.
…Y luego importarlo sin llaves:

      
        
        
          // 📁 main.js
import User from './user.js'; // no {User}, sólo User

new User('John');
        
      
      
      Las importaciones sin llaves se ven mejor. Un error común al comenzar a usar módulos es olvidarse de las llaves. Entonces, recuerde, import necesita llaves para las exportaciones con nombre y no las necesita para la predeterminada.



Export con nombre
Export predeterminada




export class User {...}
export default class User {...}


import {User} from ...
import User from ...



Técnicamente, podemos tener exportaciones predeterminadas y con nombre en un solo módulo, pero en la práctica la gente generalmente no las mezcla. Un módulo tiene exportaciones con nombre o la predeterminada.
Como puede haber como máximo una exportación predeterminada por archivo, la entidad exportada puede no tener nombre.
Por ejemplo, todas estas son exportaciones predeterminadas perfectamente válidas:

      
        
        
          export default class { // sin nombre de clase
  constructor() { ... }
}
        
      
      
      
      
        
        
          export default function(user) { // sin nombre de función
  alert(`Hello, ${user}!`);
}
        
      
      
      
      
        
        
          // exportar un único valor, sin crear una variable
export default ['Jan', 'Feb', 'Mar','Apr', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        
      
      
      No dar un nombre está bien, porque solo hay un “export default” por archivo, por lo que “import” sin llaves sabe qué importar.
Sin default, dicha exportación daría un error:

      
        
        
          export class { // Error! (exportación no predeterminada necesita un nombre)
  constructor() {}
}
        
      
      
      El nombre “default”En algunas situaciones, la palabra clave default se usa para hacer referencia a la exportación predeterminada.
Por ejemplo, para exportar una función por separado de su definición:

      
        
        
          function sayHi(user) {
  alert(`Hello, ${user}!`);
}

// lo mismo que si agregamos "export default" antes de la función
export {sayHi as default};
        
      
      
      Otra situación, supongamos un módulo user.js exporta una cosa principal “default”, y algunas cosas con nombre (raro el caso, pero sucede):

      
        
        
          // 📁 user.js
export default class User {
  constructor(name) {
    this.name = name;
  }
}

export function sayHi(user) {
  alert(`Hello, ${user}!`);
}
        
      
      
      Aquí la manera de importar la exportación predeterminada junto con la exportación con nombre:

      
        
        
          // 📁 main.js
import {default as User, sayHi} from './user.js';

new User('John');
        
      
      
      Y por último, si importamos todo * como un objeto, entonce la propiedad default es exactamente la exportación predeterminada:

      
        
        
          // 📁 main.js
import * as user from './user.js';

let User = user.default; // la exportación predeterminada
new User('John');
        
      
      
      Unas palabras contra exportaciones predeterminadasLas exportaciones con nombre son explícitas. Nombran exactamente lo que importan, así que tenemos esa información de ellos; Eso es bueno.
Las exportaciones con nombre nos obligan a usar exactamente el nombre correcto para importar:

      
        
        
          import {User} from './user.js';
// import {MyUser} no funcionará, el nombre debe ser {User}
        
      
      
      …Mientras que para una exportación predeterminada siempre elegimos el nombre al importar:

      
        
        
          import User from './user.js'; // funciona
import MyUser from './user.js'; // también funciona
// puede ser import Cualquiera... y aun funcionaría
        
      
      
      Por lo tanto, los miembros del equipo pueden usar diferentes nombres para importar lo mismo, y eso no es bueno.
Por lo general, para evitar eso y mantener el código consistente, existe una regla que establece que las variables importadas deben corresponder a los nombres de los archivos, por ejemplo:

      
        
        
          import User from './user.js';
import LoginForm from './loginForm.js';
import func from '/path/to/func.js';
...
        
      
      
      Aún así, algunos equipos lo consideran un serio inconveniente de las exportaciones predeterminadas. Por lo tanto, prefieren usar siempre exportaciones con nombre. Incluso si solo se exporta una sola cosa, todavía se exporta con un nombre, sin default.
Eso también hace que la reexportación (ver más abajo) sea un poco más fácil.
ReexportaciónLa sintaxis “Reexportar” export ... from ... permite importar cosas e inmediatamente exportarlas (posiblemente bajo otro nombre), de esta manera:

      
        
        
          export {sayHi} from './say.js'; // reexportar sayHi

export {default as User} from './user.js'; // reexportar default
        
      
      
      ¿Por qué se necesitaría eso? Veamos un caso de uso práctico.
Imagine que estamos escribiendo un “paquete”: una carpeta con muchos módulos, con algunas de las funciones exportadas al exterior (herramientas como NPM nos permiten publicar y distribuir dichos paquetes pero no estamos obligados a usarlas), y muchos módulos son solo “ayudantes”, para uso interno en otros módulos de paquete.
La estructura de archivos podría ser algo así:

      
        
        
          auth/
    index.js
    user.js
    helpers.js
    tests/
        login.js
    providers/
        github.js
        facebook.js
        ...
        
      
      
      Nos gustaría exponer la funcionalidad del paquete a través de un único punto de entrada.
En otras palabras, una persona que quiera usar nuestro paquete, debería importar solamente el archivo principal auth/index.js.
Como esto:

      
        
        
          import {login, logout} from 'auth/index.js'
        
      
      
      El “archivo principal”, auth/index.js, exporta toda la funcionalidad que queremos brindar en nuestro paquete.
La idea es que los extraños, los desarrolladores que usan nuestro paquete, no deben entrometerse con su estructura interna, buscar archivos dentro de nuestra carpeta de paquetes. Exportamos solo lo que es necesario en auth/index.js y mantenemos el resto oculto a miradas indiscretas.
Como la funcionalidad real exportada se encuentra dispersa entre el paquete, podemos importarla en auth/index.js y exportar desde ella:

      
        
        
          // 📁 auth/index.js

// importar login/logout e inmediatamente exportarlas
import {login, logout} from './helpers.js';
export {login, logout};

// importar default como User y exportarlo
import User from './user.js';
export {User};
...
        
      
      
      Ahora los usuarios de nuestro paquete pueden hacer esto import {login} from "auth/index.js".
La sintaxis export ... from ... es solo una notación más corta para tal importación-exportación:

      
        
        
          // 📁 auth/index.js
// re-exportar login/logout
export {login, logout} from './helpers.js';

// re-exportar export default como User
export {default as User} from './user.js';
...
        
      
      
      La diferencia notable de export ... from comparado a import/export es que los módulos re-exportados no están disponibles en el archivo actual. Entonces en el ejemplo anterior de auth/index.js no podemos usar las funciones re-exportadas login/logout.
Reexportando la exportación predeterminadaLa exportación predeterminada necesita un manejo separado cuando se reexporta.
Digamos que tenemos user.js con export default class User, y nos gustaría volver a exportar la clase User de él:

      
        
        
          // 📁 user.js
export default class User {
  // ...
}
        
      
      
      Podemos tener dos problemas:

export User from './user.js' no funcionará. Nos dará un error de sintaxis.

Para reexportar la exportación predeterminada, tenemos que escribir export {default as User}, tal como en el ejemplo de arriba.


export * from './user.js' reexporta únicamente las exportaciones con nombre, pero ignora la exportación predeterminada.
Si queremos reexportar tanto la exportación con nombre como la predeterminada, se necesitan dos declaraciones:

      
        
        
          export * from './user.js'; // para reexportar exportaciones con nombre
export {default} from './user.js'; // para reexportar la exportación predeterminada
        
      
      
      

Tales rarezas de reexportar la exportación predeterminada son una de las razones por las que a algunos desarrolladores no les gustan las exportaciones predeterminadas y prefieren exportaciones con nombre.
ResumenAquí están todos los tipos de ‘exportación’ que cubrimos en este y en artículos anteriores.
Puede comprobarlo al leerlos y recordar lo que significan:

Antes de la declaración de clase/función/…:

export [default] clase/función/variable ...


Export independiente:

export {x [as y], ...}.


Reexportar:

export {x [as y], ...} from "module"
export * from "module" (no reexporta la predeterminada).
export {default [as y]} from "module" (reexporta la predeterminada).



Importación:

Importa las exportaciones con nombre:

import {x [as y], ...} from "module"


Importa la exportación predeterminada:

import x from "module"
import {default as x} from "module"


Importa todo:

import * as obj from "module"


Importa el módulo (su código se ejecuta), pero no asigna ninguna de las exportaciones a variables:

import "module"



Podemos poner las declaraciones import/export en la parte superior o inferior de un script, eso no importa.
Entonces, técnicamente este código está bien:

      
        
        
          sayHi();

// ...

import {sayHi} from './say.js'; // import al final del archivo
        
      
      
      En la práctica, las importaciones generalmente se encuentran al comienzo del archivo, pero eso es solo para mayor comodidad.
Tenga en cuenta que las declaraciones de import/export no funcionan si están dentro {...}.
Una importación condicional, como esta, no funcionará:

      
        
        
          if (something) {
  import {sayHi} from "./say.js"; // Error: import debe estar en nivel superior
}
        
      
      
      …Pero, ¿qué pasa si realmente necesitamos importar algo condicionalmente? O en el momento adecuado? Por ejemplo, ¿cargar un módulo a pedido, cuando realmente se necesita?
Veremos importaciones dinámicas en el próximo artículo.
",
	"url": "https://es.javascript.info/import-export" 
},
{
	"docs_id": "90",
	"name": "Importaciones dinámicas",
	"description": "Las declaraciones de exportación e importación que cubrimos en capítulos anteriores se denominan “estáticas”. La sintaxis es muy simple y estricta.",
	"content": "Las declaraciones de exportación e importación que cubrimos en capítulos anteriores se denominan “estáticas”. La sintaxis es muy simple y estricta.
Primero, no podemos generar dinámicamente ningún parámetro de import.
La ruta del módulo debe ser una cadena primitiva, no puede ser una llamada de función. Esto no funcionará:

      
        
        
          import ... from getModuleName(); // Error, from sólo permite "string"
        
      
      
      En segundo lugar, no podemos importar condicionalmente o en tiempo de ejecución:

      
        
        
          if(...) {
  import ...; // ¡Error, no permitido!
}

{
  import ...; // Error, no podemos poner importación en ningún bloque.
}
        
      
      
      Esto se debe a que import/export proporcionan una columna vertebral para la estructura del código. Eso es algo bueno, ya que la estructura del código se puede analizar, los módulos se pueden reunir y agrupar en un archivo mediante herramientas especiales, las exportaciones no utilizadas se pueden eliminar (“tree-shaken”). Eso es posible solo porque la estructura de las importaciones/exportaciones es simple y fija.
Pero, ¿cómo podemos importar un módulo dinámicamente, a petición?
La expresión import()La expresión import(module) carga el módulo y devuelve una promesa que se resuelve en un objeto de módulo que contiene todas sus exportaciones. Se puede llamar desde cualquier lugar del código.
Podemos usarlo dinámicamente en cualquier lugar del código, por ejemplo:

      
        
        
          let modulePath = prompt("¿Qué modulo cargar?");

import(modulePath)
  .then(obj => <module object>)
  .catch(err => <loading error, e.g. if no such module>)
        
      
      
      O, podríamos usar let module = await import(modulePath) si está dentro de una función asíncrona.
Por ejemplo, si tenemos el siguiente módulo say.js:

      
        
        
          // 📁 say.js
export function hi() {
  alert(`Hola`);
}

export function bye() {
  alert(`Adiós`);
}
        
      
      
      …Entonces la importación dinámica puede ser así:

      
        
        
          let {hi, bye} = await import('./say.js');

hi();
bye();
        
      
      
      O, si say.js tiene la exportación predeterminada:

      
        
        
          // 📁 say.js
export default function() {
  alert("Módulo cargado (export default)!");
}
        
      
      
      …Luego, para acceder a él, podemos usar la propiedad default del objeto del módulo:

      
        
        
          let obj = await import('./say.js');
let say = obj.default;
// o, en una línea: let {default: say} = await import('./say.js');

say();
        
      
      
      Aquí está el ejemplo completo:
Resultadosay.jsindex.htmlexport function hi() {
  alert(`Hola`);
}

export function bye() {
  alert(`Adiós`);
}

export default function() {
  alert("Módulo cargado (export default)!");
}<!doctype html>
<script>
  async function load() {
    let say = await import('./say.js');
    say.hi(); // ¡Hola!
    say.bye(); // ¡Adiós!
    say.default(); // Módulo cargado (export default)!
  }
</script>
<button onclick="load()">Click me</button>
            Por favor tome nota:
            Las importaciones dinámicas funcionan en scripts normales, no requieren script type="module".


            Por favor tome nota:
            Aunque import() parece una llamada de función, es una sintaxis especial que solo usa paréntesis (similar a super ()).
Por lo tanto, no podemos copiar import a una variable o usar call/apply con ella. No es una función.

",
	"url": "https://es.javascript.info/modules-dynamic-imports" 
},
{
	"docs_id": "91",
	"name": "Proxy y Reflect",
	"description": "Un objeto Proxy envuelve (es un “wrapper”: envoltura, contenedor) a otro objeto e intercepta sus operaciones (como leer y escribir propiedades, entre otras). El proxy puede manejar estas operaciones él mismo o, en forma transparente permitirle manejarlas al objeto envuelto.",
	"content": "Un objeto Proxy envuelve (es un “wrapper”: envoltura, contenedor) a otro objeto e intercepta sus operaciones (como leer y escribir propiedades, entre otras). El proxy puede manejar estas operaciones él mismo o, en forma transparente permitirle manejarlas al objeto envuelto.
Los proxys son usados en muchas librerías y en algunos frameworks de navegador. En este artículo veremos muchas aplicaciones prácticas.
ProxyLa sintaxis:

      
        
        
          let proxy = new Proxy(target, handler)
        
      
      
      
target – es el objeto a envolver, puede ser cualquier cosa, incluso funciones.
handler – configuración de proxy: un objeto que “atrapa”, métodos que interceptan operaciones. Ejemplos, la trampa get para leer una propiedad de target, la trampa set para escribir una propiedad en target, entre otras.

Cuando hay una operación sobre proxy, este verifica si hay una trampa correspondiente en handler. Si la trampa existe se ejecuta y el proxy tiene la oportunidad de manejarla, de otro modo la operación es ejecutada por target.
Como ejemplo para comenzar, creemos un proxy sin ninguna trampa:

      
        
        
          
            
          
          
            
          
        
        
          let target = {};
let proxy = new Proxy(target, {}); // manejador vacío

proxy.test = 5; // escribiendo en el proxy (1)
alert(target.test); // 5, ¡la propiedad apareció en target!

alert(proxy.test); // 5, también podemos leerla en el proxy (2)

for(let key in proxy) alert(key); // test, la iteración funciona (3)
        
      
      
      Como no hay trampas, todas las operaciones sobre proxy son redirigidas a target.

Una operación de escritura proxy.test= establece el valor en target.
Una operación de lectura proxy.test devuelve el valor desde target.
La iteración sobre proxy devuelve valores de target.

Como podemos ver, sin ninguna trampa, proxy es un envoltorio transparente alrededor de target.

      
      
        
      
      Proxy es un “objeto exótico” especial. No tiene propiedades propias. Con un manejador transparente redirige todas las operaciones hacia target.
Para activar más habilidades, agreguemos trampas.
¿Qué podemos interceptar con ellas?
Para la mayoría de las operaciones en objetos existe el denominado “método interno” en la especificación Javascript que describe cómo este trabaja en el más bajo nivel. Por ejemplo [[Get]]: es el método interno para leer una propiedad, [[Set]]: el método interno para escribirla, etcétera. Estos métodos solamente son usados en la especificación, no podemos llamarlos directamente por nombre.
Las trampas del proxy interceptan la invocación a estos métodos. Están listadas en la Especificación del proxy y en la tabla debajo.
Para cada método interno, existe una “trampa” en esta tabla: es el nombre del método que podemos agregar al parámetro handler de new Proxy para interceptar la operación:



Método interno
Método manejador
Cuándo se dispara




[[Get]]
get
leyendo una propiedad


[[Set]]
set
escribiendo una propiedad


[[HasProperty]]
has
operador in


[[Delete]]
deleteProperty
operador delete


[[Call]]
apply
llamado a función


[[Construct]]
construct
operador new


[[GetPrototypeOf]]
getPrototypeOf
Object.getPrototypeOf


[[SetPrototypeOf]]
setPrototypeOf
Object.setPrototypeOf


[[IsExtensible]]
isExtensible
Object.isExtensible


[[PreventExtensions]]
preventExtensions
Object.preventExtensions


[[DefineOwnProperty]]
defineProperty
Object.defineProperty, Object.defineProperties


[[GetOwnProperty]]
getOwnPropertyDescriptor
Object.getOwnPropertyDescriptor, for..in, Object.keys/values/entries


[[OwnPropertyKeys]]
ownKeys
Object.getOwnPropertyNames, Object.getOwnPropertySymbols, for..in, Object.keys/values/entries




            Invariantes
            JavaScript impone algunas invariantes: condiciones que deben ser satisfechas por métodos internos y trampas.
La mayor parte de ellos son para devolver valores:

[[Set]] debe devolver true si el valor fue escrito correctamente, de otro modo false.
[[Delete]] debe devolver true si el valor fue borrado correctamente, de otro modo false.
…y otros, veremos más ejemplos abajo.

Existen algunas otras invariantes, como:

[[GetPrototypeOf]], aplicado al proxy, debe devolver el mismo valor que [[GetPrototypeOf]] aplicado al “target” del proxy. En otras palabras, leer el prototipo de un proxy debe devolver siempre el prototipo de su objeto target.

Las trampas pueden interceptar estas operaciones, pero deben seguir estas reglas.
Las invariantes aseguran un comportamiento correcto y consistente de características de lenguaje. La lista completa de invariantes está en la especificación. Probablemente no las infringirás si no estás haciendo algo retorcido.

Veamos cómo funciona en ejemplos prácticos.
Valores “por defecto” con la trampa “get”Las trampas más comunes son para leer y escribir propiedades.
Para interceptar una lectura, el handler debe tener un método get(target, property, receiver).
Se dispara cuando una propiedad es leída, con los siguientes argumentos:

target – “objetivo”, es el objeto pasado como primer argumento a new Proxy,
property – nombre de la propiedad,
receiver – si la propiedad objetivo es un getter, el receiver es el objeto que va a ser usado como this en su llamado. Usualmente es el objeto proxy mismo (o un objeto que hereda de él, si heredamos desde proxy). No necesitamos este argumento ahora mismo, así que se verá en más detalle luego.

Usemos get para implementar valores por defecto a un objeto.
Crearemos un arreglo numérico que devuelve 0 para valores no existentes.
Lo usual al tratar de obtener un ítem inexistente de un array es obtener undefined, pero envolveremos un array normal en un proxy que atrape lecturas y devuelva 0 si no existe tal propiedad:

      
        
        
          
            
          
          
            
          
        
        
          let numbers = [0, 1, 2];

numbers = new Proxy(numbers, {
  get(target, prop) {
    if (prop in target) {
      return target[prop];
    } else {
      return 0; // valor por defecto
    }
  }
});

alert( numbers[1] ); // 1
alert( numbers[123] ); // 0 (porque no existe tal ítem)
        
      
      
      Como podemos ver, es muy fácil de hacer con una trampa get.
Podemos usar Proxy para implementar cualquier lógica para valores “por defecto”.
Supongamos que tenemos un diccionario con frases y sus traducciones:

      
        
        
          
            
          
          
            
          
        
        
          let dictionary = {
  'Hello': 'Hola',
  'Bye': 'Adiós'
};

alert( dictionary['Hello'] ); // Hola
alert( dictionary['Welcome'] ); // undefined
        
      
      
      Por ahora, si no existe la frase, la lectura de dictionary devuelve undefined. Pero en la práctica dejar la frase sin traducir es mejor que undefined. Así que hagamos que devuelva la frase sin traducir en vez de undefined.
Para lograr esto envolvemos dictionary en un proxy que intercepta las operaciones de lectura:

      
        
        
          
            
          
          
            
          
        
        
          let dictionary = {
  'Hello': 'Hola',
  'Bye': 'Adiós'
};

dictionary = new Proxy(dictionary, {
  get(target, phrase) { // intercepta la lectura de una propiedad en dictionary
    if (phrase in target) { // si existe en el diccionario
      return target[phrase]; // devuelve la traducción
    } else {
      // caso contrario devuelve la frase sin traducir
      return phrase;
    }
  }
});

// ¡Busque frases en el diccionario!
// En el peor caso, no serán traducidas.
alert( dictionary['Hello'] ); // Hola
alert( dictionary['Welcome to Proxy']); // Welcome to Proxy (sin traducir)
        
      
      
      
            Por favor tome nota:
            Nota cómo el proxy sobrescribe la variable:

      
        
        
          dictionary = new Proxy(dictionary, ...);
        
      
      
      El proxy debe reemplazar completamente al objeto “target” que envolvió: nadie debe jamás hacer referencia al objeto target saltando tal envoltura. De otro modo sería fácil desbaratarlo.

Validación con la trampa “set”Digamos que queremos un array exclusivamente para números. Si se agrega un valor de otro tipo, debería dar un error.
La trampa set se dispara cuando una propiedad es escrita.
set(target, property, value, receiver):

target – objetivo, el objeto pasado como primer argumento a new Proxy,
property – nombre de la propiedad,
value – valor de la propiedad,
receiver – similar para la trampa get, de importancia solamente en propiedades setter.

La trampa set debe devolver true si la escritura fue exitosa, y false en caso contrario (dispara TypeError).
Usémoslo para validar valores nuevos:

      
        
        
          
            
          
          
            
          
        
        
          let numbers = [];

numbers = new Proxy(numbers, { // (*)
  set(target, prop, val) { // para interceptar la escritura de propiedad
    if (typeof val == 'number') {
      target[prop] = val;
      return true;
    } else {
      return false;
    }
  }
});

numbers.push(1); // añadido correctamente
numbers.push(2); // añadido correctamente
alert("Length is: " + numbers.length); // 2

numbers.push("test"); // TypeError ('set' en el proxy devolvió false)

alert("Esta linea nunca es alcanzada (error en la línea de arriba)");
        
      
      
      Ten en cuenta: ¡la funcionalidad integrada de los arrays aún funciona! Los valores son añadidos por push. La propiedad length se autoincrementa cuando son agregados valores. Nuestro proxy no rompe nada.
No necesitamos sobrescribir métodos de valor añadido como push, unshift y demás para agregar los chequeos allí, porque internamente ellos usan la operación [[Set]] que es interceptada por el proxy.
Entonces el código es limpio y conciso.

            No olvides devolver true
            Como dijimos antes, hay invariantes que se deben mantener.
Para set, debe devolver true si la escritura fue correcta.
Si olvidamos hacerlo o si devolvemos false, la operación dispara TypeError.

Iteración con “ownKeys” y “getOwnPropertyDescriptor”Object.keys, el bucle for..in, y la mayoría de los demás métodos que iteran sobre las propiedades de objeto usan el método interno [[OwnPropertyKeys]] (interceptado por la trampa ownKeys) para obtener una lista de propiedades .
Tales métodos difieren en detalles:

Object.getOwnPropertyNames(obj) devuelve claves no symbol.
Object.getOwnPropertySymbols(obj) devuelve claves symbol.
Object.keys/values() devuelve claves/valores no symbol con indicador enumerable (los indicadores de propiedad fueron explicados en el artículo Indicadores y descriptores de propiedad).
for..in itera sobre claves no symbol con el indicador enumerable, y también claves prototípicas.

…Pero todos ellos comienzan con aquella lista.
En el ejemplo abajo usamos la trampa ownKeys para hacer el bucle for..in sobre user. También usamos Object.keys y Object.values para pasar por alto las propiedades que comienzan con un guion bajo _:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  age: 30,
  _password: "***"
};

user = new Proxy(user, {
  ownKeys(target) {
    return Object.keys(target).filter(key => !key.startsWith('_'));
  }
});

// el filtro en "ownKeys" descarta _password
for(let key in user) alert(key); // name, then: age

// el mismo efecto con estos métodos:
alert( Object.keys(user) ); // name,age
alert( Object.values(user) ); // John,30
        
      
      
      Hasta ahora, funciona.
Aunque si devolvemos una clave que no existe en el objeto, Object.keys no la listará:

      
        
        
          
            
          
          
            
          
        
        
          let user = { };

user = new Proxy(user, {
  ownKeys(target) {
    return ['a', 'b', 'c'];
  }
});

alert( Object.keys(user) ); // <vacío>
        
      
      
      ¿Por qué? La razón es simple: Object.keys devuelve solamente propiedades con el indicador enumerable. Para verificarlo, llama el método interno [[GetOwnProperty]] en cada propiedad para obtener su descriptor. Y aquí, como no hay propiedad, su descriptor está vacío, no existe el indicador enumerable, entonces lo salta.
Para que Object.keys devuelva una propiedad, necesitamos que, o bien exista en el objeto, con el indicador enumerable, o interceptamos llamadas a [[GetOwnProperty]] (la trampa getOwnPropertyDescriptor lo hace), y devolver un descriptor con enumerable: true.
Aquí un ejemplo de ello:

      
        
        
          
            
          
          
            
          
        
        
          let user = { };

user = new Proxy(user, {
  ownKeys(target) { // llamado una vez para obtener la lista de propiedades
    return ['a', 'b', 'c'];
  },

  getOwnPropertyDescriptor(target, prop) { // llamada para cada propiedad
    return {
      enumerable: true,
      configurable: true
      /* ...otros indicadores, probablemente "value:..." */
    };
  }

});

alert( Object.keys(user) ); // a, b, c
        
      
      
      Tomemos nota de nuevo: solamente necesitamos interceptar [[GetOwnProperty]] si la propiedad está ausente en el objeto.
Propiedades protegidas con “deleteProperty” y otras trampasHay una convención extendida: las propiedades y los métodos que comienzan con guion bajo _ son de uso interno. Ellos no deberían ser accedidos desde fuera del objeto.
Aunque es técnicamente posible:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  _password: "secreto"
};

alert(user._password); // secreto
        
      
      
      Usemos proxy para prevenir cualquier acceso a propiedades que comienzan con _.
Necesitaremos las trampas:

get para arrojar un error al leer tal propiedad,
set para arrojar un error al escribirla,
deleteProperty para arrojar un error al eliminar,
ownKeys para excluir propiedades que comienzan con _ de for..in y métodos como Object.keys.

Aquí el código:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  _password: "***"
};

user = new Proxy(user, {
  get(target, prop) {
    if (prop.startsWith('_')) {
      throw new Error("Acceso denegado");
    }
    let value = target[prop];
    return (typeof value === 'function') ? value.bind(target) : value; // (*)
  },
  set(target, prop, val) { // para interceptar la escritura de la propiedad
    if (prop.startsWith('_')) {
      throw new Error("Acceso denegado");
    } else {
      target[prop] = val;
      return true;
    }
  },
  deleteProperty(target, prop) { // para interceptar la eliminación de la propiedad
    if (prop.startsWith('_')) {
      throw new Error("Acceso denegado");
    } else {
      delete target[prop];
      return true;
    }
  },
  ownKeys(target) { // para interceptar su listado
    return Object.keys(target).filter(key => !key.startsWith('_'));
  }
});

// "get" no permite leer _password
try {
  alert(user._password); // Error: Acceso denegado
} catch(e) { alert(e.message); }

// "set" no permite escribir _password
try {
  user._password = "test"; // Error: Acceso denegado
} catch(e) { alert(e.message); }

// "deleteProperty" no permite eliminar _password
try {
  delete user._password; // Error: Acceso denegado
} catch(e) { alert(e.message); }

// "ownKeys" filtra descartando _password
for(let key in user) alert(key); // name
        
      
      
      Nota el importante detalle en la trampa get, en la línea (*):

      
        
        
          get(target, prop) {
  // ...
  let value = target[prop];
  return (typeof value === 'function') ? value.bind(target) : value; // (*)
}
        
      
      
      ¿Por qué necesitamos una función para llamar value.bind(target)?
La razón es que los métodos de objeto, como user.checkPassword(), deben ser capaces de acceder a _password:

      
        
        
          user = {
  // ...
  checkPassword(value) {
    // método de objeto debe poder leer _password
    return value === this._password;
  }
}
        
      
      
      Un llamado a user.checkPassword() hace que el objeto target user sea this (el objeto antes del punto se vuelve this), entonces cuando trata de acceder a this._password, la trampa get se activa (se dispara en cualquier lectura de propiedad) y arroja un error.
Entonces vinculamos (bind) el contexto de los métodos al objeto original, target, en la línea (*). Así futuros llamados usarán target como this, sin trampas.
Esta solución usualmente funciona, pero no es ideal, porque un método podría pasar el objeto original hacia algún otro lado y lo habremos arruinado: ¿dónde está el objeto original, y dónde el apoderado?
Además, un objeto puede ser envuelto por proxys muchas veces (proxys múltiples pueden agregar diferentes ajustes al objeto), y si pasamos un objeto no envuelto por proxy a un método, puede haber consecuencias inesperadas.
Por lo tanto, tal proxy no debería usarse en todos lados.

            Propiedades privadas de una clase
            Los motores de JavaScript moderno soportan en las clases las propiedades privadas, aquellas con el prefijo #. Estas son descritas en el artículo Propiedades y métodos privados y protegidos.. No requieren proxys.
Pero tales propiedades tienen sus propios problemas. En particular, ellas no se heredan.

“In range” con la trampa “has”Veamos más ejemplos.
Tenemos un objeto range:

      
        
        
          let range = {
  start: 1,
  end: 10
};
        
      
      
      Queremos usar el operador in para verificar que un número está en el rango, range.
La trampa has intercepta la llamada in.
has(target, property)

target – objetivo, el objeto pasado como primer argumento a new Proxy,
property – nombre de propiedad

Aquí el demo:

      
        
        
          
            
          
          
            
          
        
        
          let range = {
  start: 1,
  end: 10
};

range = new Proxy(range, {
  has(target, prop) {
    return prop >= target.start && prop <= target.end;
  }
});

alert(5 in range); // true
alert(50 in range); // false
        
      
      
      Bonita azúcar sintáctica, ¿no es cierto? Y muy simple de implementar.
Envolviendo funciones: "apply"Podemos envolver un proxy a una función también.
La trampa apply(target, thisArg, args) maneja llamados a proxy como función:

target es el objeto/objetivo (en JavaScript, la función es un objeto),
thisArg es el valor de this.
args es una lista de argumentos.

Por ejemplo, recordemos el decorador delay(f, ms) que hicimos en el artículo Decoradores y redirecciones, call/apply.
En ese artículo lo hicimos sin proxy. Un llamado a delay(f, ms) devolvía una función que redirigía todos los llamados a f después de ms milisegundos.
Aquí la version previa, implementación basada en función:

      
        
        
          
            
          
          
            
          
        
        
          function delay(f, ms) {
  // devuelve un envoltorio que pasa el llamado a f después del timeout
  return function() { // (*)
    setTimeout(() => f.apply(this, arguments), ms);
  };
}

function sayHi(user) {
  alert(`Hello, ${user}!`);
}

// después de esta envoltura, los llamados a sayHi serán demorados por 3 segundos
sayHi = delay(sayHi, 3000);

sayHi("John"); // Hello, John! (después de 3 segundos)
        
      
      
      Como ya hemos visto, esto mayormente funciona. La función envoltorio (*) ejecuta el llamado después del lapso.
Pero una simple función envoltura (wrapper) no redirige operaciones de lectura y escritura ni ninguna otra cosa. Una vez envuelta, el acceso a las propiedades de la función original (name, length) se pierde:

      
        
        
          
            
          
          
            
          
        
        
          function delay(f, ms) {
  return function() {
    setTimeout(() => f.apply(this, arguments), ms);
  };
}

function sayHi(user) {
  alert(`Hello, ${user}!`);
}

alert(sayHi.length); // 1 (length, longitud, en una función es la cantidad de argumentos en su declaración)

sayHi = delay(sayHi, 3000);

alert(sayHi.length); // 0 (en la declaración de envoltorio hay cero argumentos)
        
      
      
      El Proxy es mucho más poderoso, porque redirige todo lo que no maneja al objeto envuelto “target”.
Usemos Proxy en lugar de una función envoltura:

      
        
        
          
            
          
          
            
          
        
        
          function delay(f, ms) {
  return new Proxy(f, {
    apply(target, thisArg, args) {
      setTimeout(() => target.apply(thisArg, args), ms);
    }
  });
}

function sayHi(user) {
  alert(`Hello, ${user}!`);
}

sayHi = delay(sayHi, 3000);

alert(sayHi.length); // 1 (*) el proxy redirige la operación "get length" al objeto target

sayHi("John"); // Hello, John! (después de 3 segundos)
        
      
      
      El resultado es el mismo, pero ahora no solo las llamadas sino todas las operaciones son redirigidas a la función original. Así sayHi.length se devuelve correctamente luego de la envoltura en la línea (*).
Obtuvimos una envoltura “enriquecida”.
Existen otras trampas. La lista completa está en el principio de este artículo. Su patrón de uso es similar al de arriba.
ReflectReflect es un objeto nativo que simplifica la creación de Proxy.
Se dijo previamente que los métodos internos como [[Get]], [[Set]] son únicamente para la especificación, que no pueden ser llamados directamente.
El objeto Reflect hace de alguna manera esto posible. Sus métodos son envoltorios mínimos alrededor del método interno.
Aquí hay ejemplos de operaciones y llamados a Reflect que hacen lo mismo:



Operación
Llamada Reflect
Método interno




obj[prop]
Reflect.get(obj, prop)
[[Get]]


obj[prop] = value
Reflect.set(obj, prop, value)
[[Set]]


delete obj[prop]
Reflect.deleteProperty(obj, prop)
[[Delete]]


new F(value)
Reflect.construct(F, value)
[[Construct]]


…
…
…



Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {};

Reflect.set(user, 'name', 'John');

alert(user.name); // John
        
      
      
      En particular, Reflect nos permite llamar a los operadores (new, delete, …) como funciones (Reflect.construct, Reflect.deleteProperty, …). Esta es una capacidad interesante, pero hay otra cosa importante.
Para cada método interno atrapable por Proxy, hay un método correspondiente en Reflect con el mismo nombre y argumentos que la trampa Proxy.
Entonces podemos usar Reflect para redirigir una operación al objeto original.
En este ejemplo, ambas trampas get y set transparentemente (como si no existieran) reenvían las operaciones de lectura y escritura al objeto, mostrando un mensaje:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
};

user = new Proxy(user, {
  get(target, prop, receiver) {
    alert(`GET ${prop}`);
    return Reflect.get(target, prop, receiver); // (1)
  },
  set(target, prop, val, receiver) {
    alert(`SET ${prop}=${val}`);
    return Reflect.set(target, prop, val, receiver); // (2)
  }
});

let name = user.name; // muestra "GET name"
user.name = "Pete"; // muestra "SET name=Pete"
        
      
      
      Aquí:

Reflect.get lee una propiedad de objeto.
Reflect.set escribe una propiedad de objeto y devuelve true si fue exitosa, false si no lo fue.

Eso es todo, así de simple: si una trampa quiere dirigir el llamado al objeto, es suficiente con el llamado a Reflect.<method> con los mismos argumentos.
En la mayoría de los casos podemos hacerlo sin Reflect, por ejemplo, leer una propiedad Reflect.get(target, prop, receiver) puede ser reemplazado por target[prop]. Aunque hay importantes distinciones.
Proxy en un getterVeamos un ejemplo que demuestra por qué Reflect.get es mejor. Y veremos también por qué get/set tiene el tercer argumento receiver que no usamos antes.
Tenemos un objeto user con la propiedad _name y un getter para ella.
Aquí hay un proxy alrededor de él:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  _name: "Guest",
  get name() {
    return this._name;
  }
};

let userProxy = new Proxy(user, {
  get(target, prop, receiver) {
    return target[prop];
  }
});

alert(userProxy.name); // Guest
        
      
      
      La trampa get es “transparente” aquí, devuelve la propiedad original, y no hace nada más. Esto es suficiente para nuestro ejemplo.
Todo se ve bien. Pero hagamos el ejemplo un poco más complejo.
Después de heredar otro objeto admin desde user, podemos observar el comportamiento incorrecto:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  _name: "Guest",
  get name() {
    return this._name;
  }
};

let userProxy = new Proxy(user, {
  get(target, prop, receiver) {
    return target[prop]; // (*) target = user
  }
});

let admin = {
  __proto__: userProxy,
  _name: "Admin"
};

// Esperado: Admin
alert(admin.name); // salida: Guest (?!?)
        
      
      
      ¡Leer admin.name debería devolver "Admin", no "Guest"!
¿Qué es lo que pasa? ¿Acaso hicimos algo mal con la herencia?
Pero si quitamos el proxy, todo funciona como se espera.
En realidad el problema está en el proxy, en la línea (*).


Cuando leemos admin.name, como el objetoadmin no tiene su propia propiedad, la búsqueda va a su prototipo.


El prototipo es userProxy.


Cuando se lee la propiedad name del proxy, se dispara su trampa get y devuelve desde el objeto original como target[prop] en la línea (*).
Un llamado a target[prop], cuando prop es un getter, ejecuta su código en el contexto this=target. Entonces el resultado es this._name desde el objeto original target, que es: desde user.


Para arreglar estas situaciones, necesitamos receiver, el tercer argumento de la trampa get. Este mantiene el this correcto para pasarlo al getter. Que en nuestro caso es admin.
¿Cómo pasar el contexto para un getter? Para una función regular podemos usar call/apply, pero es un getter, no es “llamado”, solamente accedido.
Reflect.get hace eso. Todo funcionará bien si lo usamos.
Aquí la variante corregida:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  _name: "Guest",
  get name() {
    return this._name;
  }
};

let userProxy = new Proxy(user, {
  get(target, prop, receiver) { // receiver = admin
    return Reflect.get(target, prop, receiver); // (*)
  }
});


let admin = {
  __proto__: userProxy,
  _name: "Admin"
};

alert(admin.name); // Admin
        
      
      
      Ahora receiver, que mantiene una referencia al this correcto (que es admin), es pasado al getter usando Reflect.get en la línea (*).
Podemos reescribir la trampa aún más corta:

      
        
        
          get(target, prop, receiver) {
  return Reflect.get(...arguments);
}
        
      
      
      Los llamados de Reflect fueron nombrados exactamente igual a las trampas y aceptan los mismos argumentos. Fueron específicamente diseñados así.
Entonces, return Reflect... brinda una forma segura y “no cerebral” de redirigir la operación y asegurarse de que no olvidamos nada relacionado a ello.
Limitaciones del proxyProxy brinda una manera única de alterar o ajustar el comportamiento de objetos existentes al más bajo nivel. Pero no es perfecto. Hay limitaciones.
Objetos nativos: slots internosMuchos objetos nativos, por ejemplo Map, Set, Date, Promise, etc,  hacen uso de los llamados “slots internos”.
Los slots (hueco, celda) son como propiedades; pero están reservados para uso interno, con propósito de especificación únicamente. Por ejemplo, Map almacena items en el slot interno [[MapData]]. Los métodos nativos los acceden directamente, sin usar los métodos internos [[Get]]/[[Set]]. Entonces Proxy no puede interceptar eso.
¿Qué importa? ¡De cualquier manera son internos!
Bueno, hay un problema. Cuando se envuelve un objeto nativo el proxy no tiene acceso a estos slots internos, entonces los métodos nativos fallan.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

let proxy = new Proxy(map, {});

proxy.set('test', 1); // Error
        
      
      
      Internamente, un Map almacena todos los datos en su slot interno [[MapData]]. El proxy no tiene tal slot. El método nativo Map.prototype.set trata de acceder a la propiedad interna this.[[MapData]], pero como this=proxy, no puede encontrarlo en proxy y simplemente falla.
Afortunadamente, hay una forma de arreglarlo:

      
        
        
          
            
          
          
            
          
        
        
          let map = new Map();

let proxy = new Proxy(map, {
  get(target, prop, receiver) {
    let value = Reflect.get(...arguments);
    return typeof value == 'function' ? value.bind(target) : value;
  }
});

proxy.set('test', 1);
alert(proxy.get('test')); // 1 (¡Funciona!)
        
      
      
      Ahora funciona bien porque la trampa get vincula las propiedades de la función, tales como map.set, al objeto target mismo (map).
A diferencia del ejemplo previo, el valor de this dentro de proxy.set(...) no será proxy sino el map original. Entonces, cuando la implementación interna de set trata de acceder al slot interno this.[[MapData]], lo logra.

            Array no tiene slots internos
            Una excepción notable: El objeto nativo Array no tiene slots internos. Esto es por razones históricas, ya que apareció hace tanto tiempo.
Así que no hay problema en usar proxy con un array.

Campos privadosAlgo similar ocurre con los “campos privados” usados en las clases.
Por ejemplo, el método getName() accede a la propiedad privada #name y falla cuando lo proxificamos:

      
        
        
          
            
          
          
            
          
        
        
          class User {
  #name = "Guest";

  getName() {
    return this.#name;
  }
}

let user = new User();

user = new Proxy(user, {});

alert(user.getName()); // Error
        
      
      
      La razón es que los campos privados son implementados usando slots internos. JavaScript no usa [[Get]]/[[Set]] cuando accede a ellos.
En la llamada a getName(), el valor de this es el proxy userque no tiene el slot con campos privados.
De nuevo, la solución de vincular el método hace que funcione:

      
        
        
          
            
          
          
            
          
        
        
          class User {
  #name = "Guest";

  getName() {
    return this.#name;
  }
}

let user = new User();

user = new Proxy(user, {
  get(target, prop, receiver) {
    let value = Reflect.get(...arguments);
    return typeof value == 'function' ? value.bind(target) : value;
  }
});

alert(user.getName()); // Guest
        
      
      
      Dicho esto, la solución tiene su contra, explicada previamente: expone el objeto original al método, potencialmente permite ser pasado más allá y dañar otra funcionalidad del proxy.
Proxy != targetEl proxy y el objeto original son objetos diferentes. Es natural, ¿cierto?
Así que si usamos el objeto original como clave y luego lo hacemos proxy, entonces el proxy no puede ser hallado:

      
        
        
          
            
          
          
            
          
        
        
          let allUsers = new Set();

class User {
  constructor(name) {
    this.name = name;
    allUsers.add(this);
  }
}

let user = new User("John");

alert(allUsers.has(user)); // true

user = new Proxy(user, {});

alert(allUsers.has(user)); // false
        
      
      
      Como podemos ver, después del proxy no podemos hallar user en el set allUsers porque el proxy es un objeto diferente.

            El proxy no puede interceptar un test de igualdad estricta ===
            Los proxys pueden interceptar muchos operadores; tales como new (con construct), in (con has), delete (con deleteProperty) y otros.
Pero no hay forma de interceptar un test de igualdad estricta entre objetos. Un objeto es estrictamente igual únicamente a sí mismo y a ningún otro valor.
Por lo tanto todas las operaciones y clases nativas que hacen una comparación estricta de objetos diferenciarán entre el objeto original y su proxy. No hay reemplazo transparente aquí…

Proxy revocableUn proxy revocable es uno que puede ser deshabilitado.
Digamos que tenemos un recurso al que quisiéramos poder cerrar en cualquier momento.
Podemos envolverlo en un proxy revocable sin trampas. Tal proxy dirigirá todas las operaciones al objeto, y podemos deshabilitarlo en cualquier momento.
La sintaxis es:

      
        
        
          let {proxy, revoke} = Proxy.revocable(target, handler)
        
      
      
      La llamada devuelve un objeto con el proxy y la función revoke para deshabilitarlo.
Aquí hay un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let object = {
  data: "datos valiosos"
};

let {proxy, revoke} = Proxy.revocable(object, {});

// pasamos el proxy en lugar del objeto...
alert(proxy.data); // datos valiosos

// luego en nuestro código
revoke();

// el proxy no funciona más (revocado)
alert(proxy.data); // Error
        
      
      
      La llamada a revoke() quita al proxy todas las referencias internas hacia el objeto target, ya no estarán conectados.
En principio revoke está separado de proxy, así que podemos pasar proxy alrededor mientras mantenemos revoke en la vista actual.
También podemos vincular el método revoke al proxy asignándolo como propiedad: proxy.revoke = revoke.
Otra opción es crear un WeakMap que tenga a proxy como clave y su correspondiente revoke como valor, esto permite fácilmente encontrar el revoke para un proxy:

      
        
        
          
            
          
          
            
          
        
        
          let revokes = new WeakMap();

let object = {
  data: "Valuable data"
};

let {proxy, revoke} = Proxy.revocable(object, {});

revokes.set(proxy, revoke);

// ...en algún otro lado de nuestro código...
revoke = revokes.get(proxy);
revoke();

alert(proxy.data); // Error (revocado)
        
      
      
      Usamos WeakMap en lugar de Map aquí porque no bloqueará la recolección de basura. Si el objeto proxy se vuelve inalcanzable (es decir, ya ninguna variable hace referencia a él), WeakMap permite eliminarlo junto con su revoke que no necesitaremos más.
References
Specification: Proxy.
MDN: Proxy.

ResumenProxy es un envoltorio (wrapper) alrededor de un objeto que redirige las operaciones en el hacia el objeto, opcionalmente atrapando algunas de ellas para manejarlas por su cuenta.
Puede envolver cualquier tipo de objeto, incluyendo clases y funciones.
La sintaxis es:

      
        
        
          let proxy = new Proxy(target, {
  /* trampas */
});
        
      
      
      …Entonces deberíamos usar proxy en todos lados en lugar de target. Un proxy no tiene sus propias propiedades o métodos. Atrapa una operación si la trampa correspondiente le es provista, de otro modo la reenvía al objeto target.
Podemos atrapar:

Lectura (get), escritura (set), eliminación de propiedad (deleteProperty) (incluso si no existe).
Llamadas a función (trampa apply).
El operador new (trampa construct).
Muchas otras operaciones (la lista completa al principio del artículo y en docs).

Esto nos permite crear propiedades y métodos “virtuales”, implementar valores por defecto, objetos observables, decoradores de función y mucho más.
También podemos atrapar un objeto múltiples veces en proxys diferentes, decorándolos con varios aspectos de funcionalidad.
La API de Reflect está diseñada para complementar Proxy. Para cada trampa de Proxy hay una llamada Reflect con los mismos argumentos. Deberíamos usarlas para redirigir llamadas hacia los objetos target.
Los proxys tienen algunas limitaciones:

Los objetos nativos tienen “slots internos” a los que el proxy no tiene acceso. Ver la forma de sortear el problema más arriba.
Lo mismo cuenta para los campos privados en las clases porque están implementados internamente usando slots. Entonces las llamadas a métodos atrapados deben tener en this al objeto target para poder accederlos.
El test de igualdad de objeto === no puede ser interceptado.
Performance: los tests de velocidad dependen del motor, pero generalmente acceder a una propiedad usando el proxy más simple el tiempo se multiplica unas veces. Aunque en la práctica esto solo es importante para los objetos que son los “cuello de botella” de una aplicación.

TareasError al leer una propiedad no existenteUsualmente, el intento de leer una propiedad que no existe devuelve undefined.
Crea en su lugar un proxy que arroje un error por intentar leer una propiedad no existente.
Esto puede ayudar a detectar equivocaciones en la programación en forma temprana.
Escribe una función wrap(target) que tome un objeto target y devuelva un proxy que agregue este aspecto de funcionalidad.
Así es como debe funcionar:

      
        
        
          let user = {
  name: "John"
};

function wrap(target) {
  return new Proxy(target, {
      /* tu código */
  });
}

user = wrap(user);

alert(user.name); // John
alert(user.age); // ReferenceError: La propiedad no existe: "age"
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John"
};

function wrap(target) {
  return new Proxy(target, {
    get(target, prop, receiver) {
      if (prop in target) {
        return Reflect.get(target, prop, receiver);
      } else {
        throw new ReferenceError(`La propiedad no existe: "${prop}"`)
      }
    }
  });
}

user = wrap(user);

alert(user.name); // John
alert(user.age); // ReferenceError: La propiedad no existe: "age"
        
      
      
      Accediendo a array[-1]En algunos lenguajes de programación podemos acceder a los arrays usando índices negativos, contando desde el final.
Como esto:

      
        
        
          let array = [1, 2, 3];

array[-1]; // 3, el último elemento
array[-2]; // 2, el penúltimo elemento, uno antes del final
array[-3]; // 1, el antepenúltimo elemento, dos antes el final
        
      
      
      En otras palabras, array[-N] es lo mismo que array[array.length - N].
Crea un proxy para implementar tal comportamiento.
Así es como debe funcionar:

      
        
        
          let array = [1, 2, 3];

array = new Proxy(array, {
  /* tu código */
});

alert( array[-1] ); // 3
alert( array[-2] ); // 2

// el resto de la funcionalidad debe mantenerse igual.
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          let array = [1, 2, 3];

array = new Proxy(array, {
  get(target, prop, receiver) {
    if (prop < 0) {
      // incluso aunque la accedamos como arr[1]
      // prop es un string, así que necesitamos convertirla a number
      prop = +prop + target.length;
    }
    return Reflect.get(target, prop, receiver);
  }
});


alert(array[-1]); // 3
alert(array[-2]); // 2
        
      
      
      ObservableCrea una función makeObservable(target) que “haga el objeto observable” devolviendo un proxy.
Así es como debe funcionar:

      
        
        
          
            
          
          
            
          
        
        
          function makeObservable(target) {
  /* tu código */
}

let user = {};
user = makeObservable(user);

user.observe((key, value) => {
  alert(`SET ${key}=${value}`);
});

user.name = "John"; // alerta: SET name=John
        
      
      
      En otras palabras: un objeto devuelto por makeObservable es como el original, pero que también tiene el método observe(handler) que establece una función handler, la que será llamada en cualquier cambio de propiedad.
Cada vez que una propiedad cambie, handler(key, value) es llamada con el nombre y el valor de la propiedad.
P.D. En esta tarea, solo toma en cuenta la escritura de una propiedad. Otras operaciones pueden ser implementadas de manera similar.
soluciónLa solución consiste de dos partes:

Cuando .observe(handler) es llamado, necesitamos recordar el manejador ‘handler’ en algún lugar para poder llamarlo después. Podemos almacenar los manejadores directamente en el objeto, usando nuestro symbol como clave de la propiedad.
Necesitamos un proxy con la trampa set que llame a los manejadores en caso de cualquier cambio.


      
        
        
          
            
          
          
            
          
        
        
          let handlers = Symbol('handlers');

function makeObservable(target) {
  // 1. Inicializa el almacén de manejadores
  target[handlers] = [];

  // Almacena la función manejadora en el array para llamadas futuras
  target.observe = function(handler) {
    this[handlers].push(handler);
  };

  // 2. Crea un proxy para manejar cambios
  return new Proxy(target, {
    set(target, property, value, receiver) {
      let success = Reflect.set(...arguments); // reenvía la operación al objeto
      if (success) { // si no hay errores al establecer la propiedad
        // llama a todos los manejadores
        target[handlers].forEach(handler => handler(property, value));
      }
      return success;
    }
  });
}

let user = {};

user = makeObservable(user);

user.observe((key, value) => {
  alert(`SET ${key}=${value}`);
});

user.name = "John";
        
      
      
      ",
	"url": "https://es.javascript.info/proxy" 
},
{
	"docs_id": "92",
	"name": "Eval: ejecutando una cadena de código",
	"description": "La función incorporada eval permite ejecutar una cadena de código.",
	"content": "La función incorporada eval permite ejecutar una cadena de código.
La sintaxis es:

      
        
        
          let result = eval(code);
        
      
      
      Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let code = 'alert("Hello")';
eval(code); // Hello
        
      
      
      Una cadena de código puede ser larga, contener cortes de línea, declaración de funciones, variables y así.
El resultado de eval es el resultado de la última sentencia.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let value = eval('1+1');
alert(value); // 2
        
      
      
      
      
        
        
          
            
          
          
            
          
        
        
          let value = eval('let i = 0; ++i');
alert(value); // 1
        
      
      
      El código evaluado es ejecutado en el entorno léxico presente, entonces podemos ver sus variables externas:

      
        
        
          
            
          
          
            
          
        
        
          let a = 1;

function f() {
  let a = 2;

  eval('alert(a)'); // 2
}

f();
        
      
      
      También puede modificar variables externas:

      
        
        
          
            
          
          
            
          
        
        
          let x = 5;
eval("x = 10");
alert(x); // 10, valor modificado
        
      
      
      En modo estricto, eval tiene su propio entorno léxico. Entonces funciones y variables declaradas dentro de eval no son visibles fuera:

      
        
        
          
            
          
          
            
          
        
        
          // recordatorio: 'use strict' está habilitado en los ejemplos ejecutables por defecto

eval("let x = 5; function f() {}");

alert(typeof x); // undefined (no existe tal variable)
// la función f tampoco es visible
        
      
      
      Sin use strict, eval no tiene su propio entorno léxico, entonces podemos ver x y f afuera.
Usando “eval”En programación moderna eval es usado muy ocasionalmente. Se suele decir que “eval is evil” – juego de palabras en inglés que significa en español: “eval es malvado”.
La razón es simple: largo, largo tiempo atrás JavaScript era un lenguaje mucho más débil, muchas cosas podían ser concretadas solamente con eval. Pero aquel tiempo pasó hace una década.
Ahora casi no hay razones para usar eval. Si alguien lo está usando, hay buena chance de que pueda ser reemplazado con una construcción moderna del lenguaje o un Módulo JavaScript.
Por favor ten en cuenta que su habilidad para acceder a variables externas tiene efectos colaterales.
Los Code minifiers (minimizadores de código, herramientas usadas antes de poner JS en producción para comprimirlo) renombran las variables locales acortándolas (como a, b etc) para achicar el código. Usualmente esto es seguro, pero no si eval es usado porque las variables locales pueden ser accedidas desde la cadena de código evaluada. Por ello los minimizadores no hacen tal renombrado en todas las variables potencialmente visibles por eval. Esto afecta negativamente en el índice de compresión.
El uso de variables locales dentro de eval es también considerado una mala práctica de programación, porque hace el mantenimiento de código más difícil.
Hay dos maneras de estar asegurado frente a tales problemas.
Si el código evaluado no usa variables externas, por favor llama eval como window.eval(...):
De esta manera el código es ejecutado en el entorno global:

      
        
        
          
            
          
          
            
          
        
        
          let x = 1;
{
  let x = 5;
  window.eval('alert(x)'); // 1 (variable global)
}
        
      
      
      Si el código evaluado necesita variables locales, cambia eval por new Function y pásalas como argumentos:

      
        
        
          
            
          
          
            
          
        
        
          let f = new Function('a', 'alert(a)');

f(5); // 5
        
      
      
      La construcción new Function es explicada en el capítulo La sintaxis "new Function". Esta crea una función desde una cadena, también en el entorno global, y así no puede ver las variables locales. Pero es mucho más claro pasarlas explícitamente como argumentos como en el ejemplo de arriba.
ResumenUn llamado a eval(code) ejecuta la cadena de código y devuelve el resultado de la última sentencia.

Es raramente usado en JavaScript moderno, y usualmente no es necesario.
Puede acceder a variables locales externas. Esto es considerado una mala práctica.
En su lugar, para evaluar el código en el entorno global, usa window.eval(code).
O, si tu código necesita algunos datos de el entorno externo, usa new Function y pásalos como argumentos.

TareasCalculadora-evalimportancia: 4Crea una calculadora que pida una expresión aritmética y devuelva su resultado.
No es necesario verificar que la expresión sea correcta en esta tarea. Simplemente que evalue y devuelva el resultado.
Ejecutar el demosoluciónUsemos eval para calcular la expresión matemática:

      
        
        
          
            
          
          
            
          
        
        
          let expr = prompt("Escribe una expresión matemática:", '2*3+2');

alert( eval(expr) );
        
      
      
      Aunque el usuario puede ingresar cualquier texto o código.
Para hacer las cosas seguras, y limitarlo a aritmética solamente, podemos verificar expr usando una expresión regular que solo pueda contener dígitos y operadores.
",
	"url": "https://es.javascript.info/eval" 
},
{
	"docs_id": "93",
	"name": "Currificación",
	"description": "La Currificación es una técnica avanzada de trabajo con funciones. No solo se usa en JavaScript, sino también en otros lenguajes.",
	"content": "La Currificación es una técnica avanzada de trabajo con funciones. No solo se usa en JavaScript, sino también en otros lenguajes.
La currificación es una transformación de funciones que traduce una función invocable como f(a, b, c) a invocable como f(a)(b)(c).
La currificación no llama a una función. Simplemente la transforma.
Veamos primero un ejemplo, para comprender mejor de qué estamos hablando, y luego sus aplicaciones prácticas.
Crearemos una función auxiliar curry(f) que realice el curry para una f de dos argumentos. En otras palabras, curry(f) para dos argumentos f(a, b) lo traduce en una función que se ejecuta como f(a)(b):

      
        
        
          
            
          
          
            
          
        
        
          function curry(f) { // curry (f) realiza la transformación curry
  return function(a) {
    return function(b) {
      return f(a, b);
    };
  };
}

// uso
function sum(a, b) {
  return a + b;
}

let curriedSum = curry(sum);

alert( curriedSum(1)(2) ); // 3
        
      
      
      Como se puede ver, la implementación es sencilla: son solo dos contenedores.

El resultado de curry(func) es un contenedor function(a).
Cuando se llama como curriedSum(1), el argumento se guarda en el entorno léxico y se devuelve un nuevo contenedor function(b).
Luego se llama a este contenedor con 2 como argumento, y pasa la llamada a la función sum original.

Las implementaciones más avanzadas de currificación, como _.curry de la librería lodash, devuelven un contenedor que permite llamar a una función de manera normal y parcial:

      
        
        
          
            
          
          
            
          
        
        
          function sum(a, b) {
  return a + b;
}

let curriedSum = _.curry(sum); // usando _.curry desde la librería lodash

alert( curriedSum(1, 2) ); // 3, todavía se puede llamar normalmente
alert( curriedSum(1)(2) ); // 3, llamada parcial
        
      
      
      ¿Curry? ¿Para qué?Para comprender los beneficios, necesitamos un ejemplo digno, de la vida real.
Por ejemplo, tenemos la función de registro log(date, importance, message) que formatea y genera la información. En proyectos reales, tales funciones tienen muchas características útiles, como enviar registros a través de la red, aquí solo usaremos alert:

      
        
        
          function log(date, importance, message) {
  alert(`[${date.getHours()}:${date.getMinutes()}] [${importance}] ${message}`);
}
        
      
      
      ¡Pongámosle curry!

      
        
        
          log = _.curry (log);
        
      
      
      Después de eso, log funciona normalmente:

      
        
        
          log(new Date(), "DEBUG", "some debug"); // log(a, b, c)
        
      
      
      …Pero también funciona en forma de curry:

      
        
        
          log(new Date())("DEBUG")("some debug"); // log(a)(b)(c)
        
      
      
      Ahora podemos hacer fácilmente una función conveniente para los registros actuales:

      
        
        
          // logNow será el parcial del registro con el primer argumento fijo
let logNow = log(new Date());

// uso
logNow("INFO", "message"); // [HH: mm] mensaje INFO
        
      
      
      Ahora logNow es log con un primer argumento fijo, en otras palabras, “función parcialmente aplicada” o “parcial” para abreviar.
Podemos ir más allá y hacer una función conveniente para los registros de depuración actuales:

      
        
        
          let debugNow = logNow("DEBUG");

debugNow("message"); // [HH:mm] mensaje DEBUG
        
      
      
      Entonces:

No perdimos nada después del curry: log todavía se puede llamar normalmente.
Podemos generar fácilmente funciones parciales, como los registros de hoy.

Implementación avanzada de curryEn caso de que quiera entrar en detalles, aquí está la implementación de curry “avanzado” para funciones de múltiples argumentos que podríamos usar arriba.
Es bastante corto:

      
        
        
          function curry(func) {

  return function curried(...args) {
    if (args.length >= func.length) {
      return func.apply(this, args);
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      }
    }
  };

}
        
      
      
      Ejemplos de uso:

      
        
        
          function sum(a, b, c) {
  return a + b + c;
}

let curriedSum = curry(sum);

alert( curriedSum(1, 2, 3) ); // 6, todavía se puede llamar con normalidad
alert( curriedSum(1)(2,3) ); // 6, curry en el primer argumento
alert( curriedSum(1)(2)(3) ); // 6, curry completo
        
      
      
      El nuevo curry puede parecer complicado, pero en realidad es fácil de entender.
El resultado de la llamada curry(func) es el contenedor curried que se ve así:

      
        
        
          // func es la función a transformar
function curried(...args) {
  if (args.length >= func.length) { // (1)
    return func.apply(this, args);
  } else {
    return function(...args2) { // (2)
      return curried.apply(this, args.concat(args2));
    }
  }
};
        
      
      
      Cuando lo ejecutamos, hay dos ramas de ejecución if:

Si el recuento de args pasado es el mismo que tiene la función original en su definición (func.length), entonces simplemente páselo usando func.apply.
De lo contrario, obtenga un parcial: No llamamos a func aún. En cambio, se devuelve otro contenedor que volverá a aplicar curried proporcionando los argumentos anteriores junto con los nuevos.

Luego, en una nueva llamada, nuevamente obtendremos un nuevo parcial (si no hay suficientes argumentos) o, finalmente, el resultado.

            Solo funciones de longitud fija 
            El currying requiere que la función tenga un número fijo de argumentos.
Una función que utiliza múltiples parámetros, como f(...args), no se puede currificar.


            Un poco más que curry 
            Por definición, el curry debería convertir sum(a, b, c) en sum(a)(b)(c).
Pero la mayoría de las implementaciones de curry en JavaScript son avanzadas, como se describe: también mantienen la función invocable en la variante de múltiples argumentos.

ResumenCurrificación es una transformación que hace que f(a, b, c) sea invocable como f(a)(b)(c). Las implementaciones de JavaScript generalmente mantienen la función invocable normalmente y devuelven el parcial si el conteo de argumentos no es suficiente.
La currificación nos permite obtener parciales fácilmente. Como hemos visto en el ejemplo de registro, después de aplicar currificación a la función universal de tres argumentos log(fecha, importancia, mensaje) nos da parciales cuando se llama con un argumento (como log(fecha)) o dos argumentos (como log(fecha, importancia)).
",
	"url": "https://es.javascript.info/currying-partials" 
},
{
	"docs_id": "94",
	"name": "Tipo de Referencia",
	"description": "Este artículo cubre un tema avanzado para comprender mejor ciertos casos límite.",
	"content": "
            Característica del lenguaje en profundidad
            Este artículo cubre un tema avanzado para comprender mejor ciertos casos límite.
Esto no es importante. Muchos desarrolladores experimentados viven bien sin saberlo. Sigue leyendo si quieres saber cómo funcionan las cosas por debajo de la tapa.

Una llamada al método evaluado dinámicamente puede perder this.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  hi() { alert(this.name); },
  bye() { alert("Bye"); }
};

user.hi(); // Funciona

// Ahora llamemos a user.hi o user.bye dependiendo del nombre ingresado
(user.name == "John" ? user.hi : user.bye)(); // ¡Error!
        
      
      
      En la última linea hay un operador condicional que elije entre user.hi o user.bye. En este caso el resultado es user.hi.
Entonces el método es llamado con paréntesis (). ¡Pero esto no funciona correctamente!
Como puedes ver, la llamada resulta en un error porque el valor de "this" dentro de la llamada se convierte en undefined.
Esto funciona (objeto, punto, método):

      
        
        
          user.hi();
        
      
      
      Esto no funciona (método evaluado):

      
        
        
          (user.name == "John" ? user.hi : user.bye)(); // ¡Error!
        
      
      
      ¿Por qué? Si queremos entender por qué pasa esto vayamos bajo la tapa de cómo funciona la llamada obj.method().
Tipo de Referencia explicadoMirando de cerca podemos notar dos operaciones en la declaración  obj.method():

Primero, el punto '.'recupera la propiedad de obj.method.
Luego el paréntesis () lo ejecuta.

Entonces ¿cómo es trasladada la información de this de la primera parte a la segunda?
Si ponemos estas operaciones en líneas separadas, entonces this se perderá con seguridad:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  hi() { alert(this.name); }
};

// Se divide la obtención y se llama al método en dos lineas
let hi = user.hi;
hi(); // Error porque this es indefinido
        
      
      
      Aquí hi = user.hi coloca la función dentro de una variable y luego la última linea es completamente independiente, por lo tanto no hay this.
Para hacer que la llamada user.hi() funcione, JavaScript usa un truco: el punto '.' no devuelve una función, sino un valor especial del Tipo de referencia.
El Tipo de Referencia es un “tipo de especificación”. No podemos usarla explícitamente, pero es usada internamente por el lenguaje.
El valor del Tipo de Referencia es una combinación de triple valor (base, name, strict), donde:

base es el objeto.
name es el nombre de la propiedad.
strict es verdadero si use strict está en efecto.

El resultado de un acceso a la propiedad user.hi no es una función, sino un valor de Tipo de Referencia. Para user.hi en modo estricto esto es:

      
        
        
          // Valor de Tipo de Referencia
(user, "hi", true)
        
      
      
      Cuando son llamados los paréntesis () en el tipo de referencia, reciben la información completa sobre el objeto y su método y pueden establecer el this correcto (=user en este caso).
Tipo de Referencia es un tipo interno de “intermediario”, con el propósito de pasar información desde el punto . hacia los paréntesis de la llamada ().
Cualquier otra operación como la asignación hi = user.hi descarta el tipo de referencia como un todo, toma el valor de user.hi (una función) y lo pasa. Entonces cualquier operación “pierde” this.
Entonces, como resultado, el valor de this solo se pasa de la manera correcta si la función se llama directamente usando una sintaxis de punto obj.method() o corchetes obj['method']() (aquí hacen lo mismo). Hay varias formas de resolver este problema, como func.bind().
ResumenEl Tipo de Referencia es un tipo interno del lenguaje.
Leer una propiedad como las que tienen un punto . en obj.method() no devuelve exactamente el valor de la propiedad, sino un valor especial de “tipo de referencia” que almacena tanto el valor de la propiedad como el objeto del que se tomó.
Eso se hace para la llamada () al siguiente método para obtener el objeto y establecer this en él.
Para todas las demás operaciones, el tipo de referencia se convierte automáticamente en el valor de la propiedad (una función en nuestro caso).
Toda la mecánica está oculta a nuestros ojos. Solo importa en casos sutiles, como cuando un método se obtiene dinámicamente del objeto, usando una expresión.
TareasVerificación de sintaxisimportancia: 2¿Cuál es el resultado de este código?

      
        
        
          let user = {
  name: "John",
  go: function() { alert(this.name) }
}

(user.go)()
        
      
      
      P.D. Hay una trampa :)
solución¡Error!
Inténtalo:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  go: function() { alert(this.name) }
}

(user.go)() // ¡Error!
        
      
      
      El mensaje de error en la mayoría de los navegadores no nos da una pista sobre lo que salió mal.
El error aparece porque falta un punto y coma después de user = {...}.
JavaScript no inserta automáticamente un punto y coma antes de un paréntesis (user.go)(), por lo que lee el código así:

      
        
        
          let user = { go:... }(user.go)()
        
      
      
      Entonces también podemos ver que tal expresión conjunta es sintácticamente una llamada del objeto { go: ... } como una función con el argumento (user.go). Y eso también ocurre en la misma línea con let user, por lo que el objeto user aún no se ha definido y de ahí el error.
Si insertamos el punto y coma todo está bien:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  name: "John",
  go: function() { alert(this.name) }
};

(user.go)() // John
        
      
      
      Tenga en cuenta que los paréntesis alrededor de (user.go) no hacen nada aquí. Usualmente son configurados para ordenar las operaciones, pero aquí el punto . funciona primero de todas formas, por lo que no tienen ningún efecto en él. Solamente el punto y coma importa.
Explica el valor de "this"importancia: 3En el código siguiente intentamos llamar al método obj.go() 4 veces seguidas.
Pero las llamadas (1) y (2) funcionan diferente a (3) y (4). ¿Por qué?

      
        
        
          
            
          
          
            
          
        
        
          let obj, method;

obj = {
  go: function() { alert(this); }
};

obj.go();               // (1) [object Object]

(obj.go)();             // (2) [object Object]

(method = obj.go)();    // (3) undefined

(obj.go || obj.stop)(); // (4) undefined
        
      
      
      soluciónAquí está la explicación.


Esta es una llamada común al método del objeto


Lo mismo, aquí los paréntesis no cambian el orden de las operaciones, el punto es el primero de todos modos.


Aquí tenemos una llamada más compleja (expression)(). La llamada funciona como si se dividiera en dos líneas:

      
        
        
          f = obj.go; // Calcula la expresión
f();        // Llama a lo que tenemos
        
      
      
      Aquí f() se ejecuta como una función, sin this.


Lo mismo que (3), a la izquierda de los paréntesis () tenemos una expresión.


Para explicar el funcionamiento de (3) y (4) necesitamos recordar que los accesores de propiedad (punto o corchetes) devuelven un valor del Tipo de Referencia.
Cualquier operación en él excepto una llamada al método (como asignación = o ||) lo convierte en un valor ordinario que no transporta la información que permite establecer this.
",
	"url": "https://es.javascript.info/reference-type" 
},
{
	"docs_id": "95",
	"name": "BigInt",
	"description": "BigInt es un tipo numérico especial que provee soporte a enteros de tamaño arbitrario.",
	"content": "
            Una adición reciente
            
            Esta es una adición reciente al lenguaje.
            Puede encontrar el estado actual del soporte en https://caniuse.com/#feat=bigint.
            
BigInt es un tipo numérico especial que provee soporte a enteros de tamaño arbitrario.
Un bigint se crea agregando n al final del literal entero o llamando a la función BigInt que crea bigints desde cadenas, números, etc.

      
        
        
          const bigint = 1234567890123456789012345678901234567890n;

const sameBigint = BigInt("1234567890123456789012345678901234567890");

const bigintFromNumber = BigInt(10); // lo mismo que 10n
        
      
      
      Operadores matemáticosBigInt puede ser usado mayormente como un número regular, por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert(1n + 2n); // 3

alert(5n / 2n); // 2
        
      
      
      Por favor, ten en cuenta: la división 5/2 devuelve el resultado redondeado a cero, sin la parte decimal. Todas las operaciones sobre bigints devuelven bigints.
No podemos mezclar bigints con números regulares:

      
        
        
          
            
          
          
            
          
        
        
          alert(1n + 2); // Error: No se puede mezclar BigInt y otros tipos.
        
      
      
      Podemos convertirlos explícitamente cuando es necesario: usando BigInt() o Number() como aquí:

      
        
        
          
            
          
          
            
          
        
        
          let bigint = 1n;
let number = 2;

// De number a bigint
alert(bigint + BigInt(number)); // 3

// De bigint a number
alert(Number(bigint) + number); // 3
        
      
      
      Las operaciones de conversión siempre son silenciosas, nunca dan error, pero si el bigint es tan gigante que no podrá ajustarse al tipo numérico, los bits extra serán recortados, entonces deberíamos ser cuidadosos al hacer tal conversión.

            El unario más no tiene soporte en bigints
            El operador unario más +value es una manera bien conocida de convertir value a number.
Para evitar las confusiones, con bigints eso no es soportado:

      
        
        
          
            
          
          
            
          
        
        
          let bigint = 1n;

alert( +bigint ); // error
        
      
      
      Entonces debemos usar Number() para convertir un bigint a number.

ComparacionesComparaciones tales como <, > funcionan bien entre bigints y numbers:

      
        
        
          
            
          
          
            
          
        
        
          alert( 2n > 1n ); // true

alert( 2n > 1 ); // true
        
      
      
      Por favor, nota que como number y bigint pertenecen a diferentes tipos, ellos pueden ser iguales ==, pero no estrictamente iguales ===:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1 == 1n ); // true

alert( 1 === 1n ); // false
        
      
      
      Operaciones booleanasCuando están dentro de un if u otra operación booleana, los bigints se comportan como numbers.
Por ejemplo, en if, el bigint 0n es falso, los otros valores son verdaderos:

      
        
        
          
            
          
          
            
          
        
        
          if (0n) {
  // nunca se ejecuta
}
        
      
      
      Los operadores booleanos, tales como ||, && y otros, también trabajan con bigints en forma similar a los number:

      
        
        
          
            
          
          
            
          
        
        
          alert( 1n || 2 ); // 1 (1n es considerado verdadero)

alert( 0n || 2 ); // 2 (0n es considerado falso)
        
      
      
      PolyfillsHacer Polyfill con bigints es trabajoso. La razón es que muchos operadores JavaScript como +, - y otros se comportan de diferente manera comparados con los números regulares.
Por ejemplo, la división de bigints siempre devuelve un bigint (redondeado cuando es necesario).
Para emular tal comportamiento, un polyfill necesitaría analizar el código y reemplazar todos los operadores con sus funciones. Pero hacerlo es engorroso y tendría mucho costo en performance.
Por lo que no se conoce un buen polyfill.
Aunque hay otra manera, la propuesta por los desarrolladores de la librería JSBI.
Esta librería implementa bigint usando sus propios métodos. Podemos usarlos en lugar de bigints nativos:



Operación
BigInt nativo
JSBI




Creación desde Number
a = BigInt(789)
a = JSBI.BigInt(789)


Suma
c = a + b
c = JSBI.add(a, b)


Resta
c = a - b
c = JSBI.subtract(a, b)


…
…
…



…Y entonces usar polyfill (plugin Babel) para convertir las llamadas de JSBI en bigints nativos para aquellos navegadores que los soporten.
En otras palabras, este enfoque sugiere que escribamos código en JSBI en lugar de bigints nativos. Pero JSBI trabaja internamente tanto con numbers como con bigints, los emula siguiendo de cerca la especificación, entonces el código será “bigint-ready” (preparado para bigint).
Podemos usar tal código JSBI “tal como está” en motores que no soportan bigints, y para aquellos que sí lo soportan – el polyfill convertirá las llamadas en bigints nativos.
Referencias
MDN documentación BigInt.
Especificación.

",
	"url": "https://es.javascript.info/bigint" 
},
{
	"docs_id": "96",
	"name": "Entorno del navegador, especificaciones",
	"description": "El lenguaje JavaScript fue creado inicialmente para los navegadores web. Desde entonces, ha evolucionado en un lenguaje con muchos usos y plataformas.",
	"content": "El lenguaje JavaScript fue creado inicialmente para los navegadores web. Desde entonces, ha evolucionado en un lenguaje con muchos usos y plataformas.
Una plataforma puede ser un navegador, un servidor web u otro host (“anfitrión”); incluso una máquina de café “inteligente”, si puede ejecutar JavaScript. Cada uno de ellos proporciona una funcionalidad específica de la plataforma. La especificación de JavaScript llama a esto entorno de host.
Un entorno host proporciona sus propios objetos y funciones adicionales al núcleo del lenguaje. Los navegadores web proporcionan un medio para controlar las páginas web. Node.js proporciona características del lado del servidor, etc.
Aquí tienes una vista general de lo que tenemos cuando JavaScript se ejecuta en un navegador web:

      
      
        
      
      Hay un objeto “raíz” llamado window. Tiene dos roles:

Primero, es un objeto global para el código JavaScript, como se describe en el capítulo Objeto Global.
Segundo, representa la “ventana del navegador” y proporciona métodos para controlarla.

Por ejemplo, podemos usarlo como objeto global:

      
        
        
          
            
          
          
            
          
        
        
          function sayHi() {
  alert("Hola");
}

// Las funciones globales son métodos del objeto global:
window.sayHi();
        
      
      
      Y podemos usarlo como una ventana del navegador. Para ver la altura de la ventana:

      
        
        
          
            
          
          
            
          
        
        
          alert(window.innerHeight); // altura interior de la ventana
        
      
      
      Hay más métodos y propiedades específicos de window, los que cubriremos más adelante.
DOM (Modelo de Objetos del Documento)Document Object Model, o DOM, representa todo el contenido de la página como objetos que pueden ser modificados.
El objeto document es el punto de entrada a la página. Con él podemos cambiar o crear cualquier cosa en la página.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // cambiar el color de fondo a rojo
document.body.style.background = "red";

// deshacer el cambio después de 1 segundo
setTimeout(() => document.body.style.background = "", 1000);
        
      
      
      Aquí usamos document.body.style, pero hay muchos, muchos más. Las propiedades y métodos se describen en la especificación: DOM Living Standard.

            DOM no es solo para navegadores
            La especificación DOM explica la estructura de un documento y proporciona objetos para manipularlo. Hay instrumentos que no son del navegador que también usan DOM.
Por ejemplo, los scripts del lado del servidor que descargan páginas HTML y las procesan, también pueden usar DOM. Sin embargo, podrían admitir solamente parte de la especificación.


            CSSOM para los estilos
            También hay una especificación separada, CSS Object Model (CSSOM) para las reglas y hojas de estilo CSS, que explica cómo se representan como objetos y cómo leerlos y escribirlos.
CSSOM se usa junto con DOM cuando modificamos las reglas de estilo para el documento. Sin embargo, en la práctica rara vez se requiere CSSOM, porque rara vez necesitamos modificar las reglas CSS desde JavaScript (generalmente solo agregamos y eliminamos clases CSS, no modificamos sus reglas CSS), pero eso también es posible.

BOM (Modelo de Objetos del Navegador)El Modelo de Objetos del Navegador (Browser Object Model, BOM) son objetos adicionales proporcionados por el navegador (entorno host) para trabajar con todo excepto el documento.
Por ejemplo:

El objeto navigator proporciona información sobre el navegador y el sistema operativo. Hay muchas propiedades, pero las dos más conocidas son: navigator.userAgent: acerca del navegador actual, y navigator.platform: acerca de la plataforma (ayuda a distinguir Windows/Linux/Mac, etc.).
El objeto location nos permite leer la URL actual y puede redirigir el navegador a una nueva.

Aquí vemos cómo podemos usar el objeto location:

      
        
        
          
            
          
          
            
          
        
        
          alert(location.href); // muestra la URL actual
if (confirm("Ir a wikipedia?")) {
  location.href = "https://wikipedia.org"; // redirigir el navegador a otra URL
}
        
      
      
      Las funciones alert/confirm/prompt también forman parte de BOM: no están directamente relacionadas con el documento, sino que representan métodos puros de comunicación del navegador con el usuario.

            Especificaciones
            BOM es la parte general de la especificación de HTML specification.
Sí, oíste bien. La especificación HTML en https://html.spec.whatwg.org no solo trata sobre el “lenguaje HTML” (etiquetas, atributos), sino que también cubre un montón de objetos, métodos y extensiones DOM específicas del navegador. Eso es “HTML en términos generales”. Además, algunas partes tienen especificaciones adicionales listadas en https://spec.whatwg.org.

ResumenEn términos de estándares, tenemos:

La especificación del DOM
Describe la estructura del documento, las manipulaciones y los eventos; consulte https://dom.spec.whatwg.org.
La especificación del CSSOM
Describe las hojas de estilo y las reglas de estilo, las manipulaciones con ellas y su vínculo a los documentos. Consulte https://www.w3.org/TR/cssom-1/.
La especificación del HTML
Describe el lenguaje HTML (por ejemplo, etiquetas), y también el BOM (modelo de objeto del navegador) que describe varias funciones del navegador como setTimeout, alert, location, etc. Esta toma la especificación DOM y la extiende con muchas propiedades y métodos adicionales. Consulta https://html.spec.whatwg.org.

Adicionalmente, algunas clases son descritas separadamente en https://spec.whatwg.org/.
Ten en cuenta los enlaces anteriores, ya que hay tantas cosas que es imposible cubrir y recordar todo.
Cuando desees leer sobre una propiedad o un método, el manual de Mozilla en https://developer.mozilla.org/es/search es un buen recurso, pero leer las especificaciones correspondientes puede ser mejor: es más complejo y hay más para leer, pero hará que su conocimiento de los fundamentos sea sólido y completo.
Para encontrar algo, a menudo es conveniente usar una búsqueda como “WHATWG [término]” o “MDN [término]”. Por ejemplo https://google.com?q=whatwg+localstorage, https://google.com?q=mdn+localstorage.
Ahora nos concentraremos en aprender el DOM, porque document juega el papel central en la interfaz de usuario.
",
	"url": "https://es.javascript.info/browser-environment" 
},
{
	"docs_id": "97",
	"name": "Árbol del Modelo de Objetos del Documento (DOM)",
	"description": "La estructura de un documento HTML son las etiquetas.",
	"content": "La estructura de un documento HTML son las etiquetas.
Según el Modelo de Objetos del Documento (DOM), cada etiqueta HTML es un objeto. Las etiquetas anidadas son llamadas “hijas” de la etiqueta que las contiene. El texto dentro de una etiqueta también es un objeto.
Todos estos objetos son accesibles empleando JavaScript, y podemos usarlos para modificar la página.
Por ejemplo, document.body es el objeto que representa la etiqueta <body>.
Ejecutar el siguiente código hará que el <body> sea de color rojo durante 3 segundos:

      
        
        
          
            
          
          
            
          
        
        
          document.body.style.background = 'red'; // establece un color de fondo rojo

setTimeout(() => document.body.style.background = '', 3000); // volver atrás
        
      
      
      En el caso anterior usamos style.background para cambiar el color de fondo del document.body, sin embargo existen muchas otras propiedades, tales como:

innerHTML – contenido HTML del nodo.
offsetWidth – ancho del nodo (en píxeles).
…, etc.

Más adelante, aprenderemos otras formas de manipular el DOM, pero primero necesitamos conocer su estructura.
Un ejemplo del DOMComencemos con el siguiente documento simple:

      
        
        
          
            
          
          
            
          
        
        
          <!DOCTYPE HTML>
<html>
<head>
  <title>About elk</title>
</head>
<body>
  The truth about elk.
</body>
</html>
        
      
      
      El DOM representa HTML como una estructura de árbol de etiquetas. A continuación podemos ver como se muestra:


let node1 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"\n  "},{"name":"TITLE","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"About elk"}]},{"name":"#text","nodeType":3,"content":"\n"}]},{"name":"#text","nodeType":3,"content":"\n"},{"name":"BODY","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"\n  The truth about elk.\n"}]}]}

drawHtmlTree(node1, 'div.domtree', 690, 320);

En la imagen de arriba, puedes hacer clic sobre los nodos del elemento y como resultado se expanden/colapsan sus nodos hijos.
Cada nodo del árbol es un objeto.
Las etiquetas son nodos de elementos (o solo elementos) y forman la estructura del árbol: <html> está ubicado en la raíz del documento, por lo tanto, <head> y <body> son sus hijos, etc.
El texto dentro de los elementos forma nodos de texto, etiquetados como #text. Un nodo de texto contiene solo una cadena. Esta puede no tener hijos y siempre es una hoja del árbol.
Por ejemplo, la etiqueta <title> tiene el texto "About elk".
Hay que tener en cuenta los caracteres especiales en nodos de texto:

una línea nueva: ↵ (en JavaScript se emplea \n para obtener este resultado)
un espacio: ␣

Los espacios y líneas nuevas son caracteres totalmente válidos, al igual que letras y dígitos. Ellos forman nodos de texto y se convierten en parte del DOM. Así, por ejemplo, en el caso de arriba la etiqueta <head> contiene algunos espacios antes de la etiqueta <title>, entonces ese texto se convierte en el nodo #text, que contiene una nueva línea y solo algunos espacios.
Hay solo dos excepciones de nivel superior:

Los espacios y líneas nuevas antes de la etiqueta <head> son ignorados por razones históricas.
Si colocamos algo después de la etiqueta </body>, automáticamente se sitúa dentro de body, al final, ya que, la especificación HTML necesita que todo el contenido esté dentro de la etiqueta <body>, no puede haber espacios después de esta.

En otros casos todo es sencillo – si hay espacios (como cualquier carácter) en el documento, se convierten en nodos de texto en el DOM, y si los eliminamos, entonces no habrá ninguno.
En el siguiente ejemplo, no hay nodos de texto con espacios en blanco:

      
        
        
          <!DOCTYPE HTML>
<html><head><title>About elk</title></head><body>The truth about elk.</body></html>
        
      
      
      

let node2 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[{"name":"TITLE","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"About elk"}]}]},{"name":"BODY","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"The truth about elk."}]}]}

drawHtmlTree(node2, 'div.domtree', 690, 210);


            Los espacios al inicio/final de la cadena y los nodos de texto que solo contienen espacios en blanco, por lo general, están ocultos en las herramientas
            Las herramientas del navegador (las veremos más adelante) que trabajan con DOM usualmente no muestran espacios al inicio/final del texto y nodos de texto vacíos (saltos de línea) entre etiquetas.
De esta manera, las herramientas para desarrolladores ahorran espacio en la pantalla.
En otras representaciones del DOM, las omitiremos cuando sean irrelevantes. Tales espacios generalmente no afectan la forma en la cual  el documento es mostrado.

AutocorrecciónSi el navegador encuentra HTML mal escrito, lo corrige automáticamente al construir el DOM.
Por ejemplo, la etiqueta superior siempre será <html>. Incluso si no existe en el documento, ésta existirá en el DOM, puesto que, el navegador la creará. Sucede lo mismo con la etiqueta <body>.
Como ejemplo de esto, si el archivo HTML es la palabra "Hello", el navegador lo envolverá con las etiquetas <html> y <body>, y añadirá la etiqueta <head> la cual es requerida, basado en esto,  el DOM resultante será:


let node3 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[]},{"name":"BODY","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Hello"}]}]}

drawHtmlTree(node3, 'div.domtree', 690, 150);

Al generar el DOM, los navegadores procesan automáticamente los errores en el documento, cierran etiquetas, etc.
Un documento sin etiquetas de cierre:

      
        
        
          <p>Hello
<li>Mom
<li>and
<li>Dad
        
      
      
      …se convertirá en un DOM normal a medida que el navegador lee las etiquetas y compone las partes faltantes:


let node4 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[]},{"name":"BODY","nodeType":1,"children":[{"name":"P","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Hello"}]},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Mom"}]},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"and"}]},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"Dad"}]}]}]}

drawHtmlTree(node4, 'div.domtree', 690, 360);


            Las tablas siempre tienen la etiqueta <tbody>
            Un caso especial interesante son las tablas. De acuerdo a la especificación DOM deben tener la etiqueta <tbody>, sin embargo el texto HTML puede omitirla: el navegador crea automáticamente la etiqueta <tbody> en el DOM.
Para el HTML:

      
        
        
          <table id="table"><tr><td>1</td></tr></table>
        
      
      
      La estructura del DOM será:


let node5 = {"name":"TABLE","nodeType":1,"children":[{"name":"TBODY","nodeType":1,"children":[{"name":"TR","nodeType":1,"children":[{"name":"TD","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"1"}]}]}]}]};

drawHtmlTree(node5,  'div.domtree', 600, 200);

¿Lo ves? La etiqueta <tbody> apareció de la nada. Debemos tener esto en cuenta al trabajar con tablas para evitar sorpresas.

Otros tipos de nodosExisten otros tipos de nodos además de elementos y nodos de texto.
Por ejemplo, los comentarios:

      
        
        
          <!DOCTYPE HTML>
<html>
<body>
  The truth about elk.
  <ol>
    <li>An elk is a smart</li>
    <!-- comentario -->
    <li>...y el astuto animal!</li>
  </ol>
</body>
</html>
        
      
      
      

let node6 = {"name":"HTML","nodeType":1,"children":[{"name":"HEAD","nodeType":1,"children":[]},{"name":"BODY","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"\n  The truth about elk.\n  "},{"name":"OL","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"\n    "},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"An elk is a smart"}]},{"name":"#text","nodeType":3,"content":"\n    "},{"name":"#comment","nodeType":8,"content":"comment"},{"name":"#text","nodeType":3,"content":"\n    "},{"name":"LI","nodeType":1,"children":[{"name":"#text","nodeType":3,"content":"...and cunning animal!"}]},{"name":"#text","nodeType":3,"content":"\n  "}]},{"name":"#text","nodeType":3,"content":"\n\n\n"}]}]};

drawHtmlTree(node6, 'div.domtree', 690, 500);

Aquí podemos ver un nuevo tipo de nodo de árbol – nodo de comentario, etiquetado como #comment, entre dos nodos de texto.
Podemos pensar – ¿Por qué se agrega un comentario al DOM? Esto no afecta la representación de ninguna manera. Pero hay una regla – si algo está en el código HTML, entonces también debe estar en el árbol DOM.
Todo en HTML, incluso los comentarios, se convierte en parte del DOM.
Hasta la declaración <!DOCTYPE...> al principio del HTML es un nodo del DOM. Su ubicación en el DOM es justo antes de la etiqueta <html>. No vamos a tocar ese nodo, por esa razón ni siquiera lo dibujamos en diagramas, pero esta ahí.
El objeto document que representa todo el documento es también, formalmente, un nodo DOM.
Hay 12 tipos de nodos. En la práctica generalmente trabajamos con 4 de ellos:

document – el “punto de entrada” en el DOM.
nodos de elementos – Etiquetas-HTML, los bloques de construcción del árbol.
nodos de texto – contienen texto.
comentarios – a veces podemos colocar información allí, no se mostrará, pero JS puede leerla desde el DOM.

Véalo usted mismoPara ver la estructura del DOM en tiempo real, intente Live DOM Viewer. Simplemente escriba el documento, y se mostrará como un DOM al instante.
Otra forma de explorar el DOM es usando la herramienta para desarrolladores del navegador. En realidad, eso es lo que usamos cuando estamos desarrollando.
Para hacerlo, abra la página web elk.html, active las herramientas para desarroladores del navegador y cambie la pestaña a elementos.
Debe verse así:

      
      
        
      
      Puedes ver el DOM, hacer clic sobre los elementos, ver sus detalles, etc.
Tenga en cuenta que la estructura DOM en la herramienta para desarrolladores está simplificada. Los nodos de texto se muestran como texto. Y absolutamente no hay nodos de texto con espacios en blanco. Esto está bien, porque la mayoría de las veces nos interesan los nodos de elementos.
Hacer clic en el botón  ubicado en la esquina superior izquierda nos permite elegir un nodo desde la página web utilizando un “mouse” (u otros dispositivos de puntero) e “inspeccionar” (desplazarse hasta él en la pestaña elementos). Esto funciona muy bien cuando tenemos una página HTML enorme (y el DOM correspondiente es enorme) y nos gustaría ver la posición de un elemento en particular.
Otra forma de realizarlo sería hacer clic derecho en la página web y en el menú contextual elegir la opción “Inspeccionar Elemento”.

      
      
        
      
      En la parte derecha de las herramientas encontramos las siguientes sub-pestañas:

Styles – podemos ver CSS aplicado al elemento actual regla por regla, incluidas las reglas integradas (gris). Casi todo puede ser editado en el lugar, incluyendo las dimensiones/márgenes/relleno de la siguiente caja.
Computed – nos permite ver cada propiedad CSS aplicada al elemento: para cada propiedad podemos ver la regla que la provee (incluida la herencia CSS y demás).
Event Listeners – nos ayuda a ver los listener de eventos adjuntos a elementos del DOM (los cubriremos en la siguiente parte del tutorial).
…,etc.

La manera de estudiarlos es haciendo clic en ellos. Casi todos los valores son editables en el lugar.
Interacción con la consolaA medida que trabajamos el DOM, también podemos querer aplicarle JavaScript. Al igual que: obtener un nodo y ejecutar algún código para modificarlo, para ver el resultado. Aquí hay algunos consejos para desplazarse entre la pestaña elementos y la consola.
Para empezar:

Seleccione el primer elemento <li> en la pestaña elementos.
Presiona la tecla Esc – esto abrirá la consola justo debajo de la pestaña de elementos.

Ahora el último elemento seleccionado esta disponible como $0, el seleccionado previamente es $1, etc.
Podemos ejecutar comandos en ellos. Por ejemplo, $0.style.background = 'red' hace que el elemento de la lista seleccionado sea rojo, algo así:

      
      
        
      
      Así es como en la consola, se obtiene un nodo de los elementos.
También hay un camino de regreso. Si hay una variable que hace referencia a un nodo del DOM, usamos el comando inspect(node) en la consola para verlo en el panel de elementos.
O simplemente podemos generar el nodo del DOM en la consola y explorar en el lugar, así como document.body a continuación:

      
      
        
      
      Desde luego, eso es para propósitos de depuración del curso. A partir del siguiente capítulo accederemos y modificaremos el DOM usando JavaScript.
Las herramientas para desarrolladores del navegador son de mucha ayuda en el desarrollo: podemos explorar el DOM, probar cosas y ver que sale mal.
ResumenUn documento HTML/XML esta representado dentro del navegador como un árbol de nodos (DOM).

Las etiquetas se convierten en nodos de elemento y forman la estructura.
El texto se convierte en nodos de texto.
…etc, todos los elementos de HTML tienen su lugar en el DOM, incluso los comentarios.

Podemos utilizar las herramientas para desarrolladores para inspeccionar el DOM y modificarlo manualmente.
Aquí cubrimos los conceptos básicos, las acciones más importantes y más utilizadas, para comenzar. Hay una extensa documentación acerca de las herramientas para desarrolladores de Chrome en https://developers.google.com/web/tools/chrome-devtools. La mejor forma de aprender a usar las herramientas es hacer clic en ellas, leer los menús: la mayoría de las opciones son obvias. Más adelante, cuando tenga conocimiento general sobre ellas, lea los documentos y elija el resto.
Los nodos del DOM tienen propiedades y métodos que nos permiten desplazarnos entre ellos, modificarlos, movernos por la página, y más.  Empezaremos a realizar todo esto en los siguientes capítulos.
",
	"url": "https://es.javascript.info/dom-nodes" 
},
{
	"docs_id": "98",
	"name": "Recorriendo el DOM",
	"description": "El DOM nos permite hacer cualquier cosa con sus elementos y contenidos, pero lo primero que tenemos que hacer es llegar al objeto correspondiente del DOM.",
	"content": "El DOM nos permite hacer cualquier cosa con sus elementos y contenidos, pero lo primero que tenemos que hacer es llegar al objeto correspondiente del DOM.
Todas las operaciones en el DOM comienzan con el objeto document. Este es el principal “punto de entrada” al DOM. Desde ahí podremos acceder a cualquier nodo.
Esta imagen representa los enlaces que nos permiten viajar a través de los nodos del DOM:

      
      
        
      
      Vamos a analizarlos con más detalle.
En la parte superior: documentElement y bodyLos tres nodos superiores están disponibles como propiedades de document:

<html> = document.documentElement
El nodo superior del documento es document.documentElement. Este es el nodo del DOM para la etiqueta <html>.
<body> = document.body
Otro nodo muy utilizado es el elemento <body> – document.body.
<head> = document.head
La etiqueta <head> está disponible como document.head.


            Hay una trampa: document.body puede ser null
            Un script no puede acceder a un elemento que no existe en el momento de su ejecución.
Por ejemplo, si un script está dentro de <head>, entonces document.body no está disponible, porque el navegador no lo ha leído aún.
Entonces, en el siguiente ejemplo alert muestra null:

      
        
        
          
            
          
          
            
          
        
        
          <html>

<head>
  <script>
    alert( "From HEAD: " + document.body ); // null, no hay  <body> aún
  </script>
</head>

<body>

  <script>
    alert( "From BODY: " + document.body ); // HTMLBodyElement, ahora existe
  </script>

</body>
</html>
        
      
      
      

            En el mundo del DOM null significa “no existe”
            En el DOM, el valor null significa que “no existe” o “no hay tal nodo”.

Hijos: childNodes, firstChild, lastChildExisten dos términos que vamos a utilizar de ahora en adelante:

Nodos hijos (childNodes) – elementos que son hijos directos, es decir sus descendientes inmediatos. Por ejemplo, <head> y <body> son hijos del elemento <html>.
Descendientes – todos los elementos anidados de un elemento dado, incluyendo los hijos, sus hijos y así sucesivamente.

Por ejemplo, aquí <body> tiene de hijos <div> y <ul> (y unos pocos nodos de texto en blanco):

      
        
        
          
            
          
          
            
          
        
        
          <html>
<body>
  <div>Begin</div>

  <ul>
    <li>
      <b>Information</b>
    </li>
  </ul>
</body>
</html>
        
      
      
      …Y los descendientes de <body> no son solo los hijos <div>, <ul> sino también elementos anidados más profundamente, como <li> (un hijo de <ul>) o <b> (un hijo de <li>) – el subárbol entero.
La colección childNodes enumera todos los nodos hijos, incluidos los nodos de texto.
El ejemplo inferior muestra todos los hijos de document.body:

      
        
        
          
            
          
          
            
          
        
        
          <html>
<body>
  <div>Begin</div>

  <ul>
    <li>Information</li>
  </ul>

  <div>End</div>

  <script>
    for (let i = 0; i < document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Texto, DIV, Texto, UL, ..., SCRIPT
    }
  </script>
  ...más cosas...
</body>
</html>
        
      
      
      Por favor observa un interesante detalle aquí. Si ejecutamos el ejemplo anterior, el último elemento que se muestra es <script>. De hecho, el documento tiene más cosas debajo, pero en el momento de ejecución del script el navegador todavía no lo ha leído, por lo que el script no lo ve.
Las propiedades firstChild y lastChild dan acceso rápido al primer y al último hijo.
Son solo atajos. Si existieran nodos hijos, la respuesta siguiente sería siempre verdadera:

      
        
        
          elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
        
      
      
      También hay una función especial elem.hasChildNodes() para comprobar si hay algunos nodos hijos.
Colecciones del DOMComo podemos ver, childNodes parece un array. Pero realmente no es un array, sino más bien una colección – un objeto especial iterable, simil-array.
Hay dos importantes consecuencias de esto:

Podemos usar for..of para iterar sobre él:


      
        
        
          for (let node of document.body.childNodes) {
  alert(node); // enseña todos los nodos de la colección
}
        
      
      
      Eso es porque es iterable (proporciona la propiedad `Symbol.iterator`, como se requiere).


Los métodos de Array no funcionan, porque no es un array:


      
        
        
          
            
          
          
            
          
        
        
          alert(document.body.childNodes.filter); // undefined (¡No hay método filter!)
        
      
      
      La primera consecuencia es agradable. La segunda es tolerable, porque podemos usar Array.from para crear un array “real” desde la colección si es que queremos usar métodos del array:

      
        
        
          
            
          
          
            
          
        
        
          alert( Array.from(document.body.childNodes).filter ); // función
        
      
      
      
            Las colecciones DOM son solo de lectura
            Las colecciones DOM, incluso más-- todas las propiedades de navegación enumeradas en este capítulo son sólo de lectura.
No podemos reemplazar a un hijo por otro elemento asignándolo así childNodes[i] = ....
Cambiar el DOM necesita otros métodos. Los veremos en el siguiente capítulo.


            Las colecciones del DOM están vivas
            Casi todas las colecciones del DOM, salvo algunas excepciones, están vivas. En otras palabras, reflejan el estado actual del DOM.
Si mantenemos una referencia a elem.childNodes, y añadimos o quitamos nodos del DOM, entonces estos nodos aparecen en la colección automáticamente.


            No uses for..in para recorrer colecciones
            Las colecciones son iterables usando for..of. Algunas veces las personas tratan de utilizar for..in para eso.
Por favor, no lo hagas. El bucle for..in itera sobre todas las propiedades enumerables. Y las colecciones tienen unas propiedades “extra” raramente usadas que normalmente no queremos obtener:

      
        
        
          
            
          
          
            
          
        
        
          <body>
<script>
  // enseña 0, 1, longitud, item, valores y más cosas.
  for (let prop in document.body.childNodes) alert(prop);
</script>
</body>
        
      
      
      
Hermanos y el padreLos hermanos son nodos que son hijos del mismo padre.
Por ejemplo, aquí <head> y <body> son hermanos:

      
        
        
          <html>
  <head>...</head><body>...</body>
</html>
        
      
      
      
<body> se dice que es el hermano “siguiente” o a la “derecha” de <head>,
<head> se dice que es el hermano “anterior” o a la “izquierda” de <body>.

El hermano siguiente está en la propiedad nextSibling y el anterior – en previousSibling.
El padre está disponible en parentNode.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // el padre de <body> es <html>
alert( document.body.parentNode === document.documentElement ); // verdadero

// después de <head> va <body>
alert( document.head.nextSibling ); // HTMLBodyElement

// antes de <body> va <head>
alert( document.body.previousSibling ); // HTMLHeadElement
        
      
      
      Navegación solo por elementosLas propiedades de navegación enumeradas abajo se refieren a todos los nodos. Por ejemplo, en childNodes podemos ver nodos de texto, nodos elementos; y si existen, incluso los nodos de comentarios.
Pero para muchas tareas no queremos los nodos de texto o comentarios. Queremos manipular el nodo que representa las etiquetas y formularios de la estructura de la página.
Así que vamos a ver más enlaces de navegación que solo tienen en cuenta los elementos nodos:

      
      
        
      
      Los enlaces son similares a los de arriba, solo que tienen dentro la palabra Element:

children – solo esos hijos que tienen el elemento nodo.
firstElementChild, lastElementChild – el primer y el último elemento hijo.
previousElementSibling, nextElementSibling – elementos vecinos.
parentElement – elemento padre.


            ¿Por qué parentElement? ¿Puede el padre no ser un elemento?
            La propiedad parentElement devuelve el “elemento” padre, mientras parentNode devuelve “cualquier nodo” padre. Estas propiedades son normalmente las mismas: ambas seleccionan el padre.
Con la excepción de document.documentElement:

      
        
        
          
            
          
          
            
          
        
        
          alert( document.documentElement.parentNode ); // documento
alert( document.documentElement.parentElement ); // null
        
      
      
      La razón es que el nodo raíz document.documentElement (<html>) tiene a document como su padre. Pero document no es un elemento nodo, por lo que parentNode lo devuelve y parentElement no lo hace.
Este detalle puede ser útil cuando queramos navegar hacia arriba desde cualquier elemento elem al <html>, pero no hacia el document:

      
        
        
          while(elem = elem.parentElement) { // sube hasta <html>
  alert( elem );
}
        
      
      
      
Vamos a modificar uno de los ejemplos de arriba: reemplaza childNodes por children. Ahora enseña solo elementos:

      
        
        
          
            
          
          
            
          
        
        
          <html>
<body>
  <div>Begin</div>

  <ul>
    <li>Information</li>
  </ul>

  <div>End</div>

  <script>
    for (let elem of document.body.children) {
      alert(elem); // DIV, UL, DIV, SCRIPT
    }
  </script>
  ...
</body>
</html>
        
      
      
      Más enlaces: tablasHasta ahora hemos descrito las propiedades de navegación básicas.
Ciertos tipos de elementos del DOM pueden tener propiedades adicionales, específicas de su tipo, por conveniencia.
Las tablas son un gran ejemplo de ello, y representan un particular caso importante:
El elemento <table>  soporta estas propiedades (añadidas a las que hemos dado anteriormente):

table.rows – la colección de elementos<tr> de la tabla.
table.caption/tHead/tFoot – referencias a los elementos <caption>, <thead>, <tfoot>.
table.tBodies – la colección de elementos <tbody> (pueden ser muchos según el estándar, pero siempre habrá al menos uno, aunque no esté en el HTML el navegador lo pondrá en el DOM).

<thead>, <tfoot>, <tbody> estos elementos proporcionan las propiedades de las filas.

tbody.rows – la colección dentro de <tr>.

<tr>:

tr.cells – la colección de celdas <td> y <th> dentro del <tr> dado.
tr.sectionRowIndex – la posición (índice) del  <tr> dado dentro del <thead>/<tbody>/<tfoot> adjunto.
tr.rowIndex – el número de <tr> en la tabla en su conjunto (incluyendo todas las filas de una tabla).

<td> and <th>:

td.cellIndex – el número de celdas dentro del adjunto <tr>.

Un ejemplo de uso:

      
        
        
          
            
          
          
            
          
        
        
          <table id="table">
  <tr>
    <td>one</td><td>two</td>
  </tr>
  <tr>
    <td>three</td><td>four</td>
  </tr>
</table>

<script>
  // seleccionar td con "dos" (primera fila, segunda columna)
  let td = table.rows[0].cells[1];
  td.style.backgroundColor = "red"; // destacarlo
</script>
        
      
      
      La especificación: tabular data.
También hay propiedades de navegación adicionales para los formularios HTML. Las veremos más adelante cuando empecemos a trabajar con los formularios.
ResumenDado un nodo del DOM, podemos ir a sus inmediatos vecinos utilizando las propiedades de navegación.
Hay dos conjuntos principales de ellas:

Para todos los nodos: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
Para los nodos elementos: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.

Algunos tipos de elementos del DOM, por ejemplo las tablas, proveen propiedades adicionales y colecciones para acceder a su contenido.
TareasDOM childrenimportancia: 5Mira esta página:

      
        
        
          <html>
<body>
  <div>Users:</div>
  <ul>
    <li>John</li>
    <li>Pete</li>
  </ul>
</body>
</html>
        
      
      
      Para cada una de las siguientes preguntas, da al menos una forma de cómo acceder a ellos:

¿El nodo <div> del DOM?
¿El nodo <ul> del DOM?
El segundo <li> (con Pete)?

soluciónHay muchas maneras, por ejemplo:
El nodo <div> del DOM:

      
        
        
          document.body.firstElementChild
// o
document.body.children[0]
// o (el primer nodo es un espacio, así que tomamos el segundo)
document.body.childNodes[1]
        
      
      
      El nodo <ul> del DOM:

      
        
        
          document.body.lastElementChild
// o
document.body.children[1]
        
      
      
      El segundo <li> (con Pete):

      
        
        
          // obtener <ul>, y luego obtener su último elemento hijo
document.body.lastElementChild.lastElementChild
        
      
      
      La pregunta de los hermanosimportancia: 5Si elem – es un elemento nodo arbitrario del DOM…

¿Es cierto que elem.lastChild.nextSibling siempre es null?
¿Es cierto que elem.children[0].previousSibling siempre es null ?

solución
Sí, verdadero. El elemento elem.lastChild siempre es el último, no tiene nextSibling.
No, falso. elem.children[0] es el primer hijo entre elementos, pero pueden existir nodos que no son elementos antes que él. previousSibling puede ser un nodo texto.

Ten en cuenta: para ambos casos, si no hay hijos habrá un error.
Si no hay hijos, elem.lastChild es null, entonces no podemos acceder a elem.lastChild.nextSibling. Y la colección elem.children es vacía (como un array vacío []).
Seleccionar todas las celdas diagonalesimportancia: 5Escribe el código para pintar todas las celdas diagonales de rojo.
Necesitarás obtener todas las <td> de la <table> y pintarlas usando el código:

      
        
        
          // td debe ser la referencia a la celda de la tabla
td.style.backgroundColor = 'red';
        
      
      
      El resultado debe ser:

    
    
  Abrir un entorno controlado para la tarea.soluciónUsaremos las propiedades de las filas y las celdas para acceder a las celdas de la tabla diagonal
Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/dom-navigation" 
},
{
	"docs_id": "99",
	"name": "Buscar: getElement*, querySelector*",
	"description": "Las propiedades de navegación del DOM son ideales cuando los elementos están cerca unos de otros. Pero, ¿y si no lo están? ¿Cómo obtener un elemento arbitrario de la página?",
	"content": "Las propiedades de navegación del DOM son ideales cuando los elementos están cerca unos de otros. Pero, ¿y si no lo están? ¿Cómo obtener un elemento arbitrario de la página?
Para estos casos existen métodos de búsqueda adicionales.
document.getElementById o sólo idSi un elemento tiene el atributo id, podemos obtener el elemento usando el método document.getElementById(id), sin importar dónde se encuentre.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <div id="elem">
  <div id="elem-content">Elemento</div>
</div>

<script>
  // obtener el elemento
  let elem = document.getElementById('elem');

  // hacer que su fondo sea rojo
  elem.style.background = 'red';
</script>
        
      
      
      Existe además una variable global nombrada por el id que hace referencia al elemento:

      
        
        
          
            
          
          
            
          
        
        
          <div id="elem">
  <div id="elem-content">Elemento</div>
</div>

<script>
  // elem es una referencia al elemento del DOM con id="elem"
  elem.style.background = 'red';

  // id="elem-content" tiene un guion en su interior, por lo que no puede ser un nombre de variable
  // ...pero podemos acceder a él usando corchetes: window['elem-content']
</script>
        
      
      
      …Esto es a menos que declaremos una variable de JavaScript con el mismo nombre, entonces ésta tiene prioridad:

      
        
        
          
            
          
          
            
          
        
        
          <div id="elem"></div>

<script>
  let elem = 5; // ahora elem es 5, no una referencia a <div id="elem">

  alert(elem); // 5
</script>
        
      
      
      
            Por favor, no utilice variables globales nombradas por id para acceder a los elementos
            Este comportamiento se encuentra descrito en la especificación, por lo que es una especie de estándar, pero está soportado principalmente para compatibilidad.
El navegador intenta ayudarnos mezclando espacios de nombres (namespaces) de JS y DOM. Esto está bien para los scripts simples, incrustados en HTML, pero generalmente no es una buena práctica. Puede haber conflictos de nombres. Además, cuando uno lee el código de JS y no tiene el HTML a la vista, no es obvio de dónde viene la variable.
Aquí en el tutorial usamos id para referirnos directamente a un elemento por brevedad, cuando es obvio de dónde viene el elemento.
En la vida real document.getElementById es el método preferente.


            El id debe ser único
            El id debe ser único. Sólo puede haber en todo el documento un elemento con un id determinado.
Si hay múltiples elementos con el mismo id, entonces el comportamiento de los métodos que lo usan es impredecible, por ejemplo document.getElementById puede devolver cualquiera de esos elementos al azar. Así que, por favor, sigan la regla y mantengan el id único.


            Sólo document.getElementById, no anyElem.getElementById
            El método getElementById sólo puede ser llamado en el objeto document. Busca el id dado en todo el documento.

querySelectorAllSin duda el método más versátil, elem.querySelectorAll(css) devuelve todos los elementos dentro de elem que coinciden con el selector CSS dado.
Aquí buscamos todos los elementos <li> que son los últimos hijos:

      
        
        
          
            
          
          
            
          
        
        
          <ul>
  <li>La</li>
  <li>prueba</li>
</ul>
<ul>
  <li>ha</li>
  <li>pasado/li>
</ul>
<script>
  let elements = document.querySelectorAll('ul > li:last-child');

  for (let elem of elements) {
    alert(elem.innerHTML); // "prueba", "pasado"
  }
</script>
        
      
      
      Este método es muy poderoso, porque se puede utilizar cualquier selector de CSS.

            También se pueden usar pseudoclases
            Las pseudoclases como :hover (cuando el cursor sobrevuela el elemento) y :active (cuando hace clic con el botón principal) también son soportadas. Por ejemplo, document.querySelectorAll(':hover') devolverá una colección de elementos sobre los que el puntero hace hover en ese momento (en orden de anidación: desde el más exterior <html> hasta el más anidado).

querySelectorLa llamada a elem.querySelector(css) devuelve el primer elemento para el selector CSS dado.
En otras palabras, el resultado es el mismo que elem.querySelectorAll(css)[0], pero este último busca todos los elementos y elige uno, mientras que elem.querySelector sólo busca uno. Así que es más rápido y también más corto de escribir.
matchesLos métodos anteriores consistían en buscar en el DOM.
El elem.matches(css) no busca nada, sólo comprueba si el elem coincide con el selector CSS dado. Devuelve true o false.
Este método es útil cuando estamos iterando sobre elementos (como en un array) y tratando de filtrar los que nos interesan.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>

<script>
  // puede ser cualquier colección en lugar de document.body.children
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      alert("La referencia del archivo: " + elem.href );
    }
  }
</script>
        
      
      
      closestLos ancestros de un elemento son: el padre, el padre del padre, su padre y así sucesivamente. Todos los ancestros juntos forman la cadena de padres desde el elemento hasta la cima.
El método elem.closest(css) busca el ancestro más cercano que coincide con el selector CSS. El propio elem también se incluye en la búsqueda.
En otras palabras, el método closest sube del elemento y comprueba cada uno de los padres. Si coincide con el selector, entonces la búsqueda se detiene y devuelve dicho ancestro.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <h1>Contenido</h1>

<div class="contents">
  <ul class="book">
    <li class="chapter">Capítulo 1</li>
    <li class="chapter">Capítulo 2</li>
  </ul>
</div>

<script>
  let chapter = document.querySelector('.chapter'); // LI

  alert(chapter.closest('.book')); // UL
  alert(chapter.closest('.contents')); // DIV

  alert(chapter.closest('h1')); // null (porque h1 no es un ancestro)
</script>
        
      
      
      getElementsBy*También hay otros métodos que permiten buscar nodos por una etiqueta, una clase, etc.
Hoy en día, son en su mayoría historia, ya que querySelector es más poderoso y corto de escribir.
Aquí los cubrimos principalmente por completar el temario, aunque todavía se pueden encontrar en scripts antiguos.

elem.getElementsByTagName(tag) busca elementos con la etiqueta dada y devuelve una colección con ellos. El parámetro tag también puede ser un asterisco "*" para “cualquier etiqueta”.
elem.getElementsByClassName(className) devuelve elementos con la clase dada.
document.getElementsByName(name) devuelve elementos con el atributo name dado, en todo el documento. Muy raramente usado.

Por ejemplo:

      
        
        
          // obtener todos los divs del documento
let divs = document.getElementsByTagName('div');
        
      
      
      Para encontrar todas las etiquetas input dentro de una tabla:

      
        
        
          
            
          
          
            
          
        
        
          <table id="table">
  <tr>
    <td>Su edad:</td>

    <td>
      <label>
        <input type="radio" name="age" value="young" checked> menos de 18
      </label>
      <label>
        <input type="radio" name="age" value="mature"> de 18 a 50
      </label>
      <label>
        <input type="radio" name="age" value="senior"> más de 60
      </label>
    </td>
  </tr>
</table>

<script>
  let inputs = table.getElementsByTagName('input');

  for (let input of inputs) {
    alert( input.value + ': ' + input.checked );
  }
</script>
        
      
      
      
            ¡No olvides la letra "s"!
            Los desarrolladores novatos a veces olvidan la letra "s". Esto es, intentan llamar a getElementByTagName en vez de a getElementsByTagName.
La letra "s" no se encuentra en getElementById porque devuelve sólo un elemento. But getElementsByTagName devuelve una colección de elementos, de ahí que tenga la "s".


            ¡Devuelve una colección, no un elemento!
            Otro error muy extendido entre los desarrolladores novatos es escribir:

      
        
        
          // no funciona
document.getElementsByTagName('input').value = 5;
        
      
      
      Esto no funcionará, porque toma una colección de inputs y le asigna el valor a ella en lugar de a los elementos dentro de ella.
En dicho caso, deberíamos iterar sobre la colección o conseguir un elemento por su índice y luego asignarlo así:

      
        
        
          // debería funcionar (si hay un input)
document.getElementsByTagName('input')[0].value = 5;
        
      
      
      
Buscando elementos .article:

      
        
        
          
            
          
          
            
          
        
        
          <form name="my-form">
  <div class="article">Artículo</div>
  <div class="long article">Artículo largo</div>
</form>

<script>
  // encontrar por atributo de nombre
  let form = document.getElementsByName('my-form')[0];

  // encontrar por clase dentro del formulario
  let articles = form.getElementsByClassName('article');
  alert(articles.length); // 2, encontró dos elementos con la clase "article"
</script>
        
      
      
      Colecciones vivasTodos los métodos "getElementsBy*" devuelven una colección viva (live collection). Tales colecciones siempre reflejan el estado actual del documento y se “auto-actualizan” cuando cambia.
En el siguiente ejemplo, hay dos scripts.

El primero crea una referencia a la colección de <div>. Por ahora, su longitud es 1.
El segundo script se ejecuta después de que el navegador se encuentre con otro <div>, por lo que su longitud es de 2.


      
        
        
          
            
          
          
            
          
        
        
          <div>Primer div</div>

<script>
  let divs = document.getElementsByTagName('div');
  alert(divs.length); // 1
</script>

<div>Segundo div</div>

<script>
  alert(divs.length); // 2
</script>
        
      
      
      Por el contrario, querySelectorAll devuelve una colección estática. Es como un array de elementos fijos.
Si lo utilizamos en lugar de getElementsByTagName, entonces ambos scripts dan como resultado 1:

      
        
        
          
            
          
          
            
          
        
        
          <div>Primer div</div>

<script>
  let divs = document.querySelectorAll('div');
  alert(divs.length); // 1
</script>

<div>Segundo div</div>

<script>
  alert(divs.length); // 1
</script>
        
      
      
      Ahora podemos ver fácilmente la diferencia. La colección estática no aumentó después de la aparición de un nuevo div en el documento.
ResumenHay 6 métodos principales para buscar nodos en el DOM:



Método
Busca por...
¿Puede llamar a un elemento?
¿Vivo?




querySelector
selector CSS
✔
-


querySelectorAll
selector CSS
✔
-


getElementById
id
-
-


getElementsByName
name
-
✔


getElementsByTagName
etiqueta o '*'
✔
✔


getElementsByClassName
class
✔
✔



Los más utilizados son querySelector y querySelectorAll, pero getElementBy* puede ser de ayuda esporádicamente o encontrarse en scripts antiguos.
Aparte de eso:

Existe elem.matches(css) para comprobar si elem coincide con el selector CSS dado.
Existe elem.closest(css) para buscar el ancestro más cercano que coincida con el selector CSS dado. El propio elem también se comprueba.

Y mencionemos un método más para comprobar la relación hijo-padre, ya que a veces es útil:

elemA.contains(elemB) devuelve true si elemB está dentro de elemA (un descendiente de elemA) o cuando elemA==elemB.

TareasBuscar elementosimportancia: 4Aquí está el documento con la tabla y el formulario.
¿Cómo encontrar?…

La tabla con id="age-table".
Todos los elementos labeldentro de la tabla (debería haber 3).
El primer td en la tabla (con la palabra “Age”).
El form con name="search".
El primer input en ese formulario.
El último input en ese formulario.

Abra la página table.html en una ventana separada y haga uso de las herramientas del navegador.
soluciónHay muchas maneras de resolverlo.
Aquí hay algunas de ellas:

      
        
        
          // 1. La tabla con `id="age-table"`.
let table = document.getElementById('age-table')

// 2. Todos los elementos `label` dentro de esa tabla
table.getElementsByTagName('label')
// or
document.querySelectorAll('#age-table label')

// 3. El primer `td` en la tabla (con la palabra "Age")
table.rows[0].cells[0]
// or
table.getElementsByTagName('td')[0]
// or
table.querySelector('td')

// 4. El `form` con name="search"
// suponiendo que sólo hay un elemento con name="search" en el documento
let form = document.getElementsByName('search')[0]
//o, utilizando el form específicamente
document.querySelector('form[name="search"]')

// 5. El primer input en el form.
form.getElementsByTagName('input')[0]
// o
form.querySelector('input')

// 6. El último input en el form.
let inputs = form.querySelectorAll('input') // encontrar todos los inputs
inputs[inputs.length-1] // obtener el último
        
      
      
      ",
	"url": "https://es.javascript.info/searching-elements-dom" 
},
{
	"docs_id": "100",
	"name": "Propiedades del nodo: tipo, etiqueta y contenido",
	"description": "Echemos un mirada más en profundidad a los nodos DOM.",
	"content": "Echemos un mirada más en profundidad a los nodos DOM.
En este capítulo veremos más sobre cuáles son y aprenderemos sus propiedades más utilizadas.
Clases de nodo DOMLos diferentes nodos DOM pueden tener diferentes propiedades. Por ejemplo, un nodo de elemento correspondiente a la etiqueta <a> tiene propiedades relacionadas con el enlace, y el correspondiente a <input> tiene propiedades relacionadas con la entrada y así sucesivamente. Los nodos de texto no son lo mismo que los nodos de elementos. Pero también hay propiedades y métodos comunes entre todos ellos, porque todas las clases de nodos DOM forman una única jerarquía.
Cada nodo DOM pertenece a la clase nativa correspondiente.
La raíz de la jerarquía es EventTarget, que es heredada por Node, y otros nodos DOM heredan de él.
Aquí está la imagen, con las explicaciones a continuación:

      
      
        
      
      Las clases son:


EventTarget – es la clase raíz “abstracta”.
Los objetos de esta clase nunca se crean. Sirve como base, es por la que todos los nodos DOM soportan los llamados “eventos” que estudiaremos más adelante.


Node – también es una clase “abstracta”, sirve como base para los nodos DOM.
Proporciona la funcionalidad del árbol principal: parentNode, nextSibling, childNodes y demás (son getters). Los objetos de la clase Node nunca se crean. Pero hay clases de nodos concretas que heredan de ella (y también heredan la funcionalidad de Node).


Document, por razones históricas, heredado a menudo por HTMLDocument (aunque la última especificación no lo exige) – es el documento como un todo.
El objeto global document pertenece exactamente a esta clase. Sirve como punto de entrada al DOM.


CharacterData – una clase “abstract” heredada por:

Text – la clase correspondiente a texto dentro de los elementos, por ejemplo Hello en <p>Hello</p>.
Comment – la clase para los “comentarios”. No se muestran, pero cada comentario se vuelve un miembro del DOM.



Element – es una clase base para elementos DOM.
Proporciona navegación a nivel de elemento como nextElementSibling, children y métodos de búsqueda como getElementsByTagName, querySelector.
Un navegador admite no solo HTML, sino también XML y SVG. La clase Element sirve como base para clases más específicas: SVGElement, XMLElement (no las necesitamos aquí) y HTMLElement.


Finalmente, HTMLElement – es la clase básica para todos los elementos HTML. Trabajaremos con ella la mayor parte del tiempo.
Es heredado por elementos HTML concretos:

HTMLInputElement – la clase para elementos <input>,
HTMLBodyElement – la clase para los elementos <body>,
HTMLAnchorElement – la clase para elementos <a>,
…y así sucesivamente.



Hay muchas otras etiquetas con sus propias clases que pueden tener propiedades y métodos específicos, mientras que algunos elementos, tales como <span>, <section>, <article>, no tienen ninguna propiedad específica entonces derivan de la clase HTMLElement.
Entonces, el conjunto completo de propiedades y métodos de un nodo dado viene como resultado de la cadena de herencia.
Por ejemplo, consideremos el objeto DOM para un elemento <input>. Pertenece a la clase HTMLInputElement.
Obtiene propiedades y métodos como una superposición de (enumerados en orden de herencia):

HTMLInputElement – esta clase proporciona propiedades específicas de entrada,
HTMLElement – proporciona métodos de elementos HTML comunes (y getters/setters),
Element – proporciona métodos de elementos genéricos,
Node – proporciona propiedades comunes del nodo DOM,
EventTarget – da el apoyo para eventos (a cubrir),
…y finalmente hereda de Object, por lo que también están disponibles métodos de “objeto simple” como hasOwnProperty.

Para ver el nombre de la clase del nodo DOM, podemos recordar que un objeto generalmente tiene la propiedad constructor. Hace referencia al constructor de la clase, y constructor.name es su nombre:

      
        
        
          
            
          
          
            
          
        
        
          alert( document.body.constructor.name ); // HTMLBodyElement
        
      
      
      …O podemos simplemente usar toString:

      
        
        
          
            
          
          
            
          
        
        
          alert( document.body ); // [object HTMLBodyElement]
        
      
      
      También podemos usar instanceof para verificar la herencia:

      
        
        
          
            
          
          
            
          
        
        
          alert( document.body instanceof HTMLBodyElement ); // true
alert( document.body instanceof HTMLElement ); // true
alert( document.body instanceof Element ); // true
alert( document.body instanceof Node ); // true
alert( document.body instanceof EventTarget ); // true
        
      
      
      Como podemos ver, los nodos DOM son objetos regulares de JavaScript. Usan clases basadas en prototipos para la herencia.
Eso también es fácil de ver al generar un elemento con console.dir(elem) en un navegador. Allí, en la consola, puede ver HTMLElement.prototype, Element.prototype y así sucesivamente.

            console.dir(elem) versus console.log(elem)
            La mayoría de los navegadores admiten dos comandos en sus herramientas de desarrollo: console.log y console.dir. Envían sus argumentos a la consola. Para los objetos JavaScript, estos comandos suelen hacer lo mismo.
Pero para los elementos DOM son diferentes:

console.log(elem) muestra el árbol DOM del elemento.
console.dir(elem) muestra el elemento como un objeto DOM, es bueno para explorar sus propiedades.

Inténtalo en document.body.


            IDL en la especificación
            En la especificación, las clases DOM no se describen mediante JavaScript, sino con un Lenguaje de descripción de interfaz (IDL) especial, que suele ser fácil de entender.
En IDL, todas las propiedades están precedidas por sus tipos. Por ejemplo, DOMString, boolean y así sucesivamente.
Aquí hay un extracto, con comentarios:

      
        
        
          // Definir HTMLInputElement
// Los dos puntos ":" significan que HTMLInputElement hereda de HTMLElement
interface HTMLInputElement: HTMLElement {
  // aquí van las propiedades y métodos de los elementos <input>

  // "DOMString" significa que el valor de una propiedad es un string
  attribute DOMString accept;
  attribute DOMString alt;
  attribute DOMString autocomplete;
  attribute DOMString value;

  // Propiedad de valor booleano (true/false)
  attribute boolean autofocus;
  ...
  // ahora el método: "void" significa que el método no devuelve ningún valor
  void select();
  ...
}
        
      
      
      
La propiedad “nodeType”La propiedad nodeType proporciona una forma “anticuada” más de obtener el “tipo” de un nodo DOM.
Tiene un valor numérico:

elem.nodeType == 1 para nodos de elementos,
elem.nodeType == 3 para nodos de texto,
elem.nodeType == 9 para el objeto de documento,
hay algunos otros valores en la especificación.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <body>
  <script>
  let elem = document.body;

  // vamos a examinar: ¿qué tipo de nodo es elem?
  alert(elem.nodeType); // 1 => elemento

  // Y el primer hijo es...
  alert(elem.firstChild.nodeType); // 3 => texto

  // para el objeto de tipo documento, el tipo es 9
  alert( document.nodeType ); // 9
  </script>
</body>
        
      
      
      En los scripts modernos, podemos usar instanceof y otras pruebas basadas en clases para ver el tipo de nodo, pero a veces nodeType puede ser más simple. Solo podemos leer nodeType, no cambiarlo.
Tag: nodeName y tagNameDado un nodo DOM, podemos leer su nombre de etiqueta en las propiedades de nodeName o tagName:
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( document.body.nodeName ); // BODY
alert( document.body.tagName ); // BODY
        
      
      
      ¿Hay alguna diferencia entre tagName y nodeName?
Claro, la diferencia se refleja en sus nombres, pero de hecho es un poco sutil.

La propiedad tagName existe solo para los nodos Element.
El nodeName se define para cualquier Node:

para los elementos, significa lo mismo que tagName.
para otros tipos de nodo (texto, comentario, etc.) tiene una cadena con el tipo de nodo.



En otras palabras, tagName solo es compatible con los nodos de elementos (ya que se origina en la clase Element), mientras que nodeName puede decir algo sobre otros tipos de nodos.
Por ejemplo, comparemos tagName y nodeName para document y un nodo de comentario:

      
        
        
          
            
          
          
            
          
        
        
          <body><!-- comentario -->

  <script>
    // para comentarios
    alert( document.body.firstChild.tagName ); // undefined (no es un elemento)
    alert( document.body.firstChild.nodeName ); // #comment

    // para documentos
    alert( document.tagName ); // undefined (no es un elemento)
    alert( document.nodeName ); // #document
  </script>
</body>
        
      
      
      Si solo tratamos con elementos, entonces podemos usar tanto tagName como nodeName – no hay diferencia.

            El nombre de la etiqueta siempre está en mayúsculas, excepto en el modo XML
            El navegador tiene dos modos de procesar documentos: HTML y XML. Por lo general, el modo HTML se usa para páginas web. El modo XML está habilitado cuando el navegador recibe un documento XML con el encabezado: Content-Type: application/xml+xhtml.
En el modo HTML, tagName/nodeName siempre está en mayúsculas: es BODY ya sea para <body> o <BoDy>.
En el modo XML, el caso se mantiene “tal cual”. Hoy en día, el modo XML rara vez se usa.

innerHTML: los contenidosLa propiedad innerHTML permite obtener el HTML dentro del elemento como un string.
También podemos modificarlo. Así que es una de las formas más poderosas de cambiar la página.
El ejemplo muestra el contenido de document.body y luego lo reemplaza por completo:

      
        
        
          
            
          
          
            
          
        
        
          <body>
  <p>Un párrafo</p>
  <div>Un div</div>

  <script>
    alert( document.body.innerHTML ); // leer el contenido actual
    document.body.innerHTML = 'El nuevo BODY!'; // reemplazar
  </script>

</body>
        
      
      
      Podemos intentar insertar HTML no válido, el navegador corregirá nuestros errores:

      
        
        
          
            
          
          
            
          
        
        
          <body>

  <script>
    document.body.innerHTML = '<b>prueba'; // olvidé cerrar la etiqueta
    alert( document.body.innerHTML ); // <b>prueba</b> (arreglado)
  </script>

</body>
        
      
      
      
            Los scripts no se ejecutan
            Si innerHTML inserta una etiqueta <script> en el documento, se convierte en parte de HTML, pero no se ejecuta.

Cuidado: “innerHTML+=” hace una sobrescritura completaPodemos agregar HTML a un elemento usando elem.innerHTML+="more html".
Así:

      
        
        
          chatDiv.innerHTML += "<div>Hola<img src='smile.gif'/> !</div>";
chatDiv.innerHTML += "¿Cómo vas?";
        
      
      
      Pero debemos tener mucho cuidado al hacerlo, porque lo que está sucediendo no es una adición, sino una sobrescritura completa.
Técnicamente, estas dos líneas hacen lo mismo:

      
        
        
          elem.innerHTML += "...";
// es una forma más corta de escribir:
elem.innerHTML = elem.innerHTML + "..."
        
      
      
      En otras palabras, innerHTML+= hace esto:

Se elimina el contenido antiguo.
En su lugar, se escribe el nuevo innerHTML (una concatenación del antiguo y el nuevo).

Como el contenido se “pone a cero” y se reescribe desde cero, todas las imágenes y otros recursos se volverán a cargar..
En el ejemplo de chatDiv arriba, la línea chatDiv.innerHTML+="¿Cómo va?" recrea el contenido HTML y recarga smile.gif (con la esperanza de que esté en caché). Si chatDiv tiene muchos otros textos e imágenes, entonces la recarga se vuelve claramente visible.
También hay otros efectos secundarios. Por ejemplo, si el texto existente se seleccionó con el mouse, la mayoría de los navegadores eliminarán la selección al reescribir innerHTML. Y si había un <input> con un texto ingresado por el visitante, entonces el texto será eliminado. Y así.
Afortunadamente, hay otras formas de agregar HTML además de innerHTML, y las estudiaremos pronto.
outerHTML: HTML completo del elementoLa propiedad outerHTML contiene el HTML completo del elemento. Eso es como innerHTML más el elemento en sí.
He aquí un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <div id="elem">Hola <b>Mundo</b></div>

<script>
  alert(elem.outerHTML); // <div id="elem">Hola <b>Mundo</b></div>
</script>
        
      
      
      Cuidado: a diferencia de innerHTML, escribir en outerHTML no cambia el elemento. En cambio, lo reemplaza en el DOM.
Sí, suena extraño, y es extraño, por eso hacemos una nota aparte al respecto aquí. Echa un vistazo.
Considera el ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <div>¡Hola, mundo!</div>

<script>
  let div = document.querySelector('div');

  // reemplaza div.outerHTML con <p>...</p>
  div.outerHTML = '<p>Un nuevo elemento</p>'; // (*)

  // ¡Guauu! ¡'div' sigue siendo el mismo!
  alert(div.outerHTML); // <div>¡Hola, mundo!</div> (**)
</script>
        
      
      
      Parece realmente extraño, ¿verdad?
En la línea (*) reemplazamos div con <p>Un nuevo elemento</p>. En el documento externo (el DOM) podemos ver el nuevo contenido en lugar del <div>. Pero, como podemos ver en la línea (**), ¡el valor de la antigua variable div no ha cambiado!
La asignación outerHTML no modifica el elemento DOM (el objeto al que hace referencia, en este caso, la variable ‘div’), pero lo elimina del DOM e inserta el nuevo HTML en su lugar.
Entonces, lo que sucedió en div.outerHTML=... es:

div fue eliminado del documento.
Otro fragmento de HTML <p>Un nuevo elemento</p> se insertó en su lugar.
div todavía tiene su antiguo valor. El nuevo HTML no se guardó en ninguna variable.

Es muy fácil cometer un error aquí: modificar div.outerHTML y luego continuar trabajando con div como si tuviera el nuevo contenido. Pero no es así. Esto es correcto para innerHTML, pero no para outerHTML.
Podemos escribir en elem.outerHTML, pero debemos tener en cuenta que no cambia el elemento en el que estamos escribiendo (‘elem’). En su lugar, coloca el nuevo HTML en su lugar. Podemos obtener referencias a los nuevos elementos consultando el DOM.
nodeValue/data: contenido del nodo de textoLa propiedad innerHTML solo es válida para los nodos de elementos.
Otros tipos de nodos, como los nodos de texto, tienen su contraparte: propiedades nodeValue y data. Estas dos son casi iguales para uso práctico, solo hay pequeñas diferencias de especificación. Entonces usaremos data, porque es más corto.
Un ejemplo de lectura del contenido de un nodo de texto y un comentario:

      
        
        
          
            
          
          
            
          
        
        
          <body>
  Hola
  <!-- Comentario -->
  <script>
    let text = document.body.firstChild;
    alert(text.data); // Hola

    let comment = text.nextSibling;
    alert(comment.data); // Comentario
  </script>
</body>
        
      
      
      Para los nodos de texto podemos imaginar una razón para leerlos o modificarlos, pero ¿por qué comentarios?
A veces, los desarrolladores incorporan información o instrucciones de plantilla en HTML, así:

      
        
        
          <!-- if isAdmin -->
  <div>¡Bienvenido, administrador!</div>
<!-- /if -->
        
      
      
      …Entonces JavaScript puede leerlo desde la propiedad data y procesar las instrucciones integradas.
textContent: texto puroEl textContent proporciona acceso al texto dentro del elemento: solo texto, menos todas las <tags>.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <div id="news">
  <h1>¡Titular!</h1>
  <p>¡Los marcianos atacan a la gente!</p>
</div>

<script>
  // ¡Titular! ¡Los marcianos atacan a la gente!
  alert(news.textContent);
</script>
        
      
      
      Como podemos ver, solo se devuelve texto, como si todas las <etiquetas> fueran recortadas, pero el texto en ellas permaneció.
En la práctica, rara vez se necesita leer este tipo de texto.
Escribir en textContent es mucho más útil, porque permite escribir texto de “forma segura”.
Digamos que tenemos un string arbitrario, por ejemplo, ingresado por un usuario, y queremos mostrarlo.

Con innerHTML lo tendremos insertado “como HTML”, con todas las etiquetas HTML.
Con textContent lo tendremos insertado “como texto”, todos los símbolos se tratan literalmente.

Compara los dos:

      
        
        
          
            
          
          
            
          
        
        
          <div id="elem1"></div>
<div id="elem2"></div>

<script>
  let name = prompt("¿Cuál es tu nombre?", "<b>¡Winnie-Pooh!</b>");

  elem1.innerHTML = name;
  elem2.textContent = name;
</script>
        
      
      
      
El primer <div> obtiene el nombre “como HTML”: todas las etiquetas se convierten en etiquetas, por lo que vemos el nombre en negrita.
El segundo <div> obtiene el nombre “como texto”, así que literalmente vemos <b>¡Winnie-Pooh!</b>.

En la mayoría de los casos, esperamos el texto de un usuario y queremos tratarlo como texto. No queremos HTML inesperado en nuestro sitio. Una asignación a textContent hace exactamente eso.
La propiedad “hidden”El atributo “hidden” y la propiedad DOM especifican si el elemento es visible o no.
Podemos usarlo en HTML o asignarlo usando JavaScript, así:

      
        
        
          
            
          
          
            
          
        
        
          <div>Ambos divs a continuación están ocultos</div>

<div hidden>Con el atributo "hidden"</div>

<div id="elem">JavaScript asignó la propiedad "hidden"</div>

<script>
  elem.hidden = true;
</script>
        
      
      
      Técnicamente, hidden funciona igual que style="display:none". Pero es más corto de escribir.
Aquí hay un elemento parpadeante:

      
        
        
          
            
          
          
            
          
        
        
          <div id="elem">Un elemento parpadeante</div>

<script>
  setInterval(() => elem.hidden = !elem.hidden, 1000);
</script>
        
      
      
      Más propiedadesLos elementos DOM también tienen propiedades adicionales, en particular aquellas que dependen de la clase:

value – el valor para <input>, <select> y <textarea> (HTMLInputElement, HTMLSelectElement…).
href – el “href” para <a href="..."> (HTMLAnchorElement).
id – el valor del atributo “id”, para todos los elementos (HTMLElement).
…y mucho más…

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <input type="text" id="elem" value="value">

<script>
  alert(elem.type); // "text"
  alert(elem.id); // "elem"
  alert(elem.value); // value
</script>
        
      
      
      La mayoría de los atributos HTML estándar tienen la propiedad DOM correspondiente, y podemos acceder a ella así.
Si queremos conocer la lista completa de propiedades admitidas para una clase determinada, podemos encontrarlas en la especificación. Por ejemplo, HTMLInputElement está documentado en https://html.spec.whatwg.org/#htmlinputelement.
O si nos gustaría obtenerlos rápidamente o estamos interesados en una especificación concreta del navegador, siempre podemos generar el elemento usando console.dir(elem) y leer las propiedades. O explora las “propiedades DOM” en la pestaña Elements de las herramientas de desarrollo del navegador.
ResumenCada nodo DOM pertenece a una determinada clase. Las clases forman una jerarquía. El conjunto completo de propiedades y métodos proviene de la herencia.
Las propiedades principales del nodo DOM son:

nodeType
Podemos usarla para ver si un nodo es un texto o un elemento. Tiene un valor numérico: 1 para elementos, 3 para nodos de texto y algunos otros para otros tipos de nodos. Solo lectura.
nodeName/tagName
Para los elementos, nombre de la etiqueta (en mayúsculas a menos que esté en modo XML). Para los nodos que no son elementos, nodeName describe lo que es. Solo lectura.
innerHTML
El contenido HTML del elemento. Puede modificarse.
outerHTML
El HTML completo del elemento. Una operación de escritura en elem.outerHTML no toca a elem en sí. En su lugar, se reemplaza con el nuevo HTML en el contexto externo.
nodeValue/data
El contenido de un nodo que no es un elemento (text, comment). Estos dos son casi iguales, usualmente usamos data. Puede modificarse.
textContent
El texto dentro del elemento: HTML menos todas las <tags>. Escribir en él coloca el texto dentro del elemento, con todos los caracteres especiales y etiquetas tratados exactamente como texto. Puede insertar de forma segura texto generado por el usuario y protegerse de inserciones HTML no deseadas.
hidden
Cuando se establece en true, hace lo mismo que CSS display:none.

Los nodos DOM también tienen otras propiedades dependiendo de su clase. Por ejemplo, los elementos <input> (HTMLInputElement) admiten value, type, mientras que los elementos <a> (HTMLAnchorElement) admiten href, etc. La mayoría de los atributos HTML estándar tienen una propiedad DOM correspondiente.
Sin embargo, los atributos HTML y las propiedades DOM no siempre son iguales, como veremos en el próximo capítulo.
TareasContar los descendientesimportancia: 5Hay un árbol estructurado como ul/li anidado.
Escribe el código que para cada <li> muestra:

¿Cuál es el texto dentro de él (sin el subárbol)?
El número de <li> anidados: todos los descendientes, incluidos los profundamente anidados.

Demo en nueva ventanaAbrir un entorno controlado para la tarea.soluciónHagamos un ciclo sobre <li>:

      
        
        
          for (let li of document.querySelectorAll('li')) {
  ...
}
        
      
      
      En el ciclo, necesitamos introducir el texto dentro de cada li.
Podemos leer el texto del primer nodo hijo de li, que es el nodo de texto:

      
        
        
          for (let li of document.querySelectorAll('li')) {
  let title = li.firstChild.data;

  // el título es el texto en <li> antes de cualquier otro nodo
}
        
      
      
      Entonces podemos obtener el número de descendientes como li.getElementsByTagName('li').length.
Abrir la solución en un entorno controlado.¿Qué hay en nodeType?importancia: 5¿Qué muestra el script?

      
        
        
          <html>

<body>
  <script>
    alert(document.body.lastChild.nodeType);
  </script>
</body>

</html>
        
      
      
      soluciónAquí hay una trampa.
En el momento de la ejecución de <script>, el último nodo DOM es exactamente <script>, porque el navegador aún no procesó el resto de la página.
Entonces el resultado es 1 (nodo de elemento).

      
        
        
          
            
          
          
            
          
        
        
          <html>

<body>
  <script>
    alert(document.body.lastChild.nodeType);
  </script>
</body>

</html>
        
      
      
      Etiqueta en comentarioimportancia: 3¿Qué muestra este código?

      
        
        
          <script>
  let body = document.body;

  body.innerHTML = "<!--" + body.tagName + "-->";

  alert( body.firstChild.data ); // ¿qué hay aquí?
</script>
        
      
      
      soluciónLa respuesta: BODY.

      
        
        
          
            
          
          
            
          
        
        
          <script>
  let body = document.body;

  body.innerHTML = "<!--" + body.tagName + "-->";

  alert( body.firstChild.data ); // BODY
</script>
        
      
      
      ¿Qué está pasando paso a paso?

El contenido de <body> se reemplaza con el comentario. El comentario es <!--BODY-->, porque body.tagName == "BODY". Como recordamos, tagName siempre está en mayúsculas en HTML.
El comentario es ahora el único nodo hijo, así que lo obtenemos en body.firstChild.
La propiedad data del comentario es su contenido (dentro de <!--...-->): "BODY".

¿Dónde está el "document" en la jerarquía?importancia: 4¿A qué clase pertenece el document?
¿Cuál es su lugar en la jerarquía DOM?
¿Hereda de Node o Element, o tal vez HTMLElement?
soluciónPodemos ver a qué clase pertenece, imprimiéndola, así:

      
        
        
          
            
          
          
            
          
        
        
          alert(document); // [object HTMLDocument]
        
      
      
      O:

      
        
        
          
            
          
          
            
          
        
        
          alert(document.constructor.name); // HTMLDocument
        
      
      
      Entonces, document es una instancia de la clase HTMLDocument.
¿Cuál es su lugar en la jerarquía?
Sí, podríamos examinar las especificaciones, pero sería más rápido averiguarlo manualmente.
Recorramos la cadena de prototype través de __proto__.
Como sabemos, los métodos de una clase están en el prototype del constructor. Por ejemplo, HTMLDocument.prototype tiene métodos para documentos.
Además, hay una referencia a la función constructor dentro de prototype:

      
        
        
          
            
          
          
            
          
        
        
          alert(HTMLDocument.prototype.constructor === HTMLDocument); // true
        
      
      
      Para obtener un nombre de la clase como string, podemos usar constructor.name. Hagámoslo para toda la cadena prototype de document, hasta la clase Node:

      
        
        
          
            
          
          
            
          
        
        
          alert(HTMLDocument.prototype.constructor.name); // HTMLDocument
alert(HTMLDocument.prototype.__proto__.constructor.name); // Document
alert(HTMLDocument.prototype.__proto__.__proto__.constructor.name); // Node
        
      
      
      Esa es la jerarquía.
También podríamos examinar el objeto usando console.dir(document) y ver estos nombres abriendo __proto__. La consola los toma del constructor internamente.
",
	"url": "https://es.javascript.info/basic-dom-node-properties" 
},
{
	"docs_id": "101",
	"name": "Atributos y propiedades",
	"description": "Cuando el navegador carga la página, “lee” (o “parser”(analiza en inglés")) el HTML y genera objetos DOM a partir de él. Para los nodos de elementos, la mayoría de los atributos HTML estándar se convierten automáticamente en propiedades de los objetos DOM.",
	"content": "Cuando el navegador carga la página, “lee” (o “parser”(analiza en inglés")) el HTML y genera objetos DOM a partir de él. Para los nodos de elementos, la mayoría de los atributos HTML estándar se convierten automáticamente en propiedades de los objetos DOM.
Por ejemplo, si la etiqueta es <body id="page">, entonces el objeto DOM tiene body.id="page".
¡Pero el mapeo de propiedades y atributos no es uno a uno! En este capítulo, prestaremos atención para separar estas dos nociones, para ver cómo trabajar con ellos, cuándo son iguales y cuándo son diferentes.
Propiedades DOMYa hemos visto propiedades DOM integradas. Hay muchas. Pero técnicamente nadie nos limita, y si no hay suficientes, podemos agregar las nuestras.
Los nodos DOM son objetos JavaScript normales. Podemos alterarlos.
Por ejemplo, creemos una nueva propiedad en document.body:

      
        
        
          
            
          
          
            
          
        
        
          document.body.myData = {
  name: 'Cesar',
  title: 'Emperador'
};

alert(document.body.myData.title); // Emperador
        
      
      
      También podemos agregar un método:

      
        
        
          
            
          
          
            
          
        
        
          document.body.sayTagName = function() {
  alert(this.tagName);
};

document.body.sayTagName(); // BODY (el valor de 'this' en el método es document.body)
        
      
      
      También podemos modificar prototipos incorporados como Element.prototype y agregar nuevos métodos a todos los elementos:

      
        
        
          
            
          
          
            
          
        
        
          Element.prototype.sayHi = function() {
  alert(`Hola, yo soy ${this.tagName}`);
};

document.documentElement.sayHi(); // Hola, yo soy HTML
document.body.sayHi(); // Hola, yo soy BODY
        
      
      
      Por lo tanto, las propiedades y métodos DOM se comportan igual que los objetos JavaScript normales:

Pueden tener cualquier valor.
Distingue entre mayúsculas y minúsculas (escribir elem.nodeType, no es lo mismo que elem.NoDeTyPe).

Atributos HTMLEn HTML, las etiquetas pueden tener atributos. Cuando el navegador analiza el HTML para crear objetos DOM para etiquetas, reconoce los atributos estándar y crea propiedades DOM a partir de ellos.
Entonces, cuando un elemento tiene id u otro atributo estándar, se crea la propiedad correspondiente. Pero eso no sucede si el atributo no es estándar.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <body id="test" something="non-standard">
  <script>
    alert(document.body.id); // prueba
    // el atributo no estándar no produce una propiedad
    alert(document.body.something); // undefined
  </script>
</body>
        
      
      
      Tenga en cuenta que un atributo estándar para un elemento puede ser desconocido para otro. Por ejemplo, "type" es estándar para <input> (HTMLInputElement), pero no para <body> (HTMLBodyElement). Los atributos estándar se describen en la especificación para la clase del elemento correspondiente.
Aquí podemos ver esto:

      
        
        
          
            
          
          
            
          
        
        
          <body id="body" type="...">
  <input id="input" type="text">
  <script>
    alert(input.type); // text
    alert(body.type); // undefined: Propiedad DOM no creada, porque no es estándar
  </script>
</body>
        
      
      
      Entonces, si un atributo no es estándar, no habrá una propiedad DOM para él. ¿Hay alguna manera de acceder a tales atributos?
Claro. Todos los atributos son accesibles usando los siguientes métodos:

elem.hasAttribute(nombre) – comprueba si existe.
elem.getAttribute(nombre) – obtiene el valor.
elem.setAttribute(nombre, valor) – establece el valor.
elem.removeAttribute(nombre) – elimina el atributo.

Estos métodos funcionan exactamente con lo que está escrito en HTML.
También se pueden leer todos los atributos usando elem.attributes: una colección de objetos que pertenecen a una clase integrada Attr, con propiedades nombre y valor .
Aquí hay una demostración de la lectura de una propiedad no estándar:

      
        
        
          
            
          
          
            
          
        
        
          <body something="non-standard">
  <script>
    alert(document.body.getAttribute('something')); // no estándar
  </script>
</body>
        
      
      
      Los atributos HTML tienen las siguientes características:

Su nombre no distingue entre mayúsculas y minúsculas (id es igual aID).
Sus valores son siempre strings.

Aquí hay una demostración extendida de cómo trabajar con atributos:

      
        
        
          
            
          
          
            
          
        
        
          <body>
  <div id="elem" about="Elephant"></div>

  <script>
    alert( elem.getAttribute('About') ); // (1) 'Elephant', leyendo

    elem.setAttribute('Test', 123); // (2), escribiendo

    alert( elem.outerHTML ); // (3), ver si el atributo está en HTML (sí)

    for (let attr of elem.attributes) { // (4) listar todo
      alert( `${attr.name} = ${attr.value}` );
    }
  </script>
</body>
        
      
      
      Tenga en cuenta:

getAttribute ('About) – la primera letra está en mayúscula aquí, y en HTML todo está en minúscula. Pero eso no importa: los nombres de los atributos no distinguen entre mayúsculas y minúsculas.
Podemos asignar cualquier cosa a un atributo, pero se convierte en un string. Así que aquí tenemos "123" como valor.
Todos los atributos, incluidos los que configuramos, son visibles en outerHTML.
La colección attributes es iterable y tiene todos los atributos del elemento (estándar y no estándar) como objetos con propiedades name y value.

Sincronización de propiedad y atributoCuando cambia un atributo estándar, la propiedad correspondiente se actualiza automáticamente (con algunas excepciones) y viceversa.
En el ejemplo a continuación, id se modifica como un atributo, y también podemos ver la propiedad cambiada. Y luego lo mismo al revés:

      
        
        
          
            
          
          
            
          
        
        
          <input>

<script>
  let input = document.querySelector('input');

  // atributo => propiedad
  input.setAttribute('id', 'id');
  alert(input.id); // id (actualizado)

  // propiedad => atributo
  input.id = 'newId';
  alert(input.getAttribute('id')); // newId (actualizado)
</script>
        
      
      
      Pero hay exclusiones, por ejemplo, input.value se sincroniza solo del atributo a la propiedad (atributo => propiedad), pero no de regreso:

      
        
        
          
            
          
          
            
          
        
        
          <input>

<script>
  let input = document.querySelector('input');

  // atributo => propiedad
  input.setAttribute('value', 'text');
  alert(input.value); // text

  // NO propiedad => atributo
  input.value = 'newValue';
  alert(input.getAttribute('value')); // text (¡no actualizado!)
</script>
        
      
      
      En el ejemplo anterior:

Cambiar el atributo value actualiza la propiedad.
Pero el cambio de propiedad no afecta al atributo.

Esa “característica” en realidad puede ser útil, porque las acciones del usuario pueden conducir a cambios de value, y luego, si queremos recuperar el valor “original” de HTML, está en el atributo.
Las propiedades DOM tienen tipoLas propiedades DOM no siempre son strings. Por ejemplo, la propiedad input.checked (para casillas de verificación) es un booleano:

      
        
        
          
            
          
          
            
          
        
        
          <input id="input" type="checkbox" checked> checkbox

<script>
  alert(input.getAttribute('checked')); // el valor del atributo es: string vacía
  alert(input.checked); // el valor de la propiedad es: true
</script>
        
      
      
      Hay otros ejemplos. El atributo style es un string, pero la propiedad style es un objeto:

      
        
        
          
            
          
          
            
          
        
        
          <div id="div" style="color:red;font-size:120%">Hola</div>

<script>
  // string
  alert(div.getAttribute('style')); // color:red;font-size:120%

  // object
  alert(div.style); // [object CSSStyleDeclaration]
  alert(div.style.color); // red
</script>
        
      
      
      La mayoría de las propiedades son strings.
Muy raramente, incluso si un tipo de propiedad DOM es un string, puede diferir del atributo. Por ejemplo, la propiedad DOM href siempre es una URL completa, incluso si el atributo contiene una URL relativa o solo un #hash.
Aquí hay un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <a id="a" href="#hola">link</a>
<script>
  // atributo
  alert(a.getAttribute('href')); // #hola

  // propiedad
  alert(a.href ); // URL completa de http://site.com/page#hola
</script>
        
      
      
      Si necesitamos el valor de href o cualquier otro atributo exactamente como está escrito en el HTML, podemos usar getAttribute.
Atributos no estándar, datasetCuando escribimos HTML, usamos muchos atributos estándar. Pero, ¿qué pasa con los no personalizados y personalizados? Primero, veamos si son útiles o no. ¿Para qué?
A veces, los atributos no estándar se utilizan para pasar datos personalizados de HTML a JavaScript, o para “marcar” elementos HTML para JavaScript.
Como esto:

      
        
        
          
            
          
          
            
          
        
        
          <!-- marque el div para mostrar "nombre" aquí -->
<div show-info="nombre"></div>
<!-- y "edad" aquí -->
<div show-info="edad"></div>

<script>
 // el código encuentra un elemento con la marca y muestra lo que se solicita
  let user = {
    nombre: "Pete",
    edad: 25
  };

  for(let div of document.querySelectorAll('[show-info]')) {
    // inserta la información correspondiente en el campo
    let field = div.getAttribute('show-info');
    div.innerHTML = user[field]; // primero Pete en "nombre", luego 25 en "edad"
  }
</script>
        
      
      
      También se pueden usar para diseñar un elemento.
Por ejemplo, aquí para el estado del pedido se usa el atributo order-state:

      
        
        
          
            
          
          
            
          
        
        
          <style>
  /* los estilos se basan en el atributo personalizado "order-state" */
  .order[order-state="nuevo"] {
    color: green;
  }

  .order[order-state="pendiente"] {
    color: blue;
  }

  .order[order-state="cancelado"] {
    color: red;
  }
</style>

<div class="order" order-state="nuevo">
  Un nuevo pedido.
</div>

<div class="order" order-state="pendiente">
  Un pedido pendiente.
</div>

<div class="order" order-state="cancelado">
  Un pedido cancelado
</div>
        
      
      
      ¿Por qué sería preferible usar un atributo a tener clases como .order-state-new, .order-state-pending, .order-state-canceled?
Porque un atributo es más conveniente de administrar. El estado se puede cambiar tan fácil como:

      
        
        
          // un poco más simple que eliminar/agregar clases
div.setAttribute('order-state', 'canceled');
        
      
      
      Pero puede haber un posible problema con los atributos personalizados. ¿Qué sucede si usamos un atributo no estándar para nuestros propósitos y luego el estándar lo introduce y hace que haga algo? El lenguaje HTML está vivo, crece y cada vez hay más atributos que aparecen para satisfacer las necesidades de los desarrolladores. Puede haber efectos inesperados en tal caso.
Para evitar conflictos, existen atributos data-*.
Todos los atributos que comienzan con “data-” están reservados para el uso de los programadores. Están disponibles en la propiedad dataset.
Por ejemplo, si un elem tiene un atributo llamado "data-about", está disponible como elem.dataset.about.
Como esto:

      
        
        
          
            
          
          
            
          
        
        
          <body data-about="Elefante">
<script>
  alert(document.body.dataset.about); // Elefante
</script>
        
      
      
      Los atributos de varias palabras como data-order-state se convierten en camel-case: dataset.orderState
Aquí hay un ejemplo reescrito de “estado del pedido”:

      
        
        
          
            
          
          
            
          
        
        
          <style>
  .order[data-order-state="nuevo"] {
    color: green;
  }

  .order[data-order-state="pendiente"] {
    color: blue;
  }

  .order[data-order-state="cancelado"] {
    color: red;
  }
</style>

<div id="order" class="order" data-order-state="nuevo">
  Una nueva orden.
</div>

<script>
  // leer
  alert(order.dataset.orderState); // nuevo

  // modificar
  order.dataset.orderState = "pendiente"; // (*)
</script>
        
      
      
      El uso de los atributos data- * es una forma válida y segura de pasar datos personalizados.
Tenga en cuenta que no solo podemos leer, sino también modificar los atributos de datos. Luego, CSS actualiza la vista en consecuencia: en el ejemplo anterior, la última línea (*) cambia el color a azul.
Resumen
Atributos: es lo que está escrito en HTML.
Propiedades: es lo que hay en los objetos DOM.

Una pequeña comparación:




Propiedades
Atributos




Tipo
Cualquier valor, las propiedades estándar tienen tipos descritos en la especificación
Un string


Nombre
El nombre distingue entre mayúsculas y minúsculas
El nombre no distingue entre mayúsculas y minúsculas



Los métodos para trabajar con atributos son:

elem.hasAttribute(nombre) – para comprobar si existe.
elem.getAttribute(nombre) – para obtener el valor.
elem.setAttribute(nombre, valor) – para dar un valor.
elem.removeAttribute(nombre) – para eliminar el atributo.
elem.attributes es una colección de todos los atributos.

Para la mayoría de las situaciones, es preferible usar las propiedades DOM. Deberíamos referirnos a los atributos solo cuando las propiedades DOM no nos convienen, cuando necesitamos exactamente atributos, por ejemplo:

Necesitamos un atributo no estándar. Pero si comienza con data-, entonces deberíamos usar dataset.
Queremos leer el valor “como está escrito” en HTML. El valor de la propiedad DOM puede ser diferente, por ejemplo, la propiedad href siempre es una URL completa, y es posible que queramos obtener el valor "original ".

TareasObtén en atributoimportancia: 5Escribe el código para obtener el atributo data-widget-name del documento y leer su valor.

      
        
        
          
            
          
          
            
          
        
        
          <!DOCTYPE html>
<html>
<body>

  <div data-widget-name="menu">Elige el genero</div>

  <script>
    /* Tu código */
  </script>
</body>
</html>
        
      
      
      solución
      
        
        
          
            
          
          
            
          
        
        
          <!DOCTYPE html>
<html>
<body>

  <div data-widget-name="menu">Elige el género</div>

  <script>
    // obteniéndolo
    let elem = document.querySelector('[data-widget-name]');

    // leyendo el valor
    alert(elem.dataset.widgetName);
    // o
    alert(elem.getAttribute('data-widget-name'));
  </script>
</body>
</html>
        
      
      
      Haz los enlaces externos naranjasimportancia: 3Haz todos los enlaces externos de color orange alterando su propiedad style.
Un link es externo si:

Su href tiene ://
Pero no comienza con http://internal.com.

Ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <a name="list">the list</a>
<ul>
  <li><a href="http://google.com">http://google.com</a></li>
  <li><a href="/tutorial">/tutorial.html</a></li>
  <li><a href="local/path">local/path</a></li>
  <li><a href="ftp://ftp.com/my.zip">ftp://ftp.com/my.zip</a></li>
  <li><a href="http://nodejs.org">http://nodejs.org</a></li>
  <li><a href="http://internal.com/test">http://internal.com/test</a></li>
</ul>

<script>
  // establecer un estilo para un enlace
  let link = document.querySelector('a');
  link.style.color = 'orange';
</script>
        
      
      
      El resultado podría ser:

    
    
  Abrir un entorno controlado para la tarea.soluciónPrimero, necesitamos encontrar todos los enlaces externos.
Hay dos.
El primero es encontrar todos los enlaces usando document.querySelectorAll('a') y luego filtrar lo que necesitamos:

      
        
        
          let links = document.querySelectorAll('a');

for (let link of links) {
  let href = link.getAttribute('href');
  if (!href) continue; // no atributo

  if (!href.includes('://')) continue; // no protocolo

  if (href.startsWith('http://internal.com')) continue; // interno

  link.style.color = 'orange';
}
        
      
      
      Tenga en cuenta: nosotros usamos link.getAttribute('href'). No link.href, porque necesitamos el valor del HTML.
…Otra forma más simple sería agregar las comprobaciones al selector CSS:

      
        
        
          // busque todos los enlaces que tengan: // en href
//pero href no comienza con http://internal.com
let selector = 'a[href*="://"]:not([href^="http://internal.com"])';
let links = document.querySelectorAll(selector);

links.forEach(link => link.style.color = 'orange');
        
      
      
      Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/dom-attributes-and-properties" 
},
{
	"docs_id": "102",
	"name": "Modificando el documento",
	"description": "La modificación del DOM es la clave para crear páginas “vivas”, dinámicas.",
	"content": "La modificación del DOM es la clave para crear páginas “vivas”, dinámicas.
Aquí veremos cómo crear nuevos elementos “al vuelo” y modificar el contenido existente de la página.
Ejemplo: mostrar un mensajeHagamos una demostración usando un ejemplo. Añadiremos un mensaje que se vea más agradable que un alert.
Así es como se verá:

      
        
        
          <style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<div class="alert">
  <strong>¡Hola!</strong> Usted ha leído un importante mensaje.
</div>
        
      
      
          
        
      Eso fue el ejemplo HTML. Ahora creemos el mismo div con JavaScript (asumiendo que los estilos ya están en HTML/CSS).
Creando un elementoPara crear nodos DOM, hay dos métodos:

document.createElement(tag)

Crea un nuevo nodo elemento con la etiqueta HTML dada:

      
        
        
          let div = document.createElement('div');
        
      
      
      
document.createTextNode(text)

Crea un nuevo nodo texto con el texto dado:

      
        
        
          let textNode = document.createTextNode('Aquí estoy');
        
      
      
      

La mayor parte del tiempo necesitamos crear nodos de elemento, como el div para el mensaje.
Creando el mensajeCrear el div de mensaje toma 3 pasos:

      
        
        
          // 1. Crear elemento <div>
let div = document.createElement('div');

// 2. Establecer su clase a "alert"
div.className = "alert";

// 3. Agregar el contenido
div.innerHTML = "<strong>¡Hola!</strong> Usted ha leído un importante mensaje.";
        
      
      
      Hemos creado el elemento. Pero hasta ahora solamente está en una variable llamada div, no aún en la página, y no la podemos ver.
Métodos de inserciónPara hacer que el div aparezca, necesitamos insertarlo en algún lado dentro de document. Por ejemplo, en el elemento <body>, referenciado por document.body.
Hay un método especial append para ello: document.body.append(div).
El código completo:

      
        
        
          
            
          
          
            
          
        
        
          <style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<script>
  let div = document.createElement('div');
  div.className = "alert";
  div.innerHTML = "<strong>¡Hola!</strong> Usted ha leído un importante mensaje.";

  document.body.append(div);
</script>
        
      
      
      Aquí usamos el método append sobre document.body, pero podemos llamar append sobre cualquier elemento para poner otro elemento dentro de él. Por ejemplo, podemos añadir algo a <div> llamando div.append(anotherElement).
Aquí hay más métodos de inserción, ellos especifican diferentes lugares donde insertar:

node.append(...nodos o strings) – agrega nodos o strings al final de node,
node.prepend(...nodos o strings) – insert nodos o strings al principio de node,
node.before(...nodos o strings) –- inserta nodos o strings antes de  node,
node.after(...nodos o strings) –- inserta nodos o strings después de node,
node.replaceWith(...nodos o strings) –- reemplaza node con los nodos o strings dados.

Los argumentos de estos métodos son una lista arbitraria de lo que se va a insertar: nodos DOM o strings de texto (estos se vuelven nodos de texto automáticamente).
Veámoslo en acción.
Aquí tenemos un ejemplo del uso de estos métodos para agregar items a una lista y el texto antes/después de él:

      
        
        
          <ol id="ol">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
  ol.before('before'); // inserta el string "before" antes de <ol>
  ol.after('after'); // inserta el string "after" después de <ol>

  let liFirst = document.createElement('li');
  liFirst.innerHTML = 'prepend';
  ol.prepend(liFirst); // inserta liFirst al principio de <ol>

  let liLast = document.createElement('li');
  liLast.innerHTML = 'append';
  ol.append(liLast); // inserta liLast al final de <ol>
</script>
        
      
      
          
        
      Aquí la representación visual de lo que hacen los métodos:

      
      
        
      
      Entonces la lista final será:

      
        
        
          before
<ol id="ol">
  <li>prepend</li>
  <li>0</li>
  <li>1</li>
  <li>2</li>
  <li>append</li>
</ol>
after
        
      
      
      Como dijimos antes, estos métodos pueden insertar múltiples nodos y piezas de texto en un simple llamado.
Por ejemplo, aquí se insertan un string y un elemento:

      
        
        
          
            
          
          
            
          
        
        
          <div id="div"></div>
<script>
  div.before('<p>Hola</p>', document.createElement('hr'));
</script>
        
      
      
      Nota que el texto es insertado “como texto” y no “como HTML”, escapando apropiadamente los caracteres como <, >.
Entonces el HTML final es:

      
        
        
          
            
          
          
            
          
        
        
          &lt;p&gt;Hola&lt;/p&gt;
<hr>
<div id="div"></div>
        
      
      
      En otras palabras, los strings son insertados en una manera segura, tal como lo hace elem.textContent.
Entonces, estos métodos solo pueden usarse para insertar nodos DOM como piezas de texto.
Pero ¿y si queremos insertar un string HTML “como html”, con todas las etiquetas y demás funcionando, de la misma manera que lo hace elem.innerHTML?
insertAdjacentHTML/Text/ElementPara ello podemos usar otro métodos, muy versátil: elem.insertAdjacentHTML(where, html).
El primer parámetro es un palabra código que especifica dónde insertar relativo a elem. Debe ser uno de los siguientes:

"beforebegin" – inserta html inmediatamente antes de elem
"afterbegin" – inserta html en elem, al principio
"beforeend" – inserta html en elem, al final
"afterend" – inserta html inmediatamente después de elem

El segundo parámetro es un string HTML, que es insertado “como HTML”.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <div id="div"></div>
<script>
  div.insertAdjacentHTML('beforebegin', '<p>Hola</p>');
  div.insertAdjacentHTML('afterend', '<p>Adiós</p>');
</script>
        
      
      
      …resulta en:

      
        
        
          
            
          
          
            
          
        
        
          <p>Hola</p>
<div id="div"></div>
<p>Adiós</p>
        
      
      
      Así es como podemos añadir HTML arbitrario a la página.
Aquí abajo, la imagen de las variantes de inserción:

      
      
        
      
      Fácilmente podemos notar similitudes entre esta imagen y la anterior. Los puntos de inserción son los mismos, pero este método inserta HTML.
El método tiene dos hermanos:

elem.insertAdjacentText(where, text) – la misma sintaxis, pero un string de texto es insertado “como texto” en vez de HTML,
elem.insertAdjacentElement(where, elem) – la misma sintaxis, pero inserta un elemento.

Ellos existen principalmente para hacer la sintaxis “uniforme”. En la práctica, solo insertAdjacentHTML es usado la mayor parte del tiempo. Porque para elementos y texto, tenemos los métodos append/prepend/before/after: son más cortos para escribir y pueden insertar piezas de texto y nodos.
Entonces tenemos una alternativa para mostrar un mensaje:

      
        
        
          
            
          
          
            
          
        
        
          <style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<script>
  document.body.insertAdjacentHTML("afterbegin", `<div class="alert">
    <strong>¡Hola!</strong> Usted ha leído un importante mensaje.
  </div>`);
</script>
        
      
      
      Eliminación de nodosPara quitar un nodo, tenemos el método node.remove().
Hagamos que nuestro mensaje desaparezca después de un segundo:

      
        
        
          
            
          
          
            
          
        
        
          <style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<script>
  let div = document.createElement('div');
  div.className = "alert";
  div.innerHTML = "<strong>¡Hola!</strong> Usted ha leído un importante mensaje.";

  document.body.append(div);
  setTimeout(() => div.remove(), 1000);
</script>
        
      
      
      Nota que si queremos mover un elemento a un nuevo lugar, no hay necesidad de quitarlo del viejo.
Todos los métodos de inserción automáticamente quitan el nodo del lugar viejo.
Por ejemplo, intercambiemos elementos:

      
        
        
          
            
          
          
            
          
        
        
          <div id="first">Primero</div>
<div id="second">Segundo</div>
<script>
  // no hay necesidad de llamar "remove"
  second.after(first); // toma #second y después inserta #first
</script>
        
      
      
      Clonando nodos: cloneNode¿Cómo insertar un mensaje similar más?
Podríamos hacer una función y poner el código allí. Pero la alternativa es clonar el div existente, y modificar el texto dentro si es necesario.
A veces, cuando tenemos un elemento grande, esto es más simple y rápido.

La llamada elem.cloneNode(true) crea una clonación “profunda” del elemento, con todos los atributos y subelementos. Si llamamos elem.cloneNode(false), la clonación se hace sin sus elementos hijos.

Un ejemplo de copia del mensaje:

      
        
        
          
            
          
          
            
          
        
        
          <style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<div class="alert" id="div">
  <strong>¡Hola!</strong> Usted ha leído un importante mensaje.
</div>

<script>
  let div2 = div.cloneNode(true); // clona el mensaje
  div2.querySelector('strong').innerHTML = '¡Adiós!'; // altera el clon

  div.after(div2); // muestra el clon después del div existente
</script>
        
      
      
      DocumentFragmentDocumentFragment es un nodo DOM especial que sirve como contenedor para trasladar listas de nodos.
Podemos agregarle nodos, pero cuando lo insertamos en algún lugar, lo que se inserta es su contenido.
Por ejemplo, getListContent de abajo genera un fragmento con items <li>, que luego son insertados en <ul>:

      
        
        
          
            
          
          
            
          
        
        
          <ul id="ul"></ul>

<script>
function getListContent() {
  let fragment = new DocumentFragment();

  for(let i=1; i<=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    fragment.append(li);
  }

  return fragment;
}

ul.append(getListContent()); // (*)
</script>
        
      
      
      Nota que a la última línea (*) añadimos DocumentFragment, pero este despliega su contenido. Entonces la estructura resultante será:

      
        
        
          <ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>
        
      
      
      Es raro que DocumentFragment se use explícitamente. ¿Por qué añadir un tipo especial de nodo si en su lugar  podemos devolver un array de nodos? El ejemplo reescrito:

      
        
        
          
            
          
          
            
          
        
        
          <ul id="ul"></ul>

<script>
function getListContent() {
  let result = [];

  for(let i=1; i<=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    result.push(li);
  }

  return result;
}

ul.append(...getListContent()); // append +  el operador "..." = ¡amigos!
</script>
        
      
      
      Mencionamos DocumentFragment principalmente porque hay algunos conceptos asociados a él, como el elemento template, que cubriremos mucho después.
Métodos de la vieja escuela para insertar/quitar
            Vieja escuela
            
            Esta información ayuda a entender los viejos scripts, pero no es necesaria para nuevos desarrollos.
            
Hay también métodos de manipulación de DOM de “vieja escuela”, existentes por razones históricas.
Estos métodos vienen de realmente viejos tiempos. No hay razón para usarlos estos días, ya que los métodos modernos como append, prepend, before, after, remove, replaceWith, son más flexibles.
La única razón por la que los listamos aquí es porque podrías encontrarlos en viejos scripts:

parentElem.appendChild(node)

Añade node como último hijo de parentElem.
El siguiente ejemplo agrega un nuevo <li> al final de <ol>:

      
        
        
          
            
          
          
            
          
        
        
          <ol id="list">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
  let newLi = document.createElement('li');
  newLi.innerHTML = '¡Hola, mundo!';

  list.appendChild(newLi);
</script>
        
      
      
      
parentElem.insertBefore(node, nextSibling)

Inserta node antes de nextSibling dentro de parentElem.
El siguiente código inserta un nuevo ítem de lista antes del segundo <li>:

      
        
        
          
            
          
          
            
          
        
        
          <ol id="list">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>
<script>
  let newLi = document.createElement('li');
  newLi.innerHTML = '¡Hola, mundo!';

  list.insertBefore(newLi, list.children[1]);
</script>
        
      
      
      Para insertar newLi como primer elemento, podemos hacerlo así:

      
        
        
          list.insertBefore(newLi, list.firstChild);
        
      
      
      
parentElem.replaceChild(node, oldChild)

Reemplaza oldChild con node entre los hijos de parentElem.

parentElem.removeChild(node)

Quita node de parentElem (asumiendo que node es su hijo).
El siguiente ejemplo quita el primer <li> de <ol>:

      
        
        
          
            
          
          
            
          
        
        
          <ol id="list">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
  let li = list.firstElementChild;
  list.removeChild(li);
</script>
        
      
      
      

Todos estos métodos devuelven el nodo insertado/quitado. En otras palabras, parentElem.appendChild(node) devuelve node. Pero lo usual es que el valor no se use y solo ejecutemos el método.
Una palabra acerca de “document.write”Hay uno más, un método muy antiguo para agregar algo a una página web: document.write.
La sintaxis:

      
        
        
          
            
          
          
            
          
        
        
          <p>En algún lugar de la página...</p>
<script>
  document.write('<b>Saludos de JS</b>');
</script>
<p>Fin</p>
        
      
      
      El llamado a document.write(html) escribe el html en la página “aquí y ahora”. El string html puede ser generado dinámicamente, así que es muy flexible. Podemos usar JavaScript para crear una página completa al vuelo y escribirla.
El método viene de tiempos en que no había DOM ni estándares… Realmente viejos tiempos. Todavía vive, porque hay scripts que lo usan.
En scripts modernos rara vez lo vemos, por una importante limitación:
El llamado a document.write solo funciona mientras la página está cargando.
Si la llamamos después, el contenido existente del documento es borrado.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <p>Después de un segundo el contenido de esta página será reemplazado...</p>
<script>
  // document.write después de 1 segundo
  // eso es después de que la página cargó, entonces borra el contenido existente
  setTimeout(() => document.write('<b>...Por esto.</b>'), 1000);
</script>
        
      
      
      Así que es bastante inusable en el estado “after loaded” (después de cargado), al contrario de los otros métodos DOM que cubrimos antes.
Ese es el punto en contra.
También tiene un punto a favor. Técnicamente, cuando es llamado document.write mientras el navegador está leyendo el HTML entrante (“parsing”), y escribe algo, el navegador lo consume como si hubiera estado inicialmente allí, en el texto HTML.
Así que funciona muy rápido, porque no hay una “modificación de DOM” involucrada. Escribe directamente en el texto de la página mientras el DOM ni siquiera está construido.
Entonces: si necesitamos agregar un montón de texto en HTML dinámicamente, estamos en la fase de carga de página, y la velocidad es importante, esto puede ayudar. Pero en la práctica estos requerimientos raramente vienen juntos. Así que si vemos este método en scripts, probablemente sea solo porque son viejos.
Resumen

Métodos para crear nuevos nodos:

document.createElement(tag) – crea un elemento con la etiqueta HTML dada
document.createTextNode(value) – crea un nodo de texto (raramente usado)
elem.cloneNode(deep) – clona el elemento. Si deep==true, lo clona con todos sus descendientes.



Inserción y eliminación:

node.append(...nodes or strings) – inserta en node, al final
node.prepend(...nodes or strings) – inserta en node, al principio
node.before(...nodes or strings) –- inserta inmediatamente antes de node
node.after(...nodes or strings) –- inserta inmediatamente después de node
node.replaceWith(...nodes or strings) –- reemplaza node
node.remove() –- quita el node.

Los strings de texto son insertados “como texto”.


También hay métodos “de vieja escuela”:

parent.appendChild(node)
parent.insertBefore(node, nextSibling)
parent.removeChild(node)
parent.replaceChild(newElem, node)

Todos estos métodos devuelven node.


Dado cierto HTML en html, elem.insertAdjacentHTML(where, html) lo inserta dependiendo del valor where:

"beforebegin" – inserta html inmediatamente antes de elem
"afterbegin" – inserta html en elem, al principio
"beforeend" – inserta html en elem, al final
"afterend" – inserta html inmediatamente después deelem

También hay métodos similares, elem.insertAdjacentText y elem.insertAdjacentElement, que insertan strings de texto y elementos, pero son raramente usados.


Para agregar HTML a la página antes de que haya terminado de cargar:

document.write(html)

Después de que la página fue cargada tal llamada borra el documento. Puede verse principalmente en scripts viejos.


TareascreateTextNode vs innerHTML vs textContentimportancia: 5Tenemos un elemento DOM vacio elem y un string text.
¿Cuáles de estos 3 comandos harán exactamente lo mismo?

elem.append(document.createTextNode(text))
elem.innerHTML = text
elem.textContent = text

soluciónRespuesta: 1 y 3.
Ambos comandos agregan text “como texto” dentro de elem.
Aquí el ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <div id="elem1"></div>
<div id="elem2"></div>
<div id="elem3"></div>
<script>
  let text = '<b>text</b>';

  elem1.append(document.createTextNode(text));
  elem2.innerHTML = text;
  elem3.textContent = text;
</script>
        
      
      
      Limpiar el elementoimportancia: 5Crea una función clear(elem) que remueva todo del elemento.

      
        
        
          
            
          
          
            
          
        
        
          <ol id="elem">
  <li>Hola</li>
  <li>mundo</li>
</ol>

<script>
  function clear(elem) { /* tu código */ }

  clear(elem); // borra la lista
</script>
        
      
      
      soluciónPrimero veamos cómo no hacerlo:

      
        
        
          function clear(elem) {
  for (let i=0; i < elem.childNodes.length; i++) {
      elem.childNodes[i].remove();
  }
}
        
      
      
      Eso no funciona, porque la llamada a remove() desplaza la colección elem.childNodes, entonces los elementos comienzan desde el índice 0 cada vez. Pero i se incrementa y algunos elementos serán saltados.
El bucle for..of también hace lo mismo.
Una variante correcta puede ser:

      
        
        
          function clear(elem) {
  while (elem.firstChild) {
    elem.firstChild.remove();
  }
}
        
      
      
      Y también una manera más simple de hacer lo mismo:

      
        
        
          function clear(elem) {
  elem.innerHTML = '';
}
        
      
      
      Por qué "aaa" permanece?importancia: 1En el ejemplo de abajo, la llamada table.remove() quita la tabla del documento.
Pero si la ejecutas, puedes ver que el texto “aaa”` es aún visible.
¿Por qué ocurre esto?

      
        
        
          
            
          
          
            
          
        
        
          <table id="table">
  aaa
  <tr>
    <td>Test</td>
  </tr>
</table>

<script>
  alert(table); // la tabla, tal como debería ser

  table.remove();
  // ¿Por qué aún está "aaa" en el documento?
</script>
        
      
      
      soluciónEl HTML de la tarea es incorrecto. Esa es la razón del comportamiento extraño.
El navegador tiene que corregirlo automáticamente. No debe haber texto dentro de <table>: de acuerdo con la especificación solo son permitidas las etiquetas específicas de tabla. Entonces el navegador ubica "aaa" antes de <table>.
Ahora resulta obvio que cuando quitamos la tabla, ese texto permanece.
La pregunta puede ser respondida fácilmente explorando el DOM usando la herramientas del navegador. Estas muestran "aaa" antes que <table>.
El estándar HTML especifica en detalle cómo procesar HTML incorrecto, y tal comportamiento del navegador es el correcto.
Crear una listaimportancia: 4Escribir una interfaz para crear una lista de lo que ingresa un usuario.
Para cada item de la lista:

Preguntar al usuario acerca del contenido usando prompt.
Crear el <li> con ello y agregarlo a <ul>.
Continuar hasta que el usuario cancela el ingreso (presionando Esc o con un ingreso vacío).

Todos los elementos deben ser creados dinámicamente.
Si el usuario ingresa etiquetas HTML, deben ser tratadas como texto.
Demo en nueva ventanasoluciónObserva el uso de textContent para asignar el contenido de <li>.
Abrir la solución en un entorno controlado.Crea un árbol desde el objetoimportancia: 5Escribe una función createTree que crea una lista ramificada ul/li desde un objeto ramificado.
Por ejemplo:

      
        
        
          let data = {
  "Fish": {
    "trout": {},
    "salmon": {}
  },

  "Tree": {
    "Huge": {
      "sequoia": {},
      "oak": {}
    },
    "Flowering": {
      "apple tree": {},
      "magnolia": {}
    }
  }
};
        
      
      
      La sintaxis:

      
        
        
          let container = document.getElementById('container');
createTree(container, data); // crea el árbol en el contenedor
        
      
      
      El árbol resultante debe verse así:

    
    
  Elige una de estas dos formas para resolver esta tarea:

Crear el HTML para el árbol y entonces asignarlo a container.innerHTML.
Crear los nodos del árbol y añadirlos con métodos DOM.

Sería muy bueno que hicieras ambas soluciones.
P.S. El árbol no debe tener elementos “extras” como <ul></ul> vacíos para las hojas.
Abrir un entorno controlado para la tarea.soluciónLa forma más fácil de recorrer el objeto es usando recursividad.

La solución con innerHTML.
La solución con DOM.

Mostrar descendientes en un árbolimportancia: 5Hay un árbol organizado como ramas ul/li.
Escribe el código que agrega a cada <li> el número de su descendientes. No cuentes las hojas (nodos sin hijos).
El resultado:

    
    
  Abrir un entorno controlado para la tarea.soluciónPara añadir texto a cada <li> podemos alterar el nodo texto data.
Abrir la solución en un entorno controlado.Crea un calendarioimportancia: 4Escribe una función createCalendar(elem, year, month).
Su llamado debe crear un calendario para el año y mes dados y ponerlo dentro de elem.
El calendario debe ser una tabla, donde una semana es <tr>, y un día es<td>. Los encabezados de la tabla deben ser <th> con los nombres de los días de la semana: el primer día debe ser “lunes” y así hasta “domingo”.
Por ejemplo, createCalendar(cal, 2012, 9) debe generar en el elemento cal el siguiente calendario:

    
    
  P.S. Para esta tarea es suficiente generar el calendario, no necesita aún ser cliqueable.
Abrir un entorno controlado para la tarea.soluciónCrearemos la tabla como un string: "<table>...</table>", y entonces lo asignamos a innerHTML.
El algoritmo:

Crea el encabezado de la tabla con <th> y los nombres de los días de la semana.
Crea el objeto date d = new Date(year, month-1). Este es el primer día del mes month (tomando en cuenta que los meses en JavaScript comienzan en 0, no 1).
Las primeras celdas hasta el primer día del mes d.getDay() podrían estar vacías. Las completamos con <td></td>.
Incrementa el día en d: d.setDate(d.getDate()+1). Si d.getMonth() no es aún del mes siguiente, agregamos una nueva celda <td> al calendario. Si es domingo, agregamos un nueva línea"</tr><tr>".
Si el mes terminó, pero la fila no está completa, le agregamos <td> vacíos para hacerlo rectangular.

Abrir la solución en un entorno controlado.Reloj coloreado con setIntervalimportancia: 4Crea un reloj coloreado como aquí:

    
    
  Usa HTML/CSS para el estilo, JavaScript solamente actualiza la hora en elements.
Abrir un entorno controlado para la tarea.soluciónPrimero escribamos HTML/CSS.
Cada componente de la hora se verá muy bien dentro de su propio <span>:

      
        
        
          <div id="clock">
  <span class="hour">hh</span>:<span class="min">mm</span>:<span class="sec">ss</span>
</div>
        
      
      
      También necesitamos CSS para colorearlos.
La función update que refrescará el reloj será llamada por setInterval una vez por segundo:

      
        
        
          function update() {
  let clock = document.getElementById('clock');
  let date = new Date(); // (*)
  let hours = date.getHours();
  if (hours < 10) hours = '0' + hours;
  clock.children[0].innerHTML = hours;

  let minutes = date.getMinutes();
  if (minutes < 10) minutes = '0' + minutes;
  clock.children[1].innerHTML = minutes;

  let seconds = date.getSeconds();
  if (seconds < 10) seconds = '0' + seconds;
  clock.children[2].innerHTML = seconds;
}
        
      
      
      En la línea (*) verificamos la hora cada vez. Las llamadas a setInterval no son confiables: pueden ocurrir con demoras.
Las funciones que manejan el reloj:

      
        
        
          let timerId;

function clockStart() { // ejecuta el reloj
  if (!timerId) { // solo establece un nuevo intervalo si el reloj no está corriendo
    timerId = setInterval(update, 1000);
  }
  update(); // (*)
}

function clockStop() {
  clearInterval(timerId);
  timerId = null; // (**)
}
        
      
      
      Nota que la llamada a update() no solo está agendada en clockStart(), también la ejecuta inmediatamente en la línea (*). De otro modo el visitante tendría que esperar hasta la primera ejecución de setInterval. Y el reloj estaría vacío hasta entonces.
También es importante establecer un nuevo intervalo en clockStart() solamente cuando el reloj no está corriendo. De otra forma al cliquear el botón de inicio varias veces se establecerían múltiples intervalos concurrentes. Peor aún, solo mantendríamos el timerID del último intervalo, perdiendo referencia a todos los demás. ¡No podríamos detener el reloj nunca más! Nota que necesitamos limpiar timerID cuando el reloj es detenido en la línea (**), así puede ser reiniciado corriendo clockStart().
Abrir la solución en un entorno controlado.Inserta el  HTML en la listaimportancia: 5Escribe el código para insertar  <li>2</li><li>3</li> entre dos <li> aquí:

      
        
        
          <ul id="ul">
  <li id="one">1</li>
  <li id="two">4</li>
</ul>
        
      
      
      soluciónCuando necesitamos insertar una pieza de HTML en algún lugar, insertAdjacentHTML es lo más adecuado.
La solución:

      
        
        
          one.insertAdjacentHTML('afterend', '<li>2</li><li>3</li>');
        
      
      
      Ordena la tablaimportancia: 5Tenemos una tabla:

      
        
        
          
            
          
          
            
          
        
        
          <table>
<thead>
  <tr>
    <th>Name</th><th>Surname</th><th>Age</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>John</td><td>Smith</td><td>10</td>
  </tr>
  <tr>
    <td>Pete</td><td>Brown</td><td>15</td>
  </tr>
  <tr>
    <td>Ann</td><td>Lee</td><td>5</td>
  </tr>
  <tr>
    <td>...</td><td>...</td><td>...</td>
  </tr>
</tbody>
</table>
        
      
      
      Puede haber más filas en ella.
Escribe el código para ordenarla por la columna "name".
Abrir un entorno controlado para la tarea.soluciónLa solución es corta, pero puede verse algo dificultosa así que brindamos comentarios extendidos:

      
        
        
          let sortedRows = Array.from(table.tBodies[0].rows) // 1
  .sort((rowA, rowB) => rowA.cells[0].innerHTML.localeCompare(rowB.cells[0].innerHTML));

table.tBodies[0].append(...sortedRows); // (3)
        
      
      
      El algoritmo paso a paso:

Obtener todos los <tr> de <tbody>.
Entonces ordenarlos comparando por el contenido de su primer <td> (el campo nombre).
Ahora insertar nodos en el orden correcto con .append(...sortedRows).

No necesitamos quitar los elementos row, simplemente “reinsertarlos”, ellos dejan el viejo lugar automáticamente.
P.S. En nuestro caso, hay un <tbody> explícito en la tabla, pero incluso si la tabla HTML no tiene <tbody>, la estructura DOM siempre lo tiene.
Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/modifying-document" 
},
{
	"docs_id": "103",
	"name": "Estilos y clases",
	"description": "Antes de profundizar en cómo JavaScript maneja las clases y los estilos, hay una regla importante. Aunque es lo suficientemente obvio, aún tenemos que mencionarlo.",
	"content": "Antes de profundizar en cómo JavaScript maneja las clases y los estilos, hay una regla importante. Aunque es lo suficientemente obvio, aún tenemos que mencionarlo.
Por lo general, hay dos formas de dar estilo a un elemento:

Crear una clase css y agregarla: <div class="...">
Escribir las propiedades directamente en style: <div style="...">.

JavaScript puede modificar ambos, clases y las propiedades de style.
Nosotros deberíamos preferir las clases css en lugar de style. Este último solo debe usarse si las clases “no pueden manejarlo”.
Por ejemplo, style es aceptable si nosotros calculamos las coordenadas de un elemento dinámicamente y queremos establecer estas desde JavaScript, así:

      
        
        
          let top = /* cálculos complejos */;
let left = /* cálculos complejos */;

elem.style.left = left; // ej. '123px', calculado en tiempo de ejecución
elem.style.top = top; // ej. '456px'
        
      
      
      Para otros casos como convertir un texto en rojo, agregar un icono de fondo. Escribir eso en CSS y luego agregar la clase (JavaScript puede hacer eso), es más flexible y más fácil de mantener.
className y classListCambiar una clase es una de las acciones más utilizadas.
En la antigüedad, había una limitación en JavaScript: una palabra reservada como "class" no podía ser una propiedad de un objeto. Esa limitación no existe ahora, pero en ese momento era imposible tener una propiedad "class", como elem.class.
Entonces para clases de similares propiedades, "className" fue introducido: el elem.className corresponde al atributo "class".
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <body class="main page">
  <script>
    alert(document.body.className); // página principal
  </script>
</body>
        
      
      
      Si asignamos algo a elem.className, reemplaza toda la cadena de clases. A veces es lo que necesitamos, pero a menudo queremos agregar o eliminar una sola clase.
Hay otra propiedad para eso: elem.classList.
El elem.classList es un objeto especial con métodos para agregar, eliminar y alternar (add/remove/toggle) una sola clase.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <body class="main page">
  <script>
    // agregar una clase
    document.body.classList.add('article');

    alert(document.body.className); // clase "article" de la página principal
  </script>
</body>
        
      
      
      Entonces podemos trabajar con ambos: todas las clases como una cadena usando className o con clases individuales usando classList. Lo que elijamos depende de nuestras necesidades.
Métodos de classList:

elem.classList.add/remove("class") – agrega o remueve la clase.
elem.classList.toggle("class") – agrega la clase si no existe, si no la remueve.
elem.classList.contains("class") – verifica si tiene la clase dada, devuelve true/false.

Además, classList es iterable, entonces podemos listar todas las clases con for..of, así:

      
        
        
          
            
          
          
            
          
        
        
          <body class="main page">
  <script>
    for (let name of document.body.classList) {
      alert(name); // main y luego page
    }
  </script>
</body>
        
      
      
      style de un elementoLa propiedad elem.style es un objeto que corresponde a lo escrito en el atributo "style". Establecer elem.style.width="100px" funciona igual que sí tuviéramos en el atributo style una cadena con width:100px.
Para propiedades de varias palabras se usa camelCase:

      
        
        
          background-color  => elem.style.backgroundColor
z-index           => elem.style.zIndex
border-left-width => elem.style.borderLeftWidth
        
      
      
      Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          document.body.style.backgroundColor = prompt('background color?', 'green');
        
      
      
      
            Propiedades prefijadas
            Propiedades con prefijos del navegador como -moz-border-radius, -webkit-border-radius también siguen la misma regla: un guion significa mayúscula.
Por ejemplo:

      
        
        
          button.style.MozBorderRadius = '5px';
button.style.WebkitBorderRadius = '5px';
        
      
      
      
Reseteando la propiedad styleA veces queremos asignar una propiedad de estilo y luego removerla.
Por ejemplo, para ocultar un elemento, podemos establecer elem.style.display = "none".
Luego, más tarde, es posible que queramos remover style.display como si no estuviera establecido. En lugar de delete elem.style.display deberíamos asignarle una cadena vacía: elem.style.display = "".

      
        
        
          
            
          
          
            
          
        
        
          // si ejecutamos este código, el <body> parpadeará
document.body.style.display = "none"; // ocultar

setTimeout(() => document.body.style.display = "", 1000); // volverá a lo normal
        
      
      
      Si establecemos style.display como una cadena vacía, entonces el navegador aplica clases y estilos CSS incorporados normalmente por el navegador, como si no existiera tal style.display.
También hay un método especial para eso, elem.style.removeProperty('style property'). Así, podemos quitar una propiedad:

      
        
        
          
            
          
          
            
          
        
        
          document.body.style.background = 'red'; //establece background a rojo

setTimeout(() => document.body.style.removeProperty('background'), 1000); // quitar background después de 1 segundo
        
      
      
      
            Reescribir todo usando style.cssText
            Normalmente, podemos usar style.* para asignar propiedades de estilo individuales. No podemos establecer todo el estilo como div.style="color: red; width: 100px", porque div.style es un objeto y es solo de lectura.
Para establecer todo el estilo como una cadena, hay una propiedad especial: style.cssText:

      
        
        
          
            
          
          
            
          
        
        
          <div id="div">Button</div>

<script>
  // podemos establecer estilos especiales con banderas como "important"
  div.style.cssText=`color: red !important;
    background-color: yellow;
    width: 100px;
    text-align: center;
  `;

  alert(div.style.cssText);
</script>
        
      
      
      Esta propiedad es rara vez usada, porque tal asignación remueve todo los estilos: no agrega estilos sino que los reemplaza en su totalidad. Ocasionalmente podría eliminar algo necesario. Pero podemos usarlo de manera segura para nuevos elementos, cuando sabemos que no vamos a eliminar un estilo existente.
Lo mismo se puede lograr estableciendo un atributo: div.setAttribute('style', 'color: red...').

Cuidado con las unidades CSSNo olvidar agregar las unidades CSS a los valores.
Por ejemplo, nosotros no debemos establecer elem.style.top a 10, sino más bien a 10px. De lo contrario no funcionaría:

      
        
        
          
            
          
          
            
          
        
        
          <body>
  <script>
    // ¡no funciona!
    document.body.style.margin = 20;
    alert(document.body.style.margin); // '' (cadena vacía, la asignación es ignorada)

    // ahora agregamos la unidad CSS (px) y esta sí funciona
    document.body.style.margin = '20px';
    alert(document.body.style.margin); // 20px

    alert(document.body.style.marginTop); // 20px
    alert(document.body.style.marginLeft); // 20px
  </script>
</body>
        
      
      
      Tenga en cuenta: el navegador “desempaqueta” la propiedad style.margin en las últimas lineas e infiere style.marginLeft y style.marginTop de eso.
Estilos calculados: getComputedStyleEntonces, modificar un estilo es fácil. ¿Pero cómo leerlo?
Por ejemplo, queremos saber el tamaño, los márgenes, el color de un elemento. ¿Cómo hacerlo?
La propiedad style solo opera en el valor del atributo "style", sin ninguna cascada de css.
Entonces no podemos leer ninguna clase CSS usando elem.style.
Por ejemplo, aquí style no ve el margen:

      
        
        
          
            
          
          
            
          
        
        
          <head>
  <style> body { color: red; margin: 5px } </style>
</head>
<body>

  El texto en rojo
  <script>
    alert(document.body.style.color); // vacío
    alert(document.body.style.marginTop); // vacío
  </script>
</body>
        
      
      
      Pero si necesitamos incrementar el margen a  20px? vamos el querer el valor de la misma.
Hay otro método para eso: getComputedStyle.
La sintaxis es:

      
        
        
          getComputedStyle(element, [pseudo])
        
      
      
      
element
Elemento del cual se va a leer el valor.
pseudo
Un pseudo-elemento es requerido, por ejemplo ::before. Una cadena vacía o sin argumento significa el elemento mismo.

El resultado es un objeto con estilos, como elem.style, pero ahora con respecto a todas las clases CSS.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <head>
  <style> body { color: red; margin: 5px } </style>
</head>
<body>

  <script>
    let computedStyle = getComputedStyle(document.body);

    // ahora podemos leer los márgenes y el color de ahí

    alert( computedStyle.marginTop ); // 5px
    alert( computedStyle.color ); // rgb(255, 0, 0)
  </script>

</body>
        
      
      
      
            Valores calculado y resueltos
            Hay dos conceptos en CSS:

Un estilo calculado es el valor final de aplicar todas las reglas y herencias CSS, como resultado de la cascada CSS. Puede parecer height:1em o font-size:125%.
Un estilo resuelto es la que finalmente se aplica al elemento. Valores como 1em o 125% son relativos. El navegador toma el valor calculado y hace que todas las unidades sean fijas y absolutas, por ejemplo: height:20px o font-size:16px. Para las propiedades de geometría los valores resueltos pueden tener un punto flotante, como width:50.5px.

Hace mucho tiempo getComputedStyle fue creado para obtener los valores calculados, pero los valores resueltos son muchos más convenientes, y el estándar cambió.
Así que hoy en día getComputedStyle en realidad devuelve el valor resuelto de la propiedad, usualmente en px para geometría.


            El método getComputedStyle requiere el nombre completo de la propiedad
            Siempre deberíamos preguntar por la propiedad exacta que queremos, como paddingLeft o marginTop o borderTopWidth. De lo contrario, no se garantiza el resultado correcto.
Por ejemplo, si hay propiedades paddingLeft/paddingTop, ¿entonces qué deberíamos obtener de getComputedStyle(elem).padding? ¿Nada, o tal vez un valor “generado” de los paddings? No hay una regla estándar aquí.
Hay otras inconsistencias. Por ejemplo, algunos navegadores (Chrome) muestran 10px en el documento a continuación, y alguno de ellos (Firefox) no:

      
        
        
          
            
          
          
            
          
        
        
          <style>
  body {
    margin: 10px;
  }
</style>
<script>
  let style = getComputedStyle(document.body);
  alert(style.margin); // cadena vacía en Firefox
</script>
        
      
      
      

            ¡Los estilos aplicados a los enlaces :visited están ocultos!
            Los enlaces visitados pueden ser coloreados usando la pseudo-clase :visited de CSS.
Pero getComputedStyle no da acceso a ese color, porque de lo contrario una página cualquiera podría averiguar si el usuario visitó un enlace creándolo en la página y verificar los estilos.
JavaScript no puede ver los estilos aplicados por :visited. También hay una limitación en CSS que prohíbe la aplicación de estilos de cambio de geometría en :visited. Eso es para garantizar que no haya forma para que una página maligna pruebe si un enlace fue visitado y vulnere la privacidad.

ResumenPara manejar clases, hay dos propiedades del DOM:

className – el valor de la cadena, perfecto para manejar todo el conjunto de clases.
classList – el objeto con los métodos: add/remove/toggle/contains, perfecto para clases individuales.

Para cambiar los estilos:


La propiedad style es un objeto con los estilos en camelcase.
Leer y escribir tiene el mismo significado que modificar propiedades individuales en el atributo "style". Para ver cómo aplicar important y otras cosas raras, hay una lista de métodos en MDN.


La propiedad style.cssText corresponde a todo el atributo "style", la cadena completa de estilos.


Para leer los estilos resueltos (con respecto a todas las clases, después de que se aplica todo el css y se calculan los valores finales):

El método getComputedStyle(elem, [pseudo]) retorna el objeto de estilo con ellos (solo lectura).

TareasCrear una notificaciónimportancia: 5Escribir una función showNotification(options) que cree una notificación: <div class="notification"> con el contenido dado. La notificación debería desaparecer automáticamente despues de 1.5 segundos.
Las opciones son:

      
        
        
          // muestra un elemento con el texto "Hello" cerca de la parte superior de la ventana
showNotification({
  top: 10, // 10px desde la parte superior de la ventana (por defecto es 0px)
  right: 10, // 10px desde el borde derecho de la ventana (por defecto es 0px)
  html: "Hello!", // el HTML de la notificación
  className: "welcome" // una clase adicional para el "div" (opcional)
});
        
      
      
      Demo en nueva ventanaUsar posicionamiento CSS para mostrar el elemento en las coordenadas (top/right) dadas. El documento tiene los estilos necesarios.
Abrir un entorno controlado para la tarea.soluciónAbrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/styles-and-classes" 
},
{
	"docs_id": "104",
	"name": "Tamaño de elementos y desplazamiento",
	"description": "Hay muchas propiedades en JavaScript que nos permiten leer información sobre el ancho, alto y otras características geométricas de los elementos.",
	"content": "Hay muchas propiedades en JavaScript que nos permiten leer información sobre el ancho, alto y otras características geométricas de los elementos.
A menudo necesitamos de ellas cuando movemos o posicionamos un elemento en JavaScript.
Elemento de muestraComo un elemento de muestra para demostrar las propiedades, usaremos el que se indica a continuación:

      
        
        
          <div id="example">
  ...Texto...
</div>
<style>
  #example {
    width: 300px;
    height: 200px;
    border: 25px solid #E8C48F;
    padding: 20px;
    overflow: auto;
  }
</style>
        
      
      
      Este tiene borde, relleno y desplazamiento. El conjunto completo de funciones. No hay márgenes porque no son parte del elemento en sí, y no tienen propiedades especiales.
El elemento tiene este aspecto:

      
      
        
      
      Puedes abrir el documento en la zona de pruebas.

            Atento a la barra de desplazamiento (scrollbar)
            La imagen de arriba muestra el caso más complejo cuando el elemento tiene una barra de desplazamiento. Algunos navegadores (no todos) reservan espacio para tomarlo del contenido (el etiquetado como “content width” arriba).
Entonces, sin la barra de desplazamiento el ancho del contenido sería 300px, pero si la barra de desplazamiento tiene un ancho de 16px (el ancho puede variar entre dispositivos y navegadores) entonces solo queda 300 - 16 = 284px, y deberíamos tenerlo en cuenta. Es por eso que los ejemplos de este capítulo asumen que hay una barra de desplazamiento. Sin ella, algunos cálculos son más sencillos.


            El área padding-bottom puede estar lleno de texto
            Por lo general, los rellenos se muestran vacíos en nuestras ilustraciones, pero si hay mucho texto en el elemento y se desborda, los navegadores muestran el texto “desbordado” en padding-bottom, eso es normal.

GeometríaAquí está la imagen general con propiedades geométricas:

      
      
        
      
      Los valores de estas propiedades son técnicamente números, pero estos números son “de píxeles”, así que estas son medidas de píxeles.
Comencemos a explotar las propiedades, iniciando desde el exterior del elemento.
offsetParent, offsetLeft/TopEstas propiedades son raramente necesarias, pero aún son las propiedades de geometría “más externas” así que comenzaremos con ellas.
El offsetParent es el antepasado más cercano que usa el navegador para calcular las coordenadas durante el renderizado.
Ese es el antepasado más cercano que es uno de los siguientes:

Posicionado por CSS (position es absolute, relative, fixed o sticky),  o…
<td>, <th>, or <table>,  o…
<body>.

Las propiedades offsetLeft/offsetTop proporcionan coordenadas x/y relativas a la esquina superior izquierda de offsetParent.
En el siguiente ejemplo el <div> más interno tiene <main> como offsetParent, y offsetLeft/offsetTop lo desplaza desde su esquina superior izquierda (180):

      
        
        
          
            
          
          
            
          
        
        
          <main style="position: relative" id="main">
  <article>
    <div id="example" style="position: absolute; left: 180px; top: 180px">...</div>
  </article>
</main>
<script>
  alert(example.offsetParent.id); // main
  alert(example.offsetLeft); // 180 (nota: es un número, no un string "180px")
  alert(example.offsetTop); // 180
</script>
        
      
      
      
      
      
        
      
      Hay varias ocasiones en la que offsetParent es null:

Para elementos no mostrados (display:none o no en el documento).
Para <body> y <html>.
Para elementos con position:fixed.

offsetWidth/HeightAhora pasemos al elemento en sí.
Estas dos propiedades son las más simples. Proporcionan el ancho y alto “exterior” del elemento. O, en otras palabras, su tamaño completo, incluidos los bordes.

      
      
        
      
      Para nuestro elemento de muestra:

offsetWidth = 390 – el ancho exterior, puede ser calculado como CSS-width interno (300px) más acolchonados (2 * 20px) y bordes (2 * 25px).
offsetHeight = 290 – el alto exterior.


            Las propiedades geométricas para elementos no mostrados son cero o null
            Las propiedades geométricas son calculadas solo para elementos mostrados.
En un elemento (o cualquiera de sus antepasados) tiene display:none o no está en el documento, entonces las propiedades geométricas son cero (o null para offsetParent).
Por ejemplo, offsetParent es null, y offsetWidth, offsetHeight son 0 cuando creamos un elemento pero aún no lo han insertado en el documento, o cuando éste (o su ancestro) tiene display:none.
Nosotros podemos usar esto para verificar si un elemento está oculto, así:

      
        
        
          function isHidden(elem) {
  return !elem.offsetWidth && !elem.offsetHeight;
}
        
      
      
      Observa que tal isHidden devuelve true para elementos que están en pantalla pero tienen tamaño cero.

clientTop/LeftDentro del elemento, tenemos los bordes.
Para medirlos, están las propiedades clientTop y clientLeft.
En nuestro ejemplo:

clientLeft = 25 – ancho del borde izquierdo
clientTop = 25 – ancho del borde superior


      
      
        
      
      … pero para ser precisos: estas propiedades no son el ancho/alto del borde sino las coordenadas relativas del lado interior respecto al lado exterior.
¿Cuál es la diferencia?
Esto se vuelve evidente cuando el documento está de derecha a izquierda (con el sistema operativo en idioma árabe, o hebreo). La barra de desplazamiento no está a la derecha sino a la izquierda, entonces clientLeft también incluye el ancho de la barra de desplazamiento.
En este caso, clientLeft no es 25, sino que se suma el ancho de la barra de desplazamiento 25 + 16 = 41.
Aquí está el ejemplo en hebreo:

      
      
        
      
      clientWidth/HeightEsta propiedad proporciona el tamaño del área dentro de los bordes del elemento.
Incluyen el ancho del contenido junto con los rellenos, pero sin la barra de desplazamiento:

      
      
        
      
      En la imagen de arriba, consideramos primero clientHeight.
No hay una barra de desplazamiento horizontal, por lo que es exactamente la suma de lo que está dentro de los bordes: CSS-height 200px más el relleno superior e inferior (2 * 20px) totaliza 240px.
Ahora clientWidth: aquí el ancho del contenido no es 300px, sino 284px, porque los 16px son ocupados por la barra de desplazamiento. Entonces la suma es 284px más los rellenos de izquierda y derecha, total 324px.
Si no hay rellenos, entonces clientWidth/Height es exactamente el área de contenido, dentro de los bordes y la barra de desplazamiento (si la hay).

      
      
        
      
      Entonces, cuando no hay relleno, podremos usar clientWidth/clientHeight para obtener el tamaño del área de contenido.
scrollWidth/HeightEstas propiedades son como clientWidth/clientHeight, pero también incluyen las partes desplazadas (ocultas):

      
      
        
      
      En la imagen de arriba:

scrollHeight = 723 – es la altura interior completa del área de contenido, incluyendo las partes desplazadas.
scrollWidth = 324 – es el ancho interior completo, aquí no tenemos desplazamiento horizontal, por lo que es igual a clientWidth.

Podemos usar estas propiedades para expandir el elemento a su ancho/alto completo.
Como esto:

      
        
        
          // expanda el elemento a la altura completa del contenido
element.style.height = `${element.scrollHeight}px`;
        
      
      
      Clic en el botón para expandir el elemento:
text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text text
element.style.height = ${element.scrollHeight}px
scrollLeft/scrollTopLas propiedades scrollLeft/scrollTop son el ancho/alto de la parte oculta y desplazada del elemento.
En la imagen abajo podemos ver scrollHeight y scrollTop para un bloque con un desplazamiento vertical.

      
      
        
      
      En otras palabras, scrollTop es “cuánto se desplaza hacia arriba”.

            scrollLeft/scrollTop puede ser modificado
            La mayoría de las propiedades aquí son solo lectura, pero scrollLeft/scrollTop se puede cambiar, y el navegador desplazará el elemento.
Si haces clic en el elemento de abajo, se ejecuta el código elem.scrollTop += 10. Eso hace que el contenido del elemento se desplace 10px abajo.
ClickMe123456789
Establecer scrollTop en 0 o un valor grande, como 1e9 hará que el elemento se desplace hacia arriba/abajo respectivamente.

No uses width/height obtenidos de CSSAcabamos de cubrir las propiedades geométricas de los elementos DOM, que se pueden usar para obtener anchos, alturas y calcular distancias.
Pero como sabemos por el capítulo Estilos y clases, podemos leer CSS-height y width usando getComputedStyle.
Entonces, ¿Por qué no leer el ancho de un elemento con getComputedStyle como aquí?

      
        
        
          
            
          
          
            
          
        
        
          let elem = document.body;

alert( getComputedStyle(elem).width ); // muestra CSS width por elemento
        
      
      
      ¿Por qué deberíamos usar propiedades geométricas en su lugar? Hay dos razones:


Primero, CSS width/height dependen de otra propiedad: box-sizing que define “qué es” CSS width y height. Un cambio en box-sizing para propósitos de CSS puede romper dicho JavaScript.


Segundo, CSS width/height puede ser auto, por ejemplo para un elemento en linea:

      
        
        
          
            
          
          
            
          
        
        
          <span id="elem">Hola!</span>

<script>
  alert( getComputedStyle(elem).width ); // auto
</script>
        
      
      
      Desde el punto de vista de CSS, width:auto es perfectamente normal, pero en JavaScript necesitamos un tamaño exacto en px que podríamos usar en los cálculos. Entonces, aquí el ancho de CSS width es inútil.


Y hay una razón más: una barra de desplazamiento. A veces, el código que funcionaba bien sin una barra de desplazamiento tiene errores, porque una barra de desplazamiento toma el espacio del contenido en algunos navegadores. Entonces, el ancho real disponible para el contenido es menor que el ancho de CSS. Y clientWidth/clientHeight tiene eso en cuenta.
…Pero con getComputedStyle(elem).width la situación es diferente. Algunos navegadores (p.e. Chrome) devuelven el ancho interno real, menos la barra de desplazamiento, y algunos de ellos (p.e. Firefox) – CSS width (ignora la barra de desplazamiento). Estas diferencias entre los navegadores son la razón para no usar getComputedStyle, sino confiar en las propiedades geométricas.
Si tu navegador reserva el espacio para la barra de desplazamiento (la mayoría de navegadores para Windows lo hacen), pueden probarlo a continuación.

    
        
      
      
    
  El elemento con texto tiene CSS width:300px.
En un Windows OS de escritorio, Firefox, Chrome, Edge reservan el espacio para la barra de desplazamiento. Pero Firefox muestra 300px, mientras que Chrome y Edge muestran menos. Eso es por que Firefox devuelve el ancho del CSS y otros navegadores devuelven el ancho “real”.
Tenga en cuenta que la diferencia descrita es solo de leer getComputedStyle(...).width de JavaScript, visualmente todo es correcto.
ResumenLos elementos tienen las siguientes propiedades geométricas:

offsetParent – es el ancestro posicionado más cercano o td, th, table, body.
offsetLeft/offsetTop – coordenadas relativas al borde superior izquierdo de offsetParent.
offsetWidth/offsetHeight – ancho/alto “exterior” de un elemento, incluidos los bordes.
clientLeft/clientTop – las distancias desde la esquina exterior superior izquierda a la esquina interior superior izquierda (contenido + relleno). Para los Sistemas Operativos de izquierda a derecha, siempre son los anchos de los bordes izquierdo/superior. Para los Sistemas Operativos de derecha a izquierda, la barra de desplazamiento está a la izquierda, por lo que clientLeft también incluye su ancho.
clientWidth/clientHeight – el ancho/alto del contenido incluyendo rellenos, pero sin la barra de desplazamiento.
scrollWidth/scrollHeight – el ancho/alto del contenido, al igual que clientWidth/clientHeight, pero también incluye la parte invisible desplazada del elemento.
scrollLeft/scrollTop – ancho/alto de la parte superior desplazada del elemento, comenzando desde la esquina superior izquierda.

Todas las propiedades son solo lectura excepto scrollLeft/scrollTop que hacen que el navegador desplace el elemento si se cambia.
Tareas¿Qué es el desplazamiento desde la parte inferior?importancia: 5La propiedad elem.scrollTop es el tamaño desplazado desde la parte superior. ¿Cómo obtener el tamaño de la parte inferior desplazada (vamos a llamarlo scrollBottom)?
Escribe el código que funcione para un elem arbitrario.
P.S. Por favor revisa tu código: si no hay desplazamiento o el elemento está complemamente desplazado, debería retornar 0.
soluciónLa solución es:

      
        
        
          let scrollBottom = elem.scrollHeight - elem.scrollTop - elem.clientHeight;
        
      
      
      En otras palabras: (altura total) menos (parte superior desplazada) menos (parte visible) – esa es exactamente la parte inferior desplazada.
¿Qué es el ancho de la barra de desplazamiento?importancia: 3Escribe el código que retorna el tamaño de una barra de desplazamiento estándar.
Para Windows esto usualmente varía entre 12px y 20px. Si el navegador no reserva algún espacio para esto (la barra de desplazamiento es medio traslúcida sobre el texto, también pasa), entonces puede ser 0px.
P.S. El código debería funcionar con cualquier documento HTML, no depende de su contenido.
soluciónPara obtener el ancho de la barra de desplazamiento, podemos crear un elemento con el scroll, pero sin bordes ni rellenos.
Entonces la diferencia entre su ancho completo offsetWidth y el ancho del area interior clientWidth será exactamente la barra de desplazamiento:

      
        
        
          
            
          
          
            
          
        
        
          // crea un div con el scroll
let div = document.createElement('div');

div.style.overflowY = 'scroll';
div.style.width = '50px';
div.style.height = '50px';

// debe ponerlo en el documento, de lo contrario los tamaños serán 0
document.body.append(div);
let scrollWidth = div.offsetWidth - div.clientWidth;

div.remove();

alert(scrollWidth);
        
      
      
      Coloca la pelota en el centro del campo.importancia: 5Así es como se ve el documento de origen:

    
        
      
      
        
      
      
    
  ¿Cuáles son las coordenadas del centro de campo?
Calcúlalos y úsalos para colocar la pelota en el centro del campo verde:

    
    
  
El elemento debe ser movido por JavaScript, no por CSS.
El código debería funcionar con cualquier una pelota de cualquier tamaño (10, 20, 30 pixels) y cualquier tamaño de campo, no debe estar vinculado a los valores dados.

P.S. Claro, el centrado se podría hacer con CSS, pero aquí lo queremos específicamente con JavaScript. Además, conoceremos otros temas y situaciones más complejas en las que se debe utilizar JavaScript. Aquí hacemos un “calentamiento”.
Abrir un entorno controlado para la tarea.soluciónLa pelota tiene position:absolute. Significa que sus coordenadas left/top se miden desde el elemento posicionado más cercano, es decir #field (porque tiene position:relative).
Las coordenadas inician desde el interior de la esquina superior izquierda del campo:

      
      
        
      
      El interior del campo ancho/alto es clientWidth/clientHeight. Entonces el centro del campo tiene coordenadas (clientWidth/2, clientHeight/2).
…Pero si configuramos ball.style.left/top a tales valores, entonces no la pelota en su conjunto, sino el borde superior izquierdo de la pelota estaría en el centro:

      
        
        
          ball.style.left = Math.round(field.clientWidth / 2) + 'px';
ball.style.top = Math.round(field.clientHeight / 2) + 'px';
        
      
      
      Así es como se ve:

    
    
  Para alinear la pelota al centro con el centro del campo, deberíamos mover la pelota a la mitad de su ancho a la izquierda y a la mitad de su altura hacia arriba:

      
        
        
          ball.style.left = Math.round(field.clientWidth / 2 - ball.offsetWidth / 2) + 'px';
ball.style.top = Math.round(field.clientHeight / 2 - ball.offsetHeight / 2) + 'px';
        
      
      
      Ahora la pelota está finalmente centrada.

            Atención: ¡la trampa!
            El código no funcionará seguramente mientras <img> no tenga width/height:

      
        
        
          <img src="ball.png" id="ball">
        
      
      
      
Cuando el navegador no conoce el ancho/alto de una imagen (de un atributo o CSS), entonces este asume que es igual a 0 hasta que la imagen termine de cargarse.
Entonces el valor de ball.offsetWidth deberá ser 0 hasta que la imagen cargue. Eso conduce a coordinadas incorrectas en el código anterior.
Después de la primera carga, el navegador usualmente almacena en caché la imagen, y cuando se vuelva a cargar esta tendrá el tamaño inmediatamente. Pero en la primera carga el valor de ball.offsetWidth es 0.
Deberíamos arreglar eso agregando width/height en <img>:

      
        
        
          <img src="ball.png" width="40" height="40" id="ball">
        
      
      
      …O indicar el tamaño en CSS:

      
        
        
          #ball {
  width: 40px;
  height: 40px;
}
        
      
      
      Abrir la solución en un entorno controlado.La diferencia: CSS width versus clientWidthimportancia: 5¿Cuál es la diferencia entre getComputedStyle(elem).width y elem.clientWidth?
Dar al menos 3 diferencias. Mientras más, mejor.
soluciónDiferencias:

clientWidth es numérico, mientras getComputedStyle(elem).width retorna una cadena con px en el final.
getComputedStyle puede devolver un ancho no numérico como "auto" para un elemento en linea.
clientWidth es el contenido interior del área del elemento más los rellenos, mientras el ancho de CSS (con el estándar box-sizing) es el contenido interior del área sin rellenos.
Si hay una barra de desplazamiento y el navegador reserva espacio para esta, algunos navegadores restan ese espacio del ancho de CSS (por que no está disponible para el contenido), y otros no. La propiedad clientWidth es siempre la misma: el tamaño de la barra de desplazamiento se resta si está reservado.

",
	"url": "https://es.javascript.info/size-and-scroll" 
},
{
	"docs_id": "105",
	"name": "Tamaño de ventana y desplazamiento",
	"description": "¿Cómo encontramos el ancho y el alto de la ventana del navegador? ¿Cómo obtenemos todo el ancho y la altura del documento, incluida la parte desplazada? ¿Cómo desplazamos la página usando JavaScript?",
	"content": "¿Cómo encontramos el ancho y el alto de la ventana del navegador? ¿Cómo obtenemos todo el ancho y la altura del documento, incluida la parte desplazada? ¿Cómo desplazamos la página usando JavaScript?
Para la mayoría de estas cuestiones, podemos usar el elemento de documento raíz document.documentElement, que corresponde a la etiqueta <html>. Pero hay métodos y peculiaridades adicionales lo suficientemente importantes para considerar.
Ancho/alto de la ventanaPara obtener el ancho y alto de la ventana, podemos usar clientWidth / clientHeight de document.documentElement:

      
      
        
      
      Por ejemplo, este botón muestra la altura de su ventana:
alert(document.documentElement.clientHeight)

            No window.innerWidth/Height
            Los navegadores también admiten propiedades window.innerWidth / innerHeight. Se parecen a lo que queremos. Entonces, ¿por qué no usarlos?
Si existe una barra de desplazamiento, y ocupa algo de espacio, clientWidth / clientHeight proporciona el ancho/alto sin ella (resta el espacio desplazado). En otras palabras, devuelven ancho/alto de la parte visible del documento, disponible para el contenido.
… Y window.innerWidth / innerHeight incluye la barra de desplazamiento.
Si hay una barra de desplazamiento y ocupa algo de espacio, estas dos líneas muestran valores diferentes:

      
        
        
          
            
          
          
            
          
        
        
          alert( window.innerWidth ); // ancho de la ventana completa
alert( document.documentElement.clientWidth ); // ancho de ventana menos el desplazamiento.
        
      
      
      En la mayoría de los casos, necesitamos el ancho de ventana disponible, para dibujar o colocar algo. Es decir: el espacio del desplazamiento si hay alguno. Entonces deberíamos usar documentElement.clientHeight/Width.


            DOCTYPE es importante
            Tenga en cuenta que las propiedades de geometría de nivel superior pueden funcionar de manera un poco diferente cuando no hay <!DOCTYPE HTML> en HTML. Pueden suceder cosas extrañas.
En HTML moderno siempre debemos escribir DOCTYPE.

Ancho/Alto del documentoTeóricamente, como el elemento del documento raíz es document.documentElement, e incluye todo el contenido, podríamos medir el tamaño completo del documento con document.documentElement.scrollWidth / scrollHeight.
Pero en ese elemento, para toda la página, estas propiedades no funcionan según lo previsto. ¡En Chrome/Safari/Opera si no hay desplazamiento, entonces documentElement.scrollHeight puede ser incluso menor que documentElement.clientHeight! Suena como una tontería, raro, ¿verdad?
Para obtener de manera confiable la altura completa del documento, debemos tomar el máximo de estas propiedades:

      
        
        
          
            
          
          
            
          
        
        
          let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
);

alert('Altura completa del documento, con parte desplazada: ' + scrollHeight);
        
      
      
      ¿Por qué? Mejor no preguntes. Estas inconsistencias provienen de tiempos antiguos, no una lógica “inteligente”.
Obtener el desplazamiento actualLos elementos DOM tienen su estado de desplazamiento actual en sus propiedades elem.scrollLeft/scrollTop.
El desplazamiento de documentos, document.documentElement.scrollLeft / Top funciona en la mayoría de los navegadores, excepto los más antiguos basados en WebKit, como Safari (bug 5991), donde deberíamos usar document.body en lugar de document.documentElement.
Afortunadamente, no tenemos que recordar estas peculiaridades en absoluto, porque el desplazamiento está disponible en las propiedades especiales window.pageXOffset/pageYOffset:

      
        
        
          
            
          
          
            
          
        
        
          alert('Desplazamiento actual desde la parte superior: ' + window.pageYOffset);
alert('Desplazamiento actual desde la parte izquierda: ' + window.pageXOffset);
        
      
      
      Estas propiedades son de solo lectura.

            También disponible como propiedades window: scrollX y scrollY
            Por razones históricas existen ambas propiedades, pero ambas son lo mismo:

window.pageXOffset es un alias de window.scrollX.
window.pageYOffset es un alias de window.scrollY.


Desplazamiento: scrollTo, scrollBy, scrollIntoView
            Importante:
            para desplazar la página desde JavaScript, su DOM debe estar completamente construido.
Por ejemplo, si intentamos desplazar la página desde el script en <head>, no funcionará.

Los elementos regulares se pueden desplazar cambiando scrollTop/scrollLeft.
Nosotros podemos hacer lo mismo para la página usando document.documentElement.scrollTop/Left (excepto Safari, donde document.body.scrollTop/Left debería usarse en su lugar).
Alternativamente, hay una solución más simple y universal: métodos especiales window.scrollBy(x,y) y window.scrollTo(pageX,pageY).


El método scrollBy(x, y) desplaza la página en relación con su posición actual. Por ejemplo, scrollBy(0,10) desplaza la página 10px hacia abajo.
El siguiente botón demuestra esto:
window.scrollBy(0,10)


El método scrollTo(pageX, pageY) desplaza la página a coordenadas absolutas, de modo que la esquina superior izquierda de la parte visible tiene coordenadas (pageX, pageY) en relación con la esquina superior izquierda del documento. Es como configurar scrollLeft / scrollTop.
Para desplazarnos hasta el principio, podemos usar scrollTo(0,0).
window.scrollTo(0,0)


Estos métodos funcionan para todos los navegadores de la misma manera.
scrollIntoViewPara completar, cubramos un método más: elem.scrollIntoView(top).
La llamada a elem.scrollIntoView(top) desplaza la página para hacer visible elem. Tiene un argumento:

si top=true (ese es el valor predeterminado), la página se desplazará para que aparezca element en la parte superior de la ventana. El borde superior del elemento está alineado con la parte superior de la ventana.
si top=false, la página se desplaza para hacer que element aparezca en la parte inferior. El borde inferior del elemento está alineado con la parte inferior de la ventana.

El botón a continuación desplaza la página para mostrarse en la parte superior de la ventana:
this.scrollIntoView()
Y este botón desplaza la página para mostrarla en la parte inferior:
this.scrollIntoView(false)
Prohibir el desplazamientoA veces necesitamos hacer que el documento sea “inescrutable”. Por ejemplo, cuando necesitamos cubrirlo con un mensaje grande que requiere atención inmediata, y queremos que el visitante interactúe con ese mensaje, no con el documento.
Para hacer que el documento sea inescrutable, es suficiente establecer document.body.style.overflow="hidden". La página se congelará en su desplazamiento actual.
Prueba esto:
document.body.style.overflow = ‘hidden’
document.body.style.overflow = ‘’
El primer botón congela el desplazamiento, el segundo lo reanuda.
Podemos usar la misma técnica para “congelar” el desplazamiento para otros elementos, no solo para document.body.
El inconveniente del método es que la barra de desplazamiento desaparece. Si ocupaba algo de espacio, entonces ese espacio ahora es libre y el contenido “salta” para llenarlo.
Eso parece un poco extraño, pero puede solucionarse si comparamos clientWidth antes y después del congelamiento, y si aumentó (la barra de desplazamiento desapareció) luego agregue padding a document.body en lugar de la barra de desplazamiento, para que mantenga el ancho del contenido igual.
ResumenGeometría:


Ancho/alto de la parte visible del documento (área de contenido ancho/alto): document.documentElement.clientWidth/Height


Ancho/alto de todo el documento, con la parte desplazada:

      
        
        
          let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
);
        
      
      
      

Desplazamiento:


Lee el desplazamiento actual: window.pageYOffset/pageXOffset.


Cambia el desplazamiento actual:

window.scrollTo(pageX,pageY) – coordenadas absolutas
window.scrollBy(x,y) – desplazamiento relativo al lugar actual,
elem.scrollIntoView(top) – desplácese para hacer visible el elem (alineación con la parte superior/inferior de la ventana).



",
	"url": "https://es.javascript.info/size-and-scroll-window" 
},
{
	"docs_id": "106",
	"name": "Coordenadas",
	"description": "Para mover elementos debemos estar familiarizados con las coordenadas.",
	"content": "Para mover elementos debemos estar familiarizados con las coordenadas.
La mayoría de los métodos de JavaScript tratan con uno de dos sistemas de coordenadas:

Relativo a la ventana: similar a position:fixed, calculado desde el borde superior/izquierdo de la ventana.

Designaremos estas coordenadas como clientX/clientY, el razonamiento para tal nombre se aclarará más adelante, cuando estudiemos las propiedades de los eventos.


Relative al documento – similar a position:absolute en la raíz del documento, calculado a partir del borde superior/izquierdo del documento.

Las designaremos como pageX/pageY.



Cuando la página se desplaza hasta el comienzo, de modo que la esquina superior/izquierda de la ventana es exactamente la esquina superior/izquierda del documento, estas coordenadas son iguales entre sí. Pero después de que el documento cambia, las coordenadas relativas a la ventana de los elementos cambian, a medida que los elementos se mueven a través de la ventana, mientras que las coordenadas relativas al documento permanecen iguales.
En esta imagen tomamos un punto en el documento y demostramos sus coordenadas antes del desplazamiento (primera imagen) y después (segunda imagen):

      
      
        
      
      Cuando el documento se desplazó:

La coordenada pageY relativa al documento se mantuvo igual, se cuenta desde la parte superior del documento (ahora desplazada).
La coordenada clientY relativa a la ventana cambió (la flecha se acortó), ya que el mismo punto se acercó a la parte superior de la ventana.

Coordenadas de elemento: getBoundingClientRectEl método elem.getBoundingClientRect() devuelve las coordenadas de la ventana para un rectángulo mínimo que encasilla a elem como un objeto de la clase interna DOMRect.
Propiedades principales de DOMRect:

x/y: coordenadas X/Y del origen del rectángulo con relación a la ventana.
width/height: ancho/alto del rectángulo (pueden ser negativos).

Adicionalmente existen estas propiedades derivadas:

top/bottom: coordenada Y para el borde superior/inferior del rectángulo.
left/right: coordenada X para el borde izquierdo/derecho del rectángulo.

Por ejemplo, haz click en este botón para ver las coordenadas en relación a la ventana:


function showRect(elem) {
  let r = elem.getBoundingClientRect();
  alert(`x:${r.x}
y:${r.y}
width:${r.width}
height:${r.height}
top:${r.top}
bottom:${r.bottom}
left:${r.left}
right:${r.right}
`);
}

Si desplazas la página y repites te darás cuenta que así como cambia la posición del botón relativa a la ventada también cambian sus coordenadas en la ventana (y/top/bottom si es que haces scroll vertical).
Aquí hay la imagen con el output de elem.getBoundingClientRect():

      
      
        
      
      Como puedes ver x/y y width/height describen completamente el rectángulo. Las propiedades derivadas pueden ser calculadas a partir de ellas:

left = x
top = y
right = x + width
bottom = y + height

Toma en cuenta:

Las coordenadas pueden ser fracciones decimales, tales como 10.5. Esto es normal ya que internamente el navegador usa fracciones en los cálculos. No tenemos que redondearlos para poder asignarlos a style.left/top.
Las coordenadas pueden ser negativas. Por ejemplo, si la página se desplaza hasta que elem rebase el borde superior de la ventana, entonces elem.getBoundingClientRect().top será negativo.


            ¿Por qué se necesitan propiedades derivadas? ¿Por qué top/left si existe x/y?
            Matemáticamente un rectángulo se define de únicamente con su punto de partida (x,y)  y el vector de dirección (width,height). Por lo tanto, las propiedades derivadas adicionales son por conveniencia.
Técnicamente es posible que width/height sean negativos, lo que permite un rectángulo “dirigido”. Por ejemplo, para representar la selección del mouse con su inicio y final debidamente marcados.
Los valores negativos para width/height indican que el rectángulo comienza en su esquina inferior derecha y luego se extiende hacia la izquierda y arriba.
Aquí hay un rectángulo con valores width y height negativos(ejemplo: width=-200, height=-100):

      
      
        
      
      Como puedes ver: left/top no es igual a x/y en tal caso.
Pero en la práctica elem.getBoundingClientRect() siempre devuelve el ancho y alto  positivos. Aquí hemos mencionado los valores negativos para width/height solo para que comprendas por qué estas propiedades aparentemente duplicadas en realidad no lo son.


            En Internet Explorer no hay soporte para x/y
            Internet Explorer no tiene soporte para las propiedades x/y por razones históricas.
De manera que podemos crear un polyfill y (obtenerlo con DomRect.prototype) o solo usar top/left, ya que son siempre las mismas que x/y para width/height positivos, en particular en el resultado de elem.getBoundingClientRect().


            Las coordenadas right/bottom son diferentes a las propiedades de posición en CSS
            Existen muchas similitudes obvias entre las coordenadas relativas a la ventana y position:fixed en CSS.
Pero en el posicionamiento con CSS, la propiedad right define la distancia entre el borde derecho y el elemento y la propiedad bottom supone la distancia entre el borde inferior y el elemento.
Si echamos un vistazo a la imagen anterior veremos que en JavaScript esto no es así. Todas las coordenadas de la ventana se cuentan a partir de la esquina superior izquierda, incluyendo estas.

elementFromPoint(x, y)La llamada a document.elementFromPoint(x, y) devuelve el elemento más anidado dentro de las coordenadas de la ventana (x, y).
La sintaxis es:

      
        
        
          let elem = document.elementFromPoint(x, y);
        
      
      
      Por ejemplo, el siguiente código resalta y muestra la etiqueta del elemento que ahora se encuentra en medio de la ventana:

      
        
        
          
            
          
          
            
          
        
        
          let centerX = document.documentElement.clientWidth / 2;
let centerY = document.documentElement.clientHeight / 2;

let elem = document.elementFromPoint(centerX, centerY);

elem.style.background = "red";
alert(elem.tagName);
        
      
      
      Debido a que utiliza las coordenadas de la ventana, el elemento puede ser diferente dependiendo de la posición actual del scroll.

            Para coordenadas fuera de la ventana, el elementFromPoint devuelve null
            El método document.elementFromPoint(x,y) solo funciona si (x,y) se encuentra dentro del área visible.
Si alguna de las coordenadas es negativa o excede el ancho o alto de la ventana entonces devolverá null.
Aquí hay un error típico que podría ocurrir si no nos aseguramos de ello:

      
        
        
          let elem = document.elementFromPoint(x, y);
// si las coordenadas sobrepasan la ventana entonces elem = null
elem.style.background = ''; // ¡Error!
        
      
      
      
Usándolas para posicionamiento “fijo”La mayoría del tiempo necesitamos coordenadas para posicionar algo.
Para mostrar algo cercano a un elemento podemos usar getBoundingClientRect para obtener sus coordenadas y entonces CSS position junto con left/top (o right/bottom).
Por ejemplo, la función createMessageUnder(elem, html) a continuación nos muestra un mensaje debajo de elem:

      
        
        
          let elem = document.getElementById("coords-show-mark");

function createMessageUnder(elem, html) {
  // Crea un elemento de mensaje
  let message = document.createElement('div');
  // Lo mejor es usar una clase css para el estilo aquí
  message.style.cssText = "position:fixed; color: red";

  // Asignando las coordenadas, no olvides "px"!
  let coords = elem.getBoundingClientRect();

  message.style.left = coords.left + "px";
  message.style.top = coords.bottom + "px";

  message.innerHTML = html;

  return message;
}

// Uso:
// agregarlo por 5 segundos en el documento
let message = createMessageUnder(elem, '¡Hola, mundo!');
document.body.append(message);
setTimeout(() => message.remove(), 5000);
        
      
      
      Pulsa el botón para ejecutarlo:
Botón con el id=“coords-show-mark”, el mensaje aparecerá aquí debajo
El código puede ser modificado para mostrar el mensaje a la izquierda, derecha, abajo, aplicando animaciones con CSS para “desvanecerlo” y así. Es fácil una vez que tenemos todas las coordenadas y medidas del elemento.
Pero nota un detalle importante: cuando la página se desplaza, el mensaje se aleja del botón.
La razón es obvia: el elemento del mensaje se basa en position:fixed, esto lo reubica al mismo lugar en la ventana mientras se desplaza.
Para cambiar esto necesitamos usar las coordenadas basadas en el documento y position:absolute.
Coordenadas del documentoLas coordenadas relativas al documento comienzan en la esquina superior izquierda del documento, no de la ventana.
En CSS las coordenadas de la ventana corresponden a position:fixed mientras que las del documento son similares a position:absolute en la parte superior.
Podemos usar position:absolute y top/left para colocar algo en un lugar determinado del documento, esto lo reubicará ahí mismo durante un desplazamiento de página. Pero primero necesitamos las coordenadas correctas.
No existe un estándar para obtener las coordenadas de un elemento en un documento. Pero es fácil de codificarlo.
Los dos sistemas de coordenadas están relacionados mediante la siguiente fórmula:

pageY = clientY + el alto de la parte vertical desplazada del documento.
pageX = clientX + el ancho de la parte horizontal desplazada del documento.

La función getCoords(elem) toma las coordenadas de la ventana de elem.getBoundingClientRect() y agrega el desplazamiento actual a ellas:

      
        
        
          // obteniendo las coordenadas en el documento del elemento
function getCoords(elem) {
  let box = elem.getBoundingClientRect();

  return {
    top: box.top + window.pageYOffset,
    right: box.right + window.pageXOffset,
    bottom: box.bottom + window.pageYOffset,
    left: box.left + window.pageXOffset
  };
}
        
      
      
      Si el ejemplo anterior se usara con position:absolute entonces el mensaje podría permanecer cerca del elemento durante el desplazamiento.
La función modificada createMessageUnder:

      
        
        
          function createMessageUnder(elem, html) {
  let message = document.createElement('div');
  message.style.cssText = "position:absolute; color: red";

  let coords = getCoords(elem);

  message.style.left = coords.left + "px";
  message.style.top = coords.bottom + "px";

  message.innerHTML = html;

  return message;
}
        
      
      
      ResumenCualquier punto en la página tiene coordenadas:

Relativas a la ventana: elem.getBoundingClientRect().
Relativas al documento: elem.getBoundingClientRect() mas el desplazamiento actual de la página.

Las coordenadas de la ventana son ideales para usarse con position:fixed, y las coordenadas del documento funcionan bien con position:absolute.
Ambos sistemas de coordenadas tienen pros y contras; habrá ocasiones en que ocuparemos una u otra, justamente como con los valores absolute y fixed para position en CSS.
TareasEncuentra las coordenadas del campo en la ventanaimportancia: 5En el siguiente iframe puedes ver un documento con el “campo” verde.
Usa JavaScript para encontrar las coordenadas de las esquinas de la ventana señaladas con las flechas.
Hay una pequeña característica implementada en el documento para conveniencia. Un click en cualquier lugar mostrará las coordenadas ahí.

    
        
      
      
        
      
      
    
  Tu código debe usar el DOM para obtener las coordenadas en la ventana de:

La esquina superior izquierda externa (eso es simple).
La esquina inferior derecha externa (simple también).
La esquina superior izquierda interna (un poco más difícil).
La esquina inferior derecha interna (existen muchas maneras, elige una).

Las coordenadas que tú calcules deben ser iguales a las devueltas por el click del mouse.
P.D. El código también debe funcionar si el elemento tiene otro tamaño o borde, no está ligado a ningún valor fijo.
Abrir un entorno controlado para la tarea.soluciónEsquinas externasEsquinas externasLas esquinas externas son básicamente las que obtenemos de elem.getBoundingClientRect().
Las coordenadas de la esquina superior izquierda answer1 y la esquina inferior derecha answer2:

      
        
        
          let coords = elem.getBoundingClientRect();

let answer1 = [coords.left, coords.top];
let answer2 = [coords.right, coords.bottom];
        
      
      
      Esquina interna y superior izquierdaEsquina interna y superior izquierdaEsta es diferente a la esquina externa por el ancho del borde. Una manera confiable de obtener la distancia es usando clientLeft/clientTop:

      
        
        
          let answer3 = [coords.left + field.clientLeft, coords.top + field.clientTop];
        
      
      
      Esquina interna e inferior derechaEsquina interna e inferior derechaEn nuestro caso necesitamos sustraer la medida del borde de las coordenadas externas.
Podemos usar la forma de CSS:

      
        
        
          let answer4 = [
  coords.right - parseInt(getComputedStyle(field).borderRightWidth),
  coords.bottom - parseInt(getComputedStyle(field).borderBottomWidth)
];
        
      
      
      Una forma alternativa puede ser agregando clientWidth/clientHeight a las coordenadas de la esquina superior izquierda. Probablemente sea incluso mejor:

      
        
        
          let answer4 = [
  coords.left + elem.clientLeft + elem.clientWidth,
  coords.top + elem.clientTop + elem.clientHeight
];
        
      
      
      Abrir la solución en un entorno controlado.Muestra una nota cercana al elementoimportancia: 5Crea una función positionAt(anchor, position, elem) que posicione elem, dependiendo de la proximidad de position al elemento anchor.
position debe ser un string con alguno de estos 3 valores:

"top" – posiciona elem encima de anchor
"right" – posiciona elem inmediatamente a la derecha de anchor
"bottom" – posiciona elem debajo de anchor

Esto será usado dentro de la función showNote(anchor, position, html), proveída en el código fuente de la tarea, que crea un elemento “note” con el html y lo muestra en el lugar proporcionado por position cercano a anchor.
Aquí está el demo de las notas:

    
        
      
      
    
  Abrir un entorno controlado para la tarea.soluciónEn esta tarea sólo necesitamos calcular exactamente las coordenadas. Mira el código para más detalles.
Ten en cuenta: los elementos deben estar en el documento para leer offsetHeight y otras propiedades.
Un elemento oculto (display:none) o fuera del documento no tiene medidas.
Abrir la solución en un entorno controlado.Muestra una nota cercana al elemento (absolute)importancia: 5Modifica la solución de la tarea previa de manera que la nota use position:absolute en lugar de position:fixed.
Esto evitará que se “aleje” del elemento cuando se desplace la página.
Toma la solución de la tarea anterior como punto de partida. Para testear el scroll, agrega el estilo <body style="height: 2000px">.
soluciónLa solución realmente es muy simple:

Usa position:absolute con CSS en lugar de position:fixed para .note.
Usa la función getCoords() del capítulo Coordenadas para obtener las coordenadas relativas al documento.

Abrir la solución en un entorno controlado.Posiciona la nota adentro (absolute)importancia: 5Ampliando a la tarea anterior Muestra una nota cercana al elemento (absolute): enséñale a la función positionAt(anchor, position, elem) a insertar elem dentro de anchor.
Los nuevos valores para posición son position:

top-out, right-out, bottom-out – funciona ingual que antes, inserta el elem encima, a la derecha o debajo de anchor.
top-in, right-in, bottom-in – inserta el elem dentro del anchor: lo fija en la parte superior, derecha o inferior del borde.

Por ejemplo:

      
        
        
          // Muestra la nota encima de la cita textual
positionAt(blockquote, "top-out", note);

// Muestra la nota dentro de la cita textual en la parte superior
positionAt(blockquote, "top-in", note);
        
      
      
      El resultado:

    
        
      
      
    
  Para el código fuente toma la solución de la tarea Muestra una nota cercana al elemento (absolute).
soluciónAbrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/coordinates" 
},
{
	"docs_id": "107",
	"name": "",
	"description": "Aquí aprenderemos JavaScript, empezando desde cero y llegaremos hasta conceptos avanzados como POO.",
	"content": "Parte 1El lenguaje JavaScriptParte 2El navegador: Documentos, Eventos e InterfacesParte 3Artículos adicionalesEl lenguaje JavaScriptAquí aprenderemos JavaScript, empezando desde cero y llegaremos hasta conceptos avanzados como POO.
Nos concentraremos en el lenguaje mismo con el mínimo de notas específicas del entorno.
Una introducciónUna introducción a JavaScriptManuales y especificacionesEditores de CódigoConsola de desarrolladorFundamentos de JavaScript¡Hola, mundo!Estructura del códigoEl modo moderno, "use strict"VariablesTipos de datosInteracción: alert, prompt, confirmConversiones de TiposOperadores básicos, matemáticasComparacionesEjecución condicional: if, '?'Operadores LógicosOperador Nullish Coalescing '??'Bucles: while y forLa sentencia "switch"FuncionesExpresiones de funciónFunciones Flecha, lo básicoEspeciales JavaScriptMás…Calidad del códigoDebugging en el navegadorEstilo de codificaciónComentariosCódigo ninjaTest automatizados con MochaPolyfills y transpiladoresObjetos: lo básicoObjetosReferencias de objetos y copiaRecolección de basuraMétodos del objeto, "this"Constructor, operador "new"Encadenamiento opcional '?.'Tipo SymbolConversión de objeto a valor primitivoTipos de datosMétodos en tipos primitivosNúmerosStringsArraysMétodos de arraysIterablesMap y SetWeakMap y WeakSetObject.keys, values, entriesAsignación desestructuranteFecha y HoraMétodos JSON, toJSONMás…Trabajo avanzado con funcionesRecursión y pilaParámetros Rest y operador SpreadÁmbito de Variable y el concepto "closure"La vieja "var"Objeto GlobalFunción como objeto, NFELa sintaxis "new Function"Planificación: setTimeout y setIntervalDecoradores y redirecciones, call/applyFunción bind: vinculación de funcionesFunciones de flecha revisadasMás…Configuración de las propiedades de objetosIndicadores y descriptores de propiedad"Getters" y "setters" de propiedadPrototipos y herenciaHerencia prototípicaF.prototypePrototipos nativosMétodos prototipo, objetos sin __proto__ClasesSintaxis básica de `class`Herencia de clasePropiedades y métodos estáticos.Propiedades y métodos privados y protegidos.Ampliación de clases integradasComprobación de clase: "instanceof"Los MixinsManejo de erroresManejo de errores, "try...catch"Errores personalizados, extendiendo ErrorPromesas y async/awaitIntroducción: callbacksPromesaEncadenamiento de promesasManejo de errores con promesasPromise APIPromisificaciónMicrotareas (Microtasks)Async/awaitGeneradores e iteración avanzadaGeneradoresIteradores y generadores asíncronosMódulosMódulos, introducciónExport e ImportImportaciones dinámicasTemas diversosProxy y ReflectEval: ejecutando una cadena de códigoCurrificaciónTipo de ReferenciaBigIntEl navegador: Documentos, Eventos e InterfacesAprenderemos a manejar la página del navegador: agregar elementos, manipular su tamaño y posición, crear interfaces dinámicamente e interactuar con el visitante.
DocumentoEntorno del navegador, especificacionesÁrbol del Modelo de Objetos del Documento (DOM)Recorriendo el DOMBuscar: getElement*, querySelector*Propiedades del nodo: tipo, etiqueta y contenidoAtributos y propiedadesModificando el documentoEstilos y clasesTamaño de elementos y desplazamientoTamaño de ventana y desplazamientoCoordenadasMás…Introducción a los eventosIntroducción a los eventos en el navegadorPropagación y capturaDelegación de eventosAcciones predeterminadas del navegadorEnvío de eventos personalizadosEventos en la UIEventos del MouseMoviendo el mouse: mouseover/out, mouseenter/leaveArrastrar y Soltar con eventos del ratónEventos de punteroTeclado: keydown y keyupDesplazamientoFormularios y controlesPropiedades y Métodos de FormulariosEnfocado: enfoque/desenfoqueEventos: change, input, cut, copy, pasteFormularios: evento y método submitEl documento y carga de recursosPágina: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferCarga de recursos: onload y onerrorTemas diversosMutation observerSelection y RangeLoop de eventos: microtareas y macrotareasArtículos adicionalesLista de temas adicionales que supone que ha cubierto las dos primeras partes del tutorial. Aquí no hay una jerarquía clara, puede leer los artículos en el orden que desee.Marcos y ventanasVentanas emergentes y métodos de ventanaComunicación entre ventanasEl ataque de secuestro de clicsDatos binarios y archivosArrayBuffer, arrays binariosTextDecoder y TextEncoderBlobFile y FileReaderSolicitudes de redFetchFormDataFetch: Progreso de la descargaFetch: AbortFetch: Cross-Origin RequestsFetch APIObjetos URLXMLHttpRequestCarga de archivos reanudableSondeo largoWebSocketEventos enviados por el servidorMás…Almacenando datos en el navegadorCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimacionesCurva de BézierAnimaciones CSSAnimaciones JavaScriptComponentes WebDesde la altura orbitalElementos personalizadosShadow DOMElemento templateShadow DOM slots, composiciónEstilo Shadow DOMShadow DOM y eventosExpresiones RegularesPatrones y banderas (flags)Clases de caracteresUnicode: bandera "u" y clase \p{...}Anclas: inicio ^ y final $ de cadenaModo multilínea de anclas ^ $, bandera "m"Límite de palabra: \bEscapando, caracteres especialesConjuntos y rangos [...]Cuantificadores +, *, ? y {n}Cuantificadores codiciosos y perezososGrupos de capturaReferencias inversas en patrones: \N y \k<nombre>Alternancia (O) |Lookahead y lookbehind (revisar delante/detrás)Backtracking catastróficoIndicador adhesivo “y”, buscando en una posición.Métodos de RegExp y StringMás…{
  "@context": "http://schema.org",
  "@type": "WebSite",
  "url": "https://es.javascript.info/",
  "potentialAction": {
    "@type": "SearchAction",
    "target": "https://es.javascript.info/search?query={search_term_string}",
    "query-input": "required name=search_term_string"
  }
}",
	"url": "https://es.javascript.info#" 
},
{
	"docs_id": "108",
	"name": "Introducción a los eventos en el navegador",
	"description": "Un evento es una señal de que algo ocurrió. Todos los nodos del DOM generan dichas señales (pero los eventos no est{an limitados sólo al DOM).",
	"content": "Un evento es una señal de que algo ocurrió. Todos los nodos del DOM generan dichas señales (pero los eventos no est{an limitados sólo al DOM).
Aquí hay una lista con los eventos del DOM más utilizados, solo para echar un vistazo:
Eventos del mouse:

click – cuando el mouse hace click sobre un elemento (los dispositivos touch lo generan con un toque).
contextmenu – cuando el mouse hace click derecho sobre un elemento.
mouseover / mouseout – cuando el cursor del mouse ingresa/abandona un elemento.
mousedown / mouseup – cuando el botón del mouse es presionado/soltado sobre un elemento.
mousemove – cuando el mouse se mueve.

Eventos del teclado:

keydown / keyup – cuando se presiona/suelta una tecla.

Eventos del elemento form:

submit – cuando el visitante envía un <form>.
focus –  cuando el visitante se centra sobre un elemento, por ejemplo un <input>.

Eventos del documento:

DOMContentLoaded --cuando el HTML es cargado y procesado, el DOM está completamente construido

Eventos del CSS:

transitionend – cuando una animación CSS concluye.

Hay muchos más eventos. Entraremos en detalle con eventos en particular en los siguientes capítulos.
Controladores de eventosPara reaccionar con eventos podemos asignar un handler (controlador) el cual es una función que se ejecuta en caso de un evento.
Los handlers son una forma de ejecutar código JavaScript en caso de acciones por parte del usuario.
Hay muchas maneras de asignar un handler. Vamos a verlas empezando por las más simples.
Atributo HTMLUn handler puede ser establecido en el HTML con un atributo llamado on<event>.
Por ejemplo, para asignar un handler click para un input podemos usar onclick, como aquí:

      
        
        
          
            
          
          
            
          
        
        
          <input value="Click me" onclick="alert('Click!')" type="button">
        
      
      
      Al hacer click, el código dentro de onclick se ejecuta.
Toma en cuenta que dentro de onclick usamos comillas simples, porque el atributo en sí va entre comillas dobles. Si olvidamos que el código está dentro del atributo y usamos comillas dobles dentro, así:  onclick="alert("Click!")", no funcionará correctamente.
Un atributo HTML no es un lugar conveniente para escribir un motón de código, así que mejor creamos una función JavaScript y la llamamos allí.
Aquí un click ejecuta la función  countRabbits():

      
        
        
          <script>
  function countRabbits() {
    for(let i=1; i<=3; i++) {
      alert("Conejo número " + i);
    }
  }
</script>

<input type="button" onclick="countRabbits()" value="¡Cuenta los conejos!">
        
      
      
          
        
      Como ya sabemos, los nombres de los atributos HTML no distinguen entre mayúsculas y minúsculas, entonces ONCLICK funciona bien al igual que onClick y onCLICK… Pero usualmente los atributos van con minúsculas: onclick.
Propiedad del DOMPodemos asignar un handler usando una propiedad del DOM on<event>.
Por ejemplo, elem.onclick:

      
        
        
          <input id="elem" type="button" value="Haz click en mí">
<script>
  elem.onclick = function() {
    alert('¡Gracias!');
  };
</script>
        
      
      
          
        
      Si el handler es asignado usando un atributo HTML entonces el navegador lo lee, crea una nueva función desde el contenido del atributo y lo escribe en la propiedad del DOM.
Esta forma en realidad es la misma que ya habíamos visto antes.
Estás dos piezas de código funcionan igual:


Solo HTML:

      
        
        
          <input type="button" onclick="alert('¡Click!')" value="Botón">
        
      
      
          
        
      

HTML + JS:

      
        
        
          <input type="button" id="button" value="Botón">
<script>
  button.onclick = function() {
    alert('¡Click!');
  };
</script>
        
      
      
          
        
      

En el primer ejemplo el atributo HTML es usado para inicializar el button.onclick. Mientras que en el segundo ejemplo se usa el script, esa es toda la diferencia.
Como solo hay una propiedad onclick, no podemos asignar más de un handler.
En el siguiente ejemplo se agrega un handler con JavaScript que sobrescribe el handler existente:

      
        
        
          
            
          
          
            
          
        
        
          <input type="button" id="elem" onclick="alert('Antes')" value="¡Haz click en mí!">
<script>
  elem.onclick = function() { // sobrescribe el handler existente
    alert('Después'); // solo se mostrará este
  };
</script>
        
      
      
          
        
      Para eliminar un handler, asigna elem.onclick = null.
Accediendo al elemento: thisEl valor de this dentro de un handler es el elemento. El cuál tiene el handler dentro.
En el siguiente código el button muestra su contenido usando this.innerHTML:

      
        
        
          <button onclick="alert(this.innerHTML)">Haz click en mí</button>
        
      
      
          
        
      Posibles erroresSi estás empezando a trabajar con eventos, por favor, nota algunas sutilezas.
Nosotros podemos establecer una función existente como un handler:

      
        
        
          function sayThanks() {
  alert('¡Gracias!');
}

elem.onclick = sayThanks;
        
      
      
      Pero ten cuidado: la función debe ser asignada como sayThanks, no sayThanks().

      
        
        
          // correcto
button.onclick = sayThanks;

// incorrecto
button.onclick = sayThanks();
        
      
      
      Si agregamos paréntesis, sayThanks() se convierte en una llamada de función. En ese caso la última linea toma el resultado de la ejecución de la función, que es undefined (ya que la función no devuelve nada), y lo asigna a onclick. Esto no funciona.
…Por otro lado, en el markup necesitamos los paréntesis:

      
        
        
          <input type="button" id="button" onclick="sayThanks()">
        
      
      
      La diferencia es fácil de explicar. Cuando el navegador lee el atributo crea una función handler con cuerpo a partir del contenido del atributo.
Por lo que el markup genera esta propiedad:

      
        
        
          button.onclick = function() {
  sayThanks(); // <-- el contenido del atributo va aquí
};
        
      
      
      No uses setAttribute para handlers.
Tal llamada no funcionará:

      
        
        
          
            
          
          
            
          
        
        
          // un click sobre <body> generará errores,
// debido a que los atributos siempre son strings, la función se convierte en un string
document.body.setAttribute('onclick', function() { alert(1) });
        
      
      
      Las mayúsculas en las propiedades DOM importan.
Asignar un handler a elem.onclick, en lugar de elem.ONCLICK, ya que las propiedades DOM son sensibles a mayúsculas.
addEventListenerEl problema fundamental de las formas ya mencionadas para asignar handlers es que no podemos asignar multiples handlers a un solo evento.
Digamos que una parte de nuestro código quiere resaltar un botón al hacer click, y otra quiere mostrar un mensaje en el mismo click.
Nos gustaría asignar dos handlers de eventos para eso. Pero una nueva propiedad DOM sobrescribirá la que ya existe:

      
        
        
          input.onclick = function() { alert(1); }
// ...
input.onclick = function() { alert(2); } // reemplaza el handler anterior handler
        
      
      
      Los desarrolladores de los estándares de la web entendieron eso hace mucho tiempo y sugirieron una forma alternativa de administrar los handlers utilizando los métodos especiales addEventListener and removeEventListener. Estos están libres de ese problema.
La sintaxis para agregar un handler:

      
        
        
          element.addEventListener(event, handler, [options]);
        
      
      
      
event
Nombre del evento, por ejemplo: "click".
handler
La función handler.
options
Un objeto adicional, opcional, con las propiedades:

once: si es true entonces el listener se remueve automáticamente después de activarlo.
capture: la fase en la que se controla el evento, que será cubierta en el capítulo Propagación y captura. Por razones históricas, options también puede ser false/true, lo que es igual a {capture: false/true}.
passive: si es true entonces el handler no llamará a preventDefault(), esto lo explicaremos más adelante en Acciones predeterminadas del navegador.



Para remover el handler, usa removeEventListener:

      
        
        
          element.removeEventListener(event, handler, [options]);
        
      
      
      
            Remover requiere la misma función
            Para remover un handler deberemos pasar exactamente la misma función que asignamos.
Esto no funciona:

      
        
        
          elem.addEventListener( "click" , () => alert('¡Gracias!'));
// ....
elem.removeEventListener( "click", () => alert('¡Gracias!'));
        
      
      
      El handler no será removido porque removeEventListener obtiene otra función, con el mismo código, pero eso no importa, ya que es un objeto de función diferente.
Aquí está la manera correcta:

      
        
        
          function handler() {
  alert( '¡Gracias!' );
}

input.addEventListener("click", handler);
// ....
input.removeEventListener("click", handler);
        
      
      
      Por favor nota que si no almacenamos la función en una variable entonces no podremos removerla. No hay forma de “volver a leer” los handlers asignados por addEventListener.

Múltiples llamadas a addEventListenerpermiten agregar múltiples handlers, como este:

      
        
        
          
            
          
          
            
          
        
        
          <input id="elem" type="button" value="Haz click en mí"/>

<script>
  function handler1() {
    alert('¡Gracias!');
  };

  function handler2() {
    alert('¡Gracias de nuevo!');
  }

  elem.onclick = () => alert("Hola");
  elem.addEventListener("click", handler1); // Gracias!
  elem.addEventListener("click", handler2); // Gracias de nuevo!
</script>
        
      
      
      Como podemos ver en el ejemplo anterior, podemos establecer handlers tanto usando un propiedad DOM como addEventListener juntos. Pero por lo general solo usamos una de esas maneras.

            Para algunos eventos, los handlers solo funcionan con addEventListener
            Hay eventos que no pueden ser asignados por medio de una propiedad del DOM. Solamente con addEventListener.
Por ejemplo, el evento DOMContentLoaded, que se activa cuando el documento está cargado y el DOM está construido.

      
        
        
          // nunca se ejecutará
document.onDOMContentLoaded = function() {
  alert("DOM construido");
};
        
      
      
      
      
        
        
          // Así sí funciona
document.addEventListener("DOMContentLoaded", function() {
  alert("DOM construido");
});
        
      
      
      Por lo que addEventListener es más universal. Aún así, tales eventos son una excepción más que la regla.

Objeto del eventoPero para manejar correctamente un evento nos gustaría saber todavía más acerca de lo que está pasando. No solo si fue un “click” o un “teclazo”, sino ¿cuáles eran coordenadas del cursor o qué tecla fue oprimida? Y así.
Cuando un evento ocurre, el navegador crea un objeto del evento que coloca los detalles dentro y los pasa como un argumento al handler.
Aquí hay un ejemplo para obtener las coordenadas del cursor a partir del objeto del evento:

      
        
        
          
            
          
          
            
          
        
        
          <input type="button" value="¡Haz click en mí!" id="elem">

<script>
  elem.onclick = function(event) {
    // muestra el tipo de evento, el elemento y las coordenadas del click
    alert(event.type + " en el " + event.currentTarget);
    alert("Coordenadas: " + event.clientX + ":" + event.clientY);
  };
</script>
        
      
      
      Algunas propiedades del objeto event:

event.type
Tipo de evento, en este caso fue "click".
event.currentTarget
Elemento que maneja el evento. Lo que exactamente igual a this, a menos que el handler sea una función de flecha o su this esté vinculado a otra cosa, entonces podemos obtener el elemento desde event.currentTarget.
event.clientX / event.clientY
Coordenadas del cursor relativas a la ventana, para eventos de cursor.

Hay más propiedades. La mayoría dependen del tipo de evento: los eventos del teclado tienen algunas propiedades establecidas, las de cursor otras, las estudiaremos después cuando lleguemos a los detalles de diferentes eventos.

            El objeto del evento también está disponible para handlers HTML
            Si asignamos un handler en HTML también podemos usar el objeto event, así:

      
        
        
          <input type="button" onclick="alert(event.type)" value="Event type">
        
      
      
          
        
      Esto es posible porque cuando el navegador lee el atributo, crea un handler como este:  function(event) { alert(event.type) }. Lo que significa que el primer argumento es llamado "event" y el cuerpo es tomado del atributo.

Objetos handlers: handleEventPodemos asignar no solo una función, sino un objeto como handler del evento usando addEventListener. Cuando el evento ocurre, el método handleEvent es llamado.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <button id="elem">Haz click en mí</button>

<script>
  let obj = {
    handleEvent(event) {
      alert(event.type + " en " + event.currentTarget);
    }
  };

  elem.addEventListener('click', obj);
</script>
        
      
      
      Como podemos ver, cuando addEventListener recibe como handler a un objeto, llama a obj.handleEvent(event) en caso de un evento.
También podríamos usar una clase para ello:

      
        
        
          
            
          
          
            
          
        
        
          <button id="elem">Haz click en mí</button>

<script>
  class Menu {
    handleEvent(event) {
      switch(event.type) {
        case 'mousedown':
          elem.innerHTML = "Botón del mouse presionado";
          break;
        case 'mouseup':
          elem.innerHTML += "...y soltado.";
          break;
      }
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>
        
      
      
      Aquí el mismo objeto maneja ambos eventos. Nota que necesitamos configurar explícitamente los eventos a escuchar usando addEventListener. El objeto menu solo obtiene mousedown y mouseup aquí, no hay ningún otro tipo de eventos.
El método handleEvent no tiene que hacer todo el trabajo por sí solo. En su lugar puede llamar a otros métodos específicos de eventos, como este:

      
        
        
          
            
          
          
            
          
        
        
          <button id="elem">Haz click en mí</button>

<script>
  class Menu {
    handleEvent(event) {
      // mousedown -> onMousedown
      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);
      this[method](event);
    }

    onMousedown() {
      elem.innerHTML = "Botón del mouse presionado";
    }

    onMouseup() {
      elem.innerHTML += "...y soltado.";
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>
        
      
      
      Ahora los handlers del evento están claramente separados, lo que puede ser más fácil de mantener.
ResumenHay tres formas de asignar handlers:

Atributos HTML: onclick="...".
Propiedades del DOM: elem.onclick = function.
Métodos: elem.addEventListener(event, handler[, phase]) para agregar ó removeEventListener para remover.

Los atributos HTML se usan con moderación, porque JavaScript en medio de una etiqueta HTML luce un poco extraño y ajeno. Además no podemos escribir montones de código ahí.
Las propiedades del DOM son buenas para usar, pero no podemos asignar más de un handler a un evento en particular. En la mayoría de casos esta limitación no es apremiante.
La última forma es la más flexible, pero también es la más larga para escribir. Hay pocos eventos que solo funcionan con ésta, por ejemplo transitionend y DOMContentLoaded (que veremos después). Además addEventListener soporta objetos como handlers de eventos. En este caso handleEvent es llamado en caso del evento.
No importa como asignes el handler, este obtiene un objeto como primer argumento. Este objeto contiene los detalles sobre lo que pasó.
Vamos a aprender más sobre eventos en general y sobre diferentes tipos de eventos en los siguientes capítulos.
TareasOcultar con un clickimportancia: 5Agrega JavaScript al button para hacer que <div id="text"> desaparezca al clickearlo.
El demo:

    
    
  Abrir un entorno controlado para la tarea.soluciónAbrir la solución en un entorno controlado.Ocultarseimportancia: 5Crea un botón que se oculte a sí mismo al darle un click.
Así:

soluciónPodemos usar this en el handler para referenciar “al propio elemento” aquí:

      
        
        
          
            
          
          
            
          
        
        
          <input type="button" onclick="this.hidden=true" value="Click para ocultar">
        
      
      
      ¿Qué handlers se ejecutan?importancia: 5Hay un botón en la variable. No hay handlers en él.
¿Qué handlers se ejecutan con el click después del siguiente código? ¿Qué alertas se muestran?

      
        
        
          button.addEventListener("click", () => alert("1"));

button.removeEventListener("click", () => alert("1"));

button.onclick = () => alert(2);
        
      
      
      soluciónLa respuesta: 1 y 2.
El primer handler se activa porque no es removido por removeEventListener. Para remover el handler necesitamos pasar exactamente la función que fue asignada. Y en el código se pasa una función que luce igual pero es otra función.
Para remover un objeto de función necesitamos almacenar una referencia a él, así:

      
        
        
          function handler() {
  alert(1);
}

button.addEventListener("click", handler);
button.removeEventListener("click", handler);
        
      
      
      El handler button.onclick funciona independientemente y en adición a addEventListener.
Mueve el balón por el campoimportancia: 5Mueve el balón por el campo con un click. Así:

    
        
      
      
    
  Requerimientos:

El centro del balón debe quedar exactamente bajo el cursor al hacer click (sin atravesar el borde del campo si es posible).
Las animaciones CSS son bienvenidas.
El balón no debe cruzar los límites del campo.
Cuando la página se desplace nada se debe romper.

Notas:

El código también debe funcionar con medidas diferentes de campo y balón, no debe estar asociado a ningún valor fijo.
Usa las propiedades event.clientX/event.clientY para las coordenadas del click.

Abrir un entorno controlado para la tarea.soluciónPrimero necesitamos elegir un método para posicionar el balón.
No podemos usar position:fixed para ello, porque al desplazar la página se movería el balón del campo.
Así que deberíamos usar position:absolute y, para que el posicionamiento sea realmente sólido, hacer que field sea posicione a sí mismo.
Entonces el balón se posicionará en relación al campo:

      
        
        
          #field {
  width: 200px;
  height: 150px;
  position: relative;
}

#ball {
  position: absolute;
  left: 0; /* relativo al predecesor más cercano (field) */
  top: 0;
  transition: 1s all; /* Animación CSS para que left/top hagan al balón volar  */
}
        
      
      
      Lo siguiente es asignar el ball.style.left/top correcto. Ahora contienen coordenadas relativas al campo.
Aquí está la imagen:

      
      
        
      
      Tenemos event.clientX/clientY, las cuales son las coordenadas del click relativas a la ventana.
Para obtener la coordenada left del click relativa al campo necesitamos restar el limite izquierdo del campo y el ancho del borde:

      
        
        
          let left = event.clientX - fieldCoords.left - field.clientLeft;
        
      
      
      Normalmente ball.style.left significa el “borde izquierdo del elemento” (el balón). Por lo que si asignamos ese left, entonces el borde del balón, no el centro, es el que se encontraría debajo del cursor del mouse.
Necesitamos mover la mitad del ancho del balón a la izquierda y la mitad del alto hacia arriba para que quede en el centro.
Por lo que el left final debería ser:

      
        
        
          let left = event.clientX - fieldCoords.left - field.clientLeft - ball.offsetWidth/2;
        
      
      
      La coordenada vertical es calculada usando la misma lógica.
Por favor, nota que el ancho/alto del balón se debe conocer al momento que accedemos a ball.offsetWidth. Se debe especificar en HTML o CSS.
Abrir la solución en un entorno controlado.Crear un menú deslizanteimportancia: 5Crea un menú que se abra/colapse al hacer click:

    
    
  P.D. El HTML/CSS del documento fuente se debe modificar.
Abrir un entorno controlado para la tarea.soluciónHTML/CSSHTML/CSSPrimero hay que crear el HTML y CSS.
Un menú es un componente gráfico independiente en la página, por lo que es mejor colocarlo en un solo elemento del DOM.
Una lista de elementos del menú se puede diseñar como una lista ul/li.
Aquí está la estructura de ejemplo:

      
        
        
          <div class="menu">
  <span class="title">Sweeties (click me)!</span>
  <ul>
    <li>Cake</li>
    <li>Donut</li>
    <li>Honey</li>
  </ul>
</div>
        
      
      
      Usamos <span> para el título, porque <div> tiene un display:block implícito en él, y va a ocupar 100% del ancho horizontal.
Así:

      
        
        
          <div style="border: solid red 1px" onclick="alert(1)">Sweeties (click me)!</div>
        
      
      
          
        
      Entonces si establecemos onclick en él, detectará los clics a la derecha del texto.
Como <span> tiene un display: inline implícito, ocupa exactamente el lugar suficiente para que quepa todo el texto:

      
        
        
          <span style="border: solid red 1px" onclick="alert(1)">Sweeties (click me)!</span>
        
      
      
          
        
      Alternar el menúAlternar el menúAlternar el menú debería cambiar la flecha y mostrar/ocultar la lista del menú.
Todos estos cambios son perfectamente controlados con CSS. En JavaScript debemos etiquetar el estado actual del menú agregando/eliminando la clase .open.
Sin él, el menú se cerrará:

      
        
        
          .menu ul {
  margin: 0;
  list-style: none;
  padding-left: 20px;
  display: none;
}

.menu .title::before {
  content: '▶ ';
  font-size: 80%;
  color: green;
}
        
      
      
      …Y con .open la flecha cambia y aparece la lista:

      
        
        
          .menu.open .title::before {
  content: '▼ ';
}

.menu.open ul {
  display: block;
}
        
      
      
      Abrir la solución en un entorno controlado.Agregar un botón de cierreimportancia: 5Hay una lista de mensajes.
Usa JavaScript para agregar un botón de cierre en la esquina superior derecha de cada mensaje.
El resultado debería verse algo así:

    
    
  Abrir un entorno controlado para la tarea.soluciónPara agregar el botón podemos usar cualquiera de las opciones position:absolute (y hacer el panel position:relative) o float:right. El float:right tiene la ventaja de que el botón no se encima con el texto, pero  position:absolute da más libertad. Entonces la elección es tuya.
Luego, para cada panel, el código puede ser así:

      
        
        
          pane.insertAdjacentHTML("afterbegin", '<button class="remove-button">[x]</button>');
        
      
      
      Luego el <button> se convierte en pane.firstChild, por lo que podemos agregarle un controlador como este:

      
        
        
          pane.firstChild.onclick = () => pane.remove();
        
      
      
      Abrir la solución en un entorno controlado.Carruselimportancia: 4Crea un “carrusel”: una cinta de imágenes que se puede desplazar haciendo clic en las flechas.

    
    
  Más adelante podemos agregarle más funciones: desplazamiento infinito, carga dinámica, etc.
P.D. Para esta tarea, la estructura HTML / CSS es en realidad el 90% de la solución.
Abrir un entorno controlado para la tarea.soluciónLa cinta de imágenes se puede representar como una lista ul/li de imágenes <img>.
Normalmente dicha cinta es ancha, pero colocamos un tamaño fijo <div> alrededor para “cortarla”, de modo que solo una parte de la cinta sea visible:

      
      
        
      
      Para que la lista se muestre horizontalmente debemos aplicar las propiedades CSS correctas para <li>, como display: inline-block.
Para <img> también deberíamos ajustar display, ya que es inline por default. Hay espacio adicional reservado debajo de los “letter tails”, por lo que podemos usar display:block para eliminarlo.
Para hacer el desplazamiento, podemos cambiar <ul>. Hay muchas formas de hacerlo, por ejemplo, cambiando margin-left o (para mejor rendimiento) usando  transform: translateX():

      
      
        
      
      El <div> exterior tiene un ancho fijo, por lo que se cortan las imágenes “extra”.
Todo el carrusel es un “componente gráfico” autónomo en la página, por lo que será mejor que lo envuelva en un solo elemento <div class="carousel"> y le apliquemos estilo.
Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/introduction-browser-events" 
},
{
	"docs_id": "109",
	"name": "Propagación y captura",
	"description": "Vamos a empezar con un ejemplo.",
	"content": "Vamos a empezar con un ejemplo.
Este manejador está asignado a <div>, pero también se ejecuta si haces clic a cualquier elemento anidado como <em> ó <code>:

      
        
        
          <div onclick="alert('¡El manejador!')">
  <em>Si haces clic en<code>EM</code>, el manejador en <code>DIV</code> es ejecutado.</em>
</div>
        
      
      
          
        
      ¿No es un poco extraño? ¿Por qué el manejador en <div> es ejecutado, si el clic fue hecho en <em>?
PropagaciónEl principio de propagación es simple.
Cuando un evento ocurre en un elemento, este primero ejecuta los manejadores que tiene asignados, luego los manejadores de su padre, y así hasta otros ancestros.
Digamos que tenemos 3 elementos anidados FORM > DIV > P con un manejador en cada uno de ellos:

      
        
        
          
            
          
          
            
          
        
        
          <style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
        
      
      
          
        
      Un clic en el elemento del interior <p> primero ejecuta onclick:

En ese <p>.
Luego en el <div> de arriba.
Luego en el <form> de más arriba.
Y así sucesivamente hasta el objeto document.


      
      
        
      
      Así si hacemos clic en <p>, entonces veremos 3 alertas: p → div → form.
Este proceso se conoce como “propagación” porque los eventos “se propagan” desde el elemento más al interior, a través de los padres, como una burbuja en el agua.

            Casi todos los elementos se propagan.
            La palabra clave en esta frase es “casi”.
Por ejemplo, un evento focus no se propaga. Hay otros ejemplos también, los veremos. Pero aún así, esta es la excepción a la regla, la mayoría de eventos sí se propagan.

event.targetUn manejador en un elemento padre siempre puede obtener los detalles sobre dónde realmente ocurrió el evento.
El elemento anidado más profundo que causó el evento es llamado elemento objetivo, accesible como event.target
Nota la diferencia de this (=event.currentTarget):

event.target – es el elemento “objetivo” que inició el evento, no cambia a través de todo el proceso de propagación.
this – es el elemento “actual”, el que tiene un manejador ejecutándose en el momento.

Por ejemplo, si tenemos un solo manejador form.onclick, este puede atrapar todos los clicks dentro del formulario. No importa dónde el clic se hizo, se propaga hasta el <form> y ejecuta el manejador.
En el manejador form.onclick:

this (=event.currentTarget) es el elemento <form>, porque el manejador se ejecutó en él.
event.target es el elemento actual dentro de el formulario al que se le hizo clic.

Mira esto:
Resultadoscript.jsexample.cssindex.htmlform.onclick = function(event) {
  event.target.style.backgroundColor = 'yellow';

  // chrome needs some time to paint yellow
  setTimeout(() => {
    alert("target = " + event.target.tagName + ", this=" + this.tagName);
    event.target.style.backgroundColor = ''
  }, 0);
};form {
  background-color: green;
  position: relative;
  width: 150px;
  height: 150px;
  text-align: center;
  cursor: pointer;
}

div {
  background-color: blue;
  position: absolute;
  top: 25px;
  left: 25px;
  width: 100px;
  height: 100px;
}

p {
  background-color: red;
  position: absolute;
  top: 25px;
  left: 25px;
  width: 50px;
  height: 50px;
  line-height: 50px;
  margin: 0;
}

body {
  line-height: 25px;
  font-size: 16px;
}<!DOCTYPE HTML>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="example.css">
</head>

<body>
  Un clic muestra ambos, el <code>event.target</code> y <code>this</code> para comparar:

  <form id="form">FORM
    <div>DIV
      <p>P</p>
    </div>
  </form>

  <script src="script.js"></script>
</body>
</html>Es posible que event.target sea igual a this: ocurre cuando el clic se hace directamente en el elemento <form>.
Detener la propagaciónUna propagación de evento empieza desde el elemento objetivo hacia arriba. Normalmente este continúa hasta <html> y luego hacia el objeto document, algunos eventos incluso alcanzan window, llamando a todos los manejadores en el camino.
Pero cualquier manejador podría decidir que el evento se ha procesado por completo y detener su propagación.
El método para esto es event.stopPropagation().
Por ejemplo, aquí body.onclick no funciona si haces clic en <button>:

      
        
        
          
            
          
          
            
          
        
        
          <body onclick="alert(`No se propagó hasta aquí`)">
  <button onclick="event.stopPropagation()">Haz clic</button>
</body>
        
      
      
          
        
      
            event.stopImmediatePropagation()
            Si un elemento tiene múltiples manejadores para un solo evento, aunque uno de ellos detenga la propagación, los demás aún se ejecutarán.
En otras palabras, event.stopPropagation() detiene la propagación hacia arriba, pero todos los manejadores en el elemento actual se ejecutarán.
Para detener la propagación y prevenir que los manejadores del elemento actual se ejecuten, hay un método event.stopImmediatePropagation(). Después de él, ningún otro manejador será ejecutado.


            ¡No detengas la propagación si no es necesario!
            La propagación es conveniente. No la detengas sin una necesidad real, obvia y arquitectónicamente bien pensada.
A veces event.stopPropagation() crea trampas ocultas que luego se convierten en problemas.
Por ejemplo:

Creamos un menú anidado. Cada submenú maneja los clics en sus elementos y ejecuta stopPropagation para que el menu de arriba no se desencadene.
Luego decidimos atrapar los clic en toda la ventana, para seguir el rastro del comportamiento del usuario (donde hacen clic). Algunos sistemas de análisis hacen eso. Usualmente el código usa document.addEventListener('click'…) para atrapar todos los clics.
Nuestro análisis no funcionará sobre el área dónde los clics son detenidos por stopPropagation. Tristemente, tenemos una “zona muerta”.

Usualmente no hay una necesidad real para prevenir la propagación, pero una tarea que aparentemente lo requiera puede ser resuelta por otros medios. Uno de ellos es usar eventos personalizados, cubriremos eso más tarde. También podemos escribir nuestros datos en el objeto event en un manejador y leerlo en otro, para así poder pasar información sobre el proceso de abajo a los manejadores en los padres.

CapturaHay otra fase en el procesamiento de eventos llamada “captura”. Es raro usarla en código real, pero a veces puede ser útil.
El estándar de eventos del DOM describe 3 fases de la propagación de eventos:

Fase de captura – el evento desciende al elemento.
Fase de objetivo – el evento alcanza al elemento.
Fase de propagación – el evento se propaga hacia arriba del elemento.

Aquí está la imagen de un clic en <td> dentro de una tabla, tomada desde la especificación:

      
      
        
      
      Se explica así: por un clic en <td> el evento va primero a través de la cadena de ancestros hacia el elemento (fase de captura), luego alcanza el objetivo y se desencadena ahí (fase de objetivo), y por último va hacia arriba (fase de propagación), ejecutando los manejadores en su camino.
Antes solo hablamos de la propagación porque la fase de captura es raramente usada. Normalmente es invisible a nosotros.
Los manejadores agregados usando la propiedad on<event> ó usando atributos HTML ó addEventListener(event, handler) con dos argumentos no ejecutarán la fase de captura, únicamente ejecutarán la 2da y 3ra fase.
Para atrapar un evento en la fase de captura, necesitamos preparar la opción capture como true en el manejador:

      
        
        
          elem.addEventListener(..., {capture: true})
// o, solo "true" es una forma más corta de {capture: true}
elem.addEventListener(..., true)
        
      
      
      Hay dos posibles valores para la opción capture:

Si es false (por defecto), entonces el manejador es preparado para la fase de propagación.
Si es true, entonces el manejador es preparado para la fase de captura.

Es de notar que mientras formalmente hay 3 fases, la 2da fase (“la fase de objetivo”: el evento alcanzó el elemento) no es manejada de forma separada; los manejadores en ambas fases, la de captura y propagación, se disparan en esa fase.
Veamos ambas fases, captura y propagación, en acción:

      
        
        
          
            
          
          
            
          
        
        
          <style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>FORM
  <div>DIV
    <p>P</p>
  </div>
</form>

<script>
  for(let elem of document.querySelectorAll('*')) {
    elem.addEventListener("click", e => alert(`Captura: ${elem.tagName}`), true);
    elem.addEventListener("click", e => alert(`Propagación: ${elem.tagName}`));
  }
</script>
        
      
      
          
        
      El código prepara manejadores de clic en cada elemento en el documento para ver cuáles están funcionando.
Si haces clic en <p>, verás que la secuencia es:

HTML → BODY → FORM → DIV (fase de captura, el primer detector):
P (fase de objetivo, se dispara dos veces, tan pronto como preparemos los dos detectores: de captura y propagación)
DIV → FORM → BODY → HTML (fase de propagación, el segundo detector).

Hay un propiedad event.eventPhase que nos dice el número de fase en la qué el evento fue capturado. Pero es raramente usada, ya que usualmente lo sabemos en el manejador.

            Para quitar el manejador, removeEventListener necesita la misma fase
            Si nosotros addEventListener(..., true), entonces deberíamos mencionar la misma fase en removeEventListener(..., true) para remover el manejador correctamente.


            Detectores de eventos en el mismo elemento y en la misma fase se ejecutan en el orden de asignación
            Si tenemos múltiples manejadores de eventos en la misma fase, asignados al mismo elemento con addEventListener, se ejecutarán en el orden que fueron creados:

      
        
        
          elem.addEventListener("click", e => alert(1)); // garantizado que se ejecutará primero
elem.addEventListener("click", e => alert(2));
        
      
      
      
ResumenCuando ocurre un evento, el elemento más anidado dónde ocurrió se reconoce como el “elemento objetivo” (event.target).

Luego el evento se mueve hacia abajo desde el documento raíz hacia event.target, llamando a los manejadores en el camino asignados con addEventListener(..., true) (true es una abreviación para {capture: true}).
Luego los manejadores son llamados en el elemento objetivo mismo.
Luego el evento se propaga desde event.target hacia la raíz, llamando a los manejadores que se asignaron usando on<event>, atributos HTML y addEventListener sin el 3er argumento o con el 3er argumento false/{capture:false}.

Cada manejador puede acceder a las propiedades del objeto event:

event.target – el elemento más profundo que originó el evento.
event.currentTarget (=this) – el elemento actual que maneja el evento (el que tiene al manejador en él)
event.eventPhase – la fase actual (captura=1, objetivo=2, propagación=3).

Cualquier manejador de evento puede detener el evento al llamar event.stopPropagation(), pero no es recomendado porque no podemos realmente asegurar que no lo necesitaremos más adelante, quizá para completar diferentes cosas.
La fase de captura raramente es usada, usualmente manejamos los evento en propagación. Y hay una lógica atrás de eso.
En el mundo real, cuando un accidente ocurre, las autoridades locales reaccionan primero. Ellos conocen mejor el área dónde ocurrió. Luego, si es necesario, autoridades de alto nivel.
Lo mismo para los manejadores de eventos. El código que se prepara en el manejador de un elemento en particular conoce el máximo de detalles sobre el elemento y qué hace. Un manejador en un <td> particular puede ser adecuado para ese exacto <td>, conocer todo sobre él, entonces debe tener su oportunidad primero. Luego su padre inmediato también conoce sobre el contexto, pero un poco menos, y así sucesivamente hasta el elemento de arriba que maneja conceptos generales y se ejecuta al final.
La propagación y captura ponen los cimientos para “delegación de eventos”: un extremadamente poderoso patrón de manejo de eventos que se estudia en el siguiente capítulo.
",
	"url": "https://es.javascript.info/bubbling-and-capturing" 
},
{
	"docs_id": "110",
	"name": "Delegación de eventos",
	"description": "La captura y el propagación nos permiten implementar uno de los más poderosos patrones de manejo de eventos llamado delegación de eventos.",
	"content": "La captura y el propagación nos permiten implementar uno de los más poderosos patrones de manejo de eventos llamado delegación de eventos.
La idea es que si tenemos muchos elementos manejados de manera similar podemos, en lugar de asignar un manejador a cada uno de ellos, poner un único manejador a su ancestro común.
En el manejador obtenemos event.target para ver dónde ocurrió realmente el evento y manejarlo.
Veamos un ejemplo: El diagrama Pa kua que refleja la antigua filosofía china.
Aquí está:

    
        
      
      
        
      
      
    
  El HTML es este:

      
        
        
          <table>
  <tr>
    <th colspan="3"><em>Bagua</em> Chart: Direction, Element, Color, Meaning</th>
  </tr>
  <tr>
    <td class="nw"><strong>Northwest</strong><br>Metal<br>Silver<br>Elders</td>
    <td class="n">...</td>
    <td class="ne">...</td>
  </tr>
  <tr>...2 more lines of this kind...</tr>
  <tr>...2 more lines of this kind...</tr>
</table>
        
      
      
      La tabla tiene 9 celdas, pero puede haber 99 o 999, eso no importa.
Nuestra tarea es destacar una celda <td> al hacer clic en ella.
En lugar de asignar un manejador onclick a cada <td> (puede haber muchos), configuramos un manejador “atrapa-todo” en el elemento <table>.
Este usará event.target para obtener el elemento del clic y destacarlo.
El código:

      
        
        
          let selectedTd;

table.onclick = function(event) {
  let target = event.target; // ¿dónde fue el clic?

  if (target.tagName != 'TD') return; // ¿no es un TD? No nos interesa

  highlight(target); // destacarlo
};

function highlight(td) {
  if (selectedTd) { // quitar cualquier celda destacada que hubiera antes
    selectedTd.classList.remove('highlight');
  }
  selectedTd = td;
  selectedTd.classList.add('highlight'); // y destacar el nuevo td
}
        
      
      
      A tal código no le interesa cuántas celdas hay en la tabla. Podemos agregar y quitar <td> dinámicamente en cualquier momento y el realzado aún funcionará.
Pero hay un inconveniente.
El clic puede ocurrir no sobre <td>, sino dentro de él.
En nuestro caso, si miramos dentro del HTML, podemos ver tags anidados dentro de <td>, como <strong>:

      
        
        
          <td>
  <strong>Northwest</strong>
  ...
</td>
        
      
      
      Naturalmente, si el clic ocurre en <strong>, este se vuelve el valor de event.target.

      
      
        
      
      En el manejador table.onclick debemos tomar tal event.target e indagar si el clic fue dentro de <td> o no.
Aquí el código mejorado:

      
        
        
          table.onclick = function(event) {
  let td = event.target.closest('td'); // (1)

  if (!td) return; // (2)

  if (!table.contains(td)) return; // (3)

  highlight(td); // (4)
};
        
      
      
      Explicación:

El método elem.closest(selector) devuelve el ancestro más cercano que coincide con el selector. En nuestro caso buscamos <td> hacia arriba desde el elemento de origen.
Si event.target no ocurrió dentro de algún <td>, el llamado retorna inmediatamente pues no hay nada que hacer.
En caso de tablas anidadas, event.target podría ser un <td> pero fuera de la tabla actual. Entonces verificamos que sea realmente un <td> de nuestra tabla.
Y, si es así, destacarla.

Como resultado, tenemos un código de realzado rápido y eficiente al que no le afecta la cantidad total de <td> en la tabla.
Ejemplo de delegación: acciones en markupHay otros usos para la delegación de eventos.
Digamos que queremos hacer un menú con los botones “Save”, “Load”, “Search” y así. Y hay objetos con los métodos save, load, search… ¿Cómo asociarlos?
La primera idea podría ser asignar un controlador separado para cada botón. Pero hay una solución más elegante. Podemos agregar un controlador para el menú completo y un atributo data-action a los botones con el método a llamar:

      
        
        
          <button data-action="save">Click to Save</button>
        
      
      
      El manejador lee el atributo y ejecuta el método. Puedes ver el siguiente ejemplo en funcionamiento:

      
        
        
          
            
          
          
            
          
        
        
          <div id="menu">
  <button data-action="save">Save</button>
  <button data-action="load">Load</button>
  <button data-action="search">Search</button>
</div>

<script>
  class Menu {
    constructor(elem) {
      this._elem = elem;
      elem.onclick = this.onClick.bind(this); // (*)
    }

    save() {
      alert('saving');
    }

    load() {
      alert('loading');
    }

    search() {
      alert('searching');
    }

    onClick(event) {
      let action = event.target.dataset.action;
      if (action) {
        this[action]();
      }
    };
  }

  new Menu(menu);
</script>
        
      
      
          
        
      Ten en cuenta que this.onClick está ligado a this en (*). Esto es importante, porque de otra manera el this que está dentro haría referencia al elemento DOM (elem), no al objeto Menu, y this[action] no sería lo que necesitamos.
Entonces, ¿qué ventajas nos ofrece la delegación aquí?
No necesitamos escribir el código para asignar el manejador a cada botón. Simplemente hacer un método y ponerlo en el markup.
La estructura HTML es flexible, podemos agregar y quitar botones en cualquier momento.
Podríamos usar clases .action-save, .action-load, pero un atributo data-action es mejor semánticamente. Y podemos usarlo con reglas CSS también.
El patrón “comportamiento”También podemos usar delegación de eventos para agregar “comportamiento” a los elementos de forma declarativa, con atributos y clases especiales.
El patrón tiene dos partes:

Agregamos un atributo personalizado al elemento que describe su comportamiento.
Un manejador rastrea eventos del documento completo, y si un evento ocurre en un elemento con el atributo ejecuta la acción.

Comportamiento: ContadorPor ejemplo, aquí el atributo data-counter agrega un comportamiento: “incrementar el valor con un clic” a los botones:

      
        
        
          
            
          
          
            
          
        
        
          Counter: <input type="button" value="1" data-counter>
One more counter: <input type="button" value="2" data-counter>

<script>
  document.addEventListener('click', function(event) {

    if (event.target.dataset.counter != undefined) { // si el atributo existe...
      event.target.value++;
    }

  });
</script>
        
      
      
          
        
      Si hacemos clic en un botón, su valor se incrementa. Lo importante aquí no son los botones sino el enfoque general.
Puede haber tantos atributos data-counter como queramos. Podemos agregar nuevos al HTML en cualquier momento. Usando delegación de eventos “extendimos” el HTML, agregando un atributo que describe un nuevo comportamiento.

            Para manejadores de nivel de documento: siempre addEventListener
            Cuando asignamos un manejador de evento al objeto document, debemos usar siempre addEventListener, no document.on<event>, porque este último causa conflictos: los manejadores nuevos sobrescribirán los viejos.
En proyectos reales es normal que haya muchos manejadores en document, asignados en diferentes partes del código.

Comportamiento: Conmutador (toggle)Un ejemplo más de comportamiento. Un clic en un elemento con el atributo data-toggle-id mostrará/ocultará el elemento con el id recibido:

      
        
        
          
            
          
          
            
          
        
        
          <button data-toggle-id="subscribe-mail">
  Show the subscription form
</button>

<form id="subscribe-mail" hidden>
  Your mail: <input type="email">
</form>

<script>
  document.addEventListener('click', function(event) {
    let id = event.target.dataset.toggleId;
    if (!id) return;

    let elem = document.getElementById(id);

    elem.hidden = !elem.hidden;
  });
</script>
        
      
      
          
        
      Veamos una vez más lo que hicimos aquí: ahora, para agregar la funcionalidad de conmutación a un elemento, no hay necesidad de conocer JavaScript, simplemente usamos el atributo data-toggle-id.
Esto puede ser muy conveniente: no hay necesidad de escribir JavaScript para cada elemento. Simplemente usamos el comportamiento. El manejador a nivel de documento hace el trabajo para cualquier elemento de la página.
Podemos combinar múltiples comportamientos en un único elemento también.
El patrón “comportamiento” puede ser una alternativa a los mini-fragmentos de JavaScript.
Resumen¡La delegación de eventos es verdaderamente fantástica! Es uno de los patrones más útiles entre los eventos DOM.
A menudo es usado para manejar elementos similares, pero no solamente para eso.
El algoritmo:

Pone un único manejador en el contenedor.
Dentro del manejador revisa el elemento de origen event.target.
Si el evento ocurrió dentro de un elemento que nos interesa, maneja el evento.

Beneficios:
Simplifica la inicialización y ahorra memoria: no hay necesidad de agregar muchos controladores.
Menos código: cuando agregamos o quitamos elementos, no hay necesidad de agregar y quitar controladores.
Modificaciones del DOM: podemos agregar y quitar elementos en masa con innerHTML y similares.
La delegación tiene sus limitaciones por supuesto:
Primero, el evento debe “propagarse”. Algunos eventos no lo hacen. Además manejadores de bajo nivel no deben usar event.stopPropagation().
Segundo, la delegación puede agregar carga a la CPU, porque el controlador a nivel de contenedor reacciona a eventos en cualquier lugar del mismo, no importa si nos interesan o no. Pero usualmente la carga es imperceptible y no la tomamos en cuenta.
TareasOcultar mensajes con delegaciónimportancia: 5Hay una lista de mensajes con botones para borrarlos [x]. Haz que funcionen.
Como esto:

    
    
  P.D. Debe haber solamente un event lintener en el contenedor, usa delegación de eventos.
Abrir un entorno controlado para la tarea.soluciónAbrir la solución en un entorno controlado.Menú de árbolimportancia: 5Crea un árbol que muestre y oculte nodos hijos con clics:

    
    
  Requerimientos:

Solamente un manejador de eventos (usa delegación)
Un clic fuera de los nodos de títulos (en un espacio vacío) no debe hacer nada.

Abrir un entorno controlado para la tarea.soluciónLa solución tiene dos partes.

Envuelve cada nodo de título del árbol dentro de <span>. Luego podemos aplicarles CSS-style en :hover y manejar los clics exactamente sobre el texto, porque el ancho de <span> es exactamente el ancho del texto (no lo será si no lo tiene).
Establece el manejador al nodo raíz del tree y maneja los clics en aquellos títulos <span>.

Abrir la solución en un entorno controlado.Tabla ordenableimportancia: 4Haz que la tabla se pueda ordenar: los clics en elementos <th> deberían ordenarla por la columna correspondiente.
Cada <th> tiene su tipo de datos en el atributo, como esto:

      
        
        
          <table id="grid">
  <thead>
    <tr>
      <th data-type="number">Age</th>
      <th data-type="string">Name</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>5</td>
      <td>John</td>
    </tr>
    <tr>
      <td>10</td>
      <td>Ann</td>
    </tr>
    ...
  </tbody>
</table>
        
      
      
      En el ejemplo anterior la primera columna tiene números y la segunda cadenas. La función de ordenamiento debe manejar el orden de acuerdo al tipo de dato.
Solamente los tipos "string" y "number" deben ser soportados.
Ejemplo en funcionamiento:

    
    
  P.D. La tabla puede ser grande, con cualquier cantidad de filas y columnas.
Abrir un entorno controlado para la tarea.soluciónAbrir la solución en un entorno controlado.Comportamiento: Tooltipimportancia: 5Crea código JS para el comportamiento “tooltip”.
Cuando un mouse pasa sobre un elemento con data-tooltip, el tooltip debe aparecer sobre él, y ocultarse cuando se va.
Un ejemplo en HTML comentado:

      
        
        
          <button data-tooltip="the tooltip is longer than the element">Short button</button>
<button data-tooltip="HTML<br>tooltip">One more button</button>
        
      
      
      Debe funcionar así:

    
    
  En esta tarea suponemos que todos los elementos con data-tooltip solo tienen texto dentro. Sin tags anidados (todavía).
Detalles:

La distancia entre el elemento y el tooltip debe ser 5px.
El tooltip debe ser centrado relativo al elemento si es posible.
El tooltip no debe cruzar los bordes de la ventana. Normalmente debería estar sobre el elemento, pero si el elemento está en la parte superior de la página y no hay espacio para el tooltip, entonces debajo de él.
El contenido del tooltip está dado en el atributo data-tooltip. Este puede ser HTML arbitrario.

Necesitarás dos eventos aquí:

mouseover se dispara cuando el puntero pasa sobre el elemento.
mouseout se dispara cuando el puntero deja el elemento.

Usa delegación de eventos:  prepare dos manejadores en el document para rastrear todos los “overs” y “outs” de los elementos con data-tooltip y administra los tooltips desde allí.
Después de implementar el comportamiento, incluso gente no familiarizada con JavaScript puede agregar elementos anotados.
P.D. Solamente un tooltip puede mostrarse a la vez.
Abrir un entorno controlado para la tarea.soluciónAbrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/event-delegation" 
},
{
	"docs_id": "111",
	"name": "Acciones predeterminadas del navegador",
	"description": "Muchos eventos conducen automáticamente a determinadas acciones realizadas por el navegador.",
	"content": "Muchos eventos conducen automáticamente a determinadas acciones realizadas por el navegador.
Por ejemplo:

Un clic en un enlace: inicia la navegación a su URL.
Un clic en el botón de envío de un formulario inicia su envío al servidor.
Al presionar un botón del ratón sobre un texto y moverlo, se selecciona el texto.

Si manejamos un evento en JavaScript, es posible que no queramos que suceda la acción correspondiente del navegador e implementar en cambio otro comportamiento.
Evitar las acciones del navegadorHay dos formas de decirle al navegador que no queremos que actúe:

La forma principal es utilizar el objeto event. Hay un método event.preventDefault().
Si el controlador se asigna usando on<event> (no por addEventListener), entonces devolver false también funciona igual.

En este HTML, un clic en un enlace no conduce a la navegación. El navegador no hace nada:

      
        
        
          <a href="/" onclick="return false">Haz clic aquí</a>
o
<a href="/" onclick="event.preventDefault()">aquí</a>
        
      
      
          
        
      En el siguiente ejemplo usaremos esta técnica para crear un menú basado en JavaScript.

            Regresar false desde un controlador es una excepción
            El valor devuelto por un controlador de eventos generalmente se ignora.
La única excepción es return false de un controlador asignado usando on<event>.
En todos los demás casos, se ignora el valor return. En particular, no tiene sentido devolver true.

Ejemplo: el menúConsidere un menú de sitio, como este:

      
        
        
          <ul id="menu" class="menu">
  <li><a href="/html">HTML</a></li>
  <li><a href="/javascript">JavaScript</a></li>
  <li><a href="/css">CSS</a></li>
</ul>
        
      
      
      Así es como se ve con algo de CSS:

    
        
      
      
        
      
      
    
  Los elementos del menú se implementan como enlaces HTML <a>, no como botones <botón>. Hay varias razones para hacerlo, por ejemplo:

A muchas personas les gusta usar “clic derecho” – “abrir en una nueva ventana”. Si usamos <button> o <span>, eso no funciona.
Los motores de búsqueda siguen los enlaces <a href="..."> durante la indexación.

Entonces usamos <a> en el markup. Pero normalmente pretendemos manejar clics en JavaScript. Por tanto, deberíamos evitar la acción predeterminada del navegador.
Como aquí:

      
        
        
          menu.onclick = function(event) {
  if (event.target.nodeName != 'A') return;

  let href = event.target.getAttribute('href');
  alert( href ); // ...se puede cargar desde el servidor, generación de interfaz de usuario, etc.

  return false; // evitar la acción del navegador (no vaya a la URL)
};
        
      
      
      Si omitimos return false, luego de ejecutar nuestro código el navegador realizará su “acción predeterminada”: navegar a la URL en href. Y no lo necesitamos aquí, ya que estamos manejando el clic nosotros mismos.
Por cierto, usar la delegación de eventos aquí hace que nuestro menú sea muy flexible. Podemos agregar listas anidadas y diseñarlas usando CSS para “deslizarlas hacia abajo”.

            Eventos de seguimiento
            Ciertos eventos fluyen unos a otros. Si evitamos el primer evento, no habrá segundo.
Por ejemplo, mousedown en un campo <input> conduce a enfocarse en él, y al evento focus. Si evitamos el evento mousedown, no hay enfoque.
Intenta hacer clic en el primer <input> a continuación: se produce el evento focus. Pero si haces clic en el segundo, no hay enfoque.

      
        
        
          
            
          
          
            
          
        
        
          <input value="Enfoque funciona" onfocus="this.value=''">
<input onmousedown="return false" onfocus="this.value=''" value="Haz clic en mí">
        
      
      
          
        
      Eso es porque la acción del navegador se cancela en mousedown. El enfoque aún es posible si usamos otra forma de ingresar la entrada. Por ejemplo, la tecla Tab para cambiar de la primera entrada a la segunda. Pero ya no con el clic del ratón.

La opción de controlador “pasivo”La opción opcional passive:true de addEventListener indica al navegador que el controlador no llamará a preventDefault().
¿Para qué podría ser necesario?
Hay algunos eventos como touchmove en dispositivos móviles (cuando el usuario mueve el dedo por la pantalla), que provocan el desplazamiento por defecto, pero ese desplazamiento se puede evitar usando preventDefault() en el controlador.
Entonces, cuando el navegador detecta tal evento, primero tiene que procesar todos los controladores, y luego, si no se llama a preventDefault en ninguna parte, puede continuar con el desplazamiento. Eso puede causar retrasos innecesarios y “movimientos de salto repentinos” en la interfaz de usuario.
Las opciones passive: true le dicen al navegador que el controlador no va a cancelar el desplazamiento. Entonces el navegador se desplaza de inmediato para brindar una experiencia con la máxima fluidez, y el evento se maneja de inmediato.
Para algunos navegadores (Firefox, Chrome), passive es true por defecto para los eventos touchstart y touchmove.
event.defaultPreventedLa propiedad event.defaultPrevented es true si se impidió la acción predeterminada y false en caso contrario.
Hay un caso de uso interesante para ello.
¿Recuerdas que en el capítulo Propagación y captura hablamos sobre event.stopPropagation() y por qué detener propagación es malo?
A veces podemos usar event.defaultPrevented en su lugar, para señalar a otros controladores de eventos que el evento fue manejado.
Veamos un ejemplo práctico.
Por defecto, el navegador en el evento contextmenu (clic derecho del ratón) muestra un menú contextual con opciones estándar. Podemos prevenirlo y mostrar el nuestro, así:

      
        
        
          
            
          
          
            
          
        
        
          <button>El clic derecho muestra el menú contextual del navegador</button>

<button oncontextmenu="alert('Dibuja nuestro menú'); return false">
  El clic derecho muestra nuestro menú contextual
</button>
        
      
      
          
        
      Ahora, además de ese menú contextual, nos gustaría implementar un menú contextual para todo el documento.
Al hacer clic derecho, debería aparecer el menú contextual más cercano.

      
        
        
          
            
          
          
            
          
        
        
          <p>Haz clic derecho aquí para el menú contextual del documento</p>
<button id="elem">Haz clic derecho aquí para el menú contextual del botón</button>

<script>
  elem.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Menú contextual del botón");
  };

  document.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Menú contextual del documento");
  };
</script>
        
      
      
          
        
      El problema es que cuando hacemos clic en elem, obtenemos dos menús: el de nivel de botón y (el evento emerge) el menú de nivel de documento.
¿Como arreglarlo? Una de las soluciones es pensar así: “Cuando hagamos clic con el botón derecho en el controlador de botones, detengamos su propagación” y usemos event.stopPropagation():

      
        
        
          
            
          
          
            
          
        
        
          <p>Haz clic derecho para el menú del documento</p>
<button id="elem">Haz clic derecho para el menú del botón (arreglado con event.stopPropagation)</button>

<script>
  elem.oncontextmenu = function(event) {
    event.preventDefault();
    event.stopPropagation();
    alert("Menú contextual del botón");
  };

  document.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Menú contextual del documento");
  };
</script>
        
      
      
          
        
      Ahora, el menú de nivel de botón funciona según lo previsto. Pero el precio es alto. Siempre negamos el acceso a la información sobre los clics con el botón derecho del ratón para cualquier código externo, incluidos los contadores que recopilan estadísticas, etc. Eso es bastante imprudente.
¿Sería una solución alternativa verificar en el controlador document si se evitó la acción predeterminada? Si es así, entonces se manejó el evento y no necesitamos reaccionar ante él.

      
        
        
          
            
          
          
            
          
        
        
          <p>Haz clic con el botón derecho en el menú del documento (se agregó una marca de verificación para event.defaultPrevented)</p>
<button id="elem">Haz clic derecho para el menú de botones</button>

<script>
  elem.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Menú contextual del botón");
  };

  document.oncontextmenu = function(event) {
    if (event.defaultPrevented) return;

    event.preventDefault();
    alert("Menú contextual del documento");
  };
</script>
        
      
      
          
        
      Ahora todo también funciona correctamente. Si tenemos elementos anidados, y cada uno de ellos tiene un menú contextual propio, eso también funcionaría. Solo asegúrate de buscar event.defaultPrevented en cada controlador de contextmenu.

            event.stopPropagation() y event.preventDefault()
            Como podemos ver claramente, event.stopPropagation() y event.preventDefault() (también conocido como return false) son dos cosas diferentes. No están relacionados entre sí.


            Arquitectura de menús contextuales anidados
            También hay formas alternativas de implementar menús contextuales anidados. Uno de ellos es tener un único objeto global con un manejador para document.oncontextmenu, y también métodos que nos permitan almacenar otros manejadores en él.
El objeto detectará cualquier clic derecho, examinará los controladores almacenados y ejecutará el apropiado.
Pero entonces cada fragmento de código que quiera un menú contextual debe conocer ese objeto y usar su ayuda en lugar del propio controlador contextmenu.

ResumenHay muchas acciones predeterminadas del navegador:

mousedown – inicia la selección (mueva el ratón para seleccionar).
click en <input type="checkbox"> – marca/desmarca el input.
submit – dar clic en <input type="submit"> o presionar Enter dentro de un campo de formulario hace que suceda este evento y el navegador envía el formulario a continuación.
keydown – presionar una tecla puede llevar a agregar un carácter a un campo u otras acciones.
contextmenu – el evento ocurre con un clic derecho, la acción es mostrar el menú contextual del navegador.
…hay mas…

Todas las acciones predeterminadas se pueden evitar si queremos manejar el evento exclusivamente mediante JavaScript.
Para evitar una acción predeterminada, utiliza event.preventDefault() o return false. El segundo método funciona solo para los controladores asignados con on<event>.
La opción passive: true de addEventListener le dice al navegador que la acción no se evitará. Eso es útil para algunos eventos móviles, como touchstart y touchmove, para decirle al navegador que no debe esperar a que todos los controladores terminen antes de desplazarse.
Si se evitó la acción predeterminada, el valor de event.defaultPrevented se convierte en true, de lo contrario, es false.

            Mantente semántico, no abuses
            Técnicamente, al evitar acciones predeterminadas y agregar JavaScript, podemos personalizar el comportamiento de cualquier elemento. Por ejemplo, podemos hacer que un enlace <a> funcione como un botón, y un botón <button> se comporte como un enlace (redirigir a otra URL o algo así).
Pero en general deberíamos mantener el significado semántico de los elementos HTML. Por ejemplo, la navegación debe realizarla <a>, no un botón.
Además de ser “algo bueno”, hace que su HTML sea mejor en términos de accesibilidad.
Además, si consideramos el ejemplo con <a>, ten en cuenta: un navegador nos permite abrir dichos enlaces en una nueva ventana (usando el botón derecho u otros medios). Y a la gente le gusta. Pero si hacemos que un botón se comporte como un enlace usando JavaScript e incluso parezca un enlace usando CSS, las características específicas de <a> no funcionarán en él.

Tareas¿Por qué "return false" no funciona?importancia: 3¿Por qué en el código de abajo return false no funciona en absoluto?

      
        
        
          
            
          
          
            
          
        
        
          <script>
  function handler() {
    alert( "..." );
    return false;
  }
</script>

<a href="https://w3.org" onclick="handler()">el navegador irá a w3.org</a>
        
      
      
          
        
      El navegador sigue la URL al hacer clic, pero no la queremos.
¿Como se arregla?
soluciónCuando el navegador lee un atributo on* como onclick, crea el controlador a partir de su contenido.
Para onclick="handler()" la función será:

      
        
        
          function(event) {
  handler() // el contenido de onclick
}
        
      
      
      Ahora podemos ver que el valor devuelto por handler() no se usa y no afecta el resultado.
La solución es simple:

      
        
        
          
            
          
          
            
          
        
        
          <script>
  function handler() {
    alert("...");
    return false;
  }
</script>

<a href="https://w3.org" onclick="return handler()">w3.org</a>
        
      
      
      También podemos usar event.preventDefault(), así:

      
        
        
          
            
          
          
            
          
        
        
          <script>
  function handler(event) {
    alert("...");
    event.preventDefault();
  }
</script>

<a href="https://w3.org" onclick="handler(event)">w3.org</a>
        
      
      
      Captura enlaces en el elementoimportancia: 5Haz que todos los enlaces dentro del elemento con id="contents" pregunten al usuario si realmente quiere irse. Y si no quiere, no sigas.
Así:

    
    
  Detalles:

El HTML dentro del elemento puede cargarse o regenerarse dinámicamente en cualquier momento, por lo que no podemos encontrar todos los enlaces y ponerles controladores. Utilice la delegación de eventos.
El contenido puede tener etiquetas anidadas. Dentro de los enlaces también, como <a href=".."><i>...</i></a>.

Abrir un entorno controlado para la tarea.soluciónEse es un gran uso para el patrón de delegación de eventos.
En la vida real, en lugar de preguntar, podemos enviar una solicitud de “logging” al servidor que guarda la información sobre dónde se fue el visitante. O podemos cargar el contenido y mostrarlo directamente en la página (si está permitido).
Todo lo que necesitamos es capturar el contents.onclick y usar confirm para preguntar al usuario. Una buena idea sería usar link.getAttribute('href') en lugar de link.href para la URL. Consulte la solución para obtener más detalles.
Abrir la solución en un entorno controlado.Galería de imágenesimportancia: 5Crea una galería de imágenes donde la imagen principal cambia al hacer clic en una miniatura.
Así:

    
    
  P.D. Utiliza la delegación de eventos.
Abrir un entorno controlado para la tarea.soluciónLa solución es asignar el controlador al contenedor y realizar un seguimiento de los clics. Si haces clic en el enlace <a>, cambias src de #largeImg por el href de la miniatura.
Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/default-browser-action" 
},
{
	"docs_id": "112",
	"name": "Envío de eventos personalizados",
	"description": "No solo podemos asignar controladores, sino también generar eventos desde JavaScript.",
	"content": "No solo podemos asignar controladores, sino también generar eventos desde JavaScript.
Los eventos personalizados se pueden utilizar para crear “componentes gráficos”. Por ejemplo, un elemento raíz de nuestro propio menú basado en JS puede desencadenar eventos que indiquen lo que sucede con el menú: abrir (menú abierto),seleccionar (se selecciona un elemento) y así sucesivamente. Otro código puede escuchar los eventos y observar lo que sucede con el menú.
No solo podemos generar eventos completamente nuevos, que inventamos para nuestros propios fines, sino también eventos integrados, como click, mousedown, etc. Eso puede ser útil para las pruebas automatizadas.
Constructor de eventosLas clases de eventos integradas forman una jerarquía, similar a las clases de elementos DOM. La raíz es la clase incorporada Event.
Podemos crear objetos Event así:

      
        
        
          let event = new Event(type[, options]);
        
      
      
      Argumentos:


type – tipo de event, un string como "click" o nuestro propio evento como "mi-evento".


options – el objeto con 2 propiedades opcionales:

bubbles: true/false – si es true, entonces el evento se propaga.
cancelable: true/false – si es true, entonces la “acción predeterminada” puede ser prevenida. Más adelante veremos qué significa para los eventos personalizados.

Por defecto, los dos son false: {bubbles: false, cancelable: false}.


dispatchEventDespués de que se crea un objeto de evento, debemos “ejecutarlo” en un elemento usando la llamada elem.dispatchEvent(event).
Luego, los controladores reaccionan como si fuera un evento normal del navegador. Si el evento fue creado con la bandera bubbles, entonces se propaga.
En el siguiente ejemplo, el evento click se inicia en JavaScript. El controlador funciona de la misma manera que si se hiciera clic en el botón:

      
        
        
          
            
          
          
            
          
        
        
          <button id="elem" onclick="alert('Clic!');">Click automático</button>

<script>
  let event = new Event("click");
  elem.dispatchEvent(event);
</script>
        
      
      
      
            event.isTrusted
            Hay una forma de diferenciar un evento de usuario “real” de uno generado por script.
La propiedad event.isTrusted es true para eventos que provienen de acciones de usuarios reales y false para eventos generados por script.

Ejemplo de BubblingPodemos crear un evento bubbling con el nombre "hello" y capturarlo en document.
Todo lo que necesitamos es establecer bubbles en true:

      
        
        
          
            
          
          
            
          
        
        
          <h1 id="elem">Hola desde el script!</h1>

<script>
  // Captura en document...
  document.addEventListener("hello", function(event) { // (1)
    alert("Hola desde " + event.target.tagName); // Hola desde H1
  });

  // ...Envío en elem!
  let event = new Event("hello", {bubbles: true}); // (2)
  elem.dispatchEvent(event);

// el controlador del documento se activará y mostrará el mensaje.

</script>
        
      
      
      Notas:

Debemos usar addEventListener para nuestros eventos personalizados, porque on<event> solo existe para eventos incorporados, document.onhello no funciona.
Debes poner bubbles:true, de otra manera el evento no se propagará.

La mecánica de bubbling es la misma para los eventos integrados (click) y personalizados (hello). También hay etapas de captura y propagación.
MouseEvent, KeyboardEvent y otrosAquí hay una breve lista de clases para eventos UI (interfaz de usuario) de la especificación de eventos UI:

UIEvent
FocusEvent
MouseEvent
WheelEvent
KeyboardEvent
…

Deberíamos usarlos en lugar de new Event si queremos crear tales eventos. Por ejemplo, new MouseEvent("click").
El constructor correcto permite especificar propiedades estándar para ese tipo de evento.
Como clientX/clientY para un evento de mouse:

      
        
        
          
            
          
          
            
          
        
        
          let event = new MouseEvent("click", {
  bubbles: true,
  cancelable: true,
  clientX: 100,
  clientY: 100
});

alert(event.clientX); // 100
        
      
      
      Tenga en cuenta: el constructor genérico Event no lo permite.
Intentemos:

      
        
        
          
            
          
          
            
          
        
        
          let event = new Event("click", {
  bubbles: true, // solo bubbles y cancelable
  cancelable: true, // funcionan en el constructor de Event
  clientX: 100,
  clientY: 100
});

alert(event.clientX); // undefined, se ignora la propiedad desconocida!
        
      
      
      Técnicamente, podemos solucionarlo asignando directamente event.clientX=100 después de la creación. Entonces eso es una cuestión de conveniencia y de seguir las reglas. Los eventos generados por el navegador siempre tienen el tipo correcto.
La lista completa de propiedades para diferentes eventos de UI se encuentra en la especificación, por ejemplo, MouseEvent.
Eventos personalizadosPara nuestros tipos de eventos completamente nuevos, como "hello", deberíamos usar new CustomEvent. Técnicamente, CustomEvent es lo mismo que Event, con una excepción.
En el segundo argumento (objeto) podemos agregar una propiedad adicional detail para cualquier información personalizada que queramos pasar con el evento.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <h1 id="elem">Hola para John!</h1>

<script>
  // detalles adicionales que vienen con el evento para el controlador.
  elem.addEventListener("hello", function(event) {
    alert(event.detail.name);
  });

  elem.dispatchEvent(new CustomEvent("hello", {
    detail: { name: "John" }
  }));
</script>
        
      
      
      La propiedad detail puede tener cualquier dato. Técnicamente podríamos vivir sin él, porque podemos asignar cualquier propiedad a un objeto new Event regular después de su creación. Pero CustomEvent proporciona el campo especial detail para evitar conflictos con otras propiedades del evento.
Además, la clase de evento describe “qué tipo de evento” es, y si el evento es personalizado, entonces deberíamos usar CustomEvent solo para tener claro qué es.
event.preventDefault()Muchos eventos del navegador tienen una “acción predeterminada”, como ir a un enlace, iniciar una selección, etc.
Para eventos nuevos y personalizados, definitivamente no hay acciones predeterminadas del navegador, pero un código que distribuye dicho evento puede tener sus propios planes de qué hacer después de activar el evento.
Al llamar a event.preventDefault(), un controlador de eventos puede enviar una señal de que esas acciones deben cancelarse.
En ese caso, la llamada a elem.dispatchEvent(event) devuelve false. Y el código que lo envió sabe que no debería continuar.
Veamos un ejemplo práctico: un conejo escondido (podría ser un menú de cierre u otra cosa).
A continuación puede ver una función #rabbit y hide() que distribuye el evento "hide" en él, para que todas las partes interesadas sepan que el conejo se va a esconder.
Cualquier controlador puede escuchar ese evento con rabbit.addEventListener('hide', ...) y, si es necesario, cancelar la acción usando event.preventDefault(). Entonces el conejo no desaparecerá:

      
        
        
          
            
          
          
            
          
        
        
          <pre id="rabbit">
  |\   /|
   \|_|/
   /. .\
  =\_Y_/=
   {>o<}
</pre>
<button onclick="hide()">Esconder()</button>

<script>
  // hide() será llamado automáticamente en 2 segundos.
  function hide() {
    let event = new CustomEvent("hide", {
      cancelable: true // sin esa bandera preventDefault no funciona
    });
    if (!rabbit.dispatchEvent(event)) {
      alert('La acción fue impedida por un controlador');
    } else {
      rabbit.hidden = true;
    }
  }

  rabbit.addEventListener('hide', function(event) {
    if (confirm("¿Llamar a preventDefault?")) {
      event.preventDefault();
    }
  });
</script>
        
      
      
          
        
      Tenga en cuenta: el evento debe tener la bandera cancelable: true, de lo contrario, la llamada event.preventDefault() se ignora.
Los eventos dentro de eventos son sincrónicosUsualmente los eventos se procesan en una cola. Por ejemplo: si el navegador está procesando onclick y ocurre un nuevo evento porque el mouse se movió, entonces el manejo de este último se pone en cola, y el controlador correspondiente mousemove será llamado cuando el procesamiento de onclick haya terminado.
La excepción notable es cuando un evento se inicia desde dentro de otro, por ejemplo, usando dispatchEvent. Dichos eventos se procesan inmediatamente: se llaman los nuevos controladores de eventos y luego se reanuda el manejo de eventos actual.
Por ejemplo, en el código siguiente, el evento menu-open se activa durante el onclick.
Se procesa inmediatamente, sin esperar a que termine el controlador onclick:

      
        
        
          
            
          
          
            
          
        
        
          <button id="menu">Menu (dame clic)</button>

<script>
  menu.onclick = function() {
    alert(1);

    menu.dispatchEvent(new CustomEvent("menu-open", {
      bubbles: true
    }));

    alert(2);
  };

  // se dispara entre 1 y 2
  document.addEventListener('menu-open', () => alert('anidado'));
</script>
        
      
      
          
        
      El orden de salida es: 1 → anidado → 2.
Tenga en cuenta que el evento anidado menu-open se captura en document. La propagación y el manejo del evento anidado finaliza antes de que el procesamiento vuelva al código externo (onclick).
No se trata solo de dispatchEvent, hay otros casos. Si un controlador de eventos llama a métodos que desencadenan otros eventos, también se procesan sincrónicamente, de forma anidada.
Supongamos que no nos gusta. Querríamos que onclick se procesara por completo primero, independientemente de menu-open o cualquier otro evento anidado.
Entonces podemos poner el dispatchEvent (u otra llamada de activación de eventos) al final de onclick o, mejor aún, envolverlo en el setTimeout de retardo cero:

      
        
        
          
            
          
          
            
          
        
        
          <button id="menu">Menu (dame clic)</button>

<script>
  menu.onclick = function() {
    alert(1);

    setTimeout(() => menu.dispatchEvent(new CustomEvent("menu-open", {
      bubbles: true
    })));

    alert(2);
  };

  document.addEventListener('menu-open', () => alert('anidado'));
</script>
        
      
      
      Ahora dispatchEvent se ejecuta asincrónicamente después de que la ejecución del código actual finaliza, incluyendo menu.onclick. Los controladores de eventos están totalmente separados.
El orden de salida se convierte en: 1 → 2 → anidado.
ResumenPara generar un evento a partir del código, primero necesitamos crear un objeto de evento.
El constructor genérico Event(name, options) acepta un nombre de evento arbitrario y el objeto options con dos propiedades:

bubbles: true si el evento debe propagarse.
cancelable: true si event.preventDefault() debe funcionar.

Otros constructores de eventos nativos como MouseEvent, KeyboardEvent, y similares, aceptan propiedades específicas para ese tipo de evento. Por ejemplo, clientX para eventos de mouse.
Para eventos personalizados deberíamos usar el constructor CustomEvent. Este tiene una opción adicional llamada detail a la que podemos asignarle los datos específicos del evento. De esta forma, todos los controladores pueden accederlos como event.detail.
A pesar de la posibilidad técnica de generar eventos del navegador como click o keydown, debemos usarlo con mucho cuidado.
No deberíamos generar eventos de navegador, ya que es una forma trillada de ejecutar controladores. Esa es una mala arquitectura la mayor parte del tiempo.
Se pueden generar eventos nativos:

Como un truco sucio para hacer que las bibliotecas de terceros funcionen de la manera necesaria, si  es que ellas no proporcionan otros medios de interacción.
Para pruebas automatizadas, que el script “haga clic en el botón” y vea si la interfaz reacciona correctamente.

Los eventos personalizados con nuestros propios nombres a menudo se generan con fines arquitectónicos, para señalar lo que sucede dentro de nuestros menús, controles deslizantes, carruseles, etc.
",
	"url": "https://es.javascript.info/dispatch-events" 
},
{
	"docs_id": "113",
	"name": "Eventos del Mouse",
	"description": "En este capítulo vamos a entrar en más detalles sobre los eventos del mouse y sus propiedades.",
	"content": "En este capítulo vamos a entrar en más detalles sobre los eventos del mouse y sus propiedades.
Ten en cuenta que tales eventos pueden provenir no sólo del “dispositivo mouse”, sino también de otros dispositivos, como teléfonos y tabletas, donde se emulan por compatibilidad.
Tipos de eventos del mouseYa hemos visto algunos de estos eventos:

mousedown/mouseup
Se oprime/suelta el botón del ratón sobre un elemento.
mouseover/mouseout
El puntero del mouse se mueve sobre/sale de un elemento.
mousemove
Cualquier movimiento del mouse sobre un elemento activa el evento.
click
Se activa después de mousedown y un mouseup enseguida sobre el mismo elemento si se usó el botón.
dblclick
Se activa después de dos clicks seguidos sobre el mismo elemento. Hoy en día se usa raramente.
contextmenu
Se activa al pulsar el botón derecho del ratón. Existen otras formas de abrir el menú contextual, por ejemplo: usando un comando especial de teclado también puede activarse, de manera que no es exactamente un evento exclusivo del mouse.

…Existen otros eventos más que cubriremos más tarde.
El orden de los eventosComo pudiste ver en la lista anterior, una acción del usuario puede desencadenar varios eventos.
Por ejemplo , un click izquierdo primero activa mousedowncuando se presiona el botón, enseguida mouseup y click cuando se suelta.
En casos así, el orden es fijo. Es decir, los controladores son llamados en el siguiente orden mousedown → mouseup → click.
Haz click en el botón abajo y verás los eventos. Intenta con doble click también.
En el testeador de abajo todos los eventos quedan registrados. Si hay mas de un segundo de retraso entre cada uno de ellos quedan separados por una línea horizontal.
Además podemos ver la propiedad de button que nos permite detectar el botón del mouse. Lo explicaremos a continuación.
   
El botón del mouseLos eventos relacionados con clics siempre tienen la propiedad button, esta nos permite conocer el botón exacto del mouse.
Normalmente no la usamos para eventos click y contextmenu events, porque sabemos que ocurren solo con click izquierdo y derecho respectivamente.
Por otro lado, los controladores mousedown y mouseup pueden necesitar event.button ya que estos eventos se activan con cualquier botón, y button nos permitirá distinguir entre “mousedown derecho” y “mousedown izquierdo”.
Los valores posibles para event.button son:



Estado del botón
event.button




Botón izquierdo (primario)
0


Botón central (auxiliar)
1


Botón derecho (secundario)
2


Botón X1 (atrás)
3


Botón X2 (adelante)
4



La mayoría de los dispositivos de ratón sólo tienen los botones izquierdo y derecho, por lo que los valores posibles son 0 o 2. Los dispositivos táctiles también generan eventos similares cuando se toca sobre ellos.
También hay una propiedad event.buttons que guarda todos los botones presionados actuales en un solo entero, un bit por botón. En la práctica, esta propiedad es raramente utilizada. Puedes encontrar más detalles en MDN si alguna vez lo necesitas.

            El obsoleto event.which
            El código puede utilizar la propiedad event.which que es una forma antigua no estándar de obtener un botón con los valores posibles:

event.which == 1 – botón izquierdo,
event.which == 2 – botón central,
event.which == 3 – botón derecho.

Ahora event.which está en desuso, no deberíamos usarlo.

Modificadores: shift, alt, ctrl y metaTodos los eventos del mouse incluyen la información sobre las teclas modificadoras presionadas.
Propiedades del evento:

shiftKey: Shift
altKey: Alt (p Opt para Mac)
ctrlKey: Ctrl
metaKey: Cmd para Mac

Su valor es true si la tecla fue presionada durante el evento.
Por ejemplo, el botón abajo solo funciona conAlt+Shift+click:

      
        
        
          <button id="button">Alt+Shift+¡Click sobre mí!</button>

<script>
  button.onclick = function(event) {
    if (event.altKey && event.shiftKey) {
      alert('¡Genial!');
    }
  };
</script>
        
      
      
          
        
      
            Atención: en Mac suele ser Cmd en lugar de Ctrl
            En Windows y Linux existen las teclas modificadoras Alt, Shift y Ctrl. En Mac hay una más: Cmd, correspondiente a la propiedad metaKey.
En la mayoría de las aplicaciones, cuando Windows/Linux usan Ctrl, en Mac se usa Cmd.
Es decir: cuando un usuario de Windows usa Ctrl+Enter o Ctrl+A, un usuario Mac presionaría Cmd+Enter o Cmd+A, y así sucesivamente.
Entonces si queremos darle soporte a combinaciones como Ctrl+click, entonces para Mac tendría más sentido usar Cmd+click. Esto es más cómodo para los usuarios de Mac.
Incluso si quisiéramos obligar a los usuarios de Mac a hacer Ctrl+click – esto supone algo de dificultad. El problema es que: un click izquierdo con Ctrl es interpretado como  click derecho en MacOS, y esto genera un evento contextmenu, no un click como en Windows/Linux.
Así que si queremos que los usuarios de todos los sistemas operativos se sientan cómodos, entonces junto con ctrlKey debemos verificar metaKey.
Para código JS  significa que debemos hacer la comprobación if (event.ctrlKey || event.metaKey).


            También hay dispositivos móviles
            Las combinaciones de teclado son buenas como una adición al flujo de trabajo. De modo que si el visitante usa un teclado – funcionan.
Pero si su dispositivo no lo tiene – entonces debería haber una manera de vivir sin teclas modificadoras.

Coordenadas: clientX/Y, pageX/YTodos los eventos del ratón proporcionan coordenadas en dos sabores:

Relativas a la ventana: clientX y clientY.
Relativos al documento: pageX y pageY.

Ya cubrimos la diferencia entre ellos en el capítulo Coordenadas.
En resumen, las coordenadas relativas al documento pageX/Yse cuentan desde la esquina superior izquierda del documento y no cambian cuando se desplaza la página, mientras que clientX/Y se cuentan desde la esquina superior actual. Cambian cuando se desplaza la página.
Por ejemplo, si tenemos una ventana del tamaño 500x500, y el mouse está en la esquina superior izquierda, entonces clientX y clientY son 0, sin importar cómo se desplace la página.
Y si el mouse está en el centro, entonces clientX y clientY son 250, No importa en qué parte del documento se encuentren. Esto es similar a position:fixed en ese aspecto.
Mueve el mouse sobre el campo de entrada para ver clientX/clientY (el ejemplo está dentro del iframe, así que las coordenadas son relativas al iframe):

      
        
        
          <input onmousemove="this.value=event.clientX+':'+event.clientY" value="Pasa el mouse sobre mí">
        
      
      
          
        
      Previniendo la selección en mousedownEl doble clic del mouse tiene un efecto secundario que puede ser molesto en algunas interfaces: selecciona texto.
Por ejemplo, un doble clic en el texto de abajo lo selecciona además de activar nuestro controlador:

      
        
        
          <span ondblclick="alert('dblclick')">Haz doble click en mi</span>
        
      
      
          
        
      Si se pulsa el botón izquierdo del ratón y, sin soltarlo, mueve el ratón, también hace la selección, a menudo no deseado.
Hay varias maneras de evitar la selección, que se pueden leer en el capítulo Selection y Range.
En este caso particular, la forma más razonable es evitar la acción del navegador mousedown. Esto evita ambas selecciones:

      
        
        
          Antes...
<b ondblclick="alert('Click!')" onmousedown="return false">
  Haz doble click en mí
</b>
...Después
        
      
      
          
        
      Ahora el elemento en negrita no se selecciona con doble clic, y al mantener presionado el botón izquierdo y arrastrar no se iniciará la selección.
Tenga en cuenta: el texto dentro de él todavía es seleccionable. Sin embargo, la selección no debe comenzar en el texto en sí, sino antes o después. Por lo general, eso está bien para los usuarios.

            Previniendo copias
            Si queremos inhabilitar la selección para proteger nuestro contenido de la página del copy-paste, entonces podemos utilizar otro evento: oncopy.

      
        
        
          <div oncopy="alert('¡Copiado prohibido!');return false">
  Querido usuario,
  El copiado está prohibida para ti.
  Si sabes JS o HTML entonces puedes obtener todo de la fuente de la página.
</div>
        
      
      
          
        
      Si intenta copiar un fragmento de texto en el <div> no va a funcionar porque la acción default de oncopy fue evitada.
Seguramente el usuario tiene acceso a la fuente HTML de la página, y puede tomar el contenido desde allí, pero no todos saben cómo hacerlo.

ResumenLos eventos del mouse tienen las siguientes propiedades:


Botón: button.


Teclas modificadoras (true si fueron presionadas): altKey, ctrlKey, shiftKey y metaKey (Mac).

Si quieres controlar las acciones de la tecla Ctrl no te olvides de los usuarios de Mac que generalmente usan Cmd, de manera que es mejor verificar con la condicional: if (e.metaKey || e.ctrlKey).



Coordenadas relativas a la ventana: clientX/clientY.


Coordenadas relativas al documento: pageX/pageY.


La acción predeterminada del navegador mousedown es la selección del texto, si no es bueno para la interfaz, entonces debe evitarse.
En el próximo capítulo veremos más detalles sobre los eventos que siguen al movimiento del puntero y cómo rastrear los cambios de elementos debajo de él.
TareasLista seleccionableimportancia: 5Cree una lista donde los elementos son seleccionables, como en los administradores de archivos.

Un clic en un elemento de la lista selecciona solo ese elemento (agrega la clase .selected), deselecciona todos los demás.
Si se hace un clic con Ctrl (Cmd para Mac), el estado seleccionado/deseleccionado cambia para ese solo elemento, los otros elementos no se modifican.

Demo:

    
    
  PD: Para esta tarea, podemos suponer que los elementos de la lista son solo de texto. No hay etiquetas anidadas.
PPD: Evita la selección nativa del navegador del texto en los clics.
Abrir un entorno controlado para la tarea.soluciónAbrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/mouse-events-basics" 
},
{
	"docs_id": "114",
	"name": "Moviendo el mouse: mouseover/out, mouseenter/leave",
	"description": "Entremos en detalle sobre los eventos que suceden cuando el mouse se mueve entre elementos.",
	"content": "Entremos en detalle sobre los eventos que suceden cuando el mouse se mueve entre elementos.
Eventos mouseover/mouseout, relatedTargetEl evento mouseover  se produce cuando el cursor del mouse aparece sobre un elemento y mouseout cuando se va.

      
      
        
      
      Estos eventos son especiales porque tienen la propiedad relatedTarget. Esta propiedad complementa a target. Cuando el puntero del mouse deja un elemento por otro, uno de ellos se convierte en target y el otro en  relatedTarget.
Para mouseover:

event.target – Es el elemento al que se acerca el mouse.
event.relatedTarget – Es el elemento de donde proviene el mouse (relatedTarget → target).

Para mouseout sucede al contrario:

event.target – Es el elemento que el mouse dejó.
event.relatedTarget – es el nuevo elemento bajo el cursor por cuál el cursor dejó al anterior (target → relatedTarget).

En el siguiente ejemplo, cada cara y sus características son elementos separados. Puedes ver en el área de texto los eventos que ocurren cuando mueves el mouse.
Cada evento tiene la información sobre ambas propiedades: target y relatedTarget:
Resultadoscript.jsstyle.cssindex.htmlcontainer.onmouseover = container.onmouseout = handler;

function handler(event) {

  function str(el) {
    if (!el) return "null"
    return el.className || el.tagName;
  }

  log.value += event.type + ':  ' +
    'target=' + str(event.target) +
    ',  relatedTarget=' + str(event.relatedTarget) + "\n";
  log.scrollTop = log.scrollHeight;

  if (event.type == 'mouseover') {
    event.target.style.background = 'pink'
  }
  if (event.type == 'mouseout') {
    event.target.style.background = ''
  }
}body,
html {
  margin: 0;
  padding: 0;
}

#container {
  border: 1px solid brown;
  padding: 10px;
  width: 330px;
  margin-bottom: 5px;
  box-sizing: border-box;
}

#log {
  height: 120px;
  width: 350px;
  display: block;
  box-sizing: border-box;
}

[class^="smiley-"] {
  display: inline-block;
  width: 70px;
  height: 70px;
  border-radius: 50%;
  margin-right: 20px;
}

.smiley-green {
  background: #a9db7a;
  border: 5px solid #92c563;
  position: relative;
}

.smiley-green .left-eye {
  width: 18%;
  height: 18%;
  background: #84b458;
  position: relative;
  top: 29%;
  left: 22%;
  border-radius: 50%;
  float: left;
}

.smiley-green .right-eye {
  width: 18%;
  height: 18%;
  border-radius: 50%;
  position: relative;
  background: #84b458;
  top: 29%;
  right: 22%;
  float: right;
}

.smiley-green .smile {
  position: absolute;
  top: 67%;
  left: 16.5%;
  width: 70%;
  height: 20%;
  overflow: hidden;
}

.smiley-green .smile:after,
.smiley-green .smile:before {
  content: "";
  position: absolute;
  top: -50%;
  left: 0%;
  border-radius: 50%;
  background: #84b458;
  height: 100%;
  width: 97%;
}

.smiley-green .smile:after {
  background: #84b458;
  height: 80%;
  top: -40%;
  left: 0%;
}

.smiley-yellow {
  background: #eed16a;
  border: 5px solid #dbae51;
  position: relative;
}

.smiley-yellow .left-eye {
  width: 18%;
  height: 18%;
  background: #dba652;
  position: relative;
  top: 29%;
  left: 22%;
  border-radius: 50%;
  float: left;
}

.smiley-yellow .right-eye {
  width: 18%;
  height: 18%;
  border-radius: 50%;
  position: relative;
  background: #dba652;
  top: 29%;
  right: 22%;
  float: right;
}

.smiley-yellow .smile {
  position: absolute;
  top: 67%;
  left: 19%;
  width: 65%;
  height: 14%;
  background: #dba652;
  overflow: hidden;
  border-radius: 8px;
}

.smiley-red {
  background: #ee9295;
  border: 5px solid #e27378;
  position: relative;
}

.smiley-red .left-eye {
  width: 18%;
  height: 18%;
  background: #d96065;
  position: relative;
  top: 29%;
  left: 22%;
  border-radius: 50%;
  float: left;
}

.smiley-red .right-eye {
  width: 18%;
  height: 18%;
  border-radius: 50%;
  position: relative;
  background: #d96065;
  top: 29%;
  right: 22%;
  float: right;
}

.smiley-red .smile {
  position: absolute;
  top: 57%;
  left: 16.5%;
  width: 70%;
  height: 20%;
  overflow: hidden;
}

.smiley-red .smile:after,
.smiley-red .smile:before {
  content: "";
  position: absolute;
  top: 50%;
  left: 0%;
  border-radius: 50%;
  background: #d96065;
  height: 100%;
  width: 97%;
}

.smiley-red .smile:after {
  background: #d96065;
  height: 80%;
  top: 60%;
  left: 0%;
}<!DOCTYPE HTML>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <div id="container">
    <div class="smiley-green">
      <div class="left-eye"></div>
      <div class="right-eye"></div>
      <div class="smile"></div>
    </div>

    <div class="smiley-yellow">
      <div class="left-eye"></div>
      <div class="right-eye"></div>
      <div class="smile"></div>
    </div>

    <div class="smiley-red">
      <div class="left-eye"></div>
      <div class="right-eye"></div>
      <div class="smile"></div>
    </div>
  </div>

  <textarea id="log">¡Los eventos se mostrarán aquí!
</textarea>

  <script src="script.js"></script>

</body>
</html>
            relatedTarget puede ser null
            La propiedad relatedTarget puede tener un valor null.
Eso es normal y solo significa que el mouse no vino de otro elemento, sino de la ventana o que salió de la ventana.
Debemos tener en cuenta esa posibilidad cuando usemos event.relatedTarget en nuestro código. Si accedemos a event.relatedTarget.tagName entonces habrá un error.

Saltando elementosEl evento mousemove  se activa cuando el mouse se mueve pero eso no significa que cada píxel nos lleve a un evento.
El navegador verifica la posición del mouse de vez en cuando y si nota cambios entonces activan los eventos.
Eso significa que si el visitante mueve el mouse muy rápido, entonces algunos elementos del DOM podrían estar siendo ignorados:

      
      
        
      
      Si el mouse se mueve muy rápido de los elementos #FROM a #TO, como se muestra arriba, entonces los elementos intermedios <div> (o algunos de ellos) podrían ser ignorados. El evento mouseout se podría activar en #FROM e inmediatamente mouseover en #TO.
Eso es bueno para el rendimiento porque puede haber muchos elementos intermedios. Realmente no queremos procesar todo lo que sucede dentro y fuera de cada uno.
Por otro lado, debemos tener en cuenta que el puntero del mouse no “visita” todos los elementos en el camino. Los puede “saltar”.
En particular, es posible que el puntero salte dentro de la mitad de la página desde la ventana. En ese caso relatedTarget es null, porque vino de “la nada”:

      
      
        
      
      Puedes verlo “en vivo” en un testeador a continuación.
Este HTML tiene dos elementos: el <div id="child"> está adentro del <div id="parent">. Si mueves el mouse rápidamente sobre ellos entonces probablemente solo el div hijo active los eventos, o probablemente el padre, o probablemente no ocurran eventos en lo absoluto.
También prueba a mover el cursor hacia el div hijo y luego muévelo rápidamente hacia abajo a través del padre. Si el movimiento es lo suficientemente rápido entonces el padre será ignorado. El mouse cruzará el elemento padre sin notarlo.
Resultadoscript.jsstyle.cssindex.htmllet parent = document.getElementById('parent');
parent.onmouseover = parent.onmouseout = parent.onmousemove = handler;

function handler(event) {
  let type = event.type;
  while (type.length < 11) type += ' ';

  log(type + " target=" + event.target.id)
  return false;
}


function clearText() {
  text.value = "";
  lastMessage = "";
}

let lastMessageTime = 0;
let lastMessage = "";
let repeatCounter = 1;

function log(message) {
  if (lastMessageTime == 0) lastMessageTime = new Date();

  let time = new Date();

  if (time - lastMessageTime > 500) {
    message = '------------------------------\n' + message;
  }

  if (message === lastMessage) {
    repeatCounter++;
    if (repeatCounter == 2) {
      text.value = text.value.trim() + ' x 2\n';
    } else {
      text.value = text.value.slice(0, text.value.lastIndexOf('x') + 1) + repeatCounter + "\n";
    }

  } else {
    repeatCounter = 1;
    text.value += message + "\n";
  }

  text.scrollTop = text.scrollHeight;

  lastMessageTime = time;
  lastMessage = message;
}#parent {
  background: #99C0C3;
  width: 160px;
  height: 120px;
  position: relative;
}

#child {
  background: #FFDE99;
  width: 50%;
  height: 50%;
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

textarea {
  height: 140px;
  width: 300px;
  display: block;
}<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <div id="parent">parent
    <div id="child">child</div>
  </div>
  <textarea id="text"></textarea>
  <input onclick="clearText()" value="Clear" type="button">

  <script src="script.js"></script>

</body>

</html>
            Si mouseover se activa, deberá haber mouseout
            En caso de movimientos rápidos, los elementos intermedios podrían ser ignorados, pero una cosa segura sabemos: si el cursor ingresa “oficialmente” dentro de un elemento(evento mouseover generado), una vez que lo deje obtendremos mouseout.

Mouseout, cuando se deja un elemento por uno anidado.Una característica importante de mouseout – se activa cuando el cursor se mueve de un elemento hacia su descendiente (elemento anidado o interno). Por ejemplo de #parent a #child en este HTML:

      
        
        
          <div id="parent">
  <div id="child">...</div>
</div>
        
      
      
      Si estamos sobre #parent y luego movemos el cursor hacia dentro de #child, ¡vamos a obtener mouseout en #parent!

      
      
        
      
      Eso puede parecer extraño, pero puede explicarse fácilmente.
De acuerdo con la lógica del navegador, el cursor podría estar sobre un elemento individual en cualquier momento – el anidado y el más alto según el z-index.
Entonces si se dirige hacia otro elemento (incluso uno anidado), está dejando al anterior.
Por favor, note otro importante detalle sobre el procesamiento de eventos.
El evento mouseover se aparece en un un elemento anidado (brota o nace, por decirlo así). Entonces si #parent tiene el controlador mouseover, se activa:

      
      
        
      
      Puedes verlo muy bien a continuación: <div id="child"> está dentro de<div id="parent">. Hay controladores mouseover/out en el elemento #parent que arrojan los detalles de los eventos.
Si mueves el mouse de #parent a #child, verás dos eventos sobre #parent:

mouseout [target: parent] (dejó al padre), luego
mouseover [target: child] (vino hacia el hijo, y este evento brotó).

Resultadoscript.jsstyle.cssindex.htmlfunction mouselog(event) {
  let d = new Date();
  text.value += `${d.getHours()}:${d.getMinutes()}:${d.getSeconds()} | ${event.type} [target: ${event.target.id}]\n`.replace(/(:|^)(\d\D)/, '$10$2');
  text.scrollTop = text.scrollHeight;
}#parent {
  background: #99C0C3;
  width: 160px;
  height: 120px;
  position: relative;
}

#child {
  background: #FFDE99;
  width: 50%;
  height: 50%;
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

textarea {
  height: 140px;
  width: 300px;
  display: block;
}<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <div id="parent" onmouseover="mouselog(event)" onmouseout="mouselog(event)">parent
    <div id="child">child</div>
  </div>

  <textarea id="text"></textarea>
  <input type="button" onclick="text.value=''" value="Clear">

  <script src="script.js"></script>

</body>

</html>Como se muestra, cuando el cursor se mueve del elemento #parent a #child, los dos controladores se activan en el elemento padre: mouseout y mouseover:

      
        
        
          parent.onmouseout = function(event) {
  /* event.target: elemento padre  */
};
parent.onmouseover = function(event) {
  /* event.target: elemento hijo (brota) */
};
        
      
      
      Si no examinamos event.target dentro de los controladores podría parecer que el cursor dejo el elemento #parent y volvió a él inmediatamente.
Pero ese no es el caso. El cursor aún está sobre el elemento padre, simplemente se adentró más en el elemento hijo.
Si hay algunas acciones al abandonar el elemento padre,por ejemplo: una animación se ejecuta con parent.onmouseout, usualmente no la queremos cuando el cursor se adentre más sobre #parent.
Para evitar esto lo que podemos hacer es checar relatedTarget en el controlador y si el mouse aún permanece dentro del elemento entonces ignorar dicho evento.
Alternativamente podemos usar otros eventos: mouseenter y mouseleave, los cuales cubriremos a continuación, ya que con ellos no hay tales problemas.
Eventos mouseenter y mouseleaveLos eventos mouseenter/mouseleave son como mouseover/mouseout. Se activan cuando el cursor del mouse entra/sale del elemento.
Pero hay dos diferencias importantes:

Las transiciones hacia/desde los descendientes no se cuentan.
Los eventos mouseenter/mouseleave no brotan.

Son eventos extremadamente simples.
Cuando el cursor entra en un elemento mouseenter se activa. La ubicación exacta del cursor dentro del elemento o sus descendientes no importa.
Cuando el cursor deja el elemento mouseleave se activa.
Este ejemplo es similar al anterior, pero ahora el elemento tiene mouseenter/mouseleave en lugar de mouseover/mouseout.
Como puedes ver, los únicos eventos generados son los relacionados con mover el puntero dentro y fuera del elemento superior. No pasa nada cuando el puntero va hacia el descendiente y regresa. Las transiciones entre descendientes se ignoran:
Resultadoscript.jsstyle.cssindex.htmlfunction mouselog(event) {
  let d = new Date();
  text.value += `${d.getHours()}:${d.getMinutes()}:${d.getSeconds()} | ${event.type} [target: ${event.target.id}]\n`.replace(/(:|^)(\d\D)/, '$10$2');
  text.scrollTop = text.scrollHeight;
}#parent {
  background: #99C0C3;
  width: 160px;
  height: 120px;
  position: relative;
}

#child {
  background: #FFDE99;
  width: 50%;
  height: 50%;
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
}

textarea {
  height: 140px;
  width: 300px;
  display: block;
}<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <div id="parent" onmouseenter="mouselog(event)" onmouseleave="mouselog(event)">parent
    <div id="child">child</div>
  </div>

  <textarea id="text"></textarea>
  <input type="button" onclick="text.value=''" value="Clear">

  <script src="script.js"></script>

</body>

</html>Delegación de eventosLos eventos mouseenter/leave son muy simples de usar. Pero no brotan por sí solos. Por lo tanto no podemos usar la delegación de eventos con ellos.
Imagina que queremos manejar entrada/salida para celdas de tabla y hay cientos de celdas.
La solución natural sería: ajustar el controlador en <table> y manejar los eventos desde ahí. Pero mouseenter/leave no aparece. Entonces si cada evento sucede en <td>, solamente un controlador <td> es capaz de detectarlo.
Los controladores mouseenter/leave en <table> solamente se activan cuando el cursor entra/deja la tabla completa. Es imposible obtener alguna información sobre las transiciones dentro de ella.
Pues usemos mouseover/mouseout.
Comencemos con controladores simples que resaltan el elemento debajo del mouse:

      
        
        
          // Resaltemos un elemento debajo del cursor
table.onmouseover = function(event) {
  let target = event.target;
  target.style.background = 'pink';
};

table.onmouseout = function(event) {
  let target = event.target;
  target.style.background = '';
};
        
      
      
      Aquí se muestran en acción. A medida que el mouse recorre los elementos de esta tabla, se resalta la actual:
Resultadoscript.jsstyle.cssindex.htmltable.onmouseover = function(event) {
  let target = event.target;
  target.style.background = 'pink';

  text.value += `over -> ${target.tagName}\n`;
  text.scrollTop = text.scrollHeight;
};

table.onmouseout = function(event) {
  let target = event.target;
  target.style.background = '';

  text.value += `out <- ${target.tagName}\n`;
  text.scrollTop = text.scrollHeight;
};#text {
  display: block;
  height: 100px;
  width: 456px;
}

#table th {
  text-align: center;
  font-weight: bold;
}

#table td {
  width: 150px;
  white-space: nowrap;
  text-align: center;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 12px;
  cursor: pointer;
}

#table .nw {
  background: #999;
}

#table .n {
  background: #03f;
  color: #fff;
}

#table .ne {
  background: #ff6;
}

#table .w {
  background: #ff0;
}

#table .c {
  background: #60c;
  color: #fff;
}

#table .e {
  background: #09f;
  color: #fff;
}

#table .sw {
  background: #963;
  color: #fff;
}

#table .s {
  background: #f60;
  color: #fff;
}

#table .se {
  background: #0c3;
  color: #fff;
}

#table .highlight {
  background: red;
}<!DOCTYPE HTML>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>


  <table id="table">
    <tr>
      <th colspan="3"><em>Bagua</em> Chart: Direction, Element, Color, Meaning</th>
    </tr>
    <tr>
      <td class="nw"><strong>Northwest</strong>
        <br>Metal
        <br>Silver
        <br>Elders
      </td>
      <td class="n"><strong>North</strong>
        <br>Water
        <br>Blue
        <br>Change
      </td>
      <td class="ne"><strong>Northeast</strong>
        <br>Earth
        <br>Yellow
        <br>Direction
      </td>
    </tr>
    <tr>
      <td class="w"><strong>West</strong>
        <br>Metal
        <br>Gold
        <br>Youth
      </td>
      <td class="c"><strong>Center</strong>
        <br>All
        <br>Purple
        <br>Harmony
      </td>
      <td class="e"><strong>East</strong>
        <br>Wood
        <br>Blue
        <br>Future
      </td>
    </tr>
    <tr>
      <td class="sw"><strong>Southwest</strong>
        <br>Earth
        <br>Brown
        <br>Tranquility
      </td>
      <td class="s"><strong>South</strong>
        <br>Fire
        <br>Orange
        <br>Fame
      </td>
      <td class="se"><strong>Southeast</strong>
        <br>Wood
        <br>Green
        <br>Romance
      </td>
    </tr>

  </table>

  <textarea id="text"></textarea>

  <input type="button" onclick="text.value=''" value="Clear">

  <script src="script.js"></script>

</body>
</html>En nuestro caso nos gustaría manejar las transiciones entre las celdas de la tabla <td>: entradas y salidas de una celda a otra. Otras transiciones, como dentro de una celda o fuera de cualquiera de ellas no nos interesan. Vamos a filtrarlas.
Esto es lo que podemos hacer:

Recordar el elemento <td> resaltado actualmente en una variable, llamémosla currentElem.
En mouseover ignoraremos el evento si permanecemos dentro del <td> actual.
En mouseout ignoraremos el evento si no hemos dejado el <td> actual.

Aquí hay un ejemplo de código que explica todas las situaciones posibles:

      
        
        
          // Los elementos <td> bajo el maouse justo ahora(si es que hay)
let currentElem = null;

table.onmouseover = function(event) {
  // antes de ingresar un uevo elemento, el mouse siempre abandonará al anterior
  // si currentElem está establecido, no abandonamos el <td> anterior,
  // hay un mouseover dentro de él, ignoramos el evento
  if (currentElem) return;

  let target = event.target.closest('td');

  // si no hay movimientos dentro de un <td> - lo ignoramos
  if (!target) return;

  //si hay movimientos dentro de un <td>, pero afuera de una tabla(posiblemente en caso de tablas anidadas)
  // lo ignoramos
  if (!table.contains(target)) return;

  // ¡Genial! ingresamos a un nuevo <td>
  currentElem = target;
  onEnter(currentElem);
};


table.onmouseout = function(event) {
  // si estamos afuera de algún <td> ahora, entonces ignoramos el evento
  // pueden haber movimientos dentro de una tabla pero fuera de <td>,
  // por ejemplo: de un <tr> a otro <tr>
  if (!currentElem) return;

  // abandonamos el elemento – ¿pero hacia dónde? ¿podría ser hacia un descendiente?
  let relatedTarget = event.relatedTarget;

  while (relatedTarget) {
    // vamos a la cadena de padres y verificamos – si aún estamos dentro de currentElem
    // entonces hay una transición interna – la ignoramos
    if (relatedTarget == currentElem) return;

    relatedTarget = relatedTarget.parentNode;
  }

  // abandonamos el <td>.
  onLeave(currentElem);
  currentElem = null;
};

// algunas funciones para manejar entradas/salidas de un elemento
function onEnter(elem) {
  elem.style.background = 'pink';

  // lo mostramos en el área de texto
  text.value += `over -> ${currentElem.tagName}.${currentElem.className}\n`;
  text.scrollTop = 1e6;
}

function onLeave(elem) {
  elem.style.background = '';

  // lo mostramos en el area de texto
  text.value += `out <- ${elem.tagName}.${elem.className}\n`;
  text.scrollTop = 1e6;
}
        
      
      
      Una vez más, las características importantes son:

Utilizar la delegación de eventos para manejar la entrada/salida de cualquier <td> dentro de la tabla. Pues depende de mouseover/out en lugar de mouseenter/leave que no broten y por lo tanto no permita ninguna delegación.
Los eventos adicionales, como moverse entre descendientes de <td> son filtrados, así que onEnter/Leave solamente se ejecuta si el cursor ingresa a <td> o lo deja absolutamente.

Aquí está el ejemplo completo con todos los detalles:
Resultadoscript.jsstyle.cssindex.html// Los elementos <td> bajo el maouse justo ahora(si es que hay)
let currentElem = null;

table.onmouseover = function(event) {
  // antes de ingresar un uevo elemento, el mouse siempre abandonará al anterior
  // si currentElem está establecido, no abandonamos el <td> anterior,
  // hay un mouseover dentro de él, ignoramos el evento
  if (currentElem) return;

  let target = event.target.closest('td');

  // si no hay movimientos dentro de un <td> - lo ignoramos
  if (!target) return;

  //si hay movimientos dentro de un <td>, pero afuera de una tabla(posiblemente en caso de tablas anidadas)
  // lo ignoramos
  if (!table.contains(target)) return;

  // ¡Genial! ingresamos a un nuevo <td>
  currentElem = target;
  onEnter(currentElem);
};


table.onmouseout = function(event) {
  // si estamos afuera de algún <td> ahora, entonces ignoramos el evento
  // pueden haber movimientos dentro de una tabla pero fuera de <td>,
  // por ejemplo: de un <tr> a otro <tr>
  if (!currentElem) return;

  // abandonamos el elemento – ¿pero hacia dónde? ¿podría ser hacia un descendiente?
  let relatedTarget = event.relatedTarget;

  while (relatedTarget) {
    // vamos a la cadena de padres y verificamos – si aún estamos dentro de currentElem
    // entonces hay una transición interna – la ignoramos
    if (relatedTarget == currentElem) return;

    relatedTarget = relatedTarget.parentNode;
  }

  // abandonamos el <td>.
  onLeave(currentElem);
  currentElem = null;
};

// algunas funciones para manejar entradas/salidas de un elemento
function onEnter(elem) {
  elem.style.background = 'pink';

  // lo mostramos en el área de texto
  text.value += `over -> ${currentElem.tagName}.${currentElem.className}\n`;
  text.scrollTop = 1e6;
}

function onLeave(elem) {
  elem.style.background = '';

  // lo mostramos en el area de texto
  text.value += `out <- ${elem.tagName}.${elem.className}\n`;
  text.scrollTop = 1e6;
}#text {
  display: block;
  height: 100px;
  width: 456px;
}

#table th {
  text-align: center;
  font-weight: bold;
}

#table td {
  width: 150px;
  white-space: nowrap;
  text-align: center;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 12px;
  cursor: pointer;
}

#table .nw {
  background: #999;
}

#table .n {
  background: #03f;
  color: #fff;
}

#table .ne {
  background: #ff6;
}

#table .w {
  background: #ff0;
}

#table .c {
  background: #60c;
  color: #fff;
}

#table .e {
  background: #09f;
  color: #fff;
}

#table .sw {
  background: #963;
  color: #fff;
}

#table .s {
  background: #f60;
  color: #fff;
}

#table .se {
  background: #0c3;
  color: #fff;
}

#table .highlight {
  background: red;
}<!DOCTYPE HTML>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>


  <table id="table">
    <tr>
      <th colspan="3"><em>Bagua</em> Chart: Direction, Element, Color, Meaning</th>
    </tr>
    <tr>
      <td class="nw"><strong>Northwest</strong>
        <br>Metal
        <br>Silver
        <br>Elders
      </td>
      <td class="n"><strong>North</strong>
        <br>Water
        <br>Blue
        <br>Change
      </td>
      <td class="ne"><strong>Northeast</strong>
        <br>Earth
        <br>Yellow
        <br>Direction
      </td>
    </tr>
    <tr>
      <td class="w"><strong>West</strong>
        <br>Metal
        <br>Gold
        <br>Youth
      </td>
      <td class="c"><strong>Center</strong>
        <br>All
        <br>Purple
        <br>Harmony
      </td>
      <td class="e"><strong>East</strong>
        <br>Wood
        <br>Blue
        <br>Future
      </td>
    </tr>
    <tr>
      <td class="sw"><strong>Southwest</strong>
        <br>Earth
        <br>Brown
        <br>Tranquility
      </td>
      <td class="s"><strong>South</strong>
        <br>Fire
        <br>Orange
        <br>Fame
      </td>
      <td class="se"><strong>Southeast</strong>
        <br>Wood
        <br>Green
        <br>Romance
      </td>
    </tr>

  </table>

  <textarea id="text"></textarea>

  <input type="button" onclick="text.value=''" value="Clear">

  <script src="script.js"></script>

</body>
</html>Intenta mover el cursor dentro y fuera de las celdas de la tabla y dentro de cada una de ellas. Rápido o lento – no importa --. Solo se ilumina <td> como un todo, a diferencia del ejemplo anterior.
ResumenHemos cubierto mouseover, mouseout, mousemove, mouseenter ymouseleave.
Estas cosas son buenas de destacar:

Un movimiento rápido del mouse puede omitir elementos intermedios.
Los eventos mouseover/out y mouseenter/leave tienen una propiedad adicional: relatedTarget. Es el elemento de donde venimos o hacia donde vamos, complementario con target.

Los eventos mouseover/out se activan incluso cuando vamos de un elemento padre a su descendiente. El navegador asume que de el mouse solo puede estar sobre un elemento a la vez – el más interno.
Los eventos mouseenter/leave son diferentes en ese aspecto: solo se activan cuando el mouse viene hacia el elemento o lo deja como un todo. Así que no se aparecen de repente.
TareasComportamiento mejorado de un tooltipimportancia: 5Escribe JavaScript que muestre un tooltip sobre un elemento con el atributo data-tooltip. El valor de este atributo debe convertirse en el texto del tooltip.
Es como la tarea Comportamiento: Tooltip, pero aquí los elementos anotados se pueden anidar. Los tooltips más internos se muestran.
Solamente un tooltip puede aparecer a la vez.
Por ejemplo:

      
        
        
          <div data-tooltip="Aquí – está el interior de la casa" id="house">
  <div data-tooltip="Aquí – está el techo" id="roof"></div>
  ...
  <a href="https://en.wikipedia.org/wiki/The_Three_Little_Pigs" data-tooltip="Continúa leyendo…">Colócate sobre mi</a>
</div>
        
      
      
      El resultado en el iframe:

    
    
  Abrir un entorno controlado para la tarea.soluciónAbrir la solución en un entorno controlado.Tooltip "inteligente"Escribe una función que muestre un tooltip sobre un elemento solamente si el visitante mueve el mouse hacia él, pero no a través de él.
En otras palabras, si el visitante mueve el mouse hacia el elemento y para ahí, muestra el tooltip. Y si solamente mueve el mouse a través, entonces no lo necesitamos. ¿Quién quiere parpadeos extra?
Técnicamente, podemos medir la velocidad del mouse sobre el elemento, y si es lenta podemos asumir que el mouse viene “sobre el elemento” y mostramos el tooltip, si es rápida – entonces lo ignoramos.
Hay que crear un objeto universal new HoverIntent(options) para ello.
Sus options:

elem – elemento a seguir.
over – una función a llamar si el el mouse viene hacia el elemento: o sea, si viene lentamente o para sobre él.
out – una función a llamar cuando el mouse abandona el elemento (si over fue llamado).

Un ejemplo de dicho objeto siendo usado para el tooltip:

      
        
        
          //  Un tooltip de muestra
let tooltip = document.createElement('div');
tooltip.className = "tooltip";
tooltip.innerHTML = "Tooltip";

// El objeto va a rastrear al mouse y llamar a over/out
new HoverIntent({
  elem,
  over() {
    tooltip.style.left = elem.getBoundingClientRect().left + 'px';
    tooltip.style.top = elem.getBoundingClientRect().bottom + 5 + 'px';
    document.body.append(tooltip);
  },
  out() {
    tooltip.remove();
  }
});
        
      
      
      El demo:

    
    
  Si mueves el mouse sobre el “reloj” rápido no pasará nada, y si lo haces lento o paras sobre él entonces habrá un tooltip.
Toma en cuenta que el tooltip no “parpadea” cuando el cursor se mueve entre subelementos del reloj.
Abrir en entorno controlado con pruebas.soluciónEl algorítmo luce simple:

Coloca los controladores onmouseover/out en el elemento. Aquí también podemos usar onmouseenter/leave pero son menos universales, no funcionan si introducimos delegaciones.
Cuando el cursor ingrese al elemento debes medir la velocidad en mousemove.
Si la velocidad es lenta hay que ejecutar over.
Si estamos saliendo del elemento, y over ya se había ejecutado, ahora ejecutamos out.

¿Pero cómo mediremos la velocidad?
La primera idea puede ser: correr una función cada 100ms y medir la distancia entre la coordenada anterior y la actual. Si es pequeña entonces la velocidad fue rápida.
Desafortunadamente no hay manera para obtener las coordenadas actuales del mouse en JavaScript. No existe algo así como getCurrentMouseCoordinates().
La única manera es registrando los eventos del mouse, como mousemove, y tomar las coordenadas del objeto del evento.
Entonces configuremos un mousemove para registrar las coordenadas y recordarlas. Y entonces las comparamos, una por cada 100ms.
PD. Toma nota: El test de la solución usa dispatchEvent para ver si el tooltip funciona bien.
Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/mousemove-mouseover-mouseout-mouseenter-mouseleave" 
},
{
	"docs_id": "115",
	"name": "Arrastrar y Soltar con eventos del ratón",
	"description": "Arrastrar y Soltar es una excelente solución de interfaz. Tomar algo, arrastrar y soltarlo es una forma clara y simple de hacer muchas cosas, desde copiar y mover documentos (como en los manejadores de archivos) hasta ordenar (arrastrando ítems al carrito).",
	"content": "Arrastrar y Soltar es una excelente solución de interfaz. Tomar algo, arrastrar y soltarlo es una forma clara y simple de hacer muchas cosas, desde copiar y mover documentos (como en los manejadores de archivos) hasta ordenar (arrastrando ítems al carrito).
En el estándar moderno de HTML hay una sección sobre Arrastrar y Soltar con eventos especiales tales como dragstart, dragend, y así por el estilo.
Estos eventos nos permiten soportar tipos especiales de Arrastrar y Soltar, como manejar el arrastrado de archivos desde el manejador de archivos del Sistema Operativo y soltarlo en la ventana del navegador. Así JavaScript puede acceder al contenido de dichos archivos.
Pero los eventos nativos de arrastrar tienen limitaciones. Por ejemplo, no nos deja evitar el arrastre desde cierta área. Tampoco podemos hacer que el arrastre sea solamente “horizontal” o “vertical”. Y hay muchas otras tareas de “Arrastrar y Soltar” que no pueden hacerse utilizándolos. Además, el soporte para dichos eventos es muy pobre en dispositivos móviles.
Así que aquí veremos cómo implementar “Arrastrar y Soltar” usando eventos del ratón.
Algoritmo de “Arrastrar y Soltar”El algoritmo básico de Arrastrar y Soltar se ve así:

En mousedown – preparar el elemento para moverlo, si es necesario (quizá creando un clon de este, añadiéndole una clase, o lo que sea).
En mousemove – moverlo cambiando left/top con position:absolute.
En mouseup – realizar todas las acciones relacionadas con finalizar el Arrastrar y Soltar.

Esto es lo básico. Luego veremos como añadir características, como resaltar los elementos subyacentes mientras arrastramos sobre ellos.
Aquí esta la implementación de arrastrar una pelota:

      
        
        
          ball.onmousedown = function(event) {
  // (1) preparar para mover: hacerlo absoluto y ponerlo sobre todo con el z-index
  ball.style.position = 'absolute';
  ball.style.zIndex = 1000;

  // quitar cualquier padre actual y moverlo directamente a body
  // para posicionarlo relativo al body
  document.body.append(ball);

  // centrar la pelota en las coordenadas (pageX, pageY)
  function moveAt(pageX, pageY) {
    ball.style.left = pageX - ball.offsetWidth / 2 + 'px';
    ball.style.top = pageY - ball.offsetHeight / 2 + 'px';
  }

  // mover nuestra pelota posicionada absolutamente bajo el puntero
  moveAt(event.pageX, event.pageY);

  function onMouseMove(event) {
    moveAt(event.pageX, event.pageY);
  }

  // (2) mover la pelota con mousemove
  document.addEventListener('mousemove', onMouseMove);

  // (3) soltar la pelota, quitar cualquier manejador de eventos innecesario
  ball.onmouseup = function() {
    document.removeEventListener('mousemove', onMouseMove);
    ball.onmouseup = null;
  };

};
        
      
      
      Si ejecutamos el código, nos enteramos de algo extraño. Al inicio de arrastrar y soltar, la pelota se duplica: empezamos a arrastrar su “clon”.
Aquí hay un ejemplo en acción:

    
    
  Trata de arrastrar con el ratón y verás dicho comportamiento.
Esto es porque el navegador tiene su propio soporte para arrastrar y soltar para imágenes y otros elementos. Se ejecuta automáticamente y entra en conflicto con el nuestro.
Para deshabilitarlo:

      
        
        
          ball.ondragstart = function() {
  return false;
};
        
      
      
      Ahora todo estará bien.
En acción:

    
    
  Otro aspecto importante: seguimos mousemove en document, no en ball. Desde el primer momento debe verse que el ratón está siempre sobre la pelota, y podemos poner mousemove en ella.
Pero como recordamos, mousemove se dispara a menudo, pero no por cada pixel. Así que después de un movimiento rápido el puntero puede saltar de la pelota a algún lugar en el medio del documento (o incluso fuera de la ventana).
Así que tenemos que escuchar en document para captarlo.
Posicionamiento correctoEn los ejemplos de arriba la pelota siempre se mueve, de manera que su centro queda debajo del puntero:

      
        
        
          ball.style.left = pageX - ball.offsetWidth / 2 + 'px';
ball.style.top = pageY - ball.offsetHeight / 2 + 'px';
        
      
      
      Nada mal, pero hay un efecto secundario. Para iniciar el arrastrar y soltar, podemos hacer mousedown en cualquier lugar de la pelota. Pero si la “tomamos” por el borde, entonces la pelota “salta” de repente para centrarse bajo el puntero del ratón.
Sería mejor si mantenemos la posición inicial del elemento, relativo al puntero.
Por ejemplo, si empezamos a arrastrar por el borde de la pelota, entonce el puntero debería quedarse sobre el borde mientras se arrastra.

      
      
        
      
      Vamos a actualizar nuestro algoritmo:


Cuando un visitante presiona el botón (mousedown) – recordar la distancia del puntero a la esquina superior izquierda de la pelota in variables shiftX/shiftY. Mantendremos esa distancia mientras arrastramos.
Para obtener esas posiciones podemos restar las coordenadas:

      
        
        
          // onmousedown
let shiftX = event.clientX - ball.getBoundingClientRect().left;
let shiftY = event.clientY - ball.getBoundingClientRect().top;
        
      
      
      

Entonces mientras arrastra posicionamos la pelota en la misma posición relativa al puntero, de esta forma:

      
        
        
          // onmousemove
// la pelota tiene position:absolute
ball.style.left = event.pageX - shiftX + 'px';
ball.style.top = event.pageY - shiftY + 'px';
        
      
      
      

El código final con mejor posicionamiento:

      
        
        
          ball.onmousedown = function(event) {

  let shiftX = event.clientX - ball.getBoundingClientRect().left;
  let shiftY = event.clientY - ball.getBoundingClientRect().top;

  ball.style.position = 'absolute';
  ball.style.zIndex = 1000;
  document.body.append(ball);

  moveAt(event.pageX, event.pageY);

  // mueve la pelota a las coordenadas (pageX, pageY)
  // tomando la posición inicial en cuenta
  function moveAt(pageX, pageY) {
    ball.style.left = pageX - shiftX + 'px';
    ball.style.top = pageY - shiftY + 'px';
  }

  function onMouseMove(event) {
    moveAt(event.pageX, event.pageY);
  }

  // mueve la pelota con mousemove
  document.addEventListener('mousemove', onMouseMove);

  // suelta la pelota, elimina el manejador innecesario
  ball.onmouseup = function() {
    document.removeEventListener('mousemove', onMouseMove);
    ball.onmouseup = null;
  };

};

ball.ondragstart = function() {
  return false;
};
        
      
      
      En acción (dentro de un <iframe>):

    
    
  La diferencia es notable especialmente si arrastramos la pelota por su esquina inferior derecha. En el ejemplo anterior la pelota “salta” bajo el puntero. Ahora sigue el puntero fluidamente desde su posición actual.
Objetivos receptores potenciales (droppables)En los ejemplos anteriores la pelota debe ser soltada simplemente “en cualquier lugar” para quedarse. En la vida real normalmente tomamos un elemento para soltarlo en otro. Por ejemplo, un “archivo” en una “carpeta” o algo más.
Hablando abstracto, tomamos un elemento “arrastrable” y lo soltamos sobre un elemento “receptor”.
Necesitamos saber:

dónde el elemento fue soltado al final del Arrastrar y Soltar – para hacer la acción correspondiente,
y, preferiblemente, saber el receptor sobre el que estamos arrastrando, para resaltarlo.

La solución es algo interesante y un poco complicado, así que vamos a cubrirlo aquí.
¿Cuál puede ser la primera idea? ¿Probablemente configurar mouseover/mouseup en receptores potenciales?
Pero eso no funciona.
El problema es que, mientras estamos arrastrando, el elemento arrastrable siempre está encima de los demás elementos. Y los eventos del ratón solo suceden en el elemento superior, no en los que están debajo.
Por ejemplo, debajo hay dos elementos <div>, el rojo sobre el azul (totalmente cubierto). No hay forma de captar un evento en el azul, porque el rojo está encima:

      
        
        
          
            
          
          
            
          
        
        
          <style>
  div {
    width: 50px;
    height: 50px;
    position: absolute;
    top: 0;
  }
</style>
<div style="background:blue" onmouseover="alert('nunca funciona')"></div>
<div style="background:red" onmouseover="alert('sobre el rojo!')"></div>
        
      
      
          
        
      Lo mismo con un elemento arrastrable. La pelota está siempre sobre los demás elementos, así que los eventos pasan en él. Cualquier manejador que pongamos en los elementos de abajo, no funcionará.
Por eso la idea inicial de poner manejadores en receptores potenciales no funciona en práctica. No se activarán.
Entonces, ¿Qué hacer?
Existe un método llamado document.elementFromPoint(clientX, clientY). Este devuelve el elemento más anidado en las coordenadas relativas a la ventana proporcionada (o null si las coordenadas están fuera de la ventana). Si hay muchos elementos superpuestos en las mismas coordenadas, se devuelve el que está en el tope.
Podemos utilizarlo en cualquiera de nuestros manejadores para detectar los receptores potenciales bajo el puntero, de esta forma:

      
        
        
          // en un manejador de evento del ratón
ball.hidden = true; // (*) ocultar el elemento que arrastramos

let elemBelow = document.elementFromPoint(event.clientX, event.clientY);
// elemBelow es el elemento debajo de la pelota, puede ser receptor

ball.hidden = false;
        
      
      
      Favor notar: necesitamos ocultar la pelota antes de llamar (*). De otra forma usualmente tendremos una pelota con esas coordenadas, ya que es el elemento superior bajo el puntero: elemBelow=ball. Así que lo ocultamos e inmediatamente lo mostramos de nuevo.
Podemos usar este código para verificar el elemento sobre el que estamos “flotando” en todo momento. Y manejar la caída cuando sucede.
Un código extendido de onMouseMove para hallar elementos “receptores”:

      
        
        
          // elemento potencialmente arrastrable sobre el que flotamos ahora mismo
let currentDroppable = null;

function onMouseMove(event) {
  moveAt(event.pageX, event.pageY);

  ball.hidden = true;
  let elemBelow = document.elementFromPoint(event.clientX, event.clientY);
  ball.hidden = false;

  // los eventos mousemove se pueden activar fuera de la ventana (cuando la pelota se arrastra fuera de la ventana)
  // si clientX/clientY están fuera de la ventana, entonces elementFromPoint devuelve null
  if (!elemBelow) return;

  // receptores potenciales se etiquetan con la clase "droppable" (puede tener otra lógica)
  let droppableBelow = elemBelow.closest('.droppable');

  if (currentDroppable != droppableBelow) {
    // estamos flotando dentro o afuera
    // nota: ambos valores pueden ser null
    //   currentDroppable=null si no estábamos sobre un receptor antes de este evento (ej. sobre un espacio en blanco)
    //   droppableBelow=null si no estamos sobre un receptor ahora, durante este evento

    if (currentDroppable) {
      // la lógica para procesar "flying out" del receptor (elimina el resaltado)
      leaveDroppable(currentDroppable);
    }
    currentDroppable = droppableBelow;
    if (currentDroppable) {
      // la lógica para procesar "flying in" del receptor
      enterDroppable(currentDroppable);
    }
  }
}
        
      
      
      En el siguiente ejemplo cuando la pelota se arrastra sobre la portería, esta se resalta.
Resultadostyle.cssindex.html#gate {
  cursor: pointer;
  margin-bottom: 100px;
  width: 83px;
  height: 46px;
}

#ball {
  cursor: pointer;
  width: 40px;
  height: 40px;
}<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <p>Drag the ball.</p>

  <img src="https://en.js.cx/clipart/soccer-gate.svg" id="gate" class="droppable">

  <img src="https://en.js.cx/clipart/ball.svg" id="ball">

  <script>
    let currentDroppable = null;

    ball.onmousedown = function(event) {

      let shiftX = event.clientX - ball.getBoundingClientRect().left;
      let shiftY = event.clientY - ball.getBoundingClientRect().top;

      ball.style.position = 'absolute';
      ball.style.zIndex = 1000;
      document.body.append(ball);

      moveAt(event.pageX, event.pageY);

      function moveAt(pageX, pageY) {
        ball.style.left = pageX - shiftX + 'px';
        ball.style.top = pageY - shiftY + 'px';
      }

      function onMouseMove(event) {
        moveAt(event.pageX, event.pageY);

        ball.hidden = true;
        let elemBelow = document.elementFromPoint(event.clientX, event.clientY);
        ball.hidden = false;

        if (!elemBelow) return;

        let droppableBelow = elemBelow.closest('.droppable');
        if (currentDroppable != droppableBelow) {
          if (currentDroppable) { // null when we were not over a droppable before this event
            leaveDroppable(currentDroppable);
          }
          currentDroppable = droppableBelow;
          if (currentDroppable) { // null if we're not coming over a droppable now
            // (maybe just left the droppable)
            enterDroppable(currentDroppable);
          }
        }
      }

      document.addEventListener('mousemove', onMouseMove);

      ball.onmouseup = function() {
        document.removeEventListener('mousemove', onMouseMove);
        ball.onmouseup = null;
      };

    };

    function enterDroppable(elem) {
      elem.style.background = 'pink';
    }

    function leaveDroppable(elem) {
      elem.style.background = '';
    }

    ball.ondragstart = function() {
      return false;
    };
  </script>


</body>
</html>Ahora tenemos el “destino” actual, sobre el que estamos flotando, en la variable currentDroppable durante el proceso completo y podemos usarlo para resaltar o cualquier otra cosa.
ResumenConsideramos un algoritmo básico de Arrastrar y Soltar.
Los componentes clave:

Flujo de eventos: ball.mousedown → document.mousemove → ball.mouseup (no olvides cancelar el ondragstart nativo).
El inicio del arrastrado – recuerda la posición inicial del puntero relativo al elemento: shiftX/shiftY y lo mantiene durante el arrastrado.
Detectar elementos arrastrables bajo el puntero usando document.elementFromPoint.

Podemos poner mucho sobre esta base.

Con mouseup podemos intelectualmente finalizar el arrastre: cambiar datos, mover elementos alrededor.
Podemos resaltar los elementos sobre los que estamos volando.
Podemos limitar el arrastrado a cierta área o dirección.
Podemos usar delegación de eventos para mousedown/up. Un manejador de eventos para un área grande que compruebe event.target puede manejar Arrastrar y Soltar para cientos de elementos.
Y así por el estilo.

Hay frameworks que construyen una arquitectura sobre esto: DragZone, Droppable, Draggable y otras clases. La mayoría de ellos hacen cosas similares a lo que hemos descrito, así que debería ser fácil entenderlos ahora. O crea el tuyo propio: como puedes ver es fácil de hacer, a veces es más fácil que adaptarse a una solución de terceros.
TareasControl deslizanteimportancia: 5Crea un control deslizante:

    
    
  Arrastra el pasador azul con el ratón y muévelo.
Detalles importantes:

Cuando el botón del ratón es presionado, durante el arrastrado del ratón puedes ir por arriba o debajo de la barra deslizante. Ésta seguirá funcionando (es lo conveniente para el usuario).
Si el ratón se mueve muy rápido hacia la izquierda o la derecha, el pasador se detiene exactamente en el borde.

Abrir un entorno controlado para la tarea.soluciónComo podemos ver en el HTML/CSS, la barra de desplazamiento es un <div> con un fondo de color, que contiene un pasador: otro <div> con position:relative.
Para posicionar el pasador usamos position:relative, para proveer las coordenadas relativas a su padre, aquí es más conveniente que position:absolute.
En este caso implementamos un Arrastrar y Soltar horizontal limitado por el ancho.
Abrir la solución en un entorno controlado.Arrastrar super héroes por el campoimportancia: 5Esta tarea te puede ayudar a comprobar tu entendimiento de varios aspectos de Arrastrar y Soltar, y del DOM.
Hacer que todos los elementos con clase draggable sean arrastrables. Como la pelota de este capítulo.
Requerimientos:

Usa delegación de eventos para detectar el inicio del arrastrado: un solo manejador de eventos en el document para mousedown.
Si los elementos son arrastrados a los bordes superior/inferior de la ventana: la página se desliza hacia arriba/abajo para permitir dicho arrastre.
Sin desplazamiento horizontal (esto hace la tarea un poco más simple, añadirlo es fácil).
Los elementos arrastrables o sus partes nunca deben dejar la ventana, incluso después de movimientos rápidos del ratón.

La demostración es demasiado grande para caber aquí, así que aquí está el enlace.
Demo en nueva ventanaAbrir un entorno controlado para la tarea.soluciónPara arrastrar el elemento podemos usar position:fixed, esto hace las coordenadas más fáciles de manejar. Al final deberíamos devolverla a position:absolute para fijar el elemento en el documento.
Cuando las coordinadas están en el tope/fondo de la ventana, usamos window.scrollTo para desplazarla.
Más detalles en el código, en los comentarios.
Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/mouse-drag-and-drop" 
},
{
	"docs_id": "116",
	"name": "Eventos de puntero",
	"description": "Los eventos de puntero son una forma moderna de manejar la entrada de una variedad de dispositivos señaladores, como un mouse, un lápiz, una pantalla táctil, etc.",
	"content": "Los eventos de puntero son una forma moderna de manejar la entrada de una variedad de dispositivos señaladores, como un mouse, un lápiz, una pantalla táctil, etc.
Una breve historiaHagamos una pequeña descripción general para que comprenda la imagen general y el lugar de los Eventos de Puntero entre otros tipos de eventos.


Hace mucho tiempo, en el pasado, solo existían eventos de mouse.
Luego aparecieron los dispositivos táctiles, teléfonos y tablets en particular. Para que el código antiguo funcionara, generanban (y aún lo hacen) eventos de mouse. Por ejemplo, tocar la pantalla táctil genera mousedown. Así los dispositivos táctiles funcionaban bien con las páginas web.
Pero los dispositivos táctiles tienen más capacidades que un mouse. Por ejemplo, es posible tocar múltiples puntos al mismo (“multi-touch”). Los eventos del mouse no tienen las propiedades necesarias para manejar tal multi-touch.


Por lo tanto, se introdujeron eventos táctiles, como touchstart,touchend, touchmove, que tienen propiedades específicas de toque (no los cubrimos en detalle aquí, porque los eventos de puntero son aún mejores).
Aún así no fue suficiente, ya que hay muchos otros dispositivos, como los lápices, que tienen sus propias funciones. Y escribir código que escuchara ambos eventos, los táctiles y los del mouse, era engorroso.


Para resolver estos problemas, se introdujo el nuevo estándar: Pointer Events. Este proporciona un conjunto único de eventos para todo tipo de dispositivos señaladores.


Al momento la especificación Pointer Events Level 2 es soportada en todos los principales navegadores, mientras que Pointer Events Level 3 está en proceso y es mayormente compatible con Pointer Events level 2.
A menos que codifique para navegadores viejos tales como Internet Explorer 10 o Safari 12 y versiones anteriores, ya no tiene sentido usar el mouse o los eventos táctiles: podemos cambiar a eventos de puntero.
Así tu código funcionará tanto con mouse como con dispositivos táctiles.
Dicho esto, hay peculiaridades importantes, uno debe saber usarlas correctamente y evitar sorpresas adicionales. Les prestaremos atención en este artículo.
Tipos de eventos de punteroLos eventos de puntero se llaman de forma similar a los eventos del mouse:



Evento de puntero
Evento de mouse similar




pointerdown
mousedown


pointerup
mouseup


pointermove
mousemove


pointerover
mouseover


pointerout
mouseout


pointerenter
mouseenter


pointerleave
mouseleave


pointercancel
-


gotpointercapture
-


lostpointercapture
-



Como podemos ver, para cada mouse<event>, hay un pointer<event> que juega un papel similar. También hay 3 eventos de puntero adicionales que no tienen una contraparte correspondiente de mouse ..., pronto hablaremos sobre ellos.

            Remplazando mouse con pointer en nuestro código
            Podemos reemplazar los eventos mouse<event> con pointer<event> en nuestro código y esperar que las cosas sigan funcionando bien con el mouse.
El soporte para dispositivos táctiles mejorará “mágicamente”. Pero probablemente necesitemos agregar la regla touch-action: none en CSS. Cubriremos esto en la sección sobre pointercancel.

Propiedades de los eventos de punteroLos eventos de puntero tienen las mismas propiedades que los eventos del mouse, como clientX/Y, target, etc., más algunos adicionales:


pointerId – el identificador único del puntero que causa el evento.
Generado por el navegador. Permite manejar múltiples punteros, como una pantalla táctil con lápiz y multitáctil (explicado a continuación).


pointerType – el tipo de dispositivo señalador. Debe ser una cadena, uno de los siguientes: “mouse”, “pen” o “touch”.
Podemos usar esta propiedad para reaccionar de manera diferente en varios tipos de punteros.


isPrimary – true para el puntero principal (el primer dedo en multitáctil).


Para punteros que miden un área de contacto y presión, p. Ej. un dedo en la pantalla táctil, las propiedades adicionales pueden ser útiles:

width – el ancho del área donde el puntero (p.ej. el dedo) toca el dispositivo. Si el dispositivo no lo soporta (como el mouse), es siempre 1.
height – el alto del área donde el puntero toca el dispositivo. Donde no lo soporte es siempre 1.
pressure – la presión de la punta del puntero, en el rango de 0 a 1. En dispositivos que no soportan presión, debe ser 0.5 (presionada) o 0.
tangentialPressure – la presión tangencial normalizada.
tiltX, tiltY, twist – propiedades específicas del lápiz que describen cómo se lo coloca en relación con la superficie.

En la mayoría de los dispositivos estas propiedades no están soportadas, por lo que rara vez se utilizan. Si lo necesita puede encontrar los detalles en la especificación.
Multi-touch (Multitáctil)Una de las cosas que los eventos del mouse no soportan es la propiedad multitáctil: un usuario puede tocar en varios lugares a la vez en su teléfono o tableta, realizar gestos especiales.
Los eventos de puntero permiten manejar multitáctiles con la ayuda de las propiedades pointerId e isPrimary.
Esto es lo que sucede cuando un usuario toca una pantalla en un lugar y luego coloca otro dedo en otro lugar:

En el primer toque:

pointerdown with isPrimary=true y algún pointerId.


Para el segundo dedo y toques posteriores (asumiendo que el primero sigue tocando):

pointerdown con isPrimary=false y un diferente pointerId por cada dedo.



Tenga en cuenta: el pointerId no se asigna a todo el dispositivo, sino a cada dedo que se toca. Si usamos 5 dedos para tocar simultáneamente la pantalla, tenemos 5 eventos pointerdown con coordenadas respectivas y diferentes pointerId.
Los eventos asociados con el primer dedo siempre tienen isPrimary = true.
Podemos rastrear el toque de varios dedos usando sus respectivos pointerId. Cuando el usuario mueve un dedo y luego lo quita, obtenemos los eventos pointermove y pointerup con el mismo pointerId que teníamos en pointerdown
Aquí está la demostración que registra los eventos pointerdown y pointerup:

    
        
      
      
    
  Tenga en cuenta que debe utilizar un dispositivo con pantalla táctil, como un teléfono o una tableta, para ver realmente la diferencia en pointerId/isPrimary. Para dispositivos de un solo toque, como el de un mouse, siempre será el mismo pointerId con isPrimary=true para todos los eventos de puntero.
Evento: pointercancelEl evento pointercancel se dispara cuando, mientras hay una interacción de puntero en curso, sucede algo que hace que esta se anule de modo que no se generan más eventos de puntero.
Las causas son:

Se deshabilitó el hardware del dispositivo de puntero.
La orientación del dispositivo cambió (tableta rotada).
El navegador decidió manejar la interacción por su cuenta: porque lo consideró un gesto de mouse, una acción de zoom, o alguna otra cosa.

Demostraremos pointercancel en un ejemplo práctico para ver cómo nos afecta.
Digamos que queremos una implementación de “arrastrar y soltar” en una pelota, como la que está al principio del artículo Arrastrar y Soltar con eventos del ratón.
A continuación, se muestra el flujo de acciones del usuario y los eventos correspondientes:

El usuario presiona sobre una imagen para comenzar a arrastrar

pointerdown el evento se dispara


Luego comienzan a mover el puntero (arrastrando la imagen)

pointermove se dispara, tal vez varias veces


¡Sorpresa! El navegador tiene soporte nativo de arrastrar y soltar para imágenes, este bloquea el nuestro y se hace cargo del proceso de arrastrar y soltar, generando el evento pointercancel.

El navegador ahora maneja arrastrar y soltar la imagen por sí solo. El usuario puede incluso arrastrar la imagen de la bola fuera del navegador, a su programa de correo o al administrador de archivos.
No más eventos pointermove para nosotros.



Así que el problema es que el navegador “secuestra” la interacción: pointercancel se dispara y no se generan más eventos de pointermove.
Aquí la demo con eventos de puntero (solamente arriba/abajo, mover y cancelar) registrados en textarea:

    
        
      
      
    
  Queremos implementar nuestro propio arrastrar y soltar, así que digámosle al navegador que no se haga cargo.
Evitar las acciones predeterminadas del navegador para evitar pointercancel.
Necesitaremos dos cosas:

Evitar que suceda la función nativa de arrastrar y soltar:

Puede hacerlo configurando ball.ondragstart = () => false, tal como se describe en el artículo Arrastrar y Soltar con eventos del ratón.
Eso funciona bien para eventos de mouse.


Para los dispositivos táctiles, también existen acciones del navegador relacionadas con el tacto (además de arrastrar y soltar). Para evitar problemas con ellos también:

Configurar #ball{touch-action: none} en CSS.
Entonces nuestro código comenzará a funcionar en dispositivos táctiles.



Después de hacer eso, los eventos funcionarán según lo previsto, el navegador no secuestrará el proceso y no emitirá ningún pointercancel.
Esta demostración agrega estas líneas:

    
        
      
      
    
  Como puede ver, ya no hay pointercancel.
Ahora podemos agregar el código para mover realmente la bola, y nuestro método de arrastrar y soltar funcionará en dispositivos de mouse y dispositivos táctiles.
Captura del punteroLa captura de puntero es una característica especial de los eventos de puntero.
La idea es muy simple, pero puede verse extraña al principio, porque no existe algo así para ningún otro tipo de evento.
El método principal es:

elem.setPointerCapture(pointerId) – vincula el pointerId dado a elem. Después del llamado todos los eventos de puntero con el mismo pointerId tendrán elem como objetivo (como si ocurrieran sobre elem), no importa dónde hayan ocurrido en realidad.

En otras palabras: elem.setPointerCapture(pointerId) redirige hacia elem todos los eventos subsecuentes que tengan el pointerId dado.
El vínculo se deshace::

automáticamente cuando ocurren los eventos pointerup o pointercancel,
automáticamente cuando elem es quitado del documento,
cuando elem.releasePointerCapture(pointerId) es llamado.

Ahora, ¿para qué es bueno esto? Momento de ver un ejemplo de la vida real.
La captura de puntero puede utilizarse para simplificar interacciones del tipo “arrastrar y soltar”.
Recordemos cómo uno puede implementar un control deslizante personalizado,  descrito en el artículo Arrastrar y Soltar con eventos del ratón.
Podemos hacer un elemento slider que representa la corredera con una perilla thumb dentro.

      
        
        
          <div class="slider">
  <div class="thumb"></div>
</div>
        
      
      
      Con estilos, se ve así:

    
        
      
      
    
  
Esta es la lógica de funcionamientodespués de reemplazar eventos de mouse con sus equivalentes de puntero:

El usuario presiona en el deslizante thumb: se dispara pointerdown
Entonces mueve el puntero: se dispara pointermove y nuestro código mueve el botón thumb a lo largo.

…Mientras el puntero se mueve, puede salirse del control deslizante: que vaya por debajo o por encima de él. El botón debe moverse de forma estrictamente horizontal, permaneciendo alineado con el puntero.



En la solución basada en eventos de mouse, para rastrear todos los movimientos del puntero incluyendo aquellos por arriba o por debajo de thumb, asignamos el controlador de evento mousemove al document entero.
No es la solución más limpia. Uno de los problemas es que cuando el usuario mueve el puntero por el documento puede disparar manejadores de eventos (como mouseover) en otros elementos invocando funcionalidad de interfaz completamente sin relación al deslizante.
Aquí es donde entra en juego setPointerCapture.

Podemos llamar thumb.setPointerCapture(event.pointerId) en el controlador pointerdown,
Entonces futuros eventos de puntero hasta pointerup/cancel serán redirigidos a thumb.
Cuando ocurre pointerup (arrastre finalizado), el vínculo se deshace automáticamente, no necesitamos atender eso.

Entonces, incluso si el usuario mueve el puntero alrededor de todo el documento, los controladores de eventos serán llamados sobre thumb. A pesar de ello las propiedades de coordenadas de los eventos, tales como clientX/clientY aún serán correctas, la captura solo afecta a target/currentTarget.
Aquí está el código esencial:

      
        
        
          thumb.onpointerdown = function(event) {
  // reorienta todos los eventos de puntero (hasta pointerup) a thumb
  thumb.setPointerCapture(event.pointerId);

  // comienza a rastrear movimientos de puntero
  thumb.onpointermove = function(event) {
    // se mueve el control deslizante: escucha a thumb, ya que todos los eventos se redirigen a él
    let newLeft = event.clientX - slider.getBoundingClientRect().left;
    thumb.style.left = newLeft + 'px';
  };

  // on pointer up finaliza el seguimiento
  thumb.onpointerup = function(event) {
    thumb.onpointermove = null;
    thumb.onpointerup = null;
    // ...también procesa "fin de arrastre" si es necesario
  };
};

// nota: no es necesario llamar a thumb.releasePointerCapture,
// esto sucede con el pointerup automáticamente
        
      
      
      La demostración completa:

    
        
      
      
    
  
En el demo, hay un elemento adicional con un controlador onmouseover que muestra la fecha actual.
Nota que mientras arrastras el dial, puedes pasar sobre ese elemento y su controlador no se dispara.
Entonces el arrastre esta ahora libre de efectos secundarios gracias a setPointerCapture.
Finalizando, la captura de puntero nos brinda dos beneficios:

El código se vuelve más claro, ya no necesitamos agregar o quitar controladores para el document entero. El vínculo se deshace automáticamente.
Si hay cualquier otro controlador de evento en el documento, no serán disparados accidentalmente mientras el usuario está arrastrando el deslizante.

Eventos de captura de punteroUna cosa más por mencionar en bien de la exhaustividad.
Hay dos eventos de puntero asociados con la captura de puntero:

gotpointercapture se dispara cuando un elemento usa setPointerCapture para permitir la captura.
lostpointercapture se dispara cuando se libera la captura: ya sea explícitamente con la llamada a releasePointerCapture, o automáticamente con pointerup/pointercancel.

ResumenLos eventos de puntero permiten manejar eventos de mouse, toque y lápiz simultáneamente con una simple pieza de código.
Los eventos de puntero extienden los eventos del mouse. Podemos reemplazar mouse con pointer en los nombres de los eventos y esperar que nuestro código continúe funcionando para el mouse, con mejor soporte para otros tipos de dispositivos.
Para arrastrar y soltar, y complejas interacciones que el navegador pudiera decidir secuestrar y manejar por su cuenta, recuerde cancelar la acción predeterminada sobre eventos y establecer touch-action: none en CSS para los elementos que involucramos.
Las habilidades adicionales de los eventos Pointer son:

Soporte multitáctil usando pointerId y isPrimary.
Propiedades específicas del dispositivo, como pressure, width/height y otras.
Captura de puntero: podemos redirigir todos los eventos de puntero a un elemento específico hasta pointerup/pointercancel.

Al momento los eventos de puntero son compatibles con todos los navegadores principales, por lo que podemos cambiarlos de forma segura si no se necesitan IE10 y Safari 12. E incluso con esos navegadores, existen polyfills que permiten la compatibilidad con eventos de puntero.
",
	"url": "https://es.javascript.info/pointer-events" 
},
{
	"docs_id": "117",
	"name": "Teclado: keydown y keyup",
	"description": "Antes de llegar al teclado, por favor ten en cuenta que en los dispositivos modernos hay otras formas de “ingresar algo”.  Por ejemplo, el uso de reconocimiento de voz (especialmente en dispositivos móviles) o copiar/pegar con el mouse.",
	"content": "Antes de llegar al teclado, por favor ten en cuenta que en los dispositivos modernos hay otras formas de “ingresar algo”.  Por ejemplo, el uso de reconocimiento de voz (especialmente en dispositivos móviles) o copiar/pegar con el mouse.
Entonces, si queremos hacer el seguimiento de cualquier ingreso en un campo <input>, los eventos de teclado no son suficientes. Existe otro evento llamado input para detectar cambios en un campo <input> producidos por cualquier medio. Y puede ser una mejor opción para esa tarea. Lo estudiaremos más adelante, en el capítulo Eventos: change, input, cut, copy, paste.
Los eventos de teclado solo deberían ser usados cuando queremos manejar acciones de teclado (también cuentan los teclados virtuales). Por ejemplo, para reaccionar a las teclas de flecha Up y Down o a atajos de teclado “hotkeys” (incluyendo combinaciones de teclas).
TeststandPara entender mejor los eventos de teclado, puedes usar “teststand” aquí abajo.
Prueba diferentes combinaciones de tecla en el campo de texto.
Resultadoscript.jsstyle.cssindex.htmlkinput.onkeydown = kinput.onkeyup = kinput.onkeypress = handle;

let lastTime = Date.now();

function handle(e) {
  if (form.elements[e.type + 'Ignore'].checked) return;

  area.scrollTop = 1e6;

  let text = e.type +
    ' key=' + e.key +
    ' code=' + e.code +
    (e.shiftKey ? ' shiftKey' : '') +
    (e.ctrlKey ? ' ctrlKey' : '') +
    (e.altKey ? ' altKey' : '') +
    (e.metaKey ? ' metaKey' : '') +
    (e.repeat ? ' (repeat)' : '') +
    "\n";

  if (area.value && Date.now() - lastTime > 250) {
    area.value += new Array(81).join('-') + '\n';
  }
  lastTime = Date.now();

  area.value += text;

  if (form.elements[e.type + 'Stop'].checked) {
    e.preventDefault();
  }
}#kinput {
  font-size: 150%;
  box-sizing: border-box;
  width: 95%;
}

#area {
  width: 95%;
  box-sizing: border-box;
  height: 250px;
  border: 1px solid black;
  display: block;
}

form label {
  display: inline;
  white-space: nowrap;
}<!DOCTYPE HTML>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <form id="form" onsubmit="return false">

    Evitar el predeterminado (prevent default) para:
    <label>
      <input type="checkbox" name="keydownStop" value="1"> keydown</label>&nbsp;&nbsp;&nbsp;
    <label>
      <input type="checkbox" name="keyupStop" value="1"> keyup</label>

    <p>
      Ignore:
      <label>
        <input type="checkbox" name="keydownIgnore" value="1"> keydown</label>&nbsp;&nbsp;&nbsp;
      <label>
        <input type="checkbox" name="keyupIgnore" value="1"> keyup</label>
    </p>

    <p>Haz foco en el campo input y presiona una tecla.</p>

    <input type="text" placeholder="Press keys here" id="kinput">

    <textarea id="area" readonly></textarea>
    <input type="button" value="Clear" onclick="area.value = ''" />
  </form>
  <script src="script.js"></script>


</body>
</html>Keydown y keyupLos eventos keydown ocurren cuando se presiona una tecla, y keyup cuando se suelta.
event.code y event.keyLa propiedad key del objeto de evento permite obtener el carácter, mientras que la propiedad code del evento permite obtener el “código físico de la tecla”.
Por ejemplo, la misma tecla Z puede ser presionada con o sin Shift. Esto nos da dos caracteres diferentes: z minúscula y Z mayúscula.
event.key es el carácter exacto, y será diferente. Pero event.code es el mismo:



Tecla
event.key
event.code




Z
z (minúscula)
KeyZ


Shift+Z
Z (mayúscula)
KeyZ



Si un usuario trabaja con diferentes lenguajes, el cambio a otro lenguaje podría producir un carácter totalmente diferente a "Z". Este se volverá el valor de event.key, mientras que event.code es siempre el mismo: "KeyZ".

            “KeyZ” y otros códigos de tecla
            Cada tecla tiene el código que depende de su ubicación en el teclado. Los códigos de tecla están descritos en la especificación UI Events code.
Por ejemplo:

Las letras tienen códigos como "Key<letter>": "KeyA", "KeyB" etc.
Los dígitos tienen códigos como "Digit<number>": "Digit0", "Digit1" etc.
Las teclas especiales están codificadas por sus nombres: "Enter", "Backspace", "Tab" etc.

Hay varias distribuciones de teclado esparcidos, y la especificación nos da los códigos de tecla para cada una de ellas.
Para más códigos, puedes leer la sección alfanumérica de la especificación, o simplemente presionar una tecla en el teststand arriba.


            La mayúscula importa: es "KeyZ", no "keyZ"
            Parece obvio, pero aún se cometen estos errores.
Por favor evita errores de tipeo: es KeyZ, no keyZ. Una verificación como event.code=="keyZ" no funcionará: la primera letra de "Key" debe estar en mayúscula.

¿Qué pasa si una tecla no da ningún carácter? Por ejemplo, Shift o F1 u otras. Para estas teclas, event.key es aproximadamente lo mismo que event.code:



Key
event.key
event.code




F1
F1
F1


Backspace
Backspace
Backspace


Shift
Shift
ShiftRight or ShiftLeft



Ten en cuenta que event.code especifica con exactitud la tecla que es presionada. Por ejemplo, la mayoría de los teclados tienen dos teclas Shift: una a la izquierda y otra a la derecha. event.code nos dice exactamente cuál fue presionada, en cambio event.key es responsable del “significado” de la tecla: lo que “es” (una “Mayúscula”).
Digamos que queremos manejar un atajo de teclado: Ctrl+Z (o Cmd+Z en Mac). La mayoría de los editores de texto “cuelgan” la acción “Undo” en él. Podemos configurar un “listener” para escuchar el evento keydown y verificar qué tecla es presionada.
Hay un dilema aquí: en ese “listener”, ¿debemos verificar el valor de event.key o el de event.code?
Por un lado, el valor de event.key es un carácter que cambia dependiendo del lenguaje. Si el visitante tiene varios lenguajes en el sistema operativo y los cambia, la misma tecla dará diferentes caracteres. Entonces tiene sentido chequear event.code que es siempre el mismo.
Como aquí:

      
        
        
          
            
          
          
            
          
        
        
          document.addEventListener('keydown', function(event) {
  if (event.code == 'KeyZ' && (event.ctrlKey || event.metaKey)) {
    alert('Undo!')
  }
});
        
      
      
      Por otro lado, hay un problema con event.code. Para diferentes distribuciones de teclado, la misma tecla puede tener diferentes caracteres.
Por ejemplo, aquí abajo mostramos la distribución de EE.UU. “QWERTY” y la alemana “QWERTZ” (de Wikipedia):

      
      
        
      
      
      
      
        
      
      Para la misma tecla, la distribución norteamericana tiene “Z”, mientras que la alemana tiene “Y” (las letras son intercambiadas).
Efectivamente, event.code será igual a KeyZ para las personas con distribución de teclas alemana cuando presionen Y.
Si chequeamos event.code == 'KeyZ' en nuestro código, las personas con distribución alemana pasarán el test cuando presionen Y.
Esto suena realmente extraño, y lo es. La especificación explícitamente menciona este comportamiento.
Entonces, event.code puede coincidir con un carácter equivocado en una distribución inesperada. Las mismas letras en diferentes distribuciones pueden mapear a diferentes teclas físicas, llevando a diferentes códigos. Afortunadamente, ello solo ocurre en algunos códigos, por ejemplo keyA, keyQ, keyZ (que ya hemos visto), y no ocurre con teclas especiales como Shift. Puedes encontrar la lista en la especificación.
Para un seguimiento confiable de caracteres que dependen de la distribución, event.key puede ser una mejor opción.
Por otro lado, event.code tiene el beneficio de quedar siempre igual, ligado a la ubicación física de la tecla. Así los atajos de teclado que dependen de él funcionan bien aunque cambie el lenguaje.
¿Queremos manejar teclas que dependen de la distribución? Entonces event.key es lo adecuado.
¿O queremos que un atajo funcione en el mismo lugar incluso si cambia el lenguaje? Entonces event.code puede ser mejor.
AutorepeticiónSi una tecla es presionada durante suficiente tiempo, comienza a “autorepetirse”: keydown se dispara una y otra vez, y  cuando es soltada finalmente se obtiene keyup. Por ello es normal tener muchos keydown y un solo keyup.
Para eventos disparados por autorepetición, el objeto de evento tiene la propiedad event.repeat establecida a true.
Acciones predeterminadasLas acciones predeterminadas varían, al haber muchas cosas posibles que pueden ser iniciadas por el teclado.
Por ejemplo:

Un carácter aparece en la pantalla (el resultado más obvio).
Un carácter es borrado (tecla Delete).
Un avance de página (tecla PageDown).
El navegador abre el diálogo “guardar página” (Ctrl+S)
…y otras.

Evitar la acción predeterminada en keydown puede cancelar la mayoría de ellos, con la excepción de las teclas especiales basadas en el sistema operativo. Por ejemplo, en Windows la tecla Alt+F4 cierra la ventana actual del navegador. Y no hay forma de detenerla por medio de “evitar la acción predeterminada” de JavaScript.
Por ejemplo, el <input> debajo espera un número telefónico, entonces no acepta teclas excepto dígitos, +, () or -:

      
        
        
          
            
          
          
            
          
        
        
          <script>
function checkPhoneKey(key) {
  return (key >= '0' && key <= '9') || ['+','(',')','-'].includes(key);
}
</script>
<input onkeydown="return checkPhoneKey(event.key)" placeholder="Teléfono, por favor" type="tel">
        
      
      
          
        
      Aquí el manejador onkeydown usa checkPhoneKey para chequear la tecla presionada. Si es válida (de 0..9 o uno de +-()), entonces devuelve true, de otro modo, false.
Como ya sabemos, el valor false devuelto por el manejador de eventos, asignado usando una propiedad DOM o un atributo tal como lo hicimos arriba, evita la acción predeterminada; entonces nada aparece en <input> para las teclas que no pasan el test. (El valor true no afecta en nada, solo importa el valor false)
Ten en cuenta que las teclas especiales como Backspace, Left, Right, no funcionan en el input. Este es un efecto secundario del filtro estricto que hace checkPhoneKey. Estas teclas hacen que devuelva false.
Aliviemos un poco el filtro permitiendo las tecla de flecha Left, Right, y Delete, Backspace:

      
        
        
          
            
          
          
            
          
        
        
          <script>
function checkPhoneKey(key) {
  return (key >= '0' && key <= '9') ||
    ['+','(',')','-','ArrowLeft','ArrowRight','Delete','Backspace'].includes(key);
}
</script>
<input onkeydown="return checkPhoneKey(event.key)" placeholder="Teléfono, por favor" type="tel">
        
      
      
          
        
      Ahora las flechas y el borrado funcionan bien.
Aunque tenemos el filtro de teclas, aún se puede ingresar cualquier cosa usando un mouse y “botón secundario + pegar”. Dispositivos móviles brindan otros medios para ingresar valores. Así que el filtro no es 100% confiable.
Un enfoque alternativo sería vigilar el evento oninput, este se dispara después de cualquier modificación. Allí podemos chequear el nuevo input.value y modificar o resaltar <input> cuando es inválido. O podemos usar ambos manejadores de eventos juntos.
Código heredadoEn el pasado existía un evento keypress, y también las propiedades del objeto evento keyCode, charCode, which.
Al trabajar con ellos había tantas incompatibilidades entre los navegadores que los desarrolladores de la especificación no tuvieron otra alternativa que declararlos obsoletos y crear nuevos y modernos eventos (los descritos arriba en este capítulo). El viejo código todavía funciona porque los navegadores aún lo soportan, pero no hay necesidad de usarlos más, en absoluto.
Teclados en dispositivos móvilesCuando se usan teclados virtuales o los de dispositivos móviles, formalmente conocidos como IME (Input-Method Editor), el estándar W3C establece que la propiedad de KeyboardEvent e.keyCode debe ser 229 y e.key debe ser "Unidentified".
Mientras algunos de estos teclados pueden aún usar los valores correctos para e.key, e.code, e.keyCode…, cuando se presionan ciertas teclas tales como flechas o retroceso no hay garantía, entonces nuestra lógica de teclado podría no siempre funcionar bien en dispositivos móviles.
ResumenPresionar una tecla siempre genera un evento de teclado, sean teclas de símbolos o teclas especiales como Shift o Ctrl y demás. La única excepción es la tecla Fn que a veces está presente en teclados de laptops. No hay un evento de teclado para ella porque suele estar implementado en un nivel más bajo que el del sistema operativo.
Eventos de teclado:

keydown – al presionar la tecla (comienza a autorepetir si la tecla queda presionada por un tiempo),
keyup – al soltar la tecla.

Principales propiedades de evento de teclado:

code – el código de tecla “key code” ("KeyA", "ArrowLeft" y demás), especifica la ubicación física de la tecla en el teclado.
key – el carácter ("A", "a" y demás). Para las teclas que no son de caracteres como Esc, suele tener el mismo valor que code.

En el pasado, los eventos de teclado eran usados para detectar cambios en los campos de formulario. Esto no es confiable, porque el ingreso puede venir desde varias fuentes. Para manejar cualquier ingreso tenemos los eventos input y change (tratados en el capítulo Eventos: change, input, cut, copy, paste). Ellos se disparan después de cualquier clase de ingreso, incluyendo copiar/pegar y el reconocimiento de voz.
Deberíamos usar eventos de teclado solamente cuando realmente queremos el teclado. Por ejemplo, para reaccionar a atajos o a teclas especiales.
TareasExtendiendo atajos de tecladoimportancia: 5Crea una función runOnKeys(func, code1, code2, ... code_n) que ejecute func al presionar simultáneamente las teclas con códigos code1, code2, …, code_n.
Por ejemplo, el siguiente código muestra un alert cuando "Q" y "W" se presionan juntas (en cualquier lenguaje, con o sin mayúscula)

      
        
        
          runOnKeys(
  () => alert("¡Hola!"),
  "KeyQ",
  "KeyW"
);
        
      
      
      Demo en nueva ventanasoluciónDebemos manejar dos eventos: document.onkeydown y document.onkeyup.
Creemos un set pressed = new Set() para registrar las teclas presionads actualmente.
El primer manejador las agrega en él, mientras que el segundo las quita. Con cada keydown verificamos si tenemos suficientes teclas presionadas, y ejecutamos la función si es así.
Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/keyboard-events" 
},
{
	"docs_id": "118",
	"name": "Desplazamiento",
	"description": "El evento scroll permite reaccionar al desplazamiento de una página o elemento. Hay bastantes cosas buenas que podemos hacer aquí.",
	"content": "El evento scroll permite reaccionar al desplazamiento de una página o elemento. Hay bastantes cosas buenas que podemos hacer aquí.
Por ejemplo:

Mostrar/ocultar controles o información adicional según el lugar del documento en el que se encuentre el/la usuario/a.
Cargar más datos cuando el/la usuario/a se desplaza hacia abajo hasta el final del documento.

Aquí hay una pequeña función para mostrar el desplazamiento actual:

      
        
        
          window.addEventListener('scroll', function() {
  document.getElementById('showScroll').innerHTML = window.pageYOffset + 'px';
});
        
      
      
      In action:
Desplazamiento actual = Desplazamiento de la ventana
El evento scroll funciona tanto en window como en los elementos desplazables.
Evitar el desplazamiento¿Qué hacemos para que algo no se pueda desplazar?
No podemos evitar el desplazamiento utilizando event.preventDefault() oyendo al evento onscroll, porque este se activa después de que el desplazamiento haya ocurrido.
Pero podemos prevenir el desplazamiento con event.preventDefault() en un evento que cause el desplazamiento, por ejemplo en el evento keydown para pageUp y pageDown.
Si añadimos un manejador de eventos a estos eventos y un event.preventDefault() en el manejador, entonces el desplazamiento no se iniciará.
Hay muchas maneras de iniciar un desplazamiento, la más fiable es usar CSS, la propiedad overflow.
Aquí hay algunas tareas que puede resolver o revisar para ver aplicaciones de onscroll.
TareasPágina sin finimportancia: 5Crear una página interminable. Cuando un visitante la desplace hasta el final, se auto-añadirá la fecha y hora actual al texto (así el visitante podrá seguir desplazándose)
Así:

    
    
  Por favor tenga en cuenta dos características importantes del desplazamiento:

El scroll es “elástico”. En algunos navegadores/dispositivos podemos desplazarnos un poco más allá del inicio o final del documento (se muestra un espacio vacío abajo, y luego el documento “rebota” automáticamente a la normalidad).
El scroll es impreciso. Cuando nos desplazamos hasta el final de la página, podemos estar de hecho como a 0-50px del fondo del documento real.

Así que, “desplazarse hasta el final” debería significar que el visitante no está a más de 100px del final del documento.
P.D. En la vida real podemos querer mostrar “más mensajes” o “más bienes”.
Abrir un entorno controlado para la tarea.soluciónEl núcleo de la solución es una función que añade más fechas a la página (o carga más cosas en la vida real) mientras estamos en el final de la página.
Podemos llamarlo inmediatamente o agregarlo como un manejador de window.onscroll.
La pregunta más importante es: “¿Cómo detectamos que la página se desplaza hasta el fondo?”
Usaremos las coordenadas de la ventana.
El documento está representado (y contenido) dentro de la etiqueta <html>, que es document.documentElement.
Podemos obtener las coordenadas relativas a la ventana de todo el documento como  document.documentElement.getBoundingClientRect(), la propiedad bottom será la coordenada relativa a la ventana del fondo del documento.
Por ejemplo, si la altura de todo el documento es 2000px, entonces:

      
        
        
          // cuando estamos en la parte superior de la página
//  window-relative top = 0    (relativo a la ventana,  límite superior = 0 )
document.documentElement.getBoundingClientRect().top = 0

// window-relative bottom = 2000    (relativo a la ventana, límite inferior = 2000)
// el documento es largo, así que probablemente esté más allá del fondo de la ventana
document.documentElement.getBoundingClientRect().bottom = 2000
        
      
      
      Si nos desplazamos 500px abajo, entonces:

      
        
        
          // la parte superior del documento está 500px por encima de la ventana
document.documentElement.getBoundingClientRect().top = -500
// la parte inferior del documento está 500px más cerca
document.documentElement.getBoundingClientRect().bottom = 1500
        
      
      
      Cuando nos desplazamos hasta el final, asumiendo que la altura de la venta es 600px:

      
        
        
          // La parte superior del documento está 1400px sobre la ventana
document.documentElement.getBoundingClientRect().top = -1400
// la parte inferior del documento está a 600px debajo de la ventana
document.documentElement.getBoundingClientRect().bottom = 600
        
      
      
      Tened en cuenta que el fondo del documento bottom nunca puede ser 0, porque nunca llega a la parte superior de la ventana. El límite más bajo de la coordenada bottom es la altura de la ventana (asumimos que es 600), no podemos desplazarla más hacia arriba.
Podemos obtener la altura de la ventana con document.documentElement.clientHeight.
Para nuestra tarea, necesitamos saber cuando tenemos el final del documento a unos 100px (esto es: 600-700px, si la altura es de 600).
Así que aquí está la función:

      
        
        
          function populate() {
  while(true)
  {
    // final del documento
    let windowRelativeBottom = document.documentElement.getBoundingClientRect().bottom;

    // si el usuario no se ha desplazado lo suficiente (> 100px hasta el final)
    if (windowRelativeBottom > document.documentElement.clientHeight + 100) break;
      // vamos añadir más datos
      document.body.insertAdjacentHTML("beforeend", `<p>Date: ${new Date()}</p>`);
  }
}
        
      
      
      Abrir la solución en un entorno controlado.Botón para subir/bajarimportancia: 5Crea un botón “ir arriba” para ayudar con el desplazamiento de la página.
Debería funcionar así:

Mientras que la página no se desplace hacia abajo al menos la altura de la ventana… es invisible.
Cuando la página se desplaza hacia abajo más que la altura de la ventana – aparece una flecha “hacia arriba” en la esquina superior izquierda. Si la página se desplaza hacia atrás desaparece.
Cuando se hace click en la flecha, la página se desplaza hacia arriba hasta el tope.

Así (esquina superior izquierda, desplácese para ver):

    
        
      
      
    
  Abrir un entorno controlado para la tarea.soluciónAbrir la solución en un entorno controlado.Cargar imágenes visiblesimportancia: 4Digamos que tenemos un cliente con baja velocidad de conexión y queremos cuidar su tarifa de datos.
Para ello decidimos no mostrar las imágenes inmediatamente, sino sustituirlas por marcadores de posición, como este:

      
        
        
          <img src="placeholder.svg" width="128" height="128" data-src="real.jpg">
        
      
      
      Así que, inicialmente todas las imágenes son placeholder.svg. Cuando la página se desplaza a la posición donde el usuario puede ver la imagen – cambiamos src a data-src, y así la imagen se carga.
Aquí hay un ejemplo en iframe:

    
    
  Desplázate para ver las imágenes cargadas “bajo demanda”.
Requerimientos:

Cuando la página se carga, las imágenes que están en pantalla deben cargarse inmediatamente, antes de cualquier desplazamiento.
Algunas imágenes pueden ser regulares, sin data-src. El código no debe tocarlas.
Una vez que una imagen se carga, no debe recargarse más cuando haya desplazamiento arriba/abajo.

P.D. Si puedes, haz una solución más avanzada para “precargar” las imágenes que están más abajo/después de la posición actual.
Post P.D. Sólo se debe manejar el desplazamiento vertical, no el horizontal.
Abrir un entorno controlado para la tarea.soluciónEl manejador onscroll debería comprobar qué imágenes son visibles y mostrarlas.
También queremos que se ejecute cuando se cargue la página, para detectar las imágenes visibles inmediatamente y cargarlas.
El código debería ejecutarse cuando se cargue el documento, para que tenga acceso a su contenido.
O ponerlo en la parte inferior del <body>:

      
        
        
          // ...el contenido de la página está arriba...

function isVisible(elem) {

  let coords = elem.getBoundingClientRect();

  let windowHeight = document.documentElement.clientHeight;

  // ¿El borde superior del elemento es visible?
  let topVisible = coords.top > 0 && coords.top < windowHeight;

  // ¿El borde inferior del elemento es visible?
  let bottomVisible = coords.bottom < windowHeight && coords.bottom > 0;

  return topVisible || bottomVisible;
}
        
      
      
      La función showVisible() utiliza el control de visibilidad, implementado por isVisible(), para cargar imágenes visibles:

      
        
        
          function showVisible() {
  for (let img of document.querySelectorAll('img')) {
    let realSrc = img.dataset.src;
    if (!realSrc) continue;

    if (isVisible(img)) {
      img.src = realSrc;
      img.dataset.src = '';
    }
  }
}

showVisible();
window.onscroll = showVisible;
        
      
      
      P.D. La solución tiene una variante de isVisible que “precarga” imágenes que están dentro de 1 página por encima/debajo del desplazamiento del documento actual.
Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/onscroll" 
},
{
	"docs_id": "119",
	"name": "Propiedades y Métodos de Formularios",
	"description": "Los formularios y controles, como <input>, tienen muchos eventos y propiedades especiales.",
	"content": "Los formularios y controles, como <input>, tienen muchos eventos y propiedades especiales.
Trabajar con formularios será mucho más conveniente cuando los aprendamos.
Navegación: Formularios y elementosLos formularios del documento son miembros de la colección especial document.forms.
Esa es la llamada “Colección nombrada”: es ambas cosas, nombrada y ordenada. Podemos usar el nombre o el número  en el documento para conseguir el formulario.

      
        
        
          document.forms.my; // el formulario con name="my"
document.forms[0]; // el primer formulario en el documento
        
      
      
      Cuando tenemos un formulario, cualquier elemento se encuentra disponible en la colección nombrada form.elements.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <form name="my">
  <input name="one" value="1">
  <input name="two" value="2">
</form>

<script>
  // obtención del formulario
  let form = document.forms.my; // elemento <form name="my">

  // get the element
  let elem = form.elements.one; // elemento <input name="one">

  alert(elem.value); // 1
</script>
        
      
      
      Puede haber múltiples elementos con el mismo nombre. Esto es típico en el caso de los botones de radio y checkboxes.
En ese caso form.elements[name] es una colección. Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <form>
  <input type="radio" name="age" value="10">
  <input type="radio" name="age" value="20">
</form>

<script>
let form = document.forms[0];

let ageElems = form.elements.age;

alert(ageElems[0]); // [object HTMLInputElement]
</script>
        
      
      
      Estas propiedades de navegación no dependen de la estructura de las etiquetas. Todos los controles, sin importar qué tan profundos se encuentren en el formulario, están disponibles en form.elements.

            Fieldsets como “sub-formularios”
            Un formulario puede tener uno o varios elementos <fieldset> dentro. Estos también tienen la propiedad elements que lista los controles del formulario dentro de ellos.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <body>
  <form id="form">
    <fieldset name="userFields">
      <legend>info</legend>
      <input name="login" type="text">
    </fieldset>
  </form>

  <script>
    alert(form.elements.login); // <input name="login">

    let fieldset = form.elements.userFields;
    alert(fieldset); // HTMLFieldSetElement

    // podemos obtener el input por su nombre tanto desde el formulario como desde el fieldset
    alert(fieldset.elements.login == form.elements.login); // true
  </script>
</body>
        
      
      
      

            Notación corta: form.name
            Hay una notación corta: podemos acceder el elemento como form[index/name].
En otras palabras, en lugar de form.elements.login podemos escribir form.login.
Esto también funciona, pero tiene un error menor: si accedemos un elemento, y cambiamos su name, se mantendrá disponible mediante el nombre anterior (así como mediante el nuevo).
Esto es fácil de ver en un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <form id="form">
  <input name="login">
</form>

<script>
  alert(form.elements.login == form.login); // true, el mismo <input>

  form.login.name = "username"; // cambiamos el nombre el <input>

  // form.elements actualiza el nombre:
  alert(form.elements.login); // undefined
  alert(form.elements.username); // input

  // form permite ambos nombres: el nuevo y el viejo
  alert(form.username == form.login); // true
</script>
        
      
      
      Esto usualmente no es un problema, porque raramente se cambian los nombres de los elementos de un formulario.

Referencia inversa: element.formPara cualquier elemento, el formulario está disponible como element.form. Así que un formulario referencia todos los elementos, y los elementos referencian el formulario.
Aquí la imagen:

      
      
        
      
      Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <form id="form">
  <input type="text" name="login">
</form>

<script>
  // form -> element
  let login = form.login;

  // element -> form
  alert(login.form); // HTMLFormElement
</script>
        
      
      
      Elementos del formularioHablemos de los controles de los formularios.
input y textareaPodemos acceder sus valores como input.value (cadena) o input.checked (booleano) para casillas de verificación (checkboxes) y botones de opción (radio buttons).
De esta manera:

      
        
        
          input.value = "New value";
textarea.value = "New text";

input.checked = true; // para checkboxes o radios
        
      
      
      
            Usa textarea.value, no textarea.innerHTML
            Observa que incluso aunque <textarea>...</textarea> contenga su valor como HTML anidado, nunca deberíamos usar textarea.innerHTML para acceder a él.
Esto solo guarda el HTML que había inicialmente en la página, no su valor actual.

select y optionUn elemento <select> tiene 3 propiedades importantes:

select.options – la colección de subelementos <option>,
select.value – el valor del <option> seleccionado actualmente, y
select.selectedIndex – el número del <option> seleccionado actualmente.

Ellas proveen tres formas diferentes de asignar un valor para un elemento <select>:

Encontrar el elemento <option> correspondiente (por ejemplo entre select.options) y asignar a su option.selected un true.
Si conocemos un nuevo valor: Asignar tal valor a select.value.
Si conocemos el nuevo número de opción: Asignar tal número a select.selectedIndex.

Aquí hay un ejemplo de los tres métodos:

      
        
        
          
            
          
          
            
          
        
        
          <select id="select">
  <option value="apple">Apple</option>
  <option value="pear">Pear</option>
  <option value="banana">Banana</option>
</select>

<script>
  // las tres líneas hacen lo mismo
  select.options[2].selected = true;
  select.selectedIndex = 2;
  select.value = 'banana';
  // Recuerda que las opciones comienzan en cero, así que index 2 significa la tercera opción.
</script>
        
      
      
      A diferencia de la mayoría de controles, <select> permite seleccionar múltiples opciones a la vez si tiene el atributo multiple. Esta característica es raramente utilizada.
En ese caso, necesitamos usar la primera forma: Añade/elimina la propiedad selected de los subelementos <option>.
Podemos obtener su colección como select.options, por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <select id="select" multiple>
  <option value="blues" selected>Blues</option>
  <option value="rock" selected>Rock</option>
  <option value="classic">Classic</option>
</select>

<script>
  // obtener todos los valores seleccionados del multi-select
  let selected = Array.from(select.options)
    .filter(option => option.selected)
    .map(option => option.value);

  alert(selected); // blues,rock
</script>
        
      
      
      La especificación completa del elemento <select> está disponible en la especificación https://html.spec.whatwg.org/multipage/forms.html#the-select-element.
new OptionEn la especificación hay una sintaxis muy corta para crear elementos <option>:

      
        
        
          option = new Option(text, value, defaultSelected, selected);
        
      
      
      Esta sintaxis es opcional. Podemos usar document.createElement('option') y asignar atributos manualmente. Aún puede ser más corta, aquí los parámetros:

text – el texto dentro del option,
value – el valor del option,
defaultSelected – si es true, entonces se le crea el atributo HTML selected,
selected – si es true, el option se selecciona.

La diferencia entre defaultSelected y selected es que defaultSelected asigna el atributo HTML, el que podemos obtener usando option.getAttribute('selected'),  mientras que selected hace que el option esté o no seleccionado.
En la práctica, uno debería usualmente establecer ambos valores en true o false. O simplemente omitirlos, quedarán con el predeterminado false.
Por ejemplo, aquí creamos un nuevo Option “unselected”:

      
        
        
          let option = new Option("Text", "value");
// crea <option value="value">Text</option>
        
      
      
      El mismo elemento, pero seleccionado:

      
        
        
          let option = new Option("Text", "value", true, true);
        
      
      
      Los elementos Option tienen propiedades:

option.selected
Es el option seleccionado.
option.index
El número del option respecto a los demás en su <select>.
option.text
El contenido del option (visto por el visitante).

Referencias
Especificación: https://html.spec.whatwg.org/multipage/forms.html.

ResumenNavegación de formularios:

document.forms
Un formulario está disponible como document.forms[name/index].
form.elements
Los elementos del formulario están disponibles como form.elements[name/index], o puedes usar solo form[name/index]. La propiedad elements también funciona para los <fieldset>.
element.form
Los elementos referencian a su formulario en la propiedad form.

El valor está disponible con input.value, textarea.value, select.value etc.  Para checkboxes y radios, usa input.checked para determinar si el valor está seleccionado.
Para <select> también podemos obtener el valor con el índice select.selectedIndex o a través de la colección de opciones select.options.
Esto es lo básico para empezar a trabajar con formularios. Conoceremos muchos ejemplos más adelante en el tutorial.
En el siguiente capítulo vamos a hablar sobre los eventos focus y blur que pueden ocurrir en cualquier elemento, pero son manejados mayormente en formularios.
TareasAñade una opción al selectimportancia: 5Tenemos un <select>:

      
        
        
          <select id="genres">
  <option value="rock">Rock</option>
  <option value="blues" selected>Blues</option>
</select>
        
      
      
      Utiliza JavaScript para:

Mostrar el valor y el texto del option seleccionado.
Añadir un option: <option value="classic">Classic</option>.
Seleccionarlo.

Nota, si haz hecho todo bien, tu alert debería mostrar blues.
soluciónLa solución, paso a paso:

      
        
        
          
            
          
          
            
          
        
        
          <select id="genres">
  <option value="rock">Rock</option>
  <option value="blues" selected>Blues</option>
</select>

<script>
  // 1)
  let selectedOption = genres.options[genres.selectedIndex];
  alert( selectedOption.value );

  // 2)
  let newOption = new Option("Classic", "classic");
  genres.append(newOption);

  // 3)
  newOption.selected = true;
</script>
        
      
      
      ",
	"url": "https://es.javascript.info/form-elements" 
},
{
	"docs_id": "120",
	"name": "Enfocado: enfoque/desenfoque",
	"description": "Un elemento se enfoca cuando el usuario hace click sobre él o al pulsar Tab en el teclado. Existen también un atributo autofocus de HTML que enfoca un elemento por defecto cuando una página carga, y otros medios de conseguir el enfoque.",
	"content": "Un elemento se enfoca cuando el usuario hace click sobre él o al pulsar Tab en el teclado. Existen también un atributo autofocus de HTML que enfoca un elemento por defecto cuando una página carga, y otros medios de conseguir el enfoque.
Enfocarse sobre un elemento generalmente significa: “prepárate para aceptar estos datos”, por lo que es el momento en el cual podemos correr el código para inicializar la funcionalidad requerida.
El momento de desenfoque (“blur”) puede ser incluso más importante. Ocurre cuando un usuario clica en otro punto o presiona Tab para ir al siguiente campo de un formulario. También hay otras maneras.
Perder el foco o desenfocarse generalmente significa: “los datos ya han sido introducidos”, entonces podemos correr el código para comprobarlo, o para guardarlo en el servidor, etc.
Existen importantes peculiaridades al trabajar con eventos de enfoque. Haremos lo posible para abarcarlas a continuación.
Eventos focus/blurEl evento focus es llamado al enfocar, y el blur cuando el elemento pierde el foco.
Utilicémoslos para la validación de un campo de entrada.
En el ejemplo a continuación:

El manejador blur comprueba si se ha introducido un correo, y en caso contrario muestra un error.
El manejador focus esconde el mensaje de error (en blur se volverá a comprobar):


      
        
        
          
            
          
          
            
          
        
        
          <style>
  .invalid { border-color: red; }
  #error { color: red }
</style>

Su correo por favor: <input type="email" id="input">

<div id="error"></div>

<script>
input.onblur = function() {
  if (!input.value.includes('@')) { // not email
    input.classList.add('invalid');
    error.innerHTML = 'Por favor introduzca un correo válido.'
  }
};

input.onfocus = function() {
  if (this.classList.contains('invalid')) {
    // quitar la  indicación "error", porque el usuario quiere reintroducir algo
    this.classList.remove('invalid');
    error.innerHTML = "";
  }
};
</script>
        
      
      
          
        
      El HTML actual nos permite efectuar diversas validaciones utilizando atributos de entrada: required, pattern, etc. Y muchas veces son todo lo que necesitamos. JavaScript puede ser utilizado cuando queremos más flexibilidad. También podríamos enviar automáticamente el valor modificado al servidor si es correcto.
Métodos focus/blurLos métodos elem.focus() y elem.blur() ponen/quitan el foco sobre el elemento.
Por ejemplo, impidamos al visitante que deje la entrada si el valor es inválido:

      
        
        
          
            
          
          
            
          
        
        
          <style>
  .error {
    background: red;
  }
</style>

Su correo por favor: <input type="email" id="input">
<input type="text" style="width:220px" placeholder="hacer que el correo sea inválido y tratar de enfocar aquí">

<script>
  input.onblur = function() {
    if (!this.value.includes('@')) { // no es un correo
      // mostrar error
      this.classList.add("error");
      // ...y volver a enfocar
      input.focus();
    } else {
      this.classList.remove("error");
    }
  };
</script>
        
      
      
          
        
      Funciona en todos los navegadores excepto Firefox (bug).
Si introducimos algo en la entrada y luego intentamos pulsar Tab o hacer click fuera del <input>, entonces onblur lo vuelve a enfocar.
Por favor tened en cuenta que no podemos “prevenir perder el foco” llamando a event.preventDefault() en onblur, porque onblur funciona después de que el elemento perdió el foco.
Aunque en la práctica uno debería pensarlo bien antes de implementar algo como esto, porque generalmente debemos mostrar errores al usuario pero no evitar que siga adelante al llenar nuestro formulario. Podría querer llenar otros campos primero.

            Pérdida de foco iniciada por JavaScript
            Una pérdida de foco puede ocurrir por diversas razones.
Una de ellas ocurre cuando el visitante clica en algún otro lado. Pero el propio JavaScript podría causarlo, por ejemplo:

Un alert traslada el foco hacia sí mismo, lo que causa la pérdida de foco sobre el elemento (evento blur). Y cuando el alert es cerrado, el foco vuelve (evento focus).
Si un elemento es eliminado del DOM, también causa pérdida de foco. Si es reinsertado el foco no vuelve.

Estas situaciones a veces causan que los manejadores focus/blur no funcionen adecuadamente y se activen cuando no son necesarios.
Es recomendable tener cuidado al utilizar estos eventos. Si queremos monitorear pérdidas de foco iniciadas por el usuario deberíamos evitar causarlas nosotros mismos.

Permitir enfocado sobre cualquier elemento: tabindexPor defecto, muchos elementos no permiten enfoque.
La lista varía un poco entre navegadores, pero una cosa es siempre cierta: focus/blur está garantizado para elementos con los que el visitante puede interactuar: <button>, <input>, <select>, <a>, etc.
En cambio, elementos que existen para formatear algo, tales como <div>, <span>, <table>, por defecto no son posibles de enfocar. El método elem.focus() no funciona en ellos, y los eventos focus/blur no son desencadenados.
Esto puede ser modificado usando el atributo HTML tabindex.
Cualquier elemento se vuelve enfocable si contiene tabindex. El valor del atributo es el número de orden del elemento cuando Tab (o algo similar) es utilizado para cambiar entre ellos.
Es decir: si tenemos dos elementos donde el primero contiene tabindex="1" y el segundo contiene tabindex="2", al presionar Tab estando situado sobre el primer elemento se traslada el foco al segundo.
El orden de cambio es el siguiente: los elementos con tabindex de valor “1” y mayores tienen prioridad (en el orden tabindex) y después los elementos sin tabindex (por ejemplo un  estándar).
Elementos sin el tabindex correspondiente van cambiando en el orden del código fuente del documento (el orden por defecto).
Existen dos valores especiales:

tabindex="0" incluye al elemento entre los que carecen de tabindex. Esto es, cuando cambiamos entre elementos, elementos con tabindex="0" van después de elementos con tabindex ≥ "1".

Habitualmente se utiliza para hacer que un elemento sea enfocable y a la vez mantener intacto el orden de cambio por defecto. Para hacer que un elemento sea parte del formulario a la par con .

tabindex="-1" permite enfocar un elemento solamente a través de código. Tab ignora estos elementos, pero el método elem.focus() funciona.

Por ejemplo, he aquí una lista. Clique sobre el primer ítem y pulse Tab:

      
        
        
          Clique sobre el primer ítem y pulse `key:Tab`. Fíjese en el orden. Note que subsiguientes `key:Tab` pueden desplazar el foco fuera del iframe en el ejemplo.
<ul>
  <li tabindex="1">Uno</li>
  <li tabindex="0">Cero</li>
  <li tabindex="2">Dos</li>
  <li tabindex="-1">Menos uno</li>
</ul>

<style>
  li { cursor: pointer; }
  :focus { outline: 1px dashed green; }
</style>
        
      
      
          
        
      El orden es el siguiente: 1 - 2 - 0. Normalmente, <li> no admite enfocado pero tabindex lo habilita, junto con eventos y estilado con :focus.

            La propiedad elem.tabIndex también funciona
            Podemos añadir tabindex desde JavaScript utilizando la propiedad elem.tabIndex. Se consigue el mismo resultado.

Delegación: focusin/focusoutLos eventos focus y blur no se propagan.
Por ejemplo, no podemos añadir onfocus en  para resaltarlo, así:

      
        
        
          <!-- enfocando en el formulario -- añadir la clase -->
<form onfocus="this.className='focused'">
  <input type="text" name="name" value="Name">
  <input type="text" name="surname" value="Surname">
</form>

<style> .focused { outline: 1px solid red; } </style>
        
      
      
          
        
      El ejemplo anterior no funciona porque cuando el usuario enfoca sobre un  el evento ´focus´ se dispara solamente sobre esa entrada y no se propaga, por lo que form.onfocus nunca se dispara.
Existen dos soluciones.
Primera: hay una peculiar característica histórica: focus/blur no se propagan hacia arriba, pero lo hacen hacia abajo en la fase de captura.
Esto funcionará:

      
        
        
          <form id="form">
  <input type="text" name="name" value="Name">
  <input type="text" name="surname" value="Surname">
</form>

<style> .focused { outline: 1px solid red; } </style>

<script>
  // pon el manejador en fase de captura (último argumento "verdadero")
  form.addEventListener("focus", () => form.classList.add('focused'), true);
  form.addEventListener("blur", () => form.classList.remove('focused'), true);
</script>
        
      
      
          
        
      Segunda: existen los eventos focusin y focusout, exactamente iguales a focus/blur, pero se propagan.
Hay que tener en cuenta que han de asignarse utilizando elem.addEventListener, no on<event>.
La otra opción que funciona:

      
        
        
          <form id="form">
  <input type="text" name="name" value="Name">
  <input type="text" name="surname" value="Surname">
</form>

<style> .focused { outline: 1px solid red; } </style>

<script>
  form.addEventListener("focusin", () => form.classList.add('focused'));
  form.addEventListener("focusout", () => form.classList.remove('focused'));
</script>
        
      
      
          
        
      ResumenLos eventos focus y blur hacen que un elemento se enfoque/pierda el foco.
Se caracterizan por lo siguiente:

No se propagan. En su lugar se puede capturar el estado o usar focusin/focusout.
La mayoría de los elementos no permiten enfoque por defecto. Utiliza tabindex para hacer cualquier elemento enfocable.

El elemento que en el momento tiene el foco está disponible como document.activeElement.
TareasUn div editableimportancia: 5Crea un <div> que se vuelva <textarea> cuando es clicado.
El textarea permite editar HTML en <div>.
Cuando el usuario presiona Enter o se pierde el foco, el <textarea> se vuelve <div> de nuevo, y su contenido se vuelve el HTML del <div>.
Demo en nueva ventanaAbrir un entorno controlado para la tarea.soluciónAbrir la solución en un entorno controlado.Editar TD al clicarimportancia: 5Haz las celdas de la tabla editables al clicarlas.

Al clicar, la celda se vuelve “editable” (aparece un textarea dentro), y podemos cambiar el HTML. No debe haber cambios de tamaño, la geometría debe conservarse.
Bajo la celda aparecen los botones OK y CANCEL para terminar/cancelar la edición.
Solo una celda a la vez puede ser editable. Mientras un <td> esté en “modo de edición”, los clics en otras celdas son ignorados.
La tabla puede tener varias celdas. Usa delegación de eventos.

El demo:

    
    
  Abrir un entorno controlado para la tarea.solución
Al clicar (onclick) se reemplaza el innerHTML de la celda por un <textarea> com los mismos tamaños y sin bordes. Se puede usar JavaScript o CSS para establecer el tamaño correcto.
Establece textarea.value a td.innerHTML.
Pone el foco en textarea.
Muestra los botones OK/CANCEL bajo la celda, y maneja los clics en ellos.

Abrir la solución en un entorno controlado.Ratón manejado por tecladoimportancia: 4Enfoca el ratón. Luego usa las flechas del teclado para moverlo:
Demo en nueva ventanaP.S. No pongas manejadores de eventos en ningún lado excepto el elemento #mouse.
P.P.S. No modifiques HTML/CSS, el proceso debe ser genérico y trabajar con cualquier elemento.
Abrir un entorno controlado para la tarea.soluciónPodemos usar mouse.onclick para manejar el clic y hacer el ratón “movible” con position:fixed, y luego mouse.onkeydown para manejar las flechas del teclado.
La única trampa es que keydown solo se dispara en elementos con foco. Así que necesitamos agregar tabindex al elemento. Como un requisito es no cambiar el HTML, podemos usar la propiedad mouse.tabIndex para eso.
P.S. También podemos reemplazar mouse.onclick con mouse.onfocus.
Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/focus-blur" 
},
{
	"docs_id": "121",
	"name": "Eventos: change, input, cut, copy, paste",
	"description": "Veamos varios eventos que acompañan la actualización de datos.",
	"content": "Veamos varios eventos que acompañan la actualización de datos.
Evento: changeEl evento change se activa cuando el elemento finaliza un cambio.
Para ingreso de texto significa que el evento ocurre cuando se pierde foco en el elemento.
Por ejemplo, mientras estamos escribiendo en el siguiente cuadro de texto, no hay evento. Pero cuando movemos el focus (enfoque) a otro lado, por ejemplo hacemos click en un botón, entonces ocurre el evento change:

      
        
        
          
            
          
          
            
          
        
        
          <input type="text" onchange="alert(this.value)">
<input type="button" value="Button">
        
      
      
          
        
      Para otros elementos: select, input type=checkbox/radio se dispara inmediatamente después de cambiar la opción seleccionada:

      
        
        
          
            
          
          
            
          
        
        
          <select onchange="alert(this.value)">
  <option value="">Select something</option>
  <option value="1">Option 1</option>
  <option value="2">Option 2</option>
  <option value="3">Option 3</option>
</select>
        
      
      
          
        
      Evento: inputEl evento input se dispara cada vez que un valor es modificado por el usuario.
A diferencia de los eventos de teclado, ocurre con el cambio a cualquier valor, incluso aquellos que no involucran acciones de teclado: copiar/pegar con el mouse o usar reconocimiento de voz para dictar texto.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <input type="text" id="input"> oninput: <span id="result"></span>
<script>
  input.oninput = function() {
    result.innerHTML = input.value;
  };
</script>
        
      
      
          
        
      Si queremos manejar cualquier modificación en un <input> entonces este evento es la mejor opción.
Por otro lado, el evento input no se activa con entradas del teclado u otras acciones que no involucren modificar un valor, por ejemplo presionar las flechas de dirección ⇦ ⇨ mientras se está en el input.

            No podemos prevenir nada en oninput
            El evento input se dispara después de que el valor es modificado.
Por lo tanto no podemos usar event.preventDefault() aquí, es demasiado tarde y no tendría efecto.

Eventos: cut, copy, pasteEstos eventos ocurren al cortar/copiar/pegar un valor.
Estos pertenecen a la clase ClipboardEvent y dan acceso a los datos cortados/copiados/pegados.
También podemos usar event.preventDefault() para cancelar la acción y que nada sea cortado/copiado/pegado.
El siguiente código también evita todo evento cut/copy/paste y muestra qué es los que estamos intentando cortar/copiar/pegar:

      
        
        
          
            
          
          
            
          
        
        
          <input type="text" id="input">
<script>
  input.onpaste = function(event) {
    alert("paste: " + event.clipboardData.getData('text/plain'));
    event.preventDefault();
  };

  input.oncut = input.oncopy = function(event) {
    alert(event.type + '-' + document.getSelection());
    event.preventDefault();
  };
</script>
        
      
      
          
        
      Nota que dentro de los manejadores cut y copy, llamar a event.clipboardData.getData(...) devuelve  un string vacío. Esto es porque el dato no está en el portapapeles aún. Y si usamos event.preventDefault() no será copiado en absoluto.
Por ello el ejemplo arriba usa document.getSelection() para obtener el texto seleccionado. Puedes encontrar más detalles acerca de selección en el artículo Selection y Range.
No solo es posible copiar/pegar texto, sino cualquier cosa. Por ejemplo, podemos copiar un archivo en el gestor de archivos del SO y pegarlo.
Esto es porque clipboardData implementa la interfaz DataTransfer, usada comúnmente para “arrastrar y soltar” y “copiar y pegar”. Ahora esto está fuera de nuestro objetivo, pero puedes encontrar sus métodos en la especificación DataTransfer.
Hay además una API asincrónica adicional para acceso al portapapeles: navigator.clipboard. Más en la especificación Clipboard API and events, no soportado en Firefox.
Restricciones de seguridadEl portapapeles es algo a nivel “global” del SO. Un usuario puede alternar entre ventanas, copiar y pegar diferentes cosas, y el navegador no debería ver todo eso.
Por ello la mayoría de los navegadores dan acceso al portapapeles únicamente bajo determinadas acciones del usuario, como copiar y pegar.
Está prohibido generar eventos “personalizados” del portapapeles con dispatchEvent en todos los navegadores excepto Firefox. Incluso si logramos enviar tal evento, la especificación establece que tal evento “sintético” no debe brindar acceso al portapapeles.
Incluso si alguien decide guardar event.clipboardData en un manejador de evento para accederlo luego, esto no funcionará.
Para reiterar, event.clipboardData funciona únicamente en el contexto de manejadores de eventos iniciados por el usuario.
Por otro lado, navigator.clipboard es una API más reciente, pensada para el uso en cualquier contexto. Esta pide autorización al usuario cuando la necesita.
ResumenEventos de modificación de datos:



Evento
Descripción
Especiales




change
Un valor fue cambiado.
En ingreso de texto, se dispara cuando el elemento pierde el foco


input
Cada cambio de entrada de texto
Se dispara de inmediato con cada cambio, a diferencia de change.


cut/copy/paste
Acciones cortar/copiar/pegar
La acción puede ser cancelada. La propiedad event.clipboardData brinda acceso al portapeles. Todos los navegadores excepto Firefox también soportan navigator.clipboard.



TareasCalculadora de depósitoimportancia: 5Crea una interfaz que permita ingresar una suma de depósito bancario y porcentaje, luego calcula cuánto será después de un periodo de tiempo determinado.
Acá una demostración:

    
    
  Cualquier modificación debe ser procesada de inmediato.
La fórmula es:

      
        
        
          // initial: la suma inicial de dinero
// interest: e.g. 0.05 significa 5% anual
// years: cuántos años esperar
let result = Math.round(initial * (1 + interest) ** years);
        
      
      
      Abrir un entorno controlado para la tarea.soluciónAbrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/events-change-input" 
},
{
	"docs_id": "122",
	"name": "Formularios: evento y método submit",
	"description": "El evento submit se activa cuando el formulario es enviado, normalmente se utiliza para validar el formulario antes de ser enviado al servidor o bien para abortar el envío y procesarlo con JavaScript.",
	"content": "El evento submit se activa cuando el formulario es enviado, normalmente se utiliza para validar el formulario antes de ser enviado al servidor o bien para abortar el envío y procesarlo con JavaScript.
El método form.submit() permite iniciar el envío del formulario mediante JavaScript. Podemos utilizarlo para crear y enviar nuestros propios formularios al servidor.
Veamos más detalles sobre ellos.
Evento: submitMayormente un formulario puede enviarse de dos maneras:

La primera – Haciendo click en <input type="submit"> o en <input type="image">.
La segunda – Pulsando la tecla Enter en un campo del formulario.

Ambas acciones causan que el evento submit sea activado en el formulario. El handler puede comprobar los datos, y si hay errores, mostrarlos e invocar event.preventDefault(), entonces el formulario no será enviado al servidor.
En el formulario de abajo:

Ve al campo tipo texto y pulsa la tecla Enter.
Haz click en <input type="submit">.

Ambas acciones muestran alert y el formulario no es enviado debido a la presencia de return false:

      
        
        
          <form onsubmit="alert('submit!');return false">
  Primero: Enter en el campo de texto <input type="text" value="texto"><br>
  Segundo: Click en "submit": <input type="submit" value="Submit">
</form>
        
      
      
          
        
      
            Relación entre submit y click
            Cuando un formulario es enviado utilizando Enter en un campo tipo texto, un evento click se genera en el <input type="submit">
Muy curioso, dado que no hubo ningún click en absoluto.
Aquí esta la demo:

      
        
        
          <form onsubmit="return false">
 <input type="text" size="30" value="Sitúa el cursor aquí y pulsa Enter">
 <input type="submit" value="Submit" onclick="alert('click')">
</form>
        
      
      
          
        
      
Método: submitPara enviar un formulario al servidor manualmente, podemos usar form.submit().
Entonces el evento submit no será generado. Se asume que si el programador llama form.submit(), entonces el script ya realizó todo el procesamiento relacionado.
A veces es usado para crear y enviar un formulario manualmente, como en este ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let form = document.createElement('form');
form.action = 'https://google.com/search';
form.method = 'GET';

form.innerHTML = '<input name="q" value="test">';

// el formulario debe estar en el document para poder enviarlo
document.body.append(form);

form.submit();
        
      
      
      TareasFormulario modalimportancia: 5Crea una función showPrompt(html, callback)  que muestre un formulario con el mensaje html, un campo input y botones OK/CANCELAR.

Un usuario debe escribir algo en el campo de texto y pulsar Enter o el botón OK, entonces callback(value) es llamado con el valor introducido.
En caso contrario, si el usuario pulsa Esc o CANCELAR, entonces callback(null) es llamado.

En ambos casos se finaliza el proceso se y borra el formulario.
Requisitos:

El formulario debe estar en el centro de la ventana.
El formulario es modal. Es decir que no habrá interacción con el resto de la página, siempre que sea posible, hasta que el usuario lo cierre.
Cuando se muestra el formulario, el foco debe estar en el <input> del usuario.
Las teclas Tab/Shift+Tab deben alternar el foco entre los diferentes campos del formulario, no se permite cambiar el foco a otros elementos de la página.

Ejemplo de uso:

      
        
        
          showPrompt("Escribe algo<br>...inteligente :)", function(value) {
  alert(value);
});
        
      
      
      Demo en el iframe:

    
    
  P.S. El código fuente tiene el HTML/CSS para el formulario con posición fija. Pero tú decides cómo haces el modal.
Abrir un entorno controlado para la tarea.soluciónUna ventana modal puede ser implementada utilizando un <div id="cover-div"> semi-transparente que cubra completamente la ventana, como a continuación:

      
        
        
          #cover-div {
  position: fixed;
  top: 0;
  left: 0;
  z-index: 9000;
  width: 100%;
  height: 100%;
  background-color: gray;
  opacity: 0.3;
}
        
      
      
      Debido a que el <div> cubre toda la ventana, recibe todos los clicks, en vez de la página tras él.
También podemos evitar el scroll en la página utilizando body.style.overflowY='hidden'.
El formulario no debe estar en el <div> sino junto a él, porque no queremos que tenga opacity.
Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/forms-submit" 
},
{
	"docs_id": "123",
	"name": "Página: DOMContentLoaded, load, beforeunload, unload",
	"description": "El ciclo de vida de una página HTML tiene tres eventos importantes:",
	"content": "El ciclo de vida de una página HTML tiene tres eventos importantes:

DOMContentLoaded – el navegador HTML está completamente cargado y el árbol DOM está construido, pero es posible que los recursos externos como <img> y hojas de estilo aún no se hayan cargado.
load – no solo se cargó el HTML, sino también todos los recursos externos: imágenes, estilos, etc.
beforeunload/unload – el usuario sale de la pagina.

Cada evento puede ser útil:

Evento DOMContentLoaded – DOM está listo, por lo que el controlador puede buscar nodos DOM, inicializar la interfaz.
Evento load – se cargan recursos externos, por lo que se aplican estilos, se conocen tamaños de imagen, etc.
Evento beforeunload – el usuario se va: podemos comprobar si el usuario guardó los cambios y preguntarle si realmente quiere irse.
Evento unload – el usuario casi se fue, pero aún podemos iniciar algunas operaciones, como enviar estadísticas.

Exploremos los detalles de estos eventos.
DOMContentLoadedEl evento DOMContentLoaded ocurre en el objeto document.
Debemos usar addEventListener para capturarlo:

      
        
        
          document.addEventListener("DOMContentLoaded", ready);
// no "document.onDOMContentLoaded = ..."
        
      
      
      Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <script>
  function ready() {
    alert('DOM is ready');

    // la imagen aún no está cargada (a menos que se haya almacenado en caché), por lo que el tamaño es 0x0
    alert(`Image size: ${img.offsetWidth}x${img.offsetHeight}`);
  }

  document.addEventListener("DOMContentLoaded", ready);
</script>

<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0">
        
      
      
      En el ejemplo, el controlador del evento DOMContentLoaded se ejecuta cuando el documento está cargado, por lo que puede ver todos los elementos, incluido el <img> que está después de él.
Pero no espera a que se cargue la imagen. Entonces, alert muestra los tamaños en cero.
A primera vista, el evento DOMContentLoaded es muy simple. El árbol DOM está listo – aquí está el evento. Sin embargo, hay algunas peculiaridades.
DOMContentLoaded y scriptsCuando el navegador procesa un documento HTML y se encuentra con una etiqueta <script>, debe ejecutarla antes de continuar construyendo el DOM. Esa es una precaución, ya que los scripts pueden querer modificar el DOM, e incluso hacer document.write en él, por lo queDOMContentLoaded tiene que esperar.
Entonces DOMContentLoaded siempre ocurre después de tales scripts:

      
        
        
          
            
          
          
            
          
        
        
          <script>
  document.addEventListener("DOMContentLoaded", () => {
    alert("DOM listo!");
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"></script>

<script>
  alert("Libreria cargada, linea de script ejecutada");
</script>
        
      
      
      En el ejemplo anterior, primero vemos “Biblioteca cargada …” y luego “¡DOM listo!” (se ejecutan todos los scripts).

            Scripts que no bloquean DOMContentLoaded
            Hay dos excepciones a esta regla:

Scripts con el atributo async, que cubriremos un poco más tarde, no bloquea el DOMContentLoaded.
Los scripts que se generan dinámicamente con document.createElement('script') y luego se agregan a la página web, tampoco bloquean este evento.


DOMContentLoaded y estilosLas hojas de estilo externas no afectan a DOM, por lo que DOMContentLoaded no las espera.
Pero hay una trampa. Si tenemos un script después del estilo, entonces ese script debe esperar hasta que se cargue la hoja de estilo:

      
        
        
          
            
          
          
            
          
        
        
          <link type="text/css" rel="stylesheet" href="style.css">
<script>
  // el script no se ejecuta hasta que se cargue la hoja de estilo
  alert(getComputedStyle(document.body).marginTop);
</script>
        
      
      
      La razón de esto es que el script puede querer obtener coordenadas y otras propiedades de elementos dependientes del estilo, como en el ejemplo anterior. Naturalmente, tiene que esperar a que se carguen los estilos.
Como DOMContentLoaded espera los scripts, ahora también espera a los estilos que están antes que ellos.
Autocompletar del navegador integradoFirefox, Chrome y Opera autocompletan formularios en DOMContentLoaded.
Por ejemplo, si la página tiene un formulario con nombre de usuario y contraseña, y el navegador recuerda los valores, entonces en DOMContentLoaded puede intentar completarlos automáticamente (si el usuario lo aprueba).
Entonces, si DOMContentLoaded es pospuesto por scripts de largo tiempo de carga, el autocompletado también espera. Probablemente haya visto eso en algunos sitios (si usa la función de autocompletar del navegador): los campos de inicio de sesión/contraseña no se autocompletan inmediatamente, sino con retraso hasta que la página se carga por completo. En realidad es el retraso hasta el evento DOMContentLoaded.
window.onloadEl evento load en el objeto window se activa cuando se carga toda la página, incluidos estilos, imágenes y otros recursos. Este evento está disponible a través de la propiedad onload.
El siguiente ejemplo muestra correctamente los tamaños de las imágenes, porque window.onload espera todas las imágenes:

      
        
        
          
            
          
          
            
          
        
        
          <script>
  window.onload = function() { // también puede usar window.addEventListener('load', (event) => {
    alert('Página cargada');

    // la imagen es cargada al mismo tiempo
    alert(`Tamaño de imagen: ${img.offsetWidth}x${img.offsetHeight}`);
  };
</script>

<img id="img" src="https://en.js.cx/clipart/train.gif?speed=1&cache=0">
        
      
      
      window.onunloadCuando un visitante abandona la página, el evento unload se activa en window. Podemos hacer algo allí que no implique un retraso, como cerrar ventanas emergentes relacionadas.
La excepción notable es el envío de análisis.
Supongamos que recopilamos datos sobre cómo se usa la página: clicks del mouse, desplazamientos, áreas de página visitadas, etc.
Naturalmente, el evento unload sucede cuando el usuario nos deja y nos gustaría guardar los datos en nuestro servidor.
Existe un método especial navigator.sendBeacon(url, data) para tales necesidades, descrito en la especificación https://w3c.github.io/beacon/.
Este envía los datos en segundo plano. La transición a otra página no se retrasa: el navegador abandona la página, pero aún realiza sendBeacon.
Así es como se usa:

      
        
        
          let analyticsData = { /* objeto con datos recopilados */ };

window.addEventListener("unload", function() {
  navigator.sendBeacon("/analytics", JSON.stringify(analyticsData));
});
        
      
      
      
La solicitud se envía como POST.
Podemos enviar no solo una cadena, sino también formularios y otros formatos, como se describe en el capítulo <info: fetch>, pero generalmente es un objeto string.
Los datos están limitados por 64 kb.

Cuando finaliza la solicitud sendBeacon, es probable que el navegador ya haya abandonado el documento, por lo que no hay forma de obtener la respuesta del servidor (que suele estar vacía para análisis).
También hay una bandera keepalive para hacer tales solicitudes “after-page-left” en el método [fetch](info: fetch) para solicitudes de red genéricas. Puede encontrar más información en el capítulo <info: fetch-api>.
Si queremos cancelar la transición a otra página, no podemos hacerlo aquí. Pero podemos usar otro evento: onbeforeunload.
window.onbeforeunloadSi un visitante inició la navegación fuera de la página o intenta cerrar la ventana, el controlador beforeunload solicita una confirmación adicional.
Si cancelamos el evento, el navegador puede preguntar al visitante si está seguro.
Puede probarlo ejecutando este código y luego recargando la página:

      
        
        
          
            
          
          
            
          
        
        
          window.onbeforeunload = function() {
  return false;
};
        
      
      
      Por razones históricas, devolver una cadena no vacía también cuenta como cancelar el evento. Hace algún tiempo, los navegadores solían mostrarlo como un mensaje, pero como dice la especificación moderna, no deberían.
Aquí hay un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          window.onbeforeunload = function() {
  return "Hay cambios sin guardar. ¿Salir ahora?";
};
        
      
      
      El comportamiento se modificó, porque algunos webmasters abusaron de este controlador de eventos mostrando mensajes engañosos y molestos. Entonces, en este momento, los navegadores antiguos aún pueden mostrarlo como un mensaje, pero aparte de eso, no hay forma de personalizar el mensaje que se muestra al usuario.

            El event.preventDefault() no funciona desde un manejador beforeunload
            Esto puede sonar extraño, pero la mayoría de los navegadores ignoran event.preventDefault().
Lo que significa que el siguiente código puede no funcionar:

      
        
        
          
            
          
          
            
          
        
        
          window.addEventListener("beforeunload", (event) => {
  // no funciona, así que el manejador de evento no hace nada
  event.preventDefault();
});
        
      
      
      En lugar de ello, en tales manejadores uno debe establecer event.returnValue a un string para obtener un resultado similar al pretendido en el código de arriba:

      
        
        
          
            
          
          
            
          
        
        
          window.addEventListener("beforeunload", (event) => {
  // funciona, lo mismo que si devolviera desde window.onbeforeunload
  event.returnValue = "Hsy cambios sin grabar. ¿Abandonar ahora?";
});
        
      
      
      
readyState¿Qué sucede si configuramos el controlador DOMContentLoaded después de cargar el documento?
Naturalmente, nunca se ejecutará.
Hay casos en los que no estamos seguros de si el documento está listo o no. Nos gustaría que nuestra función se ejecute cuando se cargue el DOM, ya sea ahora o más tarde.
La propiedad document.readyState nos informa sobre el estado de carga actual.
Hay 3 valores posibles:

"loading" – el documento se está cargando.
"interactive" – el documento fue leído por completo.
"complete" – el documento se leyó por completo y todos los recursos (como imágenes) también se cargaron.

Entonces podemos verificar document.readyState y configurar un controlador o ejecutar el código inmediatamente si está listo.
Como esto:

      
        
        
          function work() { /*...*/ }

if (document.readyState == 'loading') {
  // cargando todavía, esperar el evento
  document.addEventListener('DOMContentLoaded', work);
} else {
  // DOM está listo!
  work();
}
        
      
      
      También existe el evento readystatechange que se activa cuando cambia el estado, por lo que podemos imprimir todos estos estados así:

      
        
        
          
            
          
          
            
          
        
        
          // estado actual
console.log(document.readyState);

//imprimir los cambios de estado
document.addEventListener('readystatechange', () => console.log(document.readyState));
        
      
      
      El evento readystatechange es una mecánica alternativa para rastrear el estado de carga del documento, apareció hace mucho tiempo. Hoy en día, rara vez se usa.
Veamos el flujo de eventos completo para ver si están completados.
Aquí hay un documento con <iframe>, <img> y controladores que registran eventos:

      
        
        
          <script>
  log('initial readyState:' + document.readyState);

  document.addEventListener('readystatechange', () => log('readyState:' + document.readyState));
  document.addEventListener('DOMContentLoaded', () => log('DOMContentLoaded'));

  window.onload = () => log('window onload');
</script>

<iframe src="iframe.html" onload="log('iframe onload')"></iframe>

<img src="http://en.js.cx/clipart/train.gif" id="img">
<script>
  img.onload = () => log('img onload');
</script>
        
      
      
      El ejemplo práctico está en el sandbox.
La salida típica:

[1] readyState inicial: loading
[2] readyState: interactive
[2] DOMContentLoaded
[3] iframe onload
[4] img onload
[4] readyState: complete
[4] window onload

Los números entre corchetes denotan el tiempo aproximado en el que ocurre. Los eventos etiquetados con el mismo dígito ocurren aproximadamente al mismo tiempo (+ – unos pocos ms).

document.readyState se convierte en interactive justo antes de DOMContentLoaded. Estas dos cosas realmente significan lo mismo.
document.readyState se convierte en complete cuando se cargan todos los recursos (iframe e img). Aquí podemos ver que ocurre aproximadamente al mismo tiempo que img.onload (img es el último recurso) y window.onload. Cambiar al estado complete significa lo mismo que “window.onload”. La diferencia es que window.onload siempre funciona después de todos los demás controladores load.

ResumenEventos de carga de página:

El evento DOMContentLoaded se activa en el document cuando el DOM está listo. Podemos aplicar JavaScript a elementos en esta etapa.

Secuencias de comandos como <script> ... </script> o <script src =" ... "> </script> bloquean DOMContentLoaded, el navegador espera a que se ejecuten.
Las imágenes y otros recursos también pueden seguir cargándose.


El evento load en window se activa cuando se cargan la página y todos los recursos. Rara vez lo usamos, porque generalmente no hay necesidad de esperar tanto.
El evento beforeunload en window se activa cuando el usuario quiere salir de la página. Si cancelamos el evento, el navegador pregunta si el usuario realmente quiere irse (por ejemplo, tenemos cambios sin guardar).
El evento unload en window se dispara cuando el usuario finalmente se está yendo, en el controlador solo podemos hacer cosas simples que no impliquen demoras o preguntas al usuario. Debido a esa limitación, rara vez se usa. Podemos enviar una solicitud de red con navigator.sendBeacon.
document.readyState es el estado actual del documento, los cambios se pueden rastrear con el evento readystatechange:

loading – el documento esta cargando.
interactive – el documento se analiza, ocurre aproximadamente casi al mismo tiempo que DOMContentLoaded, pero antes.
complete – el documento y los recursos se cargan, ocurre aproximadamente casi al mismo tiempo que window.onload, pero antes.



",
	"url": "https://es.javascript.info/onload-ondomcontentloaded" 
},
{
	"docs_id": "124",
	"name": "Scripts: async, defer",
	"description": "En los sitios web modernos los scripts suelen ser más “pesados” que el HTML, el tamaño de la descarga es grande y el tiempo de procesamiento es mayor.",
	"content": "En los sitios web modernos los scripts suelen ser más “pesados” que el HTML, el tamaño de la descarga es grande y el tiempo de procesamiento es mayor.
Cuando el navegador carga el HTML y se encuentra con una etiqueta <script>...</script>, no puede continuar construyendo el DOM. Debe ejecutar el script en el momento. Lo mismo sucede con los scripts externos <script src="..."></script>, el navegador tiene que esperar hasta que el script sea descargado, ejecutarlo y solo después procesa el resto de la página.
Esto nos lleva a dos importantes problemas:

Los scripts no pueden ver los elementos del DOM que se encuentran debajo de él por lo que no pueden agregar controladores de eventos, etc.
Si hay un script muy pesado en la parte superior de la página, este “bloquea la página”. Los usuarios no pueden ver el contenido de la página hasta que sea descargado y ejecutado.


      
        
        
          
            
          
          
            
          
        
        
          <p>...contenido previo al script...</p>

<script src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>

<!-- Esto no es visible hasta que el script sea cargado -->
<p>...contenido posterior al script...</p>
        
      
      
      Hay algunas soluciones para eso. Por ejemplo podemos poner el script en la parte inferior de la página por lo que podrá ver los elementos sobre él y no bloqueará la visualización del contenido de la página.

      
        
        
          <body>
  ...todo el contenido está arriba del script...

  <script src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>
</body>
        
      
      
      Pero esta solución está lejos de ser perfecta. Por ejemplo el navegador solo se dará cuenta del script (y podrá empezar a descargarlo) después de descargar todo el documento HTML. Para documentos HTML extensos eso puede ser un retraso notable.
Este tipo de cosas son imperceptibles para las personas que usan conexiones muy rápidas, pero muchas personas en el mundo todavía tienen velocidades de internet lentas y utilizan una conexión de internet móvil que esta lejos de ser perfecta.
Afortunadamente hay dos atributos de <script> que resuelven ese problema para nosotros: defer y async.
deferEl atributo defer indica al navegador que no espere por el script. En lugar de ello, debe seguir procesando el HTML, construir el DOM. El script carga “en segundo plano” y se ejecuta cuando el DOM esta completo.
Aquí está el mismo ejemplo de arriba pero con defer:

      
        
        
          
            
          
          
            
          
        
        
          <p>...contenido previo script...</p>

<script defer src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>

<!-- Inmediatamete visible -->
<p>...contenido posterior al script...</p>
        
      
      
      En otras palabras:

Los scripts con defer nunca bloquean la página.
Los scripts con defer siempre se ejecutan cuando el DOM esta listo (pero antes del evento DOMContentLoaded).

Los siguientes ejemplos demuestran la segunda parte:

      
        
        
          
            
          
          
            
          
        
        
          <p>...contenido previo a los scripts...</p>

<script>
  document.addEventListener('DOMContentLoaded', () => alert("¡DOM listo después del defer!"));
</script>

<script defer src="https://javascript.info/article/script-async-defer/long.js?speed=1"></script>

<p>...contenido posterior a los scripts...</p>
        
      
      
      
El contenido de la página se muestra inmediatamente.
DOMContentLoaded espera por el script diferido. Solo se dispara cuando el script es descargado y ejecutado.

**Los scripts diferidos mantienen su orden relativo, tal cual los scripts regulares.
Digamos que tenemos dos scripts diferidos, long.js (largo) y luego small.js (corto):

      
        
        
          <script defer src="https://javascript.info/article/script-async-defer/long.js"></script>
<script defer src="https://javascript.info/article/script-async-defer/small.js"></script>
        
      
      
      Los navegadores analizan la página en busca de scripts y los descarga en paralelo para mejorar el rendimiento. Entonces en el ejemplo superior ambos scripts se descargan en paralelo, el small.js probablemente lo haga primero.
…Pero el atributo defer, además de decirle al navegador “no bloquear”, asegura que el orden relativo se mantenga. Entonces incluso si small.js se carga primero, aún espera y se ejecuta después de long.js.
Por ello es importante para casos donde necesitamos cargar un librería JavaScript y entonces un script que depende de ella.

            El atributo defer es solo para scripts externos
            El atributo defer es ignorado si el <script> no tiene el atributo src.

asyncEl atributo async es de alguna manera como defer. También hace el script no bloqueante. Pero tiene importantes diferencias de comportamiento.
El atributo async significa que el script es completamente independiente:

El navegador no se bloquea con scripts async (como defer).
Otros scripts no esperan por scripts async, y scripts async no espera por ellos.
DOMContentLoaded y los scripts asincrónicos no se esperan entre sí:

DOMContentLoaded puede suceder antes que un script asincrónico (si un script asincrónico termina de cargar una vez la página está completa)
…o después de un script asincrónico (si tal script asincrónico es pequeño o está en cache)



En otras palabras, los scripts async cargan en segundo plano y se ejecutan cuando están listos. El DOM y otros scripts no esperan por ellos, y ellos no esperan por nada. Un script totalmente independiente que se ejecuta en cuanto se ha cargado. Tan simple como es posible, ¿cierto?
Aquí hay un ejemplo similar al que vimos con defer: Dos scripts long.js y small.js, pero ahora con async en lugar de defer.
Los unos no esperan por lo otros. El que cargue primero (probablemente small.js), se ejecuta primero.

      
        
        
          
            
          
          
            
          
        
        
          <p>...contenido previo a los scripts...</p>

<script>
  document.addEventListener('DOMContentLoaded', () => alert("¡DOM listo!"));
</script>

<script async src="https://javascript.info/article/script-async-defer/long.js"></script>
<script async src="https://javascript.info/article/script-async-defer/small.js"></script>

<p>...contenido posterior a los scripts...</p>
        
      
      
      
El contenido de la página se muestra inmediatamente: async no lo bloquea.
El evento DOMContentLoaded puede suceder antes o después de async, no hay garantías aquí.
Un script más pequeño small.js que esté segundo probablemente cargue antes que uno más largo long.js, entonces se ejecutará primero. Aunque podría ser que long.js cargue primero si está en caché y ejecute primero. A eso lo llamamos “load-first order”, se ejecuta primero el que cargue antes .

Los scripts asincrónicos son excelentes cuando incluimos scripts de terceros (contadores, anuncios, etc) en la página debido a que ellos no dependen de nuestros scripts y nuestros scripts no deberían esperar por ellos.

      
        
        
          <!-- Google Analytics is usually added like this -->
<script async src="https://google-analytics.com/analytics.js"></script>
        
      
      
      
            El atributo async es solo para scripts externos
            Tal como defer, el atributo async se ignora si la etiqueta <script> no tiene src.

Scripts dinámicosHay otra manera importante de agregar un script a la página.
Podemos crear un script y agregarlo dinámicamente al documento usando JavaScript:

      
        
        
          
            
          
          
            
          
        
        
          let script = document.createElement('script');
script.src = "/article/script-async-defer/long.js";
document.body.append(script); // (*)
        
      
      
      El script comienza a cargar tan pronto como es agregado al documento (*).
Los scripts dinámicos se comportan como async por defecto
Esto es:

Ellos no esperan a nadie y nadie espera por ellos.
El script que carga primero se ejecuta primero (load-first order)

Esto puede ser cambiado si explícitamente establecemos script.async=false. Así los scripts serán ejecutados en el orden del documento, tal como en defer.
En este ejemplo, la función loadScript(src) añade un script y también establece async a false.
Entonces long.js siempre ejecuta primero (por haber sido agregado primero):

      
        
        
          
            
          
          
            
          
        
        
          function loadScript(src) {
  let script = document.createElement('script');
  script.src = src;
  script.async = false;
  document.body.append(script);
}

// long.js se ejecuta primero a causa del async=false
loadScript("/article/script-async-defer/long.js");
loadScript("/article/script-async-defer/small.js");
        
      
      
      Sin script.async=false, los scripts es ejecutarían de forma predeterminada, en el orden de carga primero (probablemente small.js primero).
De nuevo, como con defer, el orden importa si queremos cargar una librería y luego otro script que depende de ella.
ResumenAmbos, async y defer, tienen algo en común: la descarga de tales scripts no bloquean el renderizado de la página. Por lo cual el usuario puede leer el contenido de la página y familiarizarse con la página inmediatamente.
Pero hay algunas diferencias esenciales entre ellos:




Orden
DOMContentLoaded




async
Load-first order. El orden del documento no importa. El que carga primero ejecuta primero
Irrelevante. Puede cargar y ejecutarse mientras el documento no ha sido completamente descargado, eso puede pasar si el script es pequeño o está en cache y el documento es suficientemente extenso.


defer
Document order (como van en el documento).
Ejecutan después de que el documento es cargado y analizado (espera si es necesario), justo antes de DOMContentLoaded.



En la práctica, defer es usado para scripts que necesitan todo el DOM y/o si su orden de ejecución relativa es importante.
Y async es usado para scripts independientes, como contadores y anuncios donde el orden de ejecución no importa.

            La página sin scripts debe ser utilizable
            Ten en cuenta: si usas defer o async, el usuario verá la página antes de que el script sea cargado.
En tal caso algunos componentes gráficos probablemente no estén listos.
No olvides poner alguna señal de “cargando” y deshabilitar los botones que aún no estén funcionando. Esto permite al usuario ver claramente qué puede hacer en la página y qué está listo y qué no.

",
	"url": "https://es.javascript.info/script-async-defer" 
},
{
	"docs_id": "125",
	"name": "Carga de recursos: onload y onerror",
	"description": "El navegador nos permite hacer seguimiento de la carga de recursos externos: scripts, iframes, imágenes y más.",
	"content": "El navegador nos permite hacer seguimiento de la carga de recursos externos: scripts, iframes, imágenes y más.
Hay dos eventos para eso:

onload – cuando cargó exitosamente,
onerror – cuando un error ha ocurrido.

Cargando un scriptDigamos que tenemos que cargar un script de terceros y llamar una función que se encuentra dentro.
Podemos cargarlo dinámicamente de esta manera:

      
        
        
          let script = document.createElement("script");
script.src = "my.js";

document.head.append(script);
        
      
      
      …pero ¿cómo podemos ejecutar la función que esta dentro del script? Necesitamos esperar hasta que el script haya cargado, y solo después podemos llamarlo.

            Por favor tome nota:
            Para nuestros scripts podemos usar JavaScript modules aquí, pero no está adoptado ampliamente por bibliotecas de terceros.

script.onloadEl evento load se dispara después de que script sea cargado y ejecutado.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let script = document.createElement('script');

// podemos cargar cualquier script desde cualquier dominio
script.src = "https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js"
document.head.append(script);

script.onload = function() {
  // el script crea una variable "_"
  alert( _.VERSION ); // muestra la versión de la librería
};
        
      
      
      Entonces en onload podemos usar variables, ejecutar funciones, etc.
…¿y si la carga falla? Por ejemplo: no hay tal script (error 404) en el servidor o el servidor está caído (no disponible).
script.onerrorLos errores que ocurren durante la carga de un script pueden ser rastreados en el evento error.
Por ejemplo, hagamos una petición a un script que no existe:

      
        
        
          
            
          
          
            
          
        
        
          let script = document.createElement('script');
script.src = "https://example.com/404.js"; // no hay tal script
document.head.append(script);

script.onerror = function() {
  alert("Error al cargar " + this.src); // Error al cargar https://example.com/404.js
};
        
      
      
      Por favor nota que como no podemos obtener detalles del error HTTP aquí, no podemos saber if fue un error 404 o algo diferente. Solo el error de carga.

            Importante:
            Los eventos onload/onerror rastrean solamente la carga de ellos mismos.
Los errores que pueden ocurrir durante el procesamiento y ejecución están fuera del alcance para esos eventos. Eso es: si un script es cargado de manera exitosa, incluso si tiene errores de programación adentro, el evento onload se dispara. Para rastrear los errores del script un puede usar el manejador global window.onerror;

Otros recursosLos eventos load y error también funcionan para otros recursos, básicamente para cualquiera que tenga una src externa.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let img = document.createElement("img");
img.src = "https://js.cx/clipart/train.gif"; // (*)

img.onload = function () {
  alert(`Image loaded, size ${img.width}x${img.height}`);
};

img.onerror = function () {
  alert("Error occurred while loading image");
};
        
      
      
      Sin embargo, hay algunas notas:

La mayoría de recursos empiezan a cargarse cuando son agregados al documento. Pero <img> es una excepción, comienza la carga cuando obtiene una fuente “.src” (*).
Para <iframe>, el evento iframe.onload se dispara cuando el iframe ha terminado de cargar, tanto para una carga exitosa como en caso de un error.

Esto es por razones históricas.
Política de origen cruzadoHay una regla: los scripts de un sitio no pueden acceder al contenido de otro sitio. Por ejemplo: un script de https://facebook.com no puede leer la bandeja de correos del usuario en https://gmail.com.
O para ser más precisos, un origen (el trío dominio/puerto/protocolo) no puede acceder al contenido de otro. Entonces, incluso si tenemos un sub-dominio o solo un puerto distinto, son considerados orígenes diferentes sin acceso al otro.
Esta regla también afecta a recursos de otros dominios.
Si usamos un script de otro dominio y tiene un error, no podemos obtener detalles del error.
Por ejemplo, tomemos un script error.js que consta de una sola llamada a una función (con errores).

      
        
        
          // 📁 error.js
noSuchFunction();
        
      
      
      Ahora cargalo desde el mismo sitio donde esta alojado:

      
        
        
          
            
          
          
            
          
        
        
          <script>
  window.onerror = function (message, url, line, col, errorObj) {
    alert(`${message}\n${url}, ${line}:${col}`);
  };
</script>
<script src="/article/onload-onerror/crossorigin/error.js"></script>
        
      
      
      Podemos ver un buen reporte de error, como este:

      
        
        
          Uncaught ReferenceError: noSuchFunction is not defined
https://javascript.info/article/onload-onerror/crossorigin/error.js, 1:1
        
      
      
      Ahora carguemos el mismo script desde otro dominio:

      
        
        
          
            
          
          
            
          
        
        
          <script>
  window.onerror = function (message, url, line, col, errorObj) {
    alert(`${message}\n${url}, ${line}:${col}`);
  };
</script>
<script src="https://cors.javascript.info/article/onload-onerror/crossorigin/error.js"></script>
        
      
      
      El reporte es diferente, como este:

      
        
        
          Script error.
, 0:0
        
      
      
      Los detalles pueden variar dependiendo del navegador, pero la idea es la misma: cualquier información sobre las partes internas de un script, incluyendo el rastreo de la pila de errores, se oculta. Exactamente porque es de otro dominio.
¿Por qué necesitamos detalles de error?
Hay muchos servicios (y podemos construir uno nuestro) que escuchan los errores globales usando window.onerror, guardan los errores y proveen una interfaz para acceder a ellos y analizarlos. Eso es grandioso ya que podemos ver los errores originales ocasionados por nuestros usuarios. Pero si el script viene desde otro origen no hay mucha información sobre los errores como acabamos de ver.
También se aplican políticas similares de origen cruzado (CORS) a otros tipos de recursos.
Para permitir el acceso de origen cruzado, la etiqueta <script> necesita tener el atributo crossorigin, además el servidor remoto debe proporcionar cabeceras especiales.
Hay 3 niveles de acceso de origen cruzado:

Sin el atributo crossorigin – acceso prohibido.
crossorigin="anonymous" – acceso permitido si el servidor responde con la cabecera Access-Control-Allow-Origin con * o nuestro origen. El navegador no envía la información de la autorización y cookies al servidor remoto.
crossorigin="use-credentials" – acceso permitido si el servidor envia de vuelta la cabecera Access-Control-Allow-Origin con nuestro origen y Access-Control-Allow-Credentials: true. El navegador envía la información de la autorización y las cookies al servidor remoto.


            Por favor tome nota:
            Puedes leer más sobre accesos de origen cruzado  en el capítulo Fetch: Cross-Origin Requests. Este describe el método fetch para requerimientos de red, pero la política es exactamente la misma.
Cosas como las “cookies” están fuera de nuestro alcance, pero podemos leer sobre ellas en Cookies, document.cookie.

En nuestro caso no teníamos ningún atributo de origen cruzado (cross-origin). Por lo que se prohibió el acceso de origen cruzado. Vamos a agregarlo.
Podemos elegir entre "anonymous" (no se envían las cookies, una sola cabecera esa necesaria en el lado del servidor) y "use-credentials" (envía las cookies, dos cabeceras son necesarias en el lado del servidor).
Si no nos importan las cookies, entonces "anonymous" es el camino a seguir:

      
        
        
          
            
          
          
            
          
        
        
          <script>
window.onerror = function(message, url, line, col, errorObj) {
  alert(`${message}\n${url}, ${line}:${col}`);
};
</script>
<script crossorigin="anonymous" src="https://cors.javascript.info/article/onload-onerror/crossorigin/error.js"></script>
        
      
      
      Ahora, asumiendo que el servidor brinda una cabecera Access-Control-Allow-Origin, todo está bien. Podemos tener el reporte completo del error.
ResumenLas imágenes <img>, estilos externos, scripts y otros recursos proveen los eventos load y error para rastrear sus cargas:

load se ejecuta cuando la carga ha sido exitosa,
error se ejecuta cuando una carga ha fallado.

La única excepción es el <iframe>: por razones históricas siempre dispara el evento load, incluso si no encontró la página.
El evento readystatechange también funciona para recursos, pero es muy poco usado debido a que los eventos load/error son mas simples.
TareasCargando imágenes con una un función de retorno (`callback`)importancia: 4Normalmente, las imágenes son cargadas cuando son creadas. Entonces, cuando nosotros agregamos <img> a la página el usuario no ve la imágen inmediatamente. El navegador necesita cargarlo primero.
Para mostrar una imágen inmediatamente, podemos crearlo “en avance”, como esto:

      
        
        
          let img = document.createElement('img');
img.src = 'my.jpg';
        
      
      
      El navegador comienza a cargar la imágen y lo guarda en el cache. Después cuando la misma imágen aparece en el documento (no importa cómo) la muestra inmediatamente.
Crear una función preloadImages(sources, callback) que cargue todas las imágenes desde una lista de fuentes (sources) y, cuando estén listas, ejecutar la función de retorno (callback).
Por ejemplo: esto puede mostrar una alerta (alert) después de que la imágen sea cargada:

      
        
        
          function loaded() {
  alert("Imágenes cargadas")
}

preloadImages(["1.jpg", "2.jpg", "3.jpg"], loaded);
        
      
      
      En caso de un error, la función debería seguir asumiendo que la imágen ha sido “cargada”.
En otras palabras, la función de retorno (callback) es ejecutada cuando todas las imágenes han sido cargadas o no.
La función es útil, por ejemplo, cuando planeamos mostrar una galería con muchas imágenes desplazables y estar seguros de que todas las imágenes están cargadas.
En el documento fuente puedes encontrar enlaces para probar imágenes y también el código para verificar si han sido cargadas o no. Debería devolver 300.
Abrir un entorno controlado para la tarea.soluciónEl algoritmo:

Crear una img para cada fuente.
Agregar los eventos onload/onerror para cada imágen.
Incrementar el contador cuando el evento onload o el evento onerror se dispare.
Cuando el valor del contador es igual a la cantidad de fuentes, hemos terminado: callback().

Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/onload-onerror" 
},
{
	"docs_id": "126",
	"name": "Mutation observer",
	"description": "MutationObserver es un objeto incorporado que observa un elemento DOM y dispara un callback cuando hay cambios en él.",
	"content": "MutationObserver es un objeto incorporado que observa un elemento DOM y dispara un callback cuando hay cambios en él.
Primero veremos su sintaxis, luego exploraremos un caso de la vida real para ver dónde puede ser útil.
SintaxisMutationObserver es fácil de usar.
Primero creamos un observador con una función callback:

      
        
        
          let observer = new MutationObserver(callback);
        
      
      
      Y luego lo vinculamos a un nodo DOM:

      
        
        
          observer.observe(node, config);
        
      
      
      config es un objeto con opciones booleanas “a qué clase de cambios reaccionar”:

childList – cambios en los hijos directos de node,
subtree – en todos los descendientes de node,
attributes – atributos de node,
attributeFilter – un array de nombres de atributos, para observar solamente a los seleccionados,
characterData – establece si debe observar cambios de texto en node.data o no,

Algunas otras opciones:

attributeOldValue – si es true, tanto el valor viejo como el nuevo del atributo son pasados al callback (ver abajo), de otro modo pasa solamente el nuevo (necesita la opción attributes),
characterDataOldValue – si es true, tanto el valor viejo como el nuevo de node.data son pasados al callback (ver abajo), de otro modo pasa solamente el nuevo (necesita la opción characterData).

Entonces, después de cualquier cambio, el callback es ejecutado: los cambios son pasados en el primer argumento como una lista objetos MutationRecord, y el observador en sí mismo como segundo argumento.
Los objetos MutationRecord tienen como propiedades:

type – tipo de mutación, uno de:

"attributes": atributo modificado,
"characterData": dato modificado, usado para nodos de texto,
"childList": elementos hijos agregados o quitados,


target – dónde ocurrió el cambio: un elemento para "attributes", o un nodo de texto para "characterData", o un elemento para una mutación de "childList",
addedNodes/removedNodes – nodos que fueron agregados o quitados,
previousSibling/nextSibling – los nodos “hermanos”, previos y siguientes a los nodos agregados y quitados,
attributeName/attributeNamespace – el nombre o namespace (para XML) del atributo cambiado,
oldValue – el valor previo, solamente cambios de atributo o cambios de texto si se establece la opción correspondiente attributeOldValue/characterDataOldValue.

Por ejemplo, aquí hay un <div> con un atributo contentEditable. Ese atributo nos permite poner el foco en él y editarlo.

      
        
        
          
            
          
          
            
          
        
        
          <div contentEditable id="elem">Click and <b>edit</b>, please</div>

<script>
let observer = new MutationObserver(mutationRecords => {
  console.log(mutationRecords); // console.log(los cambios)
});

// observa todo exceptuando atributos
observer.observe(elem, {
  childList: true, // observa hijos directos
  subtree: true, // y descendientes inferiores también
  characterDataOldValue: true // pasa el dato viejo al callback
});
</script>
        
      
      
      Si ejecutamos este código en el navegador, el foco en el <div> dado y el cambio en texto dentro de <b>edit</b>, console.log mostrará una mutación:

      
        
        
          mutationRecords = [{
  type: "characterData",
  oldValue: "edit",
  target: <text node>,
  // otras propiedades vacías
}];
        
      
      
      Si hacemos operaciones de edición más complejas, como eliminar el <b>edit</b>, el evento de mutación puede contener múltiples registros de mutación:

      
        
        
          mutationRecords = [{
  type: "childList",
  target: <div#elem>,
  removedNodes: [<b>],
  nextSibling: <text node>,
  previousSibling: <text node>
  // otras propiedades vacías
}, {
  type: "characterData"
  target: <text node>
  // ...detalles de mutación dependen de cómo el navegador maneja tal eliminación
  // puede unir dos nodos de texto adyacentes "edit " y ", please" en un nodo
  // o puede dejarlos como nodos de texto separados
}];
        
      
      
      Así, MutationObserver permite reaccionar a cualquier cambio dentro del subárbol DOM.
Uso para integración¿Cuándo puede ser práctico esto?
Imagina la situación cuando necesitas añadir un script de terceros que contiene funcionalidad útil pero que también hace algo no deseado, por ejemplo añadir publicidad <div class="ads">Unwanted ads</div>.
Naturalmente el script de terceras partes no proporciona mecanismos para removerlo.
Usando MutationObserver podemos detectar cuándo aparece el elemento no deseado en nuestro DOM y removerlo.
Hay otras situaciones, como cuando un script de terceras partes agrega algo en nuestro documento y quisiéramos detectarlo para adaptar nuestra página y cambiar el tamaño de algo dinámicamente, etc.
MutationObserver permite implementarlo.
Uso para arquitecturaHay también situaciones donde MutationObserver es bueno desde el punto de vista de la arquitectura.
Digamos que estamos haciendo un sitio web acerca de programación. Naturalmente, los artículos y otros materiales pueden contener fragmentos de código.
Tal fragmento en un markup HTML se ve como esto:

      
        
        
          ...
<pre class="language-javascript"><code>
  // aquí el código
  let hello = "world";
</code></pre>
...
        
      
      
      Para mejorar la legibilidad y al mismo tiempo embellecerlo, usaremos una librería JavaScript de “highlighting” para resaltar elementos de nuestro sitio, por ejemplo Prism.js. Para obtener sintaxis resaltada para el fragmento de arriba en Prism, llamamos a Prism.highlightElem(pre), que examina el contenido de tales elementos y les agrega tags y styles especiales para obtener sintaxis resaltada con color, similares a los que ves en esta página.
¿Exactamente cuándo ejecutar tal método de highlighting? Bien, podemos hacerlo en el evento DOMContentLoaded, o poner el script al final de la página. En el momento en que tenemos nuestro DOM listo buscamos los elementos pre[class*="language"] y llamamos Prism.highlightElem en ellos:

      
        
        
          // resaltar todos los fragmentos de código en la página
document.querySelectorAll('pre[class*="language"]').forEach(Prism.highlightElem);
        
      
      
      Todo es simple hasta ahora, ¿verdad? Buscamos fragmentos de código en HTML y los resaltamos.
Continuemos. Digamos que vamos a buscar dinámicamente material desde un servidor. Estudiaremos métodos para ello más adelante en el tutorial. Por ahora solamente importa que buscamos un artículo HTML desde un servidor web y lo mostramos bajo demanda:

      
        
        
          let article = /* busca contenido nuevo desde un servidor */
articleElem.innerHTML = article;
        
      
      
      El nuevo elemento HTML article puede contener fragmentos de código. Necesitamos llamar Prism.highlightElem en ellos, de otro modo no se resaltarían.
¿Dónde y cuándo llamar Prism.highlightElem en un artículo cargado dinámicamente?
Podríamos agregar el llamado al código que carga un “article”, como esto:

      
        
        
          let article = /* busca contenido nuevo desde un servidor */
articleElem.innerHTML = article;

let snippets = articleElem.querySelectorAll('pre[class*="language-"]');
snippets.forEach(Prism.highlightElem);
        
      
      
      …Pero imagina que tenemos muchos lugares en el código donde cargamos contenido: artículos, cuestionarios, entradas de foros. ¿Necesitamos poner el llamado al “highlighting” en todos lugares? Eso no es muy conveniente.
¿Y si el contenido es cargado por un módulo de terceras partes? Por ejemplo tenemos un foro, escrito por algún otro, que carga contenido dinámicamente y quisiéramos añadirle sintaxis resaltada. A nadie le gusta emparchar scripts de terceras partes.
Afortunadamente hay otra opción.
Podemos usar MutationObserver para detectar automáticamente cuándo los fragmentos de código son insertados en la página y resaltarlos.
Entonces manejaremos la funcionalidad de “highlighting” en un único lugar, liberándonos de la necesidad de integrarlo.
Demo de highlight dinámicoAquí el ejemplo funcionando.
Si ejecutas el código, este comienza a observar el elemento debajo y resalta cualquier fragmento de código que aparezca allí:

      
        
        
          
            
          
          
            
          
        
        
          let observer = new MutationObserver(mutations => {

  for(let mutation of mutations) {
    // examine nodos nuevos, ¿hay algo para resaltar?

    for(let node of mutation.addedNodes) {
      // seguimos elementos solamente, saltamos los otros nodos (es decir nodos de texto)
      if (!(node instanceof HTMLElement)) continue;

      // verificamos que el elemento insertado sea un fragmento de código
      if (node.matches('pre[class*="language-"]')) {
        Prism.highlightElement(node);
      }

      // ¿o tal vez haya un fragmento de código en su sub-árbol?
      for(let elem of node.querySelectorAll('pre[class*="language-"]')) {
        Prism.highlightElement(elem);
      }
    }
  }

});

let demoElem = document.getElementById('highlight-demo');

observer.observe(demoElem, {childList: true, subtree: true});
        
      
      
      Aquí, abajo, hay un elemento HTML y JavaScript que lo llena dinámicamente usando innerHTML.
Por favor ejecuta el código anterior (arriba, que observa aquel elemento) y luego el código de abajo. Verás cómo MutationObserver detecta y resalta el fragmento.
A demo-element with id="highlight-demo", run the code above to observe it.
El siguiente código llena su innerHTML, lo que causa que MutationObserver reaccione y resalte su contenido:

      
        
        
          
            
          
          
            
          
        
        
          let demoElem = document.getElementById('highlight-demo');

// inserta contenido con fragmentos de código
demoElem.innerHTML = `A code snippet is below:
  <pre class="language-javascript"><code> let hello = "world!"; </code></pre>
  <div>Another one:</div>
  <div>
    <pre class="language-css"><code>.class { margin: 5px; } </code></pre>
  </div>
`;
        
      
      
      Ahora tenemos un MutationObserver que puede rastrear todo el “highlighting” en los elementos observados del document entero. Podemos agregar o quitar fragmentos de código en el HTML sin siquiera pensar en ello.
Métodos adicionalesHay un método para detener la observación del nodo:

observer.disconnect() – detiene la observación.

Cuando detenemos la observación, algunos cambios todavía podrían quedar sin ser procesados por el observador. En tales casos usamos

observer.takeRecords() – obtiene una lista de registros de mutaciones sin procesar, aquellos que ocurrieron pero el callback no manejó.

Estos métodos pueden ser usados juntos, como esto:

      
        
        
          // obtener una lista de mutaciones sin procesar
// debe ser llamada antes de la desconexión,
// si te interesa las posibles mutaciones recientes sin manejar
let mutationRecords = observer.takeRecords();

// detener el rastreo de cambios
observer.disconnect();
...
        
      
      
      
            Lo registros devueltos por observer.takeRecords() son quitados de la cola de procesamiento
            El callback no será llamado en registros devueltos por observer.takeRecords().


            Interacción con la recolección de basura
            Los observadores usan internamente referencias débiles a nodos. Esto es: si un nodo es quitado del DOM y se hace inalcanzable, se vuelve basura para ser recolectada.
El mero hecho de que un nodo DOM sea observado no evita la recolección de basura.

ResumenMutationObserver puede reaccionar a cambios en el DOM: atributos, contenido de texto y añadir o quitar elementos.
Podemos usarlo para rastrear cambios introducidos por otras partes de nuestro código o bien para integrarlo con scripts de terceras partes.
MutationObserver puede rastrear cualquier cambio. Las opciones de config permiten establecer qué se va a observar, se usa para optimización y no desperdiciar recursos en llamados al callback innecesarios.
",
	"url": "https://es.javascript.info/mutation-observer" 
},
{
	"docs_id": "127",
	"name": "Selection y Range",
	"description": "En este capítulo cubriremos la selección en el documento, así como la selección en campos de formulario, como <input>.",
	"content": "En este capítulo cubriremos la selección en el documento, así como la selección en campos de formulario, como <input>.
JavaScript puede acceder una selección existente, seleccionar/deseleccionar nodos DOM tanto en su totalidad como parcialmente, eliminar la parte seleccionada del documento, envolverla en una etiqueta, etc.
Puedes encontrar algunas recetas para tareas comunes al final del artículo, en la sección “Resumen”. Pero será mucho más beneficiosa la lectura de todo el capítulo.
Los objetos subyacentes Range y Selection son fáciles de captar y no necesitarás recetas para que hagan lo que deseas.
RangeEl concepto básico de selección Range, es básicamente un par de “puntos límite”: inicio y fin del rango.
Un objeto rango se crea sin parámetros:

      
        
        
          let range = new Range();
        
      
      
      Entonces podemos establecer los límites de selección usando range.setStart(node, offset) y range.setEnd(node, offset).
En adelante usaremos objetos Range para selección, pero primero creemos algunos de ellos.
Seleccionando el texto parcialmenteLo interesante es que el primer argumento node en ambos métodos puede ser tanto un nodo de texto o un nodo de elemento, y el significado del segundo argumento depende de ello.
Si node es un nodo de texto, offset debe ser la posición en su texto.
Por ejemplo, dado el elemento <p>Hello</p>, podemos crear el rango conteniendo las letras “ll”:

      
        
        
          
            
          
          
            
          
        
        
          <p id="p">Hello</p>
<script>
  let range = new Range();
  range.setStart(p.firstChild, 2);
  range.setEnd(p.firstChild, 4);

  // toString de un rango devuelve su contenido como un texto
  console.log(range); // ll
</script>
        
      
      
      Aquí tomamos el primer hijo de <p> (que es el nodo de texto) y especificamos la posición del texto dentro de él:

      
      
        
      
      Seleccionando nodos de elementoAlternativamente, si node es un nodo de elemento, offset debe ser el número de hijo.
Esto es práctico para hacer rangos que contienen nodos como un todo, no detenerse en algún lugar dentro de su texto.
Por ejemplo, tenemos un fragmento de documento más complejo:

      
        
        
          <p id="p">Example: <i>italic</i> and <b>bold</b></p>
        
      
      
          
        
      Aquí está su estructura DOM usando ambos, nodos de texto y nodos de elemento:


let selectPDomtree = {
  "name": "P",
  "nodeType": 1,
  "children": [{
    "name": "#text",
    "nodeType": 3,
    "content": "Example: "
  }, {
    "name": "I",
    "nodeType": 1,
    "children": [{
      "name": "#text",
      "nodeType": 3,
      "content": "italic"
    }]
  }, {
    "name": "#text",
    "nodeType": 3,
    "content": " and "
  }, {
    "name": "B",
    "nodeType": 1,
    "children": [{
      "name": "#text",
      "nodeType": 3,
      "content": "bold"
    }]
  }]
}

drawHtmlTree(selectPDomtree, 'div.select-p-domtree', 690, 320);

Hagamos un rango para "Example: <i>italic</i>".
Como podemos ver, esta frase consiste de exactamente dos hijos de <p> con índices 0 y 1:

      
      
        
      
      
El punto de inicio tiene <p> como nodo padre node, y 0 como offset.

Así que podemos establecerlo como range.setStart(p, 0).


El punto final también tiene <p> como nodo padre, but 2 como offset (especifica el rango “hasta”, pero no incluyendo, offset).
Entonces podemos establecerlo como range.setEnd(p, 2).


Aquí la demo. Si la ejeutas, puedes ver el texto siendo seleccionado::

      
        
        
          
            
          
          
            
          
        
        
          <p id="p">Example: <i>italic</i> and <b>bold</b></p>

<script>
  let range = new Range();

  range.setStart(p, 0);
  range.setEnd(p, 2);

 // toString de un rango devuelve su contenido como texto (sin etiquetas)
  alert(range); // Ejemplo: italic

  // aplicar este rango para la selección de documentos (explicado más adelante)
  document.getSelection().addRange(range);
</script>
        
      
      
      Aquí hay un banco de pruebas más flexible donde puedes establecer números de principio y fin y explorar otras variantes:

      
        
        
          
            
          
          
            
          
        
        
          <p id="p">Example: <i>italic</i> and <b>bold</b></p>

From <input id="start" type="number" value=1> – To <input id="end" type="number" value=4>
<button id="button">Click to select</button>
<script>
  button.onclick = () => {
    let range = new Range();

    range.setStart(p, start.value);
    range.setEnd(p, end.value);

    // aplicar la selección, explicado más adelante
    document.getSelection().removeAllRanges();
    document.getSelection().addRange(range);
  };
</script>
        
      
      
          
        
      Ej. seleccionando de 1 a 4 da como rango <i>italic</i> and <b>bold</b>.

      
      
        
      
      
            Los nodos de inicio y final pueden ser diferentes
            No tenemos que usar el mismo nodo en setStart y setEnd. Un rango puede abarcar muchos nodos no relacionados. Solo es importante que el final sea posterior al comienzo.

Seleccionar partes de nodos de textoSeleccionemos el texto parcialmente, así:

      
      
        
      
      Eso también es posible, solo necesitamos establecer el inicio y el final como un desplazamiento relativo en los nodos de texto.
Necesitamos crear un rango, que:

comienza desde la posición 2 en <p> primer hijo (tomando todas menos dos primeras letras de “Example:”)
termina en la posición 3 de <b> primer hijo (tomando las primeras tres letras de “bold”, pero no más):


      
        
        
          
            
          
          
            
          
        
        
          <p id="p">Example: <i>italic</i> and <b>bold</b></p>

<script>
  let range = new Range();

  range.setStart(p.firstChild, 2);
  range.setEnd(p.querySelector('b').firstChild, 3);

  alert(range); // amplio: italic and bol

  // use este rango para la selección (explicado más adelante)
  window.getSelection().addRange(range);
</script>
        
      
      
      Como puedes ver, es fácil hacer un rango con lo que quieras.
Si queremos tomar los nodos como un todo, podemos pasar los elementos en setStart/setEnd. Si no, podemos trabajar en el nivel de texto.
Propiedades de RangeEl objeto rango que creamos arriba tiene las siguientes propiedades:

      
      
        
      
      
startContainer, startOffset – nodo y desplazamiento del inicio,

en el ejemplo anterior: primer nodo de texto dentro de <p> y 2.


endContainer, endOffset – nodo y desplazamiento del final,

en el ejemplo anterior: primer nodo de texto dentro de <b> y 3.


collapsed – booleano, true si el rango comienza y termina en el mismo punto (por lo que no hay contenido dentro del rango),

en el ejemplo anterior: false


commonAncestorContainer – el ancestro común más cercano de todos los nodos dentro del rango,

en el ejemplo anterior: <p>



Métodos de selección de rangoHay muchos métodos convenientes para manipular rangos.
Ya hemos visto setStart y setEnd, aquí hay otros métodos similares.
Establecer inicio de rango:

setStart(node, offset) establecer inicio en: posición offset en node
setStartBefore(node) establecer inicio en: justo antes node
setStartAfter(node) establecer inicio en: justo después node

Establecer fin de rango (métodos similares):

setEnd(node, offset) establecer final en: posición offset en node
setEndBefore(node) establecer final en: justo antes node
setEndAfter(node) establecer final en: justo después node

Técnicamente, setStart/setEnd puede hacer cualquier cosa, pero más métodos brindan más conveniencia.
En todos estos métodos node puede ser un nodo de texto o de elemento: para nodos de texto offset salta esa cantidad de caracteres, mientras que para los nodos de elementos es la cantidad de nodos secundarios.**
Más métodos aún para crear rangos:

selectNode(node) establecer rango para seleccionar el node
selectNodeContents(node) establecer rango para seleccionar todo el contenido de node
collapse(toStart) si toStart=true establece final=comienzo, de otra manera comienzo=final, colapsando así el rango
cloneRange() crea un nuevo rango con el mismo inicio/final

Métodos para edición en el rango:Una vez creado el rango, podemos manipular su contenido usando estos métodos:

deleteContents() – eliminar el contenido de rango del documento
extractContents() – eliminar el contenido de rango del documento y lo retorna como DocumentFragment
cloneContents() – clonar el contenido del rango y lo retorna como DocumentFragment
insertNode(node) – inserta node en el documento al comienzo del rango
surroundContents(node) – envuelve node alrededor del contenido del rango. Para que esto funcione, el rango debe contener etiquetas de apertura y cierre para todos los elementos dentro de él, sin rangos parciales como <i>abc.

Con estos métodos podemos hacer básicamente cualquier cosa con los nodos seleccionados.
Aquí está el banco de pruebas para verlos en acción:

      
        
        
          
            
          
          
            
          
        
        
          Haga clic en los botones para ejecutar métodos en la selección, "resetExample" para restablecerla.

<p id="p">Example: <i>italic</i> and <b>bold</b></p>

<p id="result"></p>
<script>
  let range = new Range();

  // Cada método demostrado se representa aquí:
  let methods = {
    deleteContents() {
      range.deleteContents()
    },
    extractContents() {
      let content = range.extractContents();
      result.innerHTML = "";
      result.append("extracted: ", content);
    },
    cloneContents() {
      let content = range.cloneContents();
      result.innerHTML = "";
      result.append("cloned: ", content);
    },
    insertNode() {
      let newNode = document.createElement('u');
      newNode.innerHTML = "NEW NODE";
      range.insertNode(newNode);
    },
    surroundContents() {
      let newNode = document.createElement('u');
      try {
        range.surroundContents(newNode);
      } catch(e) { console.log(e) }
    },
    resetExample() {
      p.innerHTML = `Example: <i>italic</i> and <b>bold</b>`;
      result.innerHTML = "";

      range.setStart(p.firstChild, 2);
      range.setEnd(p.querySelector('b').firstChild, 3);

      window.getSelection().removeAllRanges();
      window.getSelection().addRange(range);
    }
  };

  for(let method in methods) {
    document.write(`<div><button onclick="methods.${method}()">${method}</button></div>`);
  }

  methods.resetExample();
</script>
        
      
      
          
        
      También existen métodos para comparar rangos, pero rara vez se utilizan. Cuando los necesite, consulte el spec o manual MDN.
SelectionRange es un objeto genérico para gestionar rangos de selección. Pero crearlos no significa que podamos ver la selección en la pantalla.
Podemos crear objetos Range, pasarlos; no seleccionan nada visualmente por sí mismos.
La selección de documento está representada por el objeto Selection, que se puede obtener como window.getSelection() o document.getSelection() Una selección puede incluir cero o más rangos. Al menos, la especificación Selection API lo dice. Sin embargo, en la práctica, solo Firefox permite seleccionar múltiples rangos en el documento usando Ctrl+click (Cmd+click para Mac).
Aquí hay una captura de pantalla de una selección con 3 rangos en Firefox:

      
      
        
      
      Otros navegadores admiten un rango máximo de 1. Como veremos, algunos de los métodos de Selection implica que puede haber muchos rangos, pero nuevamente, en todos los navegadores excepto Firefox, hay un máximo de 1.
Aquí hay una pequeña demo que muestra la selección actual (selecciona algo y haz clic) como texto:
alert(document.getSelection())
Propiedades de SelectionComo dijimos antes, una selección en teoría tiene múltiples rangos. Podemos obtener estos objetos rango usando el método:

getRangeAt(i) – obtiene el rango “i” comenzando desde 0. En todos los navegadores excepto Firefox, solo 0 es usado.

También existen propiedades que a menudo brindan conveniencia.
Similar a Range, una selección tiene un inicio, llamado “ancla(anchor)”, y un final, llamado “foco(focus)”.
Las principales propiedades de selection son:

anchorNode – el nodo donde comienza la selección,
anchorOffset – el desplazamiento en anchorNode donde comienza la selección,
focusNode – el nodo donde termina la selección,
focusOffset – el desplazamiento en focusNode donde termina la selección,
isCollapsed – true si la selección no selecciona nada (rango vacío), o no existe.
rangeCount – recuento de rangos en la selección, máximo “1” en todos los navegadores excepto Firefox.


            Inicio/final, Selection vs. Range
            Hay una diferencia importante entre anchor/focus (ancla/foco) de una selección comparado al inicio/fin de un rango.
Sabemos que los objetos Range siempre tienen el inicio antes que el final.
En las selecciones, no siempre es así.
Seleccionar algo con el ratón puede hacerse en ambas direcciones: tanto de izquierda a derecha como de derecha a izquierda.
Cuando el botón es presionado, cuando se mueve hacia adelante en el documento, entonces su final (foco) estará después del inicio (ancla).
Ej. si el usuario comienza a seleccionar con el mouse y pasa de “Example” a “italic”:

      
      
        
      
      …Pero la selección puede hacerse hacia atrás: comenzando por “italic” terminando en “Example”, su foco estará antes del ancla:

      
      
        
      
      
Eventos SelectionHay eventos para realizar un seguimiento de la selección:

elem.onselectstart – cuando una selección comienza en elem, ej. el usuario comienza a mover el mouse con el botón presionado.

Evitar la acción predeterminada hace que la selección no se inicie.


document.onselectionchange – siempre que cambie una selección.

Tenga en cuenta: este controlador solo se puede configurar en document.



Demostración de seguimiento de selecciónAquí hay una pequeña demostración que muestra los límites de selección de forma dinámica a medida que cambia:

      
        
        
          
            
          
          
            
          
        
        
          <p id="p">Select me: <i>italic</i> and <b>bold</b></p>

From <input id="from" disabled> – To <input id="to" disabled>
<script>
  document.onselectionchange = function() {
    let selection = document.getSelection();

    let {anchorNode, anchorOffset, focusNode, focusOffset} = selection;

    // anchorNode y focusNode usualmente son nodos de texto
    from.value = `${anchorNode?.data}, offset ${anchorOffset}`;
    to.value = `${focusNode?.data}, offset ${focusOffset}`;
  };
</script>
        
      
      
      Demostración de copia de selecciónHay dos enfoques para la copia de contenido seleccionado:

Podemos usar document.getSelection().toString() para obtenerlo como texto.
O copiar el DOM entero, por ejemplo si necesitamos mantener el formato, podemos obtener los rangos correspondientes con getRangesAt(...). Un objeto Range, a su vez, tiene el método cloneContents() que clona su contenido y devuelve un objeto DocumentFragment, que podemos insertar en algún otro lugar.

Aquí está la demostración de cómo obtener la selección como texto y como nodos DOM:

      
        
        
          
            
          
          
            
          
        
        
          <p id="p">Select me: <i>italic</i> and <b>bold</b></p>

Cloned: <span id="cloned"></span>
<br>
As text: <span id="astext"></span>

<script>
  document.onselectionchange = function() {
    let selection = document.getSelection();

    cloned.innerHTML = astext.innerHTML = "";

    // Clonar nodos DOM de rangos (admitimos selección múltiple aquí)
    for (let i = 0; i < selection.rangeCount; i++) {
      cloned.append(selection.getRangeAt(i).cloneContents());
    }

    // Obtener como texto
    astext.innerHTML += selection;
  };
</script>
        
      
      
      Métodos de selecciónPodemos trabajar con métodos de selección para agregar y eliminar rangos:

getRangeAt(i) – obtener el rango i-ésimo, comenzando desde “0”. En todos los navegadores, excepto Firefox, solo se utiliza 0.
addRange(rango) – agrega un rango a la selección. Todos los navegadores excepto Firefox ignoran la llamada, si la selección ya tiene un rango asociado.
removeRange(rango) --elimina rango de la selección.
removeAllRanges() --elimina todos los rangos.
empty() – alias para removeAllRanges.

Además, existen métodos convenientes para manipular el rango de selección directamente, sin llamadas intermedias a Range:

collapse(node, offset) – Reemplazar el rango seleccionado con uno nuevo que comienza y termina en el node dado, en posición offset.
setPosition(node, offset) – alias para collapse.
collapseToStart() – colapsar (reemplazar con un rango vacío) al inicio de la selección,
collapseToEnd() – colapso hasta el final de la selección,
extend(node, offset) – mover el foco de la selección al node dado, posición offset,
setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset) – reemplazar el rango de selección con el inicio dado anchorNode/anchorOffset y final focusNode/focusOffset. Se selecciona todo el contenido entre ellos.
selectAllChildren(node) – seleccionar todos los hijos del node.
deleteFromDocument() – eliminar el contenido seleccionado del documento.
containsNode(node, allowPartialContainment = false) – comprueba si la selección contiene node (parcialmente si el segundo argumento es true)

Entonces, para muchas tareas podemos llamar a los métodos de Selection, y no es necesario acceder al objeto Range subyacente.
Por ejemplo, seleccionando todo el contenido del párrafo <p>:

      
        
        
          
            
          
          
            
          
        
        
          <p id="p">Select me: <i>italic</i> and <b>bold</b></p>

<script>
  // seleccione desde el 0 hijo de <p> hasta el último hijo
  document.getSelection().setBaseAndExtent(p, 0, p, p.childNodes.length);
</script>
        
      
      
      Lo mismo usando rangos:

      
        
        
          
            
          
          
            
          
        
        
          <p id="p">Select me: <i>italic</i> and <b>bold</b></p>

<script>
  let range = new Range();
  range.selectNodeContents(p); // o selectNode(p) para seleccionar el tag <p> también

  document.getSelection().removeAllRanges(); // borrar la selección existente si la hubiera
  document.getSelection().addRange(range);
</script>
        
      
      
      
            Para seleccionar, primero elimine la selección existente
            Si la selección ya existe, vacíelo primero con removeAllRanges(). Y luego agregue rangos. De lo contrario, todos los navegadores excepto Firefox ignoran los nuevos rangos.
La excepción son algunos métodos de selección, que reemplazan la selección existente, como setBaseAndExtent.

Selección en controles de formularioElementos de formulario, como input y textarea proporciona API especial para la selección, sin objetos Selection o Range. Como un valor de entrada es un texto puro, no HTML, no hay necesidad de tales objetos, todo es mucho más simple.
Propiedades:

input.selectionStart – posición de inicio de selección (escribible),
input.selectionEnd – posición del final de la selección (escribible),
input.selectionDirection – dirección de selección, una de: “adelante” “hacia atrás” o “ninguno” (si, por ejemplo, se selecciona con un doble clic del mouse),

Eventos:

input.onselect – se activa cuando se selecciona algo.

Métodos:


input.select() – selecciona todo en el control de texto (puede ser textarea en vez de input),


input.setSelectionRange(start, end, [direction]) – cambiar la selección para abarcar desde la posición start hasta end, en la dirección indicada (opcional).


input.setRangeText(replacement, [start], [end], [selectionMode]) – reemplace un rango de texto con el nuevo texto.
Los argumentos opcionales start y end, si se proporcionan, establecen el inicio y el final del rango; de lo contrario, se utiliza la selección del usuario.
El último argumento, selectionMode, determina cómo se establecerá la selección después de que se haya reemplazado el texto. Los posibles valores son:

"select" – se seleccionará el texto recién insertado.
"start" – el rango de selección se colapsa justo antes del texto insertado (el cursor estará inmediatamente antes).
"end" – el rango de selección se colapsa justo después del texto insertado (el cursor estará justo después).
"preserve" – intenta preservar la selección. Este es el predeterminado.



Ahora veamos estos métodos en acción.
Ejemplo: Seguimiento de selecciónPor ejemplo, este código usa el evento onselect para rastrear la selección:

      
        
        
          
            
          
          
            
          
        
        
          <textarea id="area" style="width:80%;height:60px">
Selecting in this text updates values below.
</textarea>
<br>
From <input id="from" disabled> – To <input id="to" disabled>

<script>
  area.onselect = function() {
    from.value = area.selectionStart;
    to.value = area.selectionEnd;
  };
</script>
        
      
      
          
        
      Tenga en cuenta:

onselect se activa cuando se selecciona algo, pero no cuando se elimina la selección.
El evento document.onselectionchange no debería activarse para las selecciones dentro de un control de formulario, según el spec, ya que no está relacionado con la selección y los rangos del “documento”. Algunos navegadores lo generan, pero no debemos confiar en él.

Ejemplo: cursor en movimientoPodemos cambiar selectionStart y selectionEnd, que establece la selección.
Un caso límite importante es cuando selectionStart y selectionEnd son iguales entre sí. Entonces es exactamente la posición del cursor. O, para reformular, cuando no se selecciona nada, la selección se contrae en la posición del cursor.
Entonces, al establecer selectionStart y selectionEnd en el mismo valor, movemos el cursor.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <textarea id="area" style="width:80%;height:60px">
Focus on me, the cursor will be at position 10.
</textarea>

<script>
  area.onfocus = () => {
    // zero delay setTimeout to run after browser "focus" action finishes
    setTimeout(() => {
      // we can set any selection
      // if start=end, the cursor is exactly at that place
      area.selectionStart = area.selectionEnd = 10;
    });
  };
</script>
        
      
      
          
        
      Ejemplo: modificar la selecciónPara modificar el contenido de la selección, podemos utilizar el método input.setRangeText() Por supuesto, podemos leer selectionStart/End y, con el conocimiento de la selección, cambiar la subcadena correspondiente de value, pero setRangeText es más poderoso y a menudo más conveniente.
Ese es un método algo complejo. En su forma más simple de un argumento, reemplaza el rango seleccionado por el usuario y elimina la selección.
Por ejemplo, aquí la selección de usuario estará envuelta por *...*:

      
        
        
          
            
          
          
            
          
        
        
          <input id="input" style="width:200px" value="Select here and click the button">
<button id="button">Wrap selection in stars *...*</button>

<script>
button.onclick = () => {
  if (input.selectionStart == input.selectionEnd) {
    return; // nada fue seleccionado
  }

  let selected = input.value.slice(input.selectionStart, input.selectionEnd);
  input.setRangeText(`*${selected}*`);
};
</script>
        
      
      
          
        
      Con más argumentos, podemos establecer un rango start y end.
En este ejemplo, encontramos THIS en el texto de entrada, lo reemplazamos y mantenemos el reemplazo seleccionado:

      
        
        
          
            
          
          
            
          
        
        
          <input id="input" style="width:200px" value="Replace THIS in text">
<button id="button">Replace THIS</button>

<script>
button.onclick = () => {
  let pos = input.value.indexOf("THIS");
  if (pos >= 0) {
    input.setRangeText("*THIS*", pos, pos + 4, "select");
    input.focus(); // focus to make selection visible
  }
};
</script>
        
      
      
          
        
      Ejemplo: insertar en el cursorSi no se selecciona nada, o usamos el mismo comienzo y final en setRangeText, entonces el nuevo texto se acaba de insertar, no se elimina nada.
También podemos insertar algo “en el cursor” usando setRangeText.
Aquí hay un botón que se inserta "HELLO" en la posición del cursor y lo coloca inmediatamente después. Si la selección no está vacía, entonces se reemplaza (podemos detectarla comparando selectionStart!=selectionEnd y hacer otra cosa en su lugar):

      
        
        
          
            
          
          
            
          
        
        
          <input id="input" style="width:200px" value="Text Text Text Text Text">
<button id="button">Insert "HELLO" at cursor</button>

<script>
  button.onclick = () => {
    input.setRangeText("HELLO", input.selectionStart, input.selectionEnd, "end");
    input.focus();
  };
</script>
        
      
      
          
        
      Haciendo no seleccionablePara hacer algo no seleccionable, hay tres formas:


Usar propiedad CSS user-select: none.

      
        
        
          
            
          
          
            
          
        
        
          <style>
#elem {
  user-select: none;
}
</style>
<div>Selectable <div id="elem">Unselectable</div> Selectable</div>
        
      
      
      Esto no permite que la selección comience en elem. Pero el usuario puede iniciar la selección en otro lugar e incluir elem en ella.
Entonces, elem se convertirá en parte de document.getSelection ), por lo que la selección realmente ocurre, pero su contenido generalmente se ignora al copiar y pegar.


Evita la acción predeterminada en los eventos onselectstart o mousedown.

      
        
        
          
            
          
          
            
          
        
        
          <div>Selectable <div id="elem">Unselectable</div> Selectable</div>

<script>
  elem.onselectstart = () => false;
</script>
        
      
      
      Esto evita que la selección se inicie en elem, pero el visitante puede iniciarla en otro elemento y luego extenderla a elem.


Eso es conveniente cuando hay otro controlador de eventos en la misma acción que activa la selección (por ejemplo, mousedown). Así que deshabilitamos la selección para evitar conflictos, permitiendo que se copien los contenidos de elem.

También podemos borrar la selección post-factum después de que suceda con document.getSelection().Empty (). Eso se usa con poca frecuencia, ya que provoca un parpadeo no deseado cuando la selección aparece o desaparece.

Referencias
DOM spec: Range
Selection API
HTML spec: APIs for the text control selections

ResumenCubrimos dos API diferentes para las selecciones:

Para el documento: objetos Selection y Range.
Para input, textarea: métodos y propiedades adicionales.

La segunda API es muy simple, ya que funciona con texto.
Las recetas más utilizadas probablemente sean:

Obteniendo la selección:
      
        
        
          let selection = document.getSelection();

let cloned = /* elemento para clonar los nodos seleccionados para */;

// luego aplica los métodos Range a selection.getRangeAt (0)
// o, como aquí, a todos los rangos para admitir selección múltiple
for (let i = 0; i < selection.rangeCount; i++) {
  cloned.append(selection.getRangeAt(i).cloneContents());
}
        
      
      
      
Configuración de la selección:
      
        
        
          let selection = document.getSelection();

// directamente:
selection.setBaseAndExtent(...from...to...);

// o podemos crear un rango y:
selection.removeAllRanges();
selection.addRange(range);
        
      
      
      

Y finalmente, sobre el cursor. La posición del cursor en elementos editables, como <textarea> está siempre al principio o al final de la selección. Podemos usarlo para obtener la posición del cursor o para mover el cursor configurando elem.selectionStart y elem.selectionEnd.
",
	"url": "https://es.javascript.info/selection-range" 
},
{
	"docs_id": "128",
	"name": "Loop de eventos: microtareas y macrotareas",
	"description": "El flujo de ejecución de JavaScript en el navegador, así como en Node.js, está basado en un event loop (loop de eventos).",
	"content": "El flujo de ejecución de JavaScript en el navegador, así como en Node.js, está basado en un event loop (loop de eventos).
Entender como este loop de eventos funciona es importante para optimizaciones y en algunos casos para utilizar la arquitectura correcta.
En este capítulo primero vamos a ver detalles teóricos acerca de cómo funcionan las cosas y luego veremos aplicaciones prácticas de ese conocimiento.
Loop de eventosEl concepto de loop de eventos es muy simple. Existe un ciclo infinito en el que el motor de JavaScript espera por una tarea, luego ejecuta la tarea requerida y finalmente vuelve a dormir esperando por una nueva tarea.
EL algoritmo general del motor:

Mientras haya tareas:

ejecutarlas comenzando por la más antigua.


Dormir hasta que aparezca una tarea, luego volver a 1.

Eso es una formalización de lo que vemos cuando navegamos por una página. El motor JavaScript no hace nada la mayoría del tiempo y solo corre cuando un script/controlador/evento se activa.
Ejemplos de tareas:

Cuando un script externo <script src="..."> se carga, la tarea es ejecutarlo.
Cuando un usuario mueve el mouse, la tarea es enviar el evento mousemove y ejecutar el controlador.
Cuando llega el momento de un setTimeout programado, la tarea es ejecutar su callback.
… y así sucesivamente.

Las tareas son programadas --> el motor las ejecuta --> espera por más tareas (mientras duerme y prácticamente no consume CPU).
Puede ocurrir que una tarea llegue mientras el motor está ocupado, entonces es puesta en cola.
Las tareas forman una cola, también llamada “Cola de macrotarea” (Término de v8):

      
      
        
      
      Por ejemplo, mientras el motor está ocupado ejecutando un script, un usuario podría mover su mouse causando mousemove o también podría ser setTimeout, etc. Todas estas tareas forman una cola como se observa en la imagen arriba.
Las tareas de la cola son ejecutadas según la base “El que primero llega primero se atiende”. Cuando el motor del navegador termina con el script, se encarga del evento mousemove, continúa con setTimeout, etc.
Hasta ahora bastante simple, ¿no?
Dos detalles más:

El renderizado nunca ocurre mientras el motor ejecuta una tarea. No importa si la tarea ocupa mucho tiempo. Solo se realizan cambios a DOM una vez que la tarea finaliza.
Si una tarea consume demasiado tiempo, el navegador no puede hacer otras tareas, procesos o eventos por lo que después de un tiempo muestra una alerta “La página no responde” sugiriendo detener la tarea con la página completa. Esto ocurre cuando hay muchos cálculos complejos o un error en la programación que lleva a un bucle infinito.

Esa fue la teoría. Ahora veamos como podemos aplicar ese conocimiento.
Caso de uso 1: dividiendo tareas que demandan alto consumo de CPUDigamos que tenemos una tarea con un alto consumo de CPU.
Por ejemplo, el resaltado de sintaxis (usado para colorear ejemplos de código en esta página) demanda un alto consumo de CPU. Para resaltar el código, realiza el análisis, crea muchos elementos coloreados, los agrega al documento… para una gran cantidad de texto esto lleva mucho tiempo.
Mientras el motor está ocupado con el resaltado de sintaxis, no puede hacer otras cosas relacionadas a DOM, procesar eventos de usuario, etc. Podría incluso provocar que el navegador se “congele” por un momento, lo que es inaceptable.
Podemos evitar problemas dividiendo la tarea en piezas más pequeñas. Resaltar primero 100 líneas, después programar setTimeout (con cero delay) para las próximas 100 líneas y así sucesivamente.
Para demostrar este enfoque y en pos de una mayor simplicidad, en lugar de resaltado de texto tomemos una función que cuenta desde 1 hasta 1000000000.
Si ejecutas el código siguiente, el navegador se va a “congelar” por un instante. Para JS desde el lado del servidor esto es claramente notable y si lo ejecutas en el navegador intenta hacer click en otros botones de la página. Verás que ningún otro evento es procesado hasta que termine el conteo.

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

let start = Date.now();

function count() {

  // realiza una tarea pesada
  for (let j = 0; j < 1e9; j++) {
    i++;
  }

  alert("Done in " + (Date.now() - start) + 'ms');
}

count();
        
      
      
      Puede que incluso se muestre una advertencia: “Un script en esta página está provocando que el navegador se ejecute con lentitud”.
Dividamos la tarea usando llamadas anidadas a setTimeout:

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

let start = Date.now();

function count() {

  // realiza una parte de la tarea pesada(*)
  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  } else {
    setTimeout(count); // programa una nueva llamada (**)
  }

}

count();
        
      
      
      Ahora la interfaz del navegador es completamente funcional durante el conteo.
Una solo ejecución de count realiza parte del trabajo (*) y luego se reprograma a sí misma (**) si lo necesita:

La primer ejecución cuenta: i=1...1000000.
La segunda cuenta: i=1000001..2000000.
…y así sucesivamente.

Ahora, si una tarea secundaria (por ejemplo el evento onclick) aparece mientras el motor está ocupado ejecutando la parte 1, entonces es puesta en lista y ejecutada cuando la parte 1 termina, antes de la siguiente parte. Retornos periódicos al ciclo de eventos entre ejecuciones de count brinda suficiente “aire” al motor de JavaScript para hacer algo más, para reaccionar a otras acciones del usuario.
Lo notable es que ambas variantes, con y sin división de la tarea haciendo uso de setTimeout, son comparables en velocidad. No hay mucha diferencia en el tiempo de conteo general.
Para acercar aún más los tiempos, hagamos una mejora.
Movamos la programación de setTimeout al inicio de count():

      
        
        
          
            
          
          
            
          
        
        
          let i = 0;

let start = Date.now();

function count() {

  // movemos la programación al principio
  if (i < 1e9 - 1e6) {
    setTimeout(count); // programamos la nueva llamada
  }

  do {
    i++;
  } while (i % 1e6 != 0);

  if (i == 1e9) {
    alert("Done in " + (Date.now() - start) + 'ms');
  }

}

count();
        
      
      
      Ahora cuando iniciamos count() y vemos que necesitaremos más count(), lo programamos inmediatamente, antes de hacer el trabajo.
Si lo ejecutas, es fácil notar que lleva bastante menos tiempo.
¿Por qué pasa esto?
Es simple: como recordarás existe un retraso mínimo en el navegador de 4ms para varias llamadas anidadas a setTimeout. Si configuramos 0, es 4ms (o un poco más). Por lo que mientras antes lo programemos más rápido se ejecutará.
Finalmente hemos dividido una tarea con un alto consumo de CPU en partes y ahora no bloquea la interfaz de usuario. Y el tiempo general de ejecución no es mucho mayor.
Caso de uso 2: indicación de progresoOtro beneficio de dividir tareas pesadas para scripts de navegadores es que podemos indicar el progreso.
Usualmente el navegador renderiza al terminar la ejecución del código que actualmente se está ejecutando. No importa si la tarea lleva demasiado tiempo.
Por un lado eso es genial porque nuestra función puede crear muchos elementos, agregarlos de a uno al documento y cambiar sus estilos… el visitante no verá ningún estado intermedio, sin finalizar. Lo cuál es importante, ¿no?
Acá hay una demostración, los cambios a i no se mostrarán hasta que la función finalice, por lo que veremos solo el último valor:

      
        
        
          
            
          
          
            
          
        
        
          <div id="progress"></div>

<script>

  function count() {
    for (let i = 0; i < 1e6; i++) {
      i++;
      progress.innerHTML = i;
    }
  }

  count();
</script>
        
      
      
      … Pero puede que queramos mostrar algo durante la tarea, por ejemplo una barra de progreso.
Si dividimos la tarea más pesada en partes más pequeñas usando setTimeout, entonces los cambios son aplicados entre ellos.
Esto se ve mejor:

      
        
        
          
            
          
          
            
          
        
        
          <div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // realiza una parte del trabajo pesado (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e7) {
      setTimeout(count);
    }

  }

  count();
</script>
        
      
      
      Ahora el <div> muestra el incremento en el valor i, una especie de barra de progreso.
Caso de uso 3: hacer algo después del eventoEn un controlador de evento nosotros podemos decidir posponer alguna acción hasta que el evento aparezca y sea controlado en todos los niveles. Podemos hacer esto envolviendo el código en un setTimeout con retraso cero.
En el capítulo Envío de eventos personalizados vimos un ejemplo: el evento personalizado menu-open es distribuido en setTimeout, de modo que ocurre después de que el evento “click” se maneja por completo.

      
        
        
          menu.onclick = function() {
  // ...

  // crea un evento personalizado con los datos del elemento de menú en el que se hizo clic
  let customEvent = new CustomEvent("menu-open", {
    bubbles: true
  });

  // envia el evento personalizado de forma asincrónica
  setTimeout(() => menu.dispatchEvent(customEvent));
};
        
      
      
      Macrotareas y MicrotareasJunto con las macrotareas descritas en este capítulo, existen microtareas mencionadas en el capítulo Microtareas (Microtasks).
Las microtareas provienen únicamente de nuestro código. Por lo general, se crean mediante promesas: una ejecución del controlador .then / catch / finally se convierte en una microtarea. Las microtareas también se utilizan “bajo la cubierta” de “await”, ya que es otra forma de manejo de promesas.
Existe también una función especial queueMicrotask(func) que pone a func en la cola de microtareas.
Inmediatamente después de cada macrotarea, el motor ejecuta todas las tareas desde la cola de microtareas, antes de ejecutar cualquier otra macrotarea o renderización o cualquier otra cosa.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
        
      
      
      ¿Cuál será el orden en este caso?

code se muestra primero porque es una llamada sincrónica regular.
promise aparece segundo, porque .then pasa a través de la cola de microtareas y se ejecuta después del código actual.
timeout aparece última, porque es una macrotarea.

La imagen del loop de eventos completa se ve así (el orden es de arriba a abajo, es decir: primero el script, luego las microtareas, el renderizado, etc.):

      
      
        
      
      Todas las microtareas se completan antes de que se lleve a cabo cualquier otro manejo o renderizado o cualquier otra macrotarea.
Eso es importante, ya que garantiza que el entorno de la aplicación es básicamente el mismo (sin cambios de coordenadas del mouse, sin nuevos datos de red, etc.) entre las microtareas.
Si quisiéramos ejecutar una función de forma asíncrónica (después del código actual), pero antes de que se procesen los cambios o se manejen nuevos eventos, podemos programarla con queueMicrotask.
Aquí hay un ejemplo con la “barra de progreso de conteo”, similar al que se mostró anteriormente, pero se usa queueMicrotask en lugar desetTimeout. Puedes ver que se renderiza al final. Al igual que el código sincrónico:

      
        
        
          
            
          
          
            
          
        
        
          <div id="progress"></div>

<script>
  let i = 0;

  function count() {

    // realiza una parte del trabajo pesado (*)
    do {
      i++;
      progress.innerHTML = i;
    } while (i % 1e3 != 0);

    if (i < 1e6) {
      queueMicrotask(count);
    }

  }

  count();
</script>
        
      
      
      ResumenEl algoritmo más detallado del loop de eventos (aunque aún simplificado en comparación con la especificación):

Retirar de la cola y ejecutar la tarea más antigua de la cola macrotareas (por ejemplo, “script”).
Ejecutar todas las microtareas:

Mientras la cola de microtareas no esté vacía:

Retirar de la cola y ejecutar la microtarea más antigua.




Renderizar los cambios si los hubiera.
Si la cola de macrotareas está vacía, esperar hasta que aparezca una macrotarea.
Ejecutar el paso 1.

Para programar una nueva macrotarea:

Usar setTimeout(f) con un retraso de cero.

Eso puede usarse para dividir una gran tarea de cálculo en partes, para que el navegador pueda reaccionar a los eventos del usuario y mostrar el progreso entre ellos.
Además, se utiliza en los controladores de eventos para programar una acción después de que el evento se haya manejado por completo.
Para programar una nueva microtarea

Usar queueMicrotask(f).
También se usan promesas para que los controladores pasen por la cola de microtareas.

No hay gestión de eventos de red o de UI entre las microtareas: se ejecutan inmediatamente una tras otra.
Por lo tanto, es posible que desee queueMicrotask para ejecutar una función de forma asincrónica, pero dentro del estado del entorno.

            Web Workers
            Para cálculos largos y pesados que no deberían bloquear el ciclo de eventos, podemos usar Web Workers.
Esa es una forma de ejecutar código en otro hilo paralelo.
Los Web Workers pueden intercambiar mensajes con el proceso principal, pero tienen sus propias variables y su propio ciclo de eventos.
Los Web Workers no tienen acceso a DOM, por lo que son útiles principalmente para cálculos, para utilizar varios núcleos de CPU simultáneamente.

TareasWhat will be the output of this code?importancia: 5
      
        
        
          console.log(1);

setTimeout(() => console.log(2));

Promise.resolve().then(() => console.log(3));

Promise.resolve().then(() => setTimeout(() => console.log(4)));

Promise.resolve().then(() => console.log(5));

setTimeout(() => console.log(6));

console.log(7);
        
      
      
      soluciónThe console output is: 1 7 3 5 2 6 4.
The task is quite simple, we just need to know how microtask and macrotask queues work.
Let’s see what’s going on, step by step.

      
        
        
          console.log(1);
// The first line executes immediately, it outputs `1`.
// Macrotask and microtask queues are empty, as of now.

setTimeout(() => console.log(2));
// `setTimeout` appends the callback to the macrotask queue.
// - macrotask queue content:
//   `console.log(2)`

Promise.resolve().then(() => console.log(3));
// The callback is appended to the microtask queue.
// - microtask queue content:
//   `console.log(3)`

Promise.resolve().then(() => setTimeout(() => console.log(4)));
// The callback with `setTimeout(...4)` is appended to microtasks
// - microtask queue content:
//   `console.log(3); setTimeout(...4)`

Promise.resolve().then(() => console.log(5));
// The callback is appended to the microtask queue
// - microtask queue content:
//   `console.log(3); setTimeout(...4); console.log(5)`

setTimeout(() => console.log(6));
// `setTimeout` appends the callback to macrotasks
// - macrotask queue content:
//   `console.log(2); console.log(6)`

console.log(7);
// Outputs 7 immediately.
        
      
      
      To summarize,

Numbers 1 и 7 show up immediately, because simple console.log calls don’t use any queues.
Then, after the main code flow is finished, the microtask queue runs.

It has commands: console.log(3); setTimeout(...4); console.log(5).
Numbers 3 и 5 show up, while setTimeout(() => console.log(4)) adds the console.log(4) call to the end of the macrotask queue.
The macrotask queue is now: console.log(2); console.log(6); console.log(4).


After the microtask queue becomes empty, the macrotask queue executes. It outputs 2, 6, 4.

Finally, we have the output: 1 7 3 5 2 6 4.
",
	"url": "https://es.javascript.info/event-loop" 
},
{
	"docs_id": "129",
	"name": "Ventanas emergentes y métodos de ventana",
	"description": "Una ventana emergente (popup window) es uno de los métodos más antiguos para mostrar documentos adicionales al usuario.",
	"content": "Una ventana emergente (popup window) es uno de los métodos más antiguos para mostrar documentos adicionales al usuario.
Básicamente, solo ejecutas :

      
        
        
          window.open("https://javascript.info/");
        
      
      
      …Y eso abrirá una nueva ventana con la URL dada. La mayoría de los navegadores modernos están configurados para abrir pestañas nuevas en vez de ventanas separadas.
Los popups existen desde tiempos realmente antiguos. La idea inicial fue mostrar otro contenido sin cerrar la ventana principal. Ahora hay otras formas de hacerlo: podemos cargar contenido dinámicamente con fetch y mostrarlo de forma dinámica con <div>. Entonces, los popups no son algo que usamos todos los días.
Además, los popups son complicados en dispositivos móviles, que no muestran varias ventanas simultáneamente.
Aún así, hay tareas donde los popups todavía son usados, por ejemplo para autorización o autenticación (Ingreso con Google/Facebook/…), porque:

Un popup es una ventana separada con su propio entorno JavaScript independiente. Por lo tanto es seguro abrir un popup desde un sitio de terceros no confiable.
Es muy fácil abrir un popup.
Un popup puede navegar (cambiar URL) y enviar mensajes a la ventana que lo abrió.

Bloqueo de ventanas emergentes (Popup)En el pasado, sitios malvados abusaron mucho de las ventanas emergentes. Una página incorrecta podría abrir toneladas de ventanas emergentes con anuncios. Entonces, la mayoría de los navegadores intentan bloquear las ventanas emergentes y proteger al usuario.
La mayoría de los navegadores bloquean las ventanas emergentes si se llaman fuera de los controladores de eventos activados por el usuario, como onclick.
Por ejemplo:

      
        
        
          // popup blocked
window.open("https://javascript.info");

// popup allowed
button.onclick = () => {
  window.open("https://javascript.info");
};
        
      
      
      De esta manera, los usuarios están algo protegidos de ventanas emergentes no deseadas, pero la funcionalidad no está totalmente deshabilitada.
¿Qué pasa si la ventana emergente se abre desde onclick, pero después de setTimeout? Eso es un poco complicado.
Intenta este código:

      
        
        
          
            
          
          
            
          
        
        
          // open after 3 seconds
setTimeout(() => window.open("http://google.com"), 3000);
        
      
      
      Las ventanas emergentes se abren en Chrome , pero se bloquean en Firefox.
…Si disminuimos el retraso, la ventana emergente también funciona en Firefox:

      
        
        
          
            
          
          
            
          
        
        
          // open after 1 seconds
setTimeout(() => window.open("http://google.com"), 1000);
        
      
      
      La diferencia es que Firefox trata al timeout de 2000ms o menos como aceptable, pero después elimina la “confianza” asumiendo que ahora está “fuera de la acción del usuario”. Entonces el primero está bloqueado, y el segundo no lo está.
window.openLa sintaxis para abrir una ventana emergente es: window.open(url, name, params):

url
Una URL para cargar en la nueva ventana.
name
Un nombre de la nueva ventana. Cada ventana tiene un window.name, y aquí podemos especificar cuál ventana usar para la ventana emergente. Si hay una ventana con ese nombre, la URL dada se abre en ella, de lo contrario abre una nueva ventana.
params
La cadena de configuración para nueva ventana. Contiene configuraciones, delimitado por una coma. No debe haber espacios en los parámetros, por ejemplo: width=200,height=100.

Configuración de params:

Posición:

left/top (numérico) – coordenadas de la esquina superior izquierda de la ventana en la pantalla.Hay una limitación: no se puede colocar una nueva ventana fuera de la pantalla.
width/height (numérico) – ancho y alto de una nueva ventana. Hay un límite mínimo de ancho/alto , así que es imposible crear una ventana invisible.


Características de la ventana:

menubar (yes/no) – muestra u oculta el menú del navegador en la nueva ventana.
toolbar (yes/no) – muestra u oculta la barra de navegación del navegador (atrás, adelante, recargar, etc.) en la nueva ventana.
location (yes/no) – muestra u oculta el campo URL en la nueva ventana. FF e IE no permiten ocultarlo por defecto.
status (yes/no) – muestra u oculta la barra de estado. De nuevo, la mayoría de los navegadores lo obligan a mostrar.
resizable (yes/no) – permite deshabilitar el cambio de tamaño para la nueva ventana. No recomendado.
scrollbars (yes/no) – permite deshabilitar las barras de desplazamiento para la nueva ventana. No recomendado.



También hay una serie de características específicas del navegador menos compatibles, que generalmente no se usan. Revisa window.open en MDN para ejemplos.
Ejemplo: Una ventana minimalistaAbramos una ventana con un conjunto mínimo de características solo para ver cuál de ellos permite desactivar el navegador:

      
        
        
          
            
          
          
            
          
        
        
          let params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,
width=0,height=0,left=-1000,top=-1000`;

open("/", "test", params);
        
      
      
      Aquí la mayoría de las “características de la ventana” están deshabilitadas y la ventana se coloca fuera de la pantalla. Ejecútelo y vea lo que realmente sucede. La mayoría de los navegadores “arreglan” cosas extrañas como cero ancho/alto y fuera de pantalla Izquierda/superior. Por ejemplo, Chrome abre una ventana con ancho/alto completo, para que ocupe la pantalla completa.
Agreguemos opciones de posicionamiento normal y coordenadas razonables de ancho,altura, izquierda,arriba:

      
        
        
          
            
          
          
            
          
        
        
          let params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,
width=600,height=300,left=100,top=100`;

open("/", "test", params);
        
      
      
      La mayoría de los navegadores muestran el ejemplo anterior según sea necesario.
Reglas para configuraciones omitidas:

Si no hay un tercer argumento en la llamada a open o está vacío, se usan los parámetros de ventana predeterminados.
Si hay una cadena de params, pero se omiten algunas características sí/no (yes/no), las características omitidas se asumen con valor no . Entonces, si especifica parámetros, asegúrese de establecer explícitamente todas las funciones requeridas en yes.
Si no hay izquierda/arriba en params, entonces el navegador intenta abrir una nueva ventana cerca de la última ventana abierta.
Si no hay ancho/altura, entonces la nueva ventana tendrá el mismo tamaño que la última abierta.

Acceder a la ventana emergente desde la ventanaLa llamada open devuelve una referencia a la nueva ventana. Se puede usar para manipular sus propiedades, cambiar de ubicación y aún más.
En este ejemplo, generamos contenido emergente a partir de JavaScript:

      
        
        
          let newWin = window.open("about:blank", "hello", "width=200,height=200");

newWin.document.write("Hello, world!");
        
      
      
      Y aquí modificamos el contenido después de la carga:

      
        
        
          
            
          
          
            
          
        
        
          let newWindow = open("/", "example", "width=300,height=300");
newWindow.focus();

alert(newWindow.location.href); // (*) about:blank, loading hasn't started yet

newWindow.onload = function() {
  let html = `<div style="font-size:30px">Welcome!</div>`;
  newWindow.document.body.insertAdjacentHTML("afterbegin", html);
};
        
      
      
      Por favor, tenga en cuenta: inmediatamente después de window.open la nueva ventana no está cargada aún. Esto queda demostrado por el alert en la linea (*). Así que esperamos a que onload lo modifique. También podríamos usar DOMContentLoaded de los manejadores de newWin.document.

            Política mismo origen
            Las ventanas pueden acceder libremente a los contenidos de las demás sólo si provienen del mismo origen (el mismo protocolo://domain:port).
De lo contrario es imposible por razones de seguridad del usuario, por ejemplo si la ventana principal es de site.com y la ventana emergente (popup) es de  gmail.com. Para los detalles, ver capitulo Comunicación entre ventanas.

Acceder a la ventana desde el popupUn popup también puede acceder la ventana que lo abrió usando la referencia window.opener. Es null para todas las ventanas excepto los popups.
Si ejecutas el código de abajo, reemplaza el contenido de la ventana del opener (actual) con “Test”:

      
        
        
          
            
          
          
            
          
        
        
          let newWin = window.open("about:blank", "hello", "width=200,height=200");

newWin.document.write(
  "<script>window.opener.document.body.innerHTML = 'Test'<\/script>"
);
        
      
      
      Así que la conexión entre las ventanas es bidireccional: la ventana principal y el popup tienen una referencia entre sí.
Cerrar una popupPara cerrar una ventana: win.close().
Para comprobar si una ventana esta cerrada: win.closed.
Técnicamente, el close() es un método disponible para cualquier ventana, pero window.close() es ignorado por la mayoría de los navegadores si window no es creada con window.open(). Así que solo funcionará en una popup.
El closed es una propiedad true si la ventana esta cerrada. Eso es usualmente para comprobar la popup (o la ventana principal) está todavía abierta o no. Un usuario puede cerrarla en cualquier momento, y nuestro código debería tener esa posibilidad en cuenta.
Este código se carga y luego cierra la ventana:

      
        
        
          
            
          
          
            
          
        
        
          let newWindow = open("/", "example", "width=300,height=300");

newWindow.onload = function () {
  newWindow.close();
  alert(newWindow.closed); // true
};
        
      
      
      desplazamiento y cambio de tamañoHay métodos para mover/redimensionar una ventana:

win.moveBy(x,y)
Mueve la ventana en relación con la posición actual x píxeles a la derecha y y píxeles hacia abajo. Valores negativos están permitidos(para mover a la izquierda/arriba).
win.moveTo(x,y)
Mover la ventana por coordenadas (x,y) en la pantalla.
win.resizeBy(width,height)
Cambiar el tamaño de la ventana según el width/height dado en relación con el tamaño actual. Se permiten valores negativos.
win.resizeTo(width,height)
Redimensionar la ventana al tamaño dado.

También existe el evento window.onresize.

            Solo Popup
            Para evitar abusos, el navegador suele bloquear estos métodos. Solo funcionan de manera confiable en las ventanas emergentes que abrimos, que no tienen pestañas adicionales.


            No minification/maximization
            JavaScript no tiene forma de minimizar o maximizar una ventana. Estas funciones de nivel de sistema operativo están ocultas para los desarrolladores de frontend.
Los métodos de movimiento/cambio de tamaño no funcionan para ventanas maximizadas/minimizadas.

desplazando una ventanaYa hemos hablado sobre el desplazamiento de una ventana en el capítulo Tamaño de ventana y desplazamiento.

win.scrollBy(x,y)
Desplaza la ventana x píxeles a la derecha y y hacia abajo en relación con el actual desplazamiento. Se permiten valores negativos.
win.scrollTo(x,y)
Desplaza la ventana a las coordenadas dadas (x,y).
elem.scrollIntoView(top = true)
Desplaza la ventana para hacer que elem aparezca en la parte superior (la predeterminada) o en la parte inferior para elem.scrollIntoView(false).

También existe el evento window.onscroll.
Enfocar/desenfocar una ventanaTeóricamente, están los métodos window.focus() y window.blur() para poner/sacar el foco de una ventana. Y los eventos focus/blur que permiten captar el momento en el que el visitante enfoca una ventana y en el que cambia a otro lugar.
En la práctica estos métodos están severamente limitado, porque en el pasado las páginas malignas abusaban de ellos.
Por ejemplo, mira este código:

      
        
        
          
            
          
          
            
          
        
        
          window.onblur = () => window.focus();
        
      
      
      Cuando un usuario intenta salir de la ventana (window.onblur), lo vuelve a enfocar. La intención es “bloquear” al usuario dentro de la window.
Entonces, hay limitaciones que prohíben el código así. Existen muchas limitaciones para proteger al usuario de anuncios y páginas malignas. Ellos dependen del navegador.
Por ejemplo, un navegador móvil generalmente ignora esa llamada por completo. Además, el enfoque no funciona cuando se abre una ventana emergente en una pestaña separada en lugar de en una nueva ventana.
Aún así hay algunas cosas que se pueden hacer.
Por ejemplo:

Cuando abrimos una popup, puede ser una buena idea ejecutar un newWindow.focus() en ella. Solo por si acaso. Para algunas combinaciones de sistema-operativo/navegador, asegura que el usuario ahora esté en la nueva ventana.
Si queremos saber cuándo un visitante realmente usa nuestra aplicación web, podemos monitorear window.onfocus/onblur. Esto nos permite suspender/reanudar las actividades en la página, animaciones etc. Pero tenga en cuenta que el evento blur solamente significa que el visitante salió de la ventana. La ventana queda en segundo plano, pero aún puede ser visible.

ResumenLas ventanas emergentes se utilizan con poca frecuencia, ya que existen alternativas: cargar y mostrar información en la página o en iframe.
Si vamos a abrir una ventana emergente, una buena práctica es informar al usuario al respecto. Un icono de “ventana que se abre” cerca de un enlace o botón permitiría al visitante sobrevivir al cambio de enfoque y tener en cuenta ambas ventanas.

Se puede abrir una ventana emergente con la llamada open (url, name, params). Devuelve la referencia a la ventana recién abierta.
Los navegadores bloquean las llamadas open desde el código fuera de las acciones del usuario. Por lo general aparece una notificación para que un usuario pueda permitirlos.
Los navegadores abren una nueva pestaña de forma predeterminada, pero si se proporcionan tamaños, será una ventana emergente.
La ventana emergente puede acceder a la ventana que la abre usando la propiedad window.opener.
La ventana principal y la ventana emergente pueden leerse y modificarse libremente entre sí si tienen el mismo origen. De lo contrario, pueden cambiar de ubicación e intercambiar mensajes.

Para cerrar la ventana emergente: use close (). Además, el usuario puede cerrarlas (como cualquier otra ventana). El window.closed estrue después de eso.

Los métodos focus () y blur () permiten enfocar/desenfocar una ventana. Pero no funcionan todo el tiempo.
Los eventos focus yblur permiten rastrear el cambio dentro y fuera de la ventana. Pero tenga en cuenta que una ventana puede seguir siendo visible incluso en el estado de fondo, después de “desenfoque”.

",
	"url": "https://es.javascript.info/popup-windows" 
},
{
	"docs_id": "130",
	"name": "Comunicación entre ventanas",
	"description": "La política de “Mismo origen” (mismo sitio) limita el acceso de ventanas y marcos entre sí.",
	"content": "La política de “Mismo origen” (mismo sitio) limita el acceso de ventanas y marcos entre sí.
La idea es que si un usuario tiene dos páginas abiertas: una de john-smith.com, y otra es gmail.com, entonces no querrán que un script de john-smith.com lea nuestro correo de gmail.com. Por lo tanto, el propósito de la política de “Mismo origen” es proteger a los usuarios del robo de información.
Mismo origenSe dice que dos URL tienen el “mismo origen” si tienen el mismo protocolo, dominio y puerto.
Todas estas URL comparten el mismo origen:

http://site.com
http://site.com/
http://site.com/my/page.html

Estas no:

http://www.site.com (otro dominio: www. importa)
http://site.org (otro dominio: .org importa)
https://site.com (otro protocolo: https)
http://site.com:8080 (otro puerto: 8080)

La política “Mismo Origen” establece que:

si tenemos una referencia a otra ventana, por ejemplo, una ventana emergente creada por window.open o una ventana dentro de <iframe>, y esa ventana viene del mismo origen, entonces tenemos acceso completo a esa ventana.
en caso contrario, si viene de otro origen, entonces no podemos acceder al contenido de esa ventana: variables, documento, nada. La única excepción es location: podemos cambiarla (redirigiendo así al usuario). Pero no podemos leer location (por lo que no podemos ver dónde está el usuario ahora, no hay fuga de información).

En acción: iframeUna etiqueta <iframe> aloja una ventana incrustada por separado, con sus propios objetos document y window separados.
Podemos acceder a ellos usando propiedades:

iframe.contentWindow para obtener la ventana dentro del <iframe>.
iframe.contentDocument para obtener el documento dentro del <iframe>, abreviatura de iframe.contentWindow.document.

Cuando accedemos a algo dentro de la ventana incrustada, el navegador comprueba si el iframe tiene el mismo origen. Si no es así, se niega el acceso (escribir en location es una excepción, aún está permitido).
Por ejemplo, intentemos leer y escribir en <iframe> desde otro origen:

      
        
        
          
            
          
          
            
          
        
        
          <iframe src="https://example.com" id="iframe"></iframe>

<script>
  iframe.onload = function() {
    // podemos obtener la referencia a la ventana interior
    let iframeWindow = iframe.contentWindow; // OK
    try {
      // ...pero no al documento que contiene
      let doc = iframe.contentDocument; // ERROR
    } catch(e) {
      alert(e); // Error de seguridad (otro origen)
    }

    // tampoco podemos LEER la URL de la página en iframe
    try {
      // No se puede leer la URL del objeto Location
      let href = iframe.contentWindow.location.href; // ERROR
    } catch(e) {
      alert(e); // Error de seguridad
    }

    // ...¡podemos ESCRIBIR en location (y así cargar algo más en el iframe)!
    iframe.contentWindow.location = '/'; // OK

    iframe.onload = null; // borra el controlador para no ejecutarlo después del cambio de ubicación
  };
</script>
        
      
      
      El código anterior muestra errores para cualquier operación excepto:

Obtener la referencia a la ventana interna iframe.contentWindow – eso está permitido.
Escribir a location.

Por el contrario, si el <iframe> tiene el mismo origen, podemos hacer cualquier cosa con él:

      
        
        
          
            
          
          
            
          
        
        
          <!-- iframe from the same site -->
<iframe src="/" id="iframe"></iframe>

<script>
  iframe.onload = function() {
    // solo haz cualquier cosa
    iframe.contentDocument.body.prepend("¡Hola, mundo!");
  };
</script>
        
      
      
      
            iframe.onload vs iframe.contentWindow.onload
            El evento iframe.onload (en la etiqueta <iframe>) es esencialmente el mismo que iframe.contentWindow.onload (en el objeto de ventana incrustado). Se activa cuando la ventana incrustada se carga completamente con todos los recursos.
… Pero no podemos acceder a iframe.contentWindow.onload para un iframe de otro origen, así que usamos iframe.onload.

Ventanas en subdominios: document.domainPor definición, dos URL con diferentes dominios tienen diferentes orígenes.
Pero si las ventanas comparten el mismo dominio de segundo nivel, por ejemplo, john.site.com, peter.site.com y site.com (de modo que su dominio de segundo nivel común es site.com), podemos hacer que el navegador ignore esa diferencia, de modo que puedan tratarse como si vinieran del “mismo origen” para efecto de la comunicación entre ventanas.
Para que funcione, cada una de estas ventanas debe ejecutar el código:

      
        
        
          document.domain = 'site.com';
        
      
      
      Eso es todo. Ahora pueden interactuar sin limitaciones. Nuevamente, eso solo es posible para páginas con el mismo dominio de segundo nivel.

            Obsoleto, pero aún funcionando
            La propiedad document.domain está en proceso de ser removido de la especificación. Los mensajería cross-window  (explicado pronto más abajo) es el reemplazo sugerido.
Dicho esto, hasta ahora todos los navegadores lo soportan. Y tal soporte será mantenido en el futuro, para no romper el código existente que se apoya en document.domain.

Iframe: trampa del documento incorrectoCuando un iframe proviene del mismo origen y podemos acceder a su document, existe una trampa. No está relacionado con cross-origin, pero es importante saberlo.
Tras su creación, un iframe tiene inmediatamente un documento. ¡Pero ese documento es diferente del que se carga en él!
Entonces, si hacemos algo con el documento de inmediato, probablemente se perderá.
Aquí, mira:

      
        
        
          
            
          
          
            
          
        
        
          <iframe src="/" id="iframe"></iframe>

<script>
  let oldDoc = iframe.contentDocument;
  iframe.onload = function() {
    let newDoc = iframe.contentDocument;
    // ¡el documento cargado no es el mismo que el inicial!
    alert(oldDoc == newDoc); // false
  };
</script>
        
      
      
      No deberíamos trabajar con el documento de un iframe aún no cargado, porque ese es el documento incorrecto. Si configuramos algún controlador de eventos en él, se ignorarán.
¿Cómo detectar el momento en que el documento está ahí?
El documento correcto definitivamente está en su lugar cuando se activa iframe.onload. Pero solo se activa cuando se carga todo el iframe con todos los recursos.
Podemos intentar capturar el momento anterior usando comprobaciones en setInterval:

      
        
        
          
            
          
          
            
          
        
        
          <iframe src="/" id="iframe"></iframe>

<script>
  let oldDoc = iframe.contentDocument;

  // cada 100 ms comprueba si el documento es el nuevo
  let timer = setInterval(() => {
    let newDoc = iframe.contentDocument;
    if (newDoc == oldDoc) return;

    alert("¡El nuevo documento está aquí!");

    clearInterval(timer); // cancelo setInterval, ya no lo necesito
  }, 100);
</script>
        
      
      
      Colección: window.framesUna forma alternativa de obtener un objeto de ventana para <iframe> – es obtenerlo de la colección nombrada window.frames:

Por número: window.frames[0] – el objeto de ventana para el primer marco del documento.
Por nombre: window.frames.iframeName – el objeto de ventana para el marco con name="iframeName".

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <iframe src="/" style="height:80px" name="win" id="iframe"></iframe>

<script>
  alert(iframe.contentWindow == frames[0]); // true
  alert(iframe.contentWindow == frames.win); // true
</script>
        
      
      
      Un iframe puede tener otros iframes en su interior. Los objetos window correspondientes forman una jerarquía.
Los enlaces de navegación son:

window.frames – la colección de ventanas “hijas” (para marcos anidados).
window.parent – la referencia a la ventana “padre” (exterior).
window.top – la referencia a la ventana padre superior.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          window.frames[0].parent === window; // true
        
      
      
      Podemos usar la propiedad top para verificar si el documento actual está abierto dentro de un marco o no:

      
        
        
          
            
          
          
            
          
        
        
          if (window == top) { // current window == window.top?
  alert('El script está en la ventana superior, no en un marco.');
} else {
  alert('¡El script se ejecuta en un marco!');
}
        
      
      
      El atributo “sandbox” de iframeEl atributo sandbox permite la exclusión de ciertas acciones dentro de un <iframe> para evitar que ejecute código no confiable. Separa el iframe en un “sandbox” tratándolo como si procediera de otro origen y/o aplicando otras limitaciones.
Hay un “conjunto predeterminado” de restricciones aplicadas para <iframe sandbox src="...">. Pero se puede relajar si proporcionamos una lista de restricciones separadas por espacios que no deben aplicarse como un valor del atributo, así: <iframe sandbox="allow-forms allow-popups">.
En otras palabras, un atributo “sandbox” vacío pone las limitaciones más estrictas posibles, pero podemos poner una lista delimitada por espacios de aquellas que queremos levantar.
Aquí hay una lista de limitaciones:

allow-same-origin
Por defecto, “sandbox” fuerza la política de “origen diferente” para el iframe. En otras palabras, hace que el navegador trate el iframe como si viniera de otro origen, incluso si su src apunta al mismo sitio. Con todas las restricciones implícitas para los scripts. Esta opción elimina esa característica.
allow-top-navigation
Permite que el iframe cambie parent.location.
allow-forms
Permite enviar formularios desde iframe.
allow-scripts
Permite ejecutar scripts desde el iframe.
allow-popups
Permite window.open popups desde el iframe

Consulta el manual para obtener más información.
El siguiente ejemplo muestra un iframe dentro de un entorno controlado con el conjunto de restricciones predeterminado: <iframe sandbox src="...">. Tiene algo de JavaScript y un formulario.
Tenga en cuenta que nada funciona. Entonces, el conjunto predeterminado es realmente duro:
Resultadoindex.htmlsandboxed.html<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
</head>

<body>

  <div>El siguiente iframe tiene el atributo <code> sandbox </code>.</div>

  <iframe sandbox src="sandboxed.html" style="height:60px;width:90%"></iframe>

</body>
</html><!doctype html>
<html>

<head>
  <meta charset="UTF-8">
</head>

<body>

  <button onclick="alert(123)">Haz clic para ejecutar un script (no funciona)</button>

  <form action="http://google.com">
    <input type="text">
    <input type="submit" value="Enviar (no funciona)">
  </form>

</body>
</html>
            Por favor tome nota:
            El propósito del atributo "sandbox" es solo agregar más restricciones. No puede eliminarlas. En particular, no puede relajar las restricciones del mismo origen si el iframe proviene de otro origen.

Mensajería entre ventanasLa interfaz postMessage permite que las ventanas se comuniquen entre sí sin importar de qué origen sean.
Por lo tanto, es una forma de evitar la política del “mismo origen”. Permite a una ventana de john-smith.com hablar con gmail.com e intercambiar información, pero solo si ambos están de acuerdo y llaman a las funciones de JavaScript correspondientes. Eso lo hace seguro para los usuarios.
La interfaz tiene dos partes.
postMessageLa ventana que quiere enviar un mensaje llama al método postMessage de la ventana receptora. En otras palabras, si queremos enviar el mensaje a win, debemos llamar a win.postMessage(data, targetOrigin).
Argumentos:

data
Los datos a enviar. Puede ser cualquier objeto, los datos se clonan mediante el “algoritmo de clonación estructurada”. IE solo admite strings, por lo que debemos usar JSON.stringify en objetos complejos para admitir ese navegador.
targetOrigin
Especifica el origen de la ventana de destino, de modo que solo una ventana del origen dado recibirá el mensaje.

El argumento “targetOrigin” es una medida de seguridad. Recuerde que si la ventana de destino proviene de otro origen, no podemos leer su location en la ventana del remitente. Por lo tanto, no podemos estar seguros qué sitio está abierto en la ventana deseada en este momento: el usuario podría navegar fuera del sitio y la ventana del remitente no tener idea de ello.
Especificar targetOrigin asegura que la ventana solo reciba los datos si todavía está en el sitio correcto. Importante cuando los datos son sensibles.
Por ejemplo, aquí win solo recibirá el mensaje si tiene un documento del origen http://example.com:

      
        
        
          <iframe src="http://example.com" name="example">

<script>
  let win = window.frames.example;

  win.postMessage("message", "http://example.com");
</script>
        
      
      
      Si no queremos esa comprobación, podemos establecer targetOrigin en *.

      
        
        
          <iframe src="http://example.com" name="example">

<script>
  let win = window.frames.example;

  win.postMessage("message", "*");
</script>
        
      
      
      onmessagePara recibir un mensaje, la ventana destino debe tener un controlador en el evento message. Se activa cuando se llama a postMessage (y la comprobación de targetOrigin es correcta).
El objeto de evento tiene propiedades especiales:

data
Los datos de postMessage.
origin
El origen del remitente, por ejemplo, http://javascript.info.
source
La referencia a la ventana del remitente. Podemos llamar inmediatamente source.postMessage(...) de regreso si queremos.

Para asignar ese controlador, debemos usar addEventListener, una sintaxis corta window.onmessage no funciona.
He aquí un ejemplo:

      
        
        
          window.addEventListener("message", function(event) {
  if (event.origin != 'http://javascript.info') {
    // algo de un dominio desconocido, ignorémoslo
    return;
  }

  alert( "Recibí: " + event.data );

  // puedes enviar un mensaje usando event.source.postMessage(...)
});
        
      
      
      El ejemplo completo:
Resultadoiframe.htmlindex.html<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
</head>

<body>

  Recibiendo iframe.
  <script>
    window.addEventListener('message', function(event) {
      alert(`Recibí ${event.data} de ${event.origin}`);
    });
  </script>

</body>
</html><!doctype html>
<html>

<head>
  <meta charset="UTF-8">
</head>

<body>

  <form id="form">
    <input type="text" placeholder="Ingresa mensaje" name="message">
    <input type="submit" value="Haz clic para enviar">
  </form>

  <iframe src="iframe.html" id="iframe" style="display:block;height:60px"></iframe>

  <script>
    form.onsubmit = function() {
      iframe.contentWindow.postMessage(this.message.value, '*');
      return false;
    };
  </script>

</body>
</html>ResumenPara llamar a métodos y acceder al contenido de otra ventana, primero debemos tener una referencia a ella.
Para las ventanas emergentes tenemos estas referencias:

Desde la ventana de apertura: window.open – abre una nueva ventana y devuelve una referencia a ella,
Desde la ventana emergente: window.opener – es una referencia a la ventana de apertura desde una ventana emergente.

Para iframes, podemos acceder a las ventanas padres o hijas usando:

window.frames – una colección de objetos de ventana anidados,
window.parent, window.top son las referencias a las ventanas principales y superiores,
iframe.contentWindow es la ventana dentro de una etiqueta <iframe>.

Si las ventanas comparten el mismo origen (host, puerto, protocolo), las ventanas pueden hacer lo que quieran entre sí.
En caso contrario, las únicas acciones posibles son:

Cambiar location en otra ventana (acceso de solo escritura).
Enviarle un mensaje.

Las excepciones son:

Ventanas que comparten el mismo dominio de segundo nivel: a.site.com y b.site.com. Luego, configurar document.domain='site.com' en ambos, los coloca en el estado de “mismo origen”.
Si un iframe tiene un atributo sandbox, se coloca forzosamente en el estado de “origen diferente”, a menos que se especifique allow-same-origin en el valor del atributo. Eso se puede usar para ejecutar código que no es de confianza en iframes desde el mismo sitio.

La interfaz postMessage permite que dos ventanas con cualquier origen hablen:


El remitente llama a targetWin.postMessage(data, targetOrigin).


Si targetOrigin no es '*', entonces el navegador comprueba si la ventana targetWin tiene el origen targetOrigin.


Si es así, entonces targetWin activa el evento message con propiedades especiales:

origin – el origen de la ventana del remitente (comohttp://my.site.com)
source – la referencia a la ventana del remitente.
data – los datos, cualquier objeto en todas partes excepto IE que solo admite cadenas.

Deberíamos usar addEventListener para configurar el controlador para este evento dentro de la ventana de destino.


",
	"url": "https://es.javascript.info/cross-window-communication" 
},
{
	"docs_id": "131",
	"name": "El ataque de secuestro de clics",
	"description": "El ataque “secuestro de clics” permite que una página maligna haga clic en un “sitio víctima” * en nombre del visitante *.",
	"content": "El ataque “secuestro de clics” permite que una página maligna haga clic en un “sitio víctima” * en nombre del visitante *.
Muchos sitios fueron pirateados de esta manera, incluidos Twitter, Facebook, Paypal y otros sitios. Todos han sido arreglados, por supuesto.
La ideaLa idea es muy simple.
Así es como se hizo el secuestro de clics con Facebook:

Un visitante es atraído a la página maligna. No importa cómo.
La página tiene un enlace de apariencia inofensiva (como “hazte rico ahora” o “haz clic aquí, muy divertido”).
Sobre ese enlace, la página maligna coloca un <iframe> transparente con src de facebook.com, de tal manera que el botón" Me gusta "está justo encima de ese enlace. Por lo general, eso se hace con z-index.
Al intentar hacer clic en el enlace, el visitante de hecho hace clic en el botón.

La demostraciónAsí es como se ve la página malvada. Para aclarar las cosas, el <iframe> es semitransparente (en las páginas realmente malvadas es completamente transparente):

      
        
        
          
            
          
          
            
          
        
        
          <style>
iframe { /* iframe del sitio de la víctima */
  width: 400px;
  height: 100px;
  position: absolute;
  top:0; left:-20px;
  opacity: 0.5; /* realmente opacity:0 */
  z-index: 1;
}
</style>

<div>Haga clic para hacerse rico ahora:</div>

<!-- La URL del sitio de la víctima -->
<iframe src="/clickjacking/facebook.html"></iframe>

<button>¡Haga clic aquí!</button>

<div>...Y eres genial (en realidad soy un pirata informático genial)!</div>
        
      
      
      La demostración completa del ataque:
Resultadofacebook.htmlindex.html<!DOCTYPE HTML>
<html>

<body style="margin:10px;padding:10px">

  <input type="button" onclick="alert('¡ME GUSTA fue presionado en facebook.html!')" value="ME GUSTA !">

</body>

</html><!doctype html>
<html>

<head>
  <meta charset="UTF-8">
</head>

<body>

  <style>
    iframe {
      width: 400px;
      height: 100px;
      position: absolute;
      top: 5px;
      left: -14px;
      opacity: 0.5;
      z-index: 1;
    }
  </style>

  <div>Haga clic para hacerse rico ahora:</div>

  <!-- The url from the victim site -->
  <iframe src="facebook.html"></iframe>

  <button>¡Haga clic aquí!</button>

  <div>...Y eres genial (en realidad soy un pirata informático genial)!</div>

</body>
</html>Aquí tenemos un <iframe src="facebook.html"> semitransparente, y en el ejemplo podemos verlo flotando sobre el botón. Un clic en el botón realmente hace clic en el iframe, pero eso no es visible para el usuario, porque el iframe es transparente.
Como resultado, si el visitante está autorizado en Facebook (“recordarme” generalmente está activado), entonces agrega un “Me gusta”. En Twitter sería un botón “Seguir”.
Este es el mismo ejemplo, pero más cercano a la realidad, con opacity:0 para <iframe>:
Resultadofacebook.htmlindex.html<!DOCTYPE HTML>
<html>

<body style="margin:10px;padding:10px">

  <input type="button" onclick="alert('¡ME GUSTA fue presionado en facebook.html!')" value="ME GUSTA !">

</body>

</html><!doctype html>
<html>

<head>
  <meta charset="UTF-8">
</head>

<body>

  <style>
    iframe {
      width: 400px;
      height: 100px;
      position: absolute;
      top: 5px;
      left: -14px;
      opacity: 0;
      z-index: 1;
    }
  </style>

  <div>Haga clic para hacerse rico ahora:</div>

  <!-- The url from the victim site -->
  <iframe src="facebook.html"></iframe>

  <button>¡Haga clic aquí!</button>

  <div>...Y eres genial (en realidad soy un pirata informático genial)!</div>

</body>
</html>Todo lo que necesitamos para atacar es colocar el <iframe> en la página maligna de tal manera que el botón esté justo sobre el enlace. De modo que cuando un usuario hace clic en el enlace, en realidad hace clic en el botón. Eso suele ser posible con CSS.

            Clickjacking es para clics, no para teclado
            El ataque solo afecta las acciones del mouse (o similares, como los toques en el móvil).
La entrada del teclado es muy difícil de redirigir. Técnicamente, si tenemos un campo de texto para piratear, entonces podemos colocar un iframe de tal manera que los campos de texto se superpongan entre sí. Entonces, cuando un visitante intenta concentrarse en la entrada que ve en la página, en realidad se enfoca en la entrada dentro del iframe.
Pero luego hay un problema. Todo lo que escriba el visitante estará oculto, porque el iframe no es visible.
Las personas generalmente dejarán de escribir cuando no puedan ver sus nuevos caracteres impresos en la pantalla.

Defensas de la vieja escuela (débiles)La defensa más antigua es un poco de JavaScript que prohíbe abrir la página en un marco (el llamado “framebusting”).
Eso se ve así:

      
        
        
          if (top != window) {
  top.location = window.location;
}
        
      
      
      Es decir: si la ventana descubre que no está en la parte superior, automáticamente se convierte en la parte superior.
Esta no es una defensa confiable, porque hay muchas formas de esquivarla. Cubramos algunas.
Bloquear la navegación superiorPodemos bloquear la transición causada por cambiar top.location en el controlador de eventos beforeunload.
La página superior (adjuntando una, que pertenece al pirata informático) establece un controlador de prevención, como este:

      
        
        
          window.onbeforeunload = function() {
  return false;
};
        
      
      
      Cuando el iframe intenta cambiar top.location, el visitante recibe un mensaje preguntándole si quiere irse.
En la mayoría de los casos, el visitante respondería negativamente porque no conocen el iframe; todo lo que pueden ver es la página superior, no hay razón para irse. ¡Así que top.location no cambiará!
En acción:
Resultadoiframe.htmlindex.html<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
</head>

<body>

  <div>Cambia top.location a javascript.info</div>

  <script>
    top.location = 'https://javascript.info';
  </script>

</body>

</html><!doctype html>
<html>

<head>
  <meta charset="UTF-8">

  <style>
    iframe {
      width: 400px;
      height: 100px;
      position: absolute;
      top: 0;
      left: -20px;
      opacity: 0;
      z-index: 1;
    }
  </style>

  <script>
    function attack() {

      window.onbeforeunload = function() {
        window.onbeforeunload = null;
        return "¿Quieres irte sin conocer todos los secretos (je-je)?";
      };

      document.body.insertAdjacentHTML('beforeend', '<iframe src="iframe.html">');
    }
  </script>
</head>

<body>

  <p>Después de hacer clic en el botón, el visitante recibe una pregunta "extraña" sobre si quiere irse.</p>

  <p>Probablemente responderían "No", y la protección de iframe está pirateada.</p>

  <button onclick="attack()">Agregar un iframe "protegido"</button>

</body>
</html>Atributo SandboxUna de las cosas restringidas por el atributo sandbox es la navegación. Un iframe de espacio aislado no puede cambiar top.location.
Entonces podemos agregar el iframe con sandbox="allow-scripts allow-forms". Eso relajaría las restricciones, permitiendo guiones y formularios. Pero omitimos allow-top-navigation para que se prohíba cambiar top.location.
Aquí está el código:

      
        
        
          <iframe sandbox="allow-scripts allow-forms" src="facebook.html"></iframe>
        
      
      
      También hay otras formas de evitar esa simple protección.
X-Frame-OptionsEl encabezado del lado del servidor X-Frame-Options puede permitir o prohibir mostrar la página dentro de un marco.
Debe enviarse exactamente como encabezado HTTP: el navegador lo ignorará si se encuentra en la etiqueta HTML <meta>. Entonces, <meta http-equiv="X-Frame-Options"...> no hará nada.
El encabezado puede tener 3 valores:

DENY
Nunca muestra la página dentro de un marco.
SAMEORIGIN
Permitir dentro de un marco si el documento principal proviene del mismo origen.
ALLOW-FROM domain
Permitir dentro de un marco si el documento principal es del dominio dado.

Por ejemplo, Twitter usa X-Frame-Options: SAMEORIGIN.
Aquí está el resultado:

      
        
        
          <iframe src="https://twitter.com"></iframe>
        
      
      
      

Dependiendo de su navegador, el iframe anterior está vacío o le advierte que el navegador no permitirá que esa página navegue de esta manera.
Mostrando con funcionalidad deshabilitadaEl encabezado X-Frame-Options tiene un efecto secundario. Otros sitios no podrán mostrar nuestra página en un marco, incluso si tienen buenas razones para hacerlo.
Así que hay otras soluciones… Por ejemplo, podemos “cubrir” la página con un <div> con estilos height: 100%; width: 100%;, de modo que interceptará todos los clics. Ese <div> debe eliminarse si window == top o si descubrimos que no necesitamos la protección.
Algo como esto:

      
        
        
          <style>
  #protector {
    height: 100%;
    width: 100%;
    position: absolute;
    left: 0;
    top: 0;
    z-index: 99999999;
  }
</style>

<div id="protector">
  <a href="/" target="_blank">Ir al sitio</a>
</div>

<script>
  // habrá un error si la ventana superior es de un origen diferente
  // pero esta bien aquí
  if (top.document.domain == document.domain) {
    protector.remove();
  }
</script>
        
      
      
      La demostración:
Resultadoiframe.htmlindex.html<!doctype html>
<html>

<head>
  <meta charset="UTF-8">

  <style>
    #protector {
      height: 100%;
      width: 100%;
      position: absolute;
      left: 0;
      top: 0;
      z-index: 99999999;
    }
  </style>

</head>

<body>

<div id="protector">
  <a href="/" target="_blank">Ir al sitio</a>
</div>

<script>

  if (top.document.domain == document.domain) {
    protector.remove();
  }

</script>

  Este texto siempre está visible.

  Pero si la página estuviera abierta dentro de un documento de otro dominio, el div sobre ella evitaría cualquier acción.

  <button onclick="alert(1)">El clic no funcionaría en ese caso</button>

</body>
</html><!doctype html>
<html>

<head>
  <meta charset="UTF-8">
</head>
<body>

  <iframe src="iframe.html"></iframe>

</body>
</html>Atributo Samesite cookieEl atributo samesite cookie también puede prevenir ataques de secuestro de clics.
Una cookie con dicho atributo solo se envía a un sitio web si se abre directamente, no a través de un marco o de otra manera. Más información en el capítulo Cookies, document.cookie.
Si el sitio, como Facebook, tenía el atributo samesite en su cookie de autenticación, así:

      
        
        
          Set-Cookie: authorization=secret; samesite
        
      
      
      …Entonces dicha cookie no se enviaría cuando Facebook esté abierto en iframe desde otro sitio. Entonces el ataque fracasaría.
El atributo samesite cookie no tendrá efecto cuando no se utilicen cookies. Esto puede permitir que otros sitios web muestren fácilmente nuestras páginas públicas no autenticadas en iframes.
Sin embargo, esto también puede permitir que los ataques de secuestro de clics funcionen en algunos casos limitados. Un sitio web de sondeo anónimo que evita la duplicación de votaciones al verificar las direcciones IP, por ejemplo, aún sería vulnerable al secuestro de clics porque no autentica a los usuarios que usan cookies.
ResumenEl secuestro de clics es una forma de “engañar” a los usuarios para que hagan clic en el sitio de una víctima sin siquiera saber qué está sucediendo. Eso es peligroso si hay acciones importantes activadas por clic.
Un pirata informático puede publicar un enlace a su página maligna en un mensaje o atraer visitantes a su página por otros medios. Hay muchas variaciones.
Desde una perspectiva, el ataque “no es profundo”: todo lo que hace un pirata informático es interceptar un solo clic. Pero desde otra perspectiva, si el pirata informático sabe que después del clic aparecerá otro control, entonces pueden usar mensajes astutos para obligar al usuario a hacer clic en ellos también.
El ataque es bastante peligroso, porque cuando diseñamos la interfaz de usuario generalmente no anticipamos que un pirata informático pueda hacer clic en nombre del visitante. Entonces, las vulnerabilidades se pueden encontrar en lugares totalmente inesperados.

Se recomienda utilizar X-Frame-Options: SAMEORIGIN en páginas (o sitios web completos) que no están destinados a verse dentro de marcos.
Usa una cubierta <div> si queremos permitir que nuestras páginas se muestren en iframes, pero aún así permanecer seguras.

",
	"url": "https://es.javascript.info/clickjacking" 
},
{
	"docs_id": "132",
	"name": "ArrayBuffer, arrays binarios",
	"description": "En el desarrollo web nos encontramos con datos binarios sobre todo al tratar con archivos (crear, cargar, descargar). Otro caso de uso típico es el procesamiento de imágenes.",
	"content": "En el desarrollo web nos encontramos con datos binarios sobre todo al tratar con archivos (crear, cargar, descargar). Otro caso de uso típico es el procesamiento de imágenes.
Todo esto es posible en JavaScript y las operaciones binarias son de alto rendimiento.
Aunque hay un poco de confusión porque hay muchas clases. Por nombrar algunas:

ArrayBuffer, Uint8Array, DataView, Blob, File, etc.

Los datos binarios en JavaScript se implementan de una manera no estándar en comparación con otros lenguajes. Pero cuando ordenamos las cosas, todo se vuelve bastante sencillo.
El objeto binario básico es ArrayBuffer – una referencia a un área de memoria contigua de longitud fija.
Lo creamos así:

      
        
        
          
            
          
          
            
          
        
        
          let buffer = new ArrayBuffer(16); // crea un buffer de longitud 16
alert(buffer.byteLength); // 16
        
      
      
      Esto asigna un área de memoria contigua de 16 bytes y la rellena previamente con ceros.

            ArrayBuffer no es un array de algo
            Eliminemos una posible fuente de confusión. ArrayBuffer no tiene nada en común con Array:

Tiene una longitud fija, no podemos aumentarla ni disminuirla.
Ocupa exactamente ese espacio en la memoria.
Para acceder a bytes individuales, se necesita otro objeto “vista”, no buffer[índice].


ArrayBuffer es un área de memoria. ¿Qué se almacena en ella? No tiene ninguna pista. Sólo una secuencia cruda de bytes.
Para manipular un ArrayBuffer, necesitamos utilizar un objeto “vista”.
Un objeto vista no almacena nada por sí mismo. Son “gafas” que le dan una interpretación a los bytes almacenados en el ArrayBuffer.
Por ejemplo:

Uint8Array : trata cada byte del ArrayBuffer como un número separado, con valores posibles de 0 a 255 (un byte es de 8 bits, por lo que sólo puede contener esa cantidad). Este valor se denomina “entero sin signo de 8 bits”.
Uint16Array : trata cada 2 bytes como un entero, con valores posibles de 0 a 65535. Es lo que se llama un “entero sin signo de 16 bits”.
Uint32Array : trata cada 4 bytes como un entero, con valores posibles de 0 a 4294967295. Eso se llama “entero sin signo de 32 bits”.
Float64Array : trata cada 8 bytes como un número de punto flotante con valores posibles desde 5.0x10-324 hasta 1.8x10308.

Así, los datos binarios de un ArrayBuffer de 16 bytes pueden interpretarse como 16 “números diminutos”, u 8 números más grandes (2 bytes cada uno), o 4 aún más grandes (4 bytes cada uno), o 2 valores de punto flotante con alta precisión (8 bytes cada uno).

      
      
        
      
      ArrayBuffer es el objeto central, la raíz de todo, los datos binarios en bruto.
Pero si vamos a escribir en él, o iterar sobre él (básicamente, para casi cualquier operación), debemos utilizar una vista. Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let buffer = new ArrayBuffer(16); // crea un buffer de longitud 16

let view = new Uint32Array(buffer); // trata el buffer como una secuencia de enteros de 32 bits

alert(Uint32Array.BYTES_PER_ELEMENT); // 4 bytes por entero

alert(view.length); // 4, almacena esa cantidad de enteros
alert(view.byteLength); // 16, el tamaño en bytes

// escribamos un valor
view[0] = 123456;

// iteración sobre los valores
for(let num of view) {
  alert(num); // 123456, luego 0, 0, 0 (4 valores en total)
}
        
      
      
      TypedArrayEl término común para todas estas vistas (Uint8Array, Uint32Array, etc) es TypedArray. Comparten el mismo conjunto de métodos y propiedades.
Por favor ten en cuenta que no hay ningún constructor llamado TypedArray, es sólo un término “paraguas” común para representar una de las vistas sobre ArrayBuffer: Int8Array, Uint8Array y así sucesivamente, la lista completa seguirá pronto.
Cuando veas algo como new TypedArray, significa cualquiera de new Int8Array, new Uint8Array, etc.
Las matrices tipificadas se comportan como las matrices normales: tienen índices y son iterables.
Un constructor de array tipado (ya sea Int8Array o Float64Array) se comporta de forma diferente dependiendo del tipo de argumento.
Hay 5 variantes de argumentos:

      
        
        
          new TypedArray(buffer, [byteOffset], [length]);
new TypedArray(object);
new TypedArray(typedArray);
new TypedArray(length);
new TypedArray();
        
      
      
      

Si se suministra un argumento ArrayBuffer, la vista se crea sobre él. Ya usamos esa sintaxis.
Opcionalmente podemos proporcionar byteOffset para empezar (0 por defecto) y la longitud o length (hasta el final del buffer por defecto), entonces la vista cubrirá sólo una parte del buffer.


Si se da un Array, o cualquier objeto tipo array, se crea un array tipado de la misma longitud y se copia el contenido.
Podemos usarlo para pre-llenar el array con los datos:

      
        
        
          
            
          
          
            
          
        
        
          let arr = new Uint8Array([0, 1, 2, 3]);
alert( arr.length ); // 4, creó una matriz binaria de la misma longitud
alert( arr[1] ); // 1, rellenado con 4 bytes (enteros de 8 bits sin signo) con valores dados
        
      
      
      

Si se suministra otro TypedArray hace lo mismo: crea un array tipado de la misma longitud y copia los valores. Los valores se convierten al nuevo tipo en el proceso, si es necesario.

      
        
        
          
            
          
          
            
          
        
        
          let arr16 = new Uint16Array([1, 1000]);
let arr8 = new Uint8Array(arr16);
alert( arr8[0] ); // 1
alert( arr8[1] ); // 232, trató de copiar 1000, pero no puede encajar 1000 en 8 bits (explicaciones a continuación)
        
      
      
      

Para un argumento numérico length : crea el array tipado para contener ese número de elementos. Su longitud en bytes será length multiplicada por el número de bytes de un solo elemento TypedArray.BYTES_PER_ELEMENT:

      
        
        
          
            
          
          
            
          
        
        
          let arr = new Uint16Array(4); // crea un array tipado para 4 enteros
alert( Uint16Array.BYTES_PER_ELEMENT ); // 2 bytes por entero
alert( arr.byteLength ); // 8 (tamaño en bytes)
        
      
      
      

Sin argumentos crea un array tipado de longitud cero.


Podemos crear un TypedArray directamente sin mencionar ArrayBuffer. Pero una vista no puede existir sin un ArrayBuffer subyacente, por lo que se crea automáticamente en todos estos casos excepto en el primero (cuando se proporciona).
Para acceder al ArrayBuffer subyacente,  en TypedArray existen las propiedades:

buffer : hace referencia al ArrayBuffer.
byteLength : la longitud del ArrayBuffer.

De esta forma siempre podemos pasar de una vista a otra:

      
        
        
          let arr8 = new Uint8Array([0, 1, 2, 3]);

// otra vista sobre los mismos datos
let arr16 = new Uint16Array(arr8.buffer);
        
      
      
      Esta es la lista de arrays tipados:

Uint8Array, Uint16Array, Uint32Array : para números enteros de 8, 16 y 32 bits.

Uint8ClampedArray : para números enteros de 8 bits, los “sujeta” en la asignación (ver más abajo).


Int8Array, Int16Array, Int32Array : para números enteros con signo (pueden ser negativos).
Float32Array, Float64Array : para números de punto flotante con signo de 32 y 64 bits.


            No existe int8 o tipos de valor único similares
            Ten en cuenta que a pesar de los nombres como Int8Array, no hay ningún tipo de valor único como int o int8 en JavaScript.
Esto es lógico ya que Int8Array no es un array de estos valores individuales sino una vista sobre ArrayBuffer.

Comportamiento fuera de los límites¿Qué pasa si intentamos escribir un valor fuera de límites en un array tipado? No habrá ningún error. Pero los bits extra se cortan.
Por ejemplo, intentemos poner 256 en Uint8Array. En forma binaria 256 es 100000000 (9 bits), pero Uint8Array sólo proporciona 8 bits por valor, lo que hace que el rango disponible sea de 0 a 255.
Para los números más grandes, sólo se almacenan los 8 bits más a la derecha (menos significativos), y el resto se corta:

      
      
        
      
      Así que obtendremos un cero.
Para el 257 la forma binaria es 100000001 (9 bits), los 8 más a la derecha se almacenan, por lo que tendremos 1 en el array:

      
      
        
      
      Es decir, se guarda el número módulo 28.
Esta es la demo:

      
        
        
          
            
          
          
            
          
        
        
          let uint8array = new Uint8Array(16);

let num = 256;
alert(num.toString(2)); // 100000000 (representación binaria)

uint8array[0] = 256;
uint8array[1] = 257;

alert(uint8array[0]); // 0
alert(uint8array[1]); // 1
        
      
      
      Uint8ClampedArray es especial en este aspecto y su comportamiento es diferente. Guarda 255 para cualquier número que sea mayor que 255, y 0 para cualquier número negativo. Este comportamiento es útil para el procesamiento de imágenes.
Métodos TypedArrayTypedArray tiene los métodos regulares de Array, con notables excepciones.
Podemos iterar, map, slice, find, reduce etc.
Sin embargo, hay algunas cosas que no podemos hacer:

No hay splice : no podemos “borrar” un valor, porque los arrays tipados son vistas en un buffer y estos son áreas fijas y contiguas de memoria. Todo lo que podemos hacer es asignar un cero.
No hay método concat.

Hay dos métodos adicionales:

arr.set(fromArr, [offset]) copia todos los elementos de fromArr al arr, empezando en la posición offset (0 por defecto).
arr.subarray([begin, end]) crea una nueva vista del mismo tipo desde begin hasta end (excluyéndolo). Es similar al método slice (que también está soportado) pero no copia nada, sólo crea una nueva vista para operar sobre el trozo de datos dado.

Estos métodos nos permiten copiar arrays tipados, mezclarlos, crear nuevos arrays a partir de los existentes, etc.
DataViewDataView es una vista especial superflexible “no tipada” sobre ArrayBuffer. Permite acceder a los datos en cualquier desplazamiento en cualquier formato.

En el caso de los arrays tipados, el constructor dicta cuál es el formato. Se supone que todo el array es uniforme. El número i es arr[i].
Con DataView accedemos a los datos con métodos como .getUint8(i) o .getUint16(i). Elegimos el formato en el momento de la llamada al método en lugar de en el momento de la construcción.

La sintaxis:

      
        
        
          new DataView(buffer, [byteOffset], [byteLength])
        
      
      
      
buffer : el ArrayBuffer subyacente. A diferencia de los arrays tipados, DataView no crea un buffer por sí mismo. Necesitamos tenerlo preparado.
byteOffset : la posición inicial en bytes de la vista (por defecto 0).
byteLength : la longitud en bytes de la vista (por defecto hasta el final del buffer).

Por ejemplo, aquí extraemos números en diferentes formatos del mismo buffer:

      
        
        
          
            
          
          
            
          
        
        
          // arreglo binario de 4 bytes, todos tienen el valor máximo 255
let buffer = new Uint8Array([255, 255, 255, 255]).buffer;

let dataView = new DataView(buffer);

// get 8-bit number at offset 0
alert( dataView.getUint8(0) ); // 255

// ahora obtenemos un número de 16 bits en el offset 0, que consta de 2 bytes, que juntos se interpretan como 65535
alert( dataView.getUint16(0) ); // 65535 (mayor entero sin signo de 16 bits)

// obtener un número de 32 bits en el offset 0
alert( dataView.getUint32(0) ); // 4294967295 (mayor entero de 32 bits sin signo)

dataView.setUint32(0, 0); // poner a cero el número de 4 bytes, poniendo así todos los bytes a 0
        
      
      
      DataView es genial cuando almacenamos datos de formato mixto en el mismo buffer. Por ejemplo, cuando almacenamos una secuencia de pares (entero de 16 bits, flotante de 32 bits), DataView permite acceder a ellos fácilmente.
ResumenArrayBuffer es el objeto central, una referencia al área de memoria contigua de longitud fija.
Para hacer casi cualquier operación sobre ArrayBuffer, necesitamos una vista.

Puede ser un TypedArray:

Uint8Array, Uint16Array, Uint32Array : para enteros sin signo de 8, 16 y 32 bits.
Uint8ClampedArray : para enteros de 8 bits, los “sujeta” en la asignación.
Int8Array, Int16Array, Int32Array : para números enteros con signo (pueden ser negativos).
Float32Array, Float64Array : para números de punto flotante con signo de 32 y 64 bits.


O una DataView : la vista que utiliza métodos para especificar un formato, por ejemplo getUint8(offset).

En la mayoría de los casos creamos y operamos directamente sobre arrays tipados, dejando el ArrayBuffer a cubierto, como “denominador común”. Podemos acceder a él como .buffer y hacer otra vista si es necesario.
También hay dos términos adicionales, que se utilizan en las descripciones de los métodos que operan con datos binarios:

ArrayBufferView es un término paraguas para todos estos tipos de vistas.
El término BufferSource es un término general para ArrayBuffer o ArrayBufferView.

Veremos estos términos en los próximos capítulos. El término BufferSource es uno de los más comunes, ya que significa “cualquier tipo de datos binarios” : un ArrayBuffer o una vista sobre él.
Aquí tienes la hoja de ruta:

      
      
        
      
      TareasConcatenar arrays tipadosDado un array de Uint8Array, escribir una función concat(arrays) que devuelva la concatenación de ellos en un único array.
Abrir en entorno controlado con pruebas.solución
      
        
        
          function concat(arrays) {
  // suma de las longitudes de array individuales
  let totalLength = arrays.reduce((acc, value) => acc + value.length, 0);

  let result = new Uint8Array(totalLength);

  if (!arrays.length) return result;

  // para cada array: copiarlo sobre "result"
  // el siguiente array es copiado inmediatamente después del anterior
  let length = 0;
  for(let array of arrays) {
    result.set(array, length);
    length += array.length;
  }

  return result;
}
        
      
      
      Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/arraybuffer-binary-arrays" 
},
{
	"docs_id": "133",
	"name": "TextDecoder y TextEncoder",
	"description": "¿Qué pasa si los datos binarios son en realidad un string? Por ejemplo, recibimos un archivo con datos textuales.",
	"content": "¿Qué pasa si los datos binarios son en realidad un string? Por ejemplo, recibimos un archivo con datos textuales.
El objeto incorporado TextDecoder nos permite leer el valor y convertirlo en un string de JavaScript, dados el búfer y la codificación.
Primero necesitamos crearlo:

      
        
        
          let decoder = new TextDecoder([label], [options]);
        
      
      
      
label – la codificación, utf-8 por defecto, pero big5, windows-1251 y muchos otros también son soportados.
options – objeto opcional:

fatal – booleano, si es true arroja una excepción por caracteres inválidos (no-decodificable), de otra manera (por defecto) son reemplazados con el carácter \uFFFD.
ignoreBOM – booleano, si es true entonces ignora BOM (una marca Unicode de orden de bytes opcional), raramente es necesario.



…Y luego decodificar:

      
        
        
          let str = decoder.decode([input], [options]);
        
      
      
      
input – BufferSource para decodificar.
options – objeto opcional:

stream – true para decodificación de secuencias, cuando el decoder es usado repetidamente para fragmentos de datos entrantes. En ese caso, un carácter de varios bytes puede ocasionalmente dividirse entre fragmentos. Esta opción le dice al TextDecoder que memorice caracteres “incompletos” y que los decodifique cuando venga el siguiente fragmento.



Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let uint8Array = new Uint8Array([72, 111, 108, 97]);

alert( new TextDecoder().decode(uint8Array) ); // Hola
        
      
      
      
      
        
        
          
            
          
          
            
          
        
        
          let uint8Array = new Uint8Array([228, 189, 160, 229, 165, 189]);

alert( new TextDecoder().decode(uint8Array) ); // 你好
        
      
      
      Podemos decodificar una parte del búfer al crear una vista de sub arreglo para ello:

      
        
        
          
            
          
          
            
          
        
        
          let uint8Array = new Uint8Array([0, 72, 111, 108, 97, 0]);

// El string esta en medio
// crear una nueva vista sobre el string, sin copiar nada
let binaryString = uint8Array.subarray(1, -1);

alert( new TextDecoder().decode(binaryString) ); // Hola
        
      
      
      TextEncoderTextEncoder hace lo contrario: convierte un string en bytes.
La sintaxis es:

      
        
        
          let encoder = new TextEncoder();
        
      
      
      La única codificación que soporta es “utf-8”.
Tiene dos métodos:

encode(str) – regresa un dato de tipo Uint8Array de un string.
encodeInto(str, destination) – codifica un str en destination, este último debe ser de tipo Uint8Array.


      
        
        
          
            
          
          
            
          
        
        
          let encoder = new TextEncoder();

let uint8Array = encoder.encode("Hola");
alert(uint8Array); // 72,111,108,97
        
      
      
      ",
	"url": "https://es.javascript.info/text-decoder" 
},
{
	"docs_id": "134",
	"name": "Blob",
	"description": "Los ArrayBuffer y las vistas son parte del estándar ECMA, una parte de JavaScript.",
	"content": "Los ArrayBuffer y las vistas son parte del estándar ECMA, una parte de JavaScript.
En el navegador, hay objetos de alto nivel adicionales, descritas en la API de Archivo, en particular Blob.
Blob consta de un tipo especial de cadena (usualmente de tipo MIME), más partes Blob: una secuencia de otros objetos Blob, cadenas y BufferSource.

      
      
        
      
      La sintaxis del constructor es:

      
        
        
          new Blob(blobParts, opciones);
        
      
      
      
blobParts es un array de valores Blob/BufferSource/String.
opciones objeto opcional:

tipo – Blob, usualmente un tipo MIME, por ej. image/png,
endings – para transformar los finales de línea para hacer que el Blob coincida con los caracteres de nueva línea del Sistema Operativo actual (\r\n or \n). Por omisión es "transparent" (no hacer nada), pero también puede ser "native" (transformar).



Por ejemplo:

      
        
        
          // crear un Blob a partir de una cadena
let blob = new Blob(["<html>…</html>"], {type: 'text/html'});
// observación: el primer argumento debe ser un array [...]
        
      
      
      
      
        
        
          // crear un Blob a partir de un array tipado y cadenas
let hello = new Uint8Array([72, 101, 108, 108, 111]); // "Hello" en formato binario

let blob = new Blob([hello, ' ', 'world'], {type: 'text/plain'});
        
      
      
      Podemos extraer porciones del Blob con:

      
        
        
          blob.slice([byteStart], [byteEnd], [contentType]);
        
      
      
      
byteStart – el byte inicial, por omisión es 0.
byteEnd – el último byte (exclusivo, por omisión es el final).
contentType – el tipo del nuevo blob, por omisión es el mismo que la fuente.

Los argumentos son similares a array.slice, los números negativos también son permitidos.

            los objetos Blob son inmutables
            No podemos cambiar datos directamente en un Blob, pero podemos obtener partes de un Blob, crear nuevos objetos Blob a partir de ellos, mezclarlos en un nuevo Blob y así por el estilo.
Este comportamiento es similar a las cadenas de JavaScript: no podemos cambiar un carácter en una cadena, pero podemos hacer una nueva, corregida.

Blob como URLUn Blob puede ser utilizado fácilmente como una URL para <a>, <img> u otras etiquetas, para mostrar su contenido.
Gracias al tipo, también podemos descargar/cargar objetos Blob, y el tipo se convierte naturalmente en Content-Type en solicitudes de red.
Empecemos con un ejemplo simple. Al hacer click en un link, descargas un Blob dinámicamente generado con contenido hello world en forma de archivo:

      
        
        
          
            
          
          
            
          
        
        
          <!-- descargar atributos fuerza al navegador a descargar en lugar de navegar -->
<a download="hello.txt" href='#' id="link">Descargar</a>

<script>
let blob = new Blob(["Hello, world!"], {type: 'text/plain'});

link.href = URL.createObjectURL(blob);
</script>
        
      
      
      También podemos crear un link dinámicamente en JavaScript y simular un click con link.click(), y la descarga inicia automáticamente.
Este es un código similar que permite al usuario descargar el Blob creado dinámicamente, sin HTML:

      
        
        
          
            
          
          
            
          
        
        
          let link = document.createElement('a');
link.download = 'hello.txt';

let blob = new Blob(['Hello, world!'], {type: 'text/plain'});

link.href = URL.createObjectURL(blob);

link.click();

URL.revokeObjectURL(link.href);
        
      
      
      URL.createObjectURL toma un Blob y crea una URL única para él, con la forma blob:<origin>/<uuid>.
Así es como se ve el valor de link.href:

      
        
        
          blob:https://javascript.info/1e67e00e-860d-40a5-89ae-6ab0cbee6273
        
      
      
      Por cada URL generada por URL.createObjectURL el navegador almacena un URL → Blob mapeado internamente. Así que las URLs son cortas, pero permiten acceder al Blob.
Una URL generada (y por lo tanto su enlace) solo es válida en el documento actual, mientras está abierto. Y este permite referenciar al Blob en <img>, <a>, básicamente cualquier otro objeto que espera un URL.
También hay efectos secundarios. Mientras haya un mapeado para un Blob, el Blob en sí mismo se guarda en la memoria. El navegador no puede liberarlo.
El mapeado se limpia automáticamente al vaciar un documento, así los objetos Blob son liberados. Pero si una aplicación es de larga vida, entonces eso no va a pasar pronto.
Entonces, si creamos una URL, este Blob se mantendrá en la memoria, incluso si ya no se necesita.
URL.revokeObjectURL(url) elimina la referencia el mapeo interno, además de permitir que el Blob sea borrado (si ya no hay otras referencias), y que la memoria sea liberada.
En el último ejemplo, intentamos que el Blob sea utilizado una sola vez, para descargas instantáneas, así llamamos URL.revokeObjectURL(link.href) inmediatamente.
En el ejemplo anterior con el link HTML cliqueable, no llamamos URL.revokeObjectURL(link.href), porque eso puede hacer la URL del Blob inválido. Después de la revocación, como el mapeo es eliminado, la URL ya no volverá a funcionar.
Blob a base64Una alternativa a URL.createObjectURL es convertir un Blob en una cadena codificada en base64.
Esa codificación representa datos binarios como una cadena ultra segura de caracteres “legibles” con códigos ASCII desde el 0 al 64. Y lo que es más importante, podemos utilizar codificación en las “URLs de datos”.
Un URL de datos tiene la forma data:[<mediatype>][;base64],<data>. Podemos usar suficientes URLs por doquier, junto a URLs “regulares”.
Por ejemplo, aquí hay una sonrisa:

      
        
        
          <img src="data:image/png;base64,R0lGODlhDAAMAKIFAF5LAP/zxAAAANyuAP/gaP///wAAAAAAACH5BAEAAAUALAAAAAAMAAwAAAMlWLPcGjDKFYi9lxKBOaGcF35DhWHamZUW0K4mAbiwWtuf0uxFAgA7">
        
      
      
      El navegador decodificará la cadena y mostrará la imagen: 
Para transformar un Blob a base64, usaremos el objeto nativo FileReader. Puede leer datos de Blobs en múltiples formatos. En el siguiente capítulo lo cubriremos en profundidad.
Aquí está el demo de descarga de un blob, ahora con base-64:

      
        
        
          
            
          
          
            
          
        
        
          let link = document.createElement('a');
link.download = 'hello.txt';

let blob = new Blob(['Hello, world!'], {type: 'text/plain'});

let reader = new FileReader();
reader.readAsDataURL(blob); // convierte el blob a base64 y llama a onload

reader.onload = function() {
  link.href = reader.result; // URL de datos
  link.click();
};
        
      
      
      Se pueden utilizar ambas maneras para hacer una URL de un Blob . Pero usualmente URL.createObjectURL(blob) es más simple y rápido.

      
      URL.createObjectURL(blob)Necesitamos revocarlos para cuidar la memoria.
Acceso directo al blob, sin “codificación/decodificación”

      
      Blob a URL de datosNo necesitamos revocar nada.
Se pierde rendimiento y memoria en grandes objetos Blob al codificar.
imagen a blobPodemos crear un Blob de una imagen, una parte de una imagen, o incluso hacer una captura de la página. Es práctico para subirlo a algún lugar.
Las operaciones de imágenes se hacen a través del elemento <canvas>:

Dibuja una imagen (o una parte) en el canvas utilizando canvas.drawImage.
Llama el método de canvas .toBlob(callback, format, quality) que crea un Blob y llama el callback cuando termina.

En el ejemplo siguiente, un imagen se copia, pero no podemos cortarla o transformarla en el canvas hasta convertirla en blob:

      
        
        
          
            
          
          
            
          
        
        
          // tomar cualquier imagen
let img = document.querySelector('img');

// hacer el <canvas> del mismo tamaño
let canvas = document.createElement('canvas');
canvas.width = img.clientWidth;
canvas.height = img.clientHeight;

let context = canvas.getContext('2d');

// copiar la imagen en él (este método permite cortar la imagen)
context.drawImage(img, 0, 0);
// podemos hacer un context.rotate(), y muchas otras cosas en canvas

// toBlob es una operación asincrónica, callback es llamada al terminar
canvas.toBlob(function(blob) {
  // blob listo, descárgalo
  let link = document.createElement('a');
  link.download = 'example.png';

  link.href = URL.createObjectURL(blob);
  link.click();

  // borrar la referencia interna del blob, para permitir al navegador eliminarlo de la memoria
  URL.revokeObjectURL(link.href);
}, 'image/png');
        
      
      
      Si preferimos async/await en lugar de callbacks:

      
        
        
          let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));
        
      
      
      Para capturar la página, podemos utilizar una librería como https://github.com/niklasvh/html2canvas. Que lo que hace es escanear toda la página y dibujarla en el <canvas>. Entonces podemos obtener un Blob de la misma manera que arriba.
De Blob a ArrayBufferEl constructor de Blob permite crear un blob de casi cualquier cosa, incluyendo cualquier BufferSource.
Pero si queremos ejecutar un procesamiento de bajo nivel, podemos obtener el nivel más bajo de un ArrayBuffer desde blob.arrayBuffer():

      
        
        
          // obtener un arrayBuffer desde un blob
const bufferPromise = await blob.arrayBuffer();

// or
blob.arrayBuffer().then(buffer => /* process the ArrayBuffer */);
        
      
      
      De Blob a streamCuando leemos y escribimos un blob de más de 2 GB, arrayBuffer hace un uso demasiado intensivo de la memoria para nosotros. En este punto, podemos convertir directamente el blob a un stream.
Un stream (flujo, corriente) es un objeto especial que permite leer (o escribir) porción por porción. Está fuera de nuestro objetivo aquí, pero este es un ejemplo que puedes leer https://developer.mozilla.org/en-US/docs/Web/API/Streams_API. Los streams son convenientes para datos que son adecuados para el proceso pieza por pieza.
El método interfaz stream() de Blob devuelve un ReadableStream que al leerlo devuelve datos contenidos dentro del Blob.
Entonces podemos leerlos desde él, como aquí:

      
        
        
          // obtiene readableStream desde blob
const readableStream = blob.stream();
const stream = readableStream.getReader();

while (true) {
  // para cada iteración: data es el siguiente fragmento del blob
  let { done, value } = await stream.read();
  if (done) {
    // no hay más data en el stream
    console.log('todo el blob procesado.');
    break;
  }

   // hacer algo con la porción de datos que acabamos de leer del blob
  console.log(value);
}
        
      
      
      ResumenMientras ArrayBuffer, Uint8Array y otros BufferSource son “datos binarios”, un Blob representa “datos binarios con tipo”.
Esto hace a los Blobs convenientes para operaciones de carga/descarga, estos son muy comunes en el navegador.
Los métodos que ejecutan solicitudes web, como XMLHttpRequest, fetch y otros, pueden trabajar nativamente con Blob, como con otros tipos binarios.
Podemos convertir fácilmente entre Blob y tipos de datos binarios de bajo nivel:

Podemos crear un Blob desde un array tipado usando el constructor new Blob(...).
Podemos obtener de vuelta un ArrayBuffer desde un Blob usando blob.arrayBuffer(), y entonces crear una vista sobre él para procesamiento binario de bajo nivel.

Los streams de conversión son muy útiles cuando necesitamos manejar grandes blob. Puedes crear un ReadableStream desde un blob. El método interfaz stream() de Blob devuelve un ReadableStream que una vez leído devuelve los datos contenido en el blob.
",
	"url": "https://es.javascript.info/blob" 
},
{
	"docs_id": "135",
	"name": "File y FileReader",
	"description": "Un objeto File hereda de Blob y extiende las capacidades relacionadas con el sistema de archivos.",
	"content": "Un objeto File hereda de Blob y extiende las capacidades relacionadas con el sistema de archivos.
Hay dos maneras de obtenerlo
Primero, hay un constructor, similar al de Blob:

      
        
        
          new File(fileParts, fileName, [options])
        
      
      
      
fileParts – es un array con valores de tipo Blob/BufferSource/String.
fileName – el nombre del archivo…
options – objeto opcional:

lastModified – la  marca de tiempo (fecha en mili-segundos, de tipo entero) de la última modificación.



Segundo, a menudo obtenemos un archivo mediante un <input type="file"> o arrastrar y soltar u otras interfaces del navegador. En este caso el archivo obtiene la información del Sistema Operativo.
Como File (Archivo) hereda de Blob, objetos de tipo File tienen las mismas propiedades, mas:

name – el nombre del archivo,
lastModified – la marca de tiempo de la última modificación.

Así es como obtenemos un objeto File desde <input type="file"> :

      
        
        
          
            
          
          
            
          
        
        
          <input type="file" onchange="showFile(this)">

<script>
function showFile(input) {
  let file = input.files[0];

  alert(`File name: ${file.name}`); // e.g my.png
  alert(`Last modified: ${file.lastModified}`); // e.g 1552830408824
}
</script>
        
      
      
      
            Por favor tome nota:
            El input puede seleccionar varios archivos, por lo que input.files es un array de dichos archivos . En este caso tenemos un solo archivo por lo que solo es necesario usar input.files[0].

FileReaderFileReader es un objeto con el único porpósito de leer datos desde  objetos  de tipo Blob (por lo tanto File también).
El entrega los datos usando eventos debido a que leerlos desde el disco puede tomar un tiempo.
El constructor:

      
        
        
          let reader = new FileReader(); // sin argumentos
        
      
      
      Los métodos principales:

readAsArrayBuffer(blob) – lee los datos en formato binario ArrayBuffer.
readAsText(blob, [codificación]) – lee los datos como una cadena de texto con la codificación dada (por defecto es utf-8).
readAsDataURL(blob) – lee los datos binarios y los codifica como [Datos URIs] en base 64 (https://developer.mozilla.org/es/docs/Web/HTTP/Basics_of_HTTP/Datos_URIs).
abort() – cancela la operación.

La opción del método read* depende de qué formato preferimos y cómo vamos a usar los datos.

readAsArrayBuffer – para archivos binarios, en donde se hacen operaciones binarias de bajo nivel. Para operaciones de alto nivel, como slicing, File hereda de Blob por lo que podemos llamarlas directamente sin tener que leer.
readAsText – para archivos de texto, cuando necesitamos obtener una cadena.
readAsDataURL – cuando necesitamos usar estos datos como valores de src en img u otras etiquetas html. Hay otra alternativa para leer archivos de ese tipo como discutimos en el capítulo Blob: URL.createObjectURL(file).

Mientras se va realizando la lectura, suceden varios eventos:

loadstart – la carga comenzó.
progress – ocurre mientras se lee.
load – lectura completada, sin errores.
abort – abort() ha sido llamado.
error – ha ocurrido un error .
loadend – la lectura finalizó exitosa o no .

Cuando la lectura finaliza, podemos acceder al resultado como:

reader.result el resultado (si fue exitoso)
reader.error el error (si hubo fallo).

Los mas ampliamente usados son seguramente load y error.
Un ejemplo de como leer un archivo:

      
        
        
          
            
          
          
            
          
        
        
          <input type="file" onchange="readFile(this)">

<script>
function readFile(input) {
  let file = input.files[0];

  let reader = new FileReader();

  reader.readAsText(file);

  reader.onload = function() {
    console.log(reader.result);
  };

  reader.onerror = function() {
    console.log(reader.error);
  };

}
</script>
        
      
      
      
            FileReader para blobs
            Como mencionamos en el capítulo Blob, FileReader no solo lee archivos sino también cualquier blob.
Podemos usarlo para convertir un blob a otro formato:

readAsArrayBuffer(blob) – a ArrayBuffer,
readAsText(blob, [encoding]) – a una cadena (una alternativa al TextDecoder),
readAsDataURL(blob) – a Datos URI en base 64.



            FileReaderSync está disponible dentro de  Web Workers
            Para los Web Workers también existe una variante síncrona de FileReader llamada FileReaderSync.
Sus metodos read* no generan eventos sino que devuelven un resultado como las funciones regulares.
Esto es solo dentro de un Web Worker, debido a que  demoras en  llamadas síncronas  mientras se lee el archivo en Web Worker no son tan importantes. No afectan la página.

ResumenLos objetos File heredan de  Blob.
Además de los métodos y propiedades de Blob, los objetos File también tienen las propiedades name y lastModified mas la habilidad interna de leer del sistema de archivos. Usualmente obtenemos los objetos File mediante la entrada del el usuario con <input> o eventos Drag’n’Drop (ondragend).
Los objetos FileReader pueden leer desde un archivo o un blob en uno de estos tres formatos:

String (readAsText) .
ArrayBuffer (readAsArrayBuffer).
Datos URI codificado en base 64 (readAsDataURL).

En muchos casos no necesitamos leer el contenido de un archivo como hicimos con los blobs, podemos crear un enlace corto con URL.createObjectURL(file) y asignárselo a un <a> o <img>. De esta manera el archivo puede ser descargado, mostrado como una imagen o como parte de un canvas, etc.
Y si vamos a mandar un File por la red, es fácil utilizando APIs como XMLHttpRequest o fetch que aceptan nativamente objetos File .
",
	"url": "https://es.javascript.info/file" 
},
{
	"docs_id": "136",
	"name": "Fetch",
	"description": "JavaScript puede enviar peticiones de red al servidor y cargar nueva información siempre que se necesite.",
	"content": "JavaScript puede enviar peticiones de red al servidor y cargar nueva información siempre que se necesite.
Por ejemplo, podemos utilizar una petición de red para:

Crear una orden,
Cargar información de usuario,
Recibir las últimas actualizaciones desde un servidor,
…etc.

…Y todo esto sin la necesidad de refrescar la página.
Se utiliza el término global “AJAX” (abreviado Asynchronous JavaScript And XML, en español: “JavaScript y XML Asincrónico”) para referirse a las peticiones de red originadas desde JavaScript. Sin embargo, no estamos necesariamente condicionados a utilizar XML dado que el término es antiguo y es por esto que el acrónimo XML se encuentra aquí. Probablemente lo hayáis visto anteriormente.
Existen múltiples maneras de enviar peticiones de red y obtener información de un servidor.
Comenzaremos con el el método fetch() que es moderno y versátil. Este método no es soportado por navegadores antiguos (sin embargo se puede incluir un polyfill), pero es perfectamente soportado por los navegadores actuales y modernos.
La sintaxis básica es la siguiente:

      
        
        
          let promise = fetch(url, [options])
        
      
      
      
url – representa la dirección URL a la que deseamos acceder.
options – representa los parámetros opcionales, como puede ser un método o los encabezados de nuestra petición, etc.

Si no especificamos ningún options, se ejecutará una simple petición GET, la cual descargará el contenido de lo especificado en el url.
El navegador lanzará la petición de inmediato y devolverá una promesa (promise) que luego será utilizada por el código invocado para obtener el resultado.
Por lo general, obtener una respuesta es un proceso de dos pasos.
Primero, la promesa promise, devuelta por fetch, resuelve la respuesta con un objeto de la clase incorporada Response tan pronto como el servidor responde con los encabezados de la petición.
En este paso, podemos chequear el status HTTP para poder ver si nuestra petición ha sido exitosa o no, y chequear los encabezados, pero aún no disponemos del cuerpo de la misma.
La promesa es rechazada si el fetch no ha podido establecer la petición HTTP, por ejemplo, por problemas de red o si el sitio especificado en la petición no existe. Estados HTTP anormales, como el 404 o 500 no generan errores.
Podemos visualizar los estados HTTP en las propiedades de la respuesta:

status – código de estado HTTP, por ejemplo: 200.
ok – booleana, true si el código de estado HTTP es 200 a 299.

Ejemplo:

      
        
        
          let response = await fetch(url);

if (response.ok) { // si el HTTP-status es 200-299
  // obtener cuerpo de la respuesta (método debajo)
  let json = await response.json();
} else {
  alert("Error-HTTP: " + response.status);
}
        
      
      
      Segundo, para obtener el cuerpo de la respuesta, necesitamos utilizar un método adicional.
Response provee múltiples métodos basados en promesas para acceder al cuerpo de la respuesta en distintos formatos:

response.text() – lee y devuelve la respuesta en formato texto,
response.json() – convierte la respuesta como un JSON,
response.formData() – devuelve la respuesta como un objeto FormData (explicado en el siguiente capítulo),
response.blob() – devuelve la respuesta como Blob (datos binarios tipados),
response.arrayBuffer() – devuelve la respuesta como un objeto ArrayBuffer (representación binaria de datos de bajo nivel),
Adicionalmente, response.body es un objeto ReadableStream, el cual nos permite acceder al cuerpo como si fuera un stream y leerlo por partes. Veremos un ejemplo de esto más adelante.

Por ejemplo, si obtenemos un objeto de tipo JSON con los últimos commits de GitHub:

      
        
        
          
            
          
          
            
          
        
        
          let url = 'https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits';
let response = await fetch(url);

let commits = await response.json(); // leer respuesta del cuerpo y devolver como JSON

alert(commits[0].author.login);
        
      
      
      O también usando promesas, en lugar de await:

      
        
        
          
            
          
          
            
          
        
        
          fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
  .then(response => response.json())
  .then(commits => alert(commits[0].author.login));
        
      
      
      Para obtener la respuesta como texto, await response.text() en lugar de .json():

      
        
        
          
            
          
          
            
          
        
        
          let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

let text = await response.text(); // leer cuerpo de la respuesta como texto

alert(text.slice(0, 80) + '...');
        
      
      
      Como demostración de una lectura en formato binario, hagamos un fetch y mostremos una imagen del logotipo de “especificación fetch” (ver capítulo Blob para más detalles acerca de las operaciones con Blob):

      
        
        
          
            
          
          
            
          
        
        
          let response = await fetch('/article/fetch/logo-fetch.svg');

let blob = await response.blob(); // download as Blob object

// crear tag <img> para imagen
let img = document.createElement('img');
img.style = 'position:fixed;top:10px;left:10px;width:100px';
document.body.append(img);

// mostrar
img.src = URL.createObjectURL(blob);

setTimeout(() => { // ocultar luego de tres segundos
  img.remove();
  URL.revokeObjectURL(img.src);
}, 3000);
        
      
      
      
            Importante:
            Podemos elegir un solo método de lectura para el cuerpo de la respuesta.
Si ya obtuvimos la respuesta con response.text(), entonces response.json() no funcionará, dado que el contenido del cuerpo ya ha sido procesado.

      
        
        
          let text = await response.text(); // cuerpo de respuesta obtenido y procesado
let parsed = await response.json(); // fallo (ya fue procesado)
        
      
      
      
Encabezados de respuestaLos encabezados de respuesta están disponibles como un objeto de tipo Map dentro del response.headers.
No es exactamente un Map, pero posee métodos similares para obtener de manera individual encabezados por nombre o si quisiéramos recorrerlos como un objeto:

      
        
        
          
            
          
          
            
          
        
        
          let response = await fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits');

// obtenemos un encabezado
alert(response.headers.get('Content-Type')); // application/json; charset=utf-8

// iteramos todos los encabezados
for (let [key, value] of response.headers) {
  alert(`${key} = ${value}`);
}
        
      
      
      Encabezados de peticiónPara especificar un encabezado en nuestro fetch, podemos utilizar la opción headers. La misma posee un objeto con los encabezados salientes, como se muestra en el siguiente ejemplo:

      
        
        
          let response = fetch(protectedUrl, {
  headers: {
    Authentication: 'secret'
  }
});
        
      
      
      …Pero existe una lista de encabezados que no pueden ser especificados:

Accept-Charset, Accept-Encoding
Access-Control-Request-Headers
Access-Control-Request-Method
Connection
Content-Length
Cookie, Cookie2
Date
DNT
Expect
Host
Keep-Alive
Origin
Referer
TE
Trailer
Transfer-Encoding
Upgrade
Via
Proxy-*
Sec-*

Estos encabezados nos aseguran que nuestras peticiones HTTP sean controladas exclusivamente por el navegador, de manera correcta y segura.
Peticiones POSTPara ejecutar una petición POST, o cualquier otro método, utilizaremos las opciones de fetch:

method – método HTTP, por ej: POST,
body – cuerpo de la respuesta, cualquiera de las siguientes:

cadena de texto (ej. JSON-encoded),
Objeto FormData, para enviar información como multipart/form-data,
Blob/BufferSource para enviar información en formato binario,
URLSearchParams, para enviar información en cifrado x-www-form-urlencoded (no utilizado frecuentemente).



El formato JSON es el más utilizado.
Por ejemplo, el código debajo envía la información user como un objeto JSON:

      
        
        
          
            
          
          
            
          
        
        
          let user = {
  nombre: 'Juan',
  apellido: 'Perez'
};

let response = await fetch('/article/fetch/post/user', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json;charset=utf-8'
  },
  body: JSON.stringify(user)
});

let result = await response.json();
alert(result.message);
        
      
      
      Tener en cuenta, si la respuesta del body es una cadena de texto, entonces el encabezado Content-Type será especificado como text/plain;charset=UTF-8 por defecto.
Pero, cómo vamos a enviar un objeto JSON, en su lugar utilizaremos la opción headers especificada a application/json, que es la opción correcta Content-Type para información en formato JSON.
Enviando una imagenTambién es posible enviar datos binarios con fetch, utilizando los objetos Blob o BufferSource.
En el siguiente ejemplo, utilizaremos un <canvas> donde podremos dibujar utilizando nuestro ratón. Haciendo click en el botón “enviar” enviará la imagen al servidor:

      
        
        
          
            
          
          
            
          
        
        
          <body style="margin:0">
  <canvas id="canvasElem" width="100" height="80" style="border:1px solid"></canvas>

  <input type="button" value="Enviar" onclick="submit()">

  <script>
    canvasElem.onmousemove = function(e) {
      let ctx = canvasElem.getContext('2d');
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
    };

    async function submit() {
      let blob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));
      let response = await fetch('/article/fetch/post/image', {
        method: 'POST',
        body: blob
      });

      // el servidor responde con una confirmación y el tamaño de nuestra imagen
      let result = await response.json();
      alert(result.message);
    }

  </script>
</body>
        
      
      
          
        
      Una aclaración, aquí no especificamos el Content-Type de manera manual, precisamente porque el objeto Blob posee un tipo incorporado (en este caso image/png, el cual es generado por la función toBlob). Para objetos Blob ese es el valor por defecto del encabezado Content-Type.
Podemos reescribir la función submit() sin utilizar async/await de la siguiente manera:

      
        
        
          function submit() {
  canvasElem.toBlob(function(blob) {
    fetch('/article/fetch/post/image', {
      method: 'POST',
      body: blob
    })
      .then(response => response.json())
      .then(result => alert(JSON.stringify(result, null, 2)))
  }, 'image/png');
}
        
      
      
      ResumenUna petición fetch típica está formada por dos llamadas await:

      
        
        
          let response = await fetch(url, options); // resuelve con los encabezados de respuesta
let result = await response.json(); // accede al cuerpo de respuesta como json
        
      
      
      También se puede acceder sin utilizar await:

      
        
        
          fetch(url, options)
  .then(response => response.json())
  .then(result => /* procesa resultado */)
        
      
      
      Propiedades de respuesta:

response.status – Código HTTP de la respuesta.
response.ok – Devuelve true si el código HTTP es 200-299.
response.headers – Objeto simil-Map que contiene los encabezados HTTP.

Métodos para obtener el cuerpo de la respuesta:

response.text() – lee y devuelve la respuesta en formato texto,
response.json() – convierte la respuesta como un JSON,
response.formData() – devuelve la respuesta como un objeto FormData (codificación multipart/form-data, explicado en el siguiente capítulo),
response.blob() – devuelve la respuesta como Blob (datos binarios tipados),
response.arrayBuffer() – devuelve la respuesta como un objeto ArrayBuffer (datos binarios de bajo nivel)

Opciones de fetch hasta el momento:

method – método HTTP,
headers – un objeto los encabezados de la petición (no todos los encabezados están permitidos),
body – los datos/información a enviar (cuerpo de la petición) como string, FormData, BufferSource, Blob u objeto UrlSearchParams.

En los próximos capítulos veremos más sobre opciones y casos de uso para fetch.
TareasFetch de usuarios de GitHubCrear una función async llamada getUsers(names), que tome como parámetro un arreglo de logins de GitHub, obtenga el listado de usuarios de GitHub indicado y devuelva un arreglo de usuarios de GitHub.
La url de GitHub con la información de usuario especifica USERNAME es: https://api.github.com/users/USERNAME.
En el ambiente de prueba (sandbox) hay un ejemplo de referencia.
Detalles a tener en cuenta:

Debe realizarse una única petición fetch por cada usuario.
Para que la información esté disponible lo antes posible las peticiones no deben ejecutarse de una por vez.
Si alguna de las peticiones fallara o si el usuario no existiese, la función debe devolver null en el resultado del arreglo.

Abrir en entorno controlado con pruebas.soluciónPara obtener un usuario tenemos que ejecutar el siguiente código: fetch('https://api.github.com/users/USERNAME').
Si la respuesta contiene el status 200, utilizamos el método .json() para leer el objeto JS.
Por el contrario, si el fetch falla o la respuesta no contiene un status 200, devolvemos null en el resultado del arreglo.
Código:

      
        
        
          async function getUsers(names) {
  let jobs = [];

  for(let name of names) {
    let job = fetch(`https://api.github.com/users/${name}`).then(
      successResponse => {
        if (successResponse.status != 200) {
          return null;
        } else {
          return successResponse.json();
        }
      },
      failResponse => {
        return null;
      }
    );
    jobs.push(job);
  }

  let results = await Promise.all(jobs);

  return results;
}
        
      
      
      Nota: la función .then está directamente vinculada al fetch. Por lo tanto, cuando se obtiene la respuesta se procede a ejecutar la función .json() inmediatamente en lugar de esperar a las otras peticiones.
Si en su lugar utilizáramos await Promise.all(names.map(name => fetch(...))) y llamamos a la función .json() sobre los resultados, entonces esperaríamos a que todas las peticiones fetch completen antes de obtener una respuesta. Al agregar .json() directamente en cada fetch, nos aseguramos de que las peticiones se procesen de manera independiente obteniendo una mejor respuesta en nuestra aplicación.
Esto es un ejemplo de cómo la API de Promesas puede ser útil aunque mayormente se utilice async/await.
Abrir la solución con pruebas en un entorno controlado.",
	"url": "https://es.javascript.info/fetch" 
},
{
	"docs_id": "137",
	"name": "FormData",
	"description": "Este capítulo trata sobre el envío de formularios HTML: con o sin archivos, con campos adicionales y cosas similares.",
	"content": "Este capítulo trata sobre el envío de formularios HTML: con o sin archivos, con campos adicionales y cosas similares.
Los objetos FormData pueden ser de ayuda en esta tarea. Tal como habrás supuesto, éste es el objeto encargado de representar los datos de los formularios HTML.
El constructor es:

      
        
        
          let formData = new FormData([form]);
        
      
      
      Si se le brinda un elemento HTML form, el objeto automáticamente capturará sus campos.
Lo que hace especial al objeto FormData es que los métodos de red, tales como fetch, pueden aceptar un objeto FormData como el cuerpo. Es codificado y enviado como Content-Type: multipart/form-data.
Desde el punto de vista del servidor, se ve como una entrega normal.
Enviando un formulario simpleEnviemos un formulario simple.
Tal como se puede ver, es prácticamente una línea:

      
        
        
          
            
          
          
            
          
        
        
          <form id="formElem">
  <input type="text" name="name" value="John">
  <input type="text" name="surname" value="Smith">
  <input type="submit">
</form>

<script>
  formElem.onsubmit = async (e) => {
    e.preventDefault();

    let response = await fetch('/article/formdata/post/user', {
      method: 'POST',
      body: new FormData(formElem)
    });

    let result = await response.json();

    alert(result.message);
  };
</script>
        
      
      
          
        
      En este ejemplo, el código del servidor no es representado ya que está fuera de nuestro alcance. El servidor acepta la solicitud POST y responde “Usuario registrado”.
Métodos de FormDataContamos con métodos para poder modificar los campos del FormData:

formData.append(name, value) – agrega un campo al formulario con el nombre name y el valor value,
formData.append(name, blob, fileName) – agrega un campo tal como si se tratara de un <input type="file">, el tercer argumento fileName establece el nombre del archivo (no el nombre del campo), tal como si se tratara del nombre del archivo en el sistema de archivos del usuario,
formData.delete(name) – elimina el campo de nombre name,
formData.get(name) – obtiene el valor del campo con el nombre name,
formData.has(name) – en caso de que exista el campo con el nombre name, devuelve true, de lo contrario false

Un formulario técnicamente tiene permitido contar con muchos campos con el mismo atributo name, por lo que múltiples llamadas a append agregarán más campos con el mismo nombre.
Por otra parte existe un método set, con la misma sintaxis que append. La diferencia está en que .set remueve todos los campos con el name que se le ha pasado, y luego agrega el nuevo campo. De este modo nos aseguramos de que exista solamente un campo con determinado name, el resto es tal como en append:

formData.set(name, value),
formData.set(name, blob, fileName).

También es posible iterar por los campos del objeto formData utilizando un bucle for..of:

      
        
        
          
            
          
          
            
          
        
        
          let formData = new FormData();
formData.append('key1', 'value1');
formData.append('key2', 'value2');

// Se listan los pares clave/valor
for(let [name, value] of formData) {
  alert(`${name} = ${value}`); // key1 = value1, luego key2 = value2
}
        
      
      
      Enviando un formulario con un archivoEl formulario siempre es enviado como Content-Type: multipart/form-data, esta codificación permite enviar archivos. Por lo tanto los campos <input type="file"> también son enviados, tal como sucede en un envío normal.
Aquí un ejemplo con un formulario de este tipo:

      
        
        
          
            
          
          
            
          
        
        
          <form id="formElem">
  <input type="text" name="firstName" value="John">
  Imagen: <input type="file" name="picture" accept="image/*">
  <input type="submit">
</form>

<script>
  formElem.onsubmit = async (e) => {
    e.preventDefault();

    let response = await fetch('/article/formdata/post/user-avatar', {
      method: 'POST',
      body: new FormData(formElem)
    });

    let result = await response.json();

    alert(result.message);
  };
</script>
        
      
      
          
        
      Enviando un formulario con datos BlobTal como pudimos ver en el capítulo Fetch, es fácil enviar datos binarios generados dinámicamente (por ejemplo una imagen) como Blob. Podemos proporcionarlos directamente en un fetch con el parámetro body.
De todos modos, en la práctica suele ser conveniente enviar la imagen como parte del formulario junto a otra metadata tal como el nombre y no de forma separada.
Además los servidores suelen ser más propensos a aceptar formularios multipart, en lugar de datos binarios sin procesar.
Este ejemplo envía una imagen desde un <canvas> junto con algunos campos más, como un formulario utilizando FormData:

      
        
        
          
            
          
          
            
          
        
        
          <body style="margin:0">
  <canvas id="canvasElem" width="100" height="80" style="border:1px solid"></canvas>

  <input type="button" value="Submit" onclick="submit()">

  <script>
    canvasElem.onmousemove = function(e) {
      let ctx = canvasElem.getContext('2d');
      ctx.lineTo(e.clientX, e.clientY);
      ctx.stroke();
    };

    async function submit() {
      let imageBlob = await new Promise(resolve => canvasElem.toBlob(resolve, 'image/png'));

      let formData = new FormData();
      formData.append("firstName", "John");
      formData.append("image", imageBlob, "image.png");

      let response = await fetch('/article/formdata/post/image-form', {
        method: 'POST',
        body: formData
      });
      let result = await response.json();
      alert(result.message);
    }

  </script>
</body>
        
      
      
          
        
      Nota como la imagen Blob es agregada:

      
        
        
          formData.append("image", imageBlob, "image.png");
        
      
      
      Es lo mismo que si hubiera un campo <input type="file" name="image"> en el formulario, y el usuario enviara un archivo con nombre "image.png" (3er argumento) con los datos imageBlob (2do argumento) desde su sistema de archivos.
El servidor lee el formulario form-data y el archivo tal como si de un formulario regular se tratara.
ResumenLos objetos FormData son utilizados para capturar un formulario HTML y enviarlo utilizando fetch u otro método de red.
Podemos crear el objeto con new FormData(form) desde un formulario HTML, o crear un objeto sin un formulario en absoluto y agregar los campos con los siguientes métodos:

formData.append(nombre, valor)
formData.append(nombre, blob, nombreDeArchivo)
formData.set(nombre, valor)
formData.set(nombre, blob, nombreDeArchivo)

Nótese aquí dos particularidades:

El método set remueve campos con el mismo nombre, mientras que append no. Esta es la única diferencia entre estos dos métodos.
Para enviar un archivo, se requiere de tres argumentos, el último argumento es el nombre del archivo, el cual normalmente es tomado desde el sistema de archivos del usuario por el <input type="file">.

Otros métodos son:

formData.delete(nombre)
formData.get(nombre)
formData.has(nombre)

¡Esto es todo!
",
	"url": "https://es.javascript.info/formdata" 
},
{
	"docs_id": "138",
	"name": "Fetch: Progreso de la descarga",
	"description": "El método fetch permite rastrear el progreso de descarga.",
	"content": "El método fetch permite rastrear el progreso de descarga.
Ten en cuenta: actualmente no hay forma de que fetch rastree el progreso de carga. Para ese propósito, utiliza XMLHttpRequest, lo cubriremos más adelante.
Para rastrear el progreso de la descarga, podemos usar la propiedad response.body. Esta propiedad es un ReadableStream, un objeto especial que proporciona la transmisión del cuerpo fragmento a fragmento tal como viene. Estas se describen en la especificación de la API de transmisiones.
A diferencia de response.text(), response.json() y otros métodos, response.body da control total sobre el proceso de lectura, y podemos contar cuánto se consume en cualquier momento.
Aquí está el bosquejo del código que lee la respuesta de response.body:

      
        
        
          // en lugar de response.json() y otros métodos
const reader = response.body.getReader();

// bucle infinito mientras el cuerpo se descarga
while(true) {
  // done es true para el último fragmento
  // value es Uint8Array de los bytes del fragmento
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  console.log(`Recibí ${value.length} bytes`)
}
        
      
      
      El resultado de la llamada await reader.read() es un objeto con dos propiedades:

done – true cuando la lectura está completa, de lo contrario false.
value – una matriz de tipo bytes: Uint8Array.


            Por favor tome nota:
            La API de transmisiones también describe la iteración asincrónica sobre ReadableStream con el bucle for await..of, pero aún no es ampliamente compatible (consulta problemas del navegador), por lo que usamos el bucle while.

Recibimos fragmentos de respuesta en el bucle, hasta que finaliza la carga, es decir: hasta que done se convierte en true.
Para registrar el progreso, solo necesitamos que cada value de fragmento recibido agregue su longitud al contador.
Aquí está el ejemplo funcional completo que obtiene la respuesta y registra el progreso en la consola, seguido de su explicación:

      
        
        
          
            
          
          
            
          
        
        
          // Paso 1: iniciar la búsqueda y obtener un lector
let response = await fetch('https://api.github.com/repos/javascript-tutorial/es.javascript.info/commits?per_page=100');

const reader = response.body.getReader();

// Paso 2: obtener la longitud total
const contentLength = +response.headers.get('Content-Length');

// Paso 3: leer los datos
let receivedLength = 0; // cantidad de bytes recibidos hasta el momento
let chunks = []; // matriz de fragmentos binarios recibidos (comprende el cuerpo)
while(true) {
  const {done, value} = await reader.read();

  if (done) {
    break;
  }

  chunks.push(value);
  receivedLength += value.length;

  console.log(`Recibí ${receivedLength} de ${contentLength}`)
}

// Paso 4: concatenar fragmentos en un solo Uint8Array
let chunksAll = new Uint8Array(receivedLength); // (4.1)
let position = 0;
for(let chunk of chunks) {
  chunksAll.set(chunk, position); // (4.2)
  position += chunk.length;
}

// Paso 5: decodificar en un string
let result = new TextDecoder("utf-8").decode(chunksAll);

// ¡Hemos terminado!
let commits = JSON.parse(result);
alert(commits[0].author.login);
        
      
      
      Expliquemos esto paso a paso:


Realizamos fetch como de costumbre, pero en lugar de llamar a response.json(), obtenemos un lector de transmisión response.body.getReader().
Ten en cuenta que no podemos usar ambos métodos para leer la misma respuesta: usa un lector o un método de respuesta para obtener el resultado.


Antes de leer, podemos averiguar la longitud completa de la respuesta del encabezado Content-Length.
Puede estar ausente para solicitudes cross-origin (consulta el capítulo Fetch: Cross-Origin Requests) y, bueno, técnicamente un servidor no tiene que configurarlo. Pero generalmente está en su lugar.


Llama a await reader.read() hasta que esté listo.
Recopilamos fragmentos de respuesta en la matriz chunks. Eso es importante, porque después de consumir la respuesta, no podremos “releerla” usando response.json() u otra forma (puedes intentarlo, habrá un error).


Al final, tenemos chunks – una matriz de fragmentos de bytes Uint8Array. Necesitamos unirlos en un solo resultado. Desafortunadamente, no hay un método simple que los concatene, por lo que hay un código para hacerlo:

Creamos chunksAll = new Uint8Array(selectedLength) – una matriz del mismo tipo con la longitud combinada.
Luego usa el método .set(chunk, position) para copiar cada chunk uno tras otro en él.



Tenemos el resultado en chunksAll. Sin embargo, es una matriz de bytes, no un string.
Para crear un string, necesitamos interpretar estos bytes. El TextDecoder nativo hace exactamente eso. Luego podemos usar el resultado en JSON.parse, si es necesario.
¿Qué pasa si necesitamos contenido binario en lugar de un string? Eso es aún más sencillo. Reemplaza los pasos 4 y 5 con una sola línea que crea un Blob de todos los fragmentos:

      
        
        
          let blob = new Blob(chunks);
        
      
      
      

Al final tenemos el resultado (como un string o un blob, lo que sea conveniente) y el seguimiento del progreso en el proceso.
Una vez más, ten en cuenta que eso no es para el progreso de carga (hasta ahora eso no es posible con fetch), solo para el progreso de descarga.
Además, si el tamaño es desconocido, deberíamos chequear receivedLength en el bucle y cortarlo en cuanto alcance cierto límite, así los chunks no agotarán la memoria.
",
	"url": "https://es.javascript.info/fetch-progress" 
},
{
	"docs_id": "139",
	"name": "Fetch: Abort",
	"description": "Como sabemos fetch devuelve una promesa. Y generalmente JavaScript no tiene un concepto de “abortar” una promesa. Entonces, ¿cómo podemos abortar una llamada al método fetch? Por ejemplo si las acciones del usuario en nuestro sitio indican que fetch no se necesitará más.",
	"content": "Como sabemos fetch devuelve una promesa. Y generalmente JavaScript no tiene un concepto de “abortar” una promesa. Entonces, ¿cómo podemos abortar una llamada al método fetch? Por ejemplo si las acciones del usuario en nuestro sitio indican que fetch no se necesitará más.
Existe para esto de forma nativa un objeto especial: AbortController. Puede ser utilizado para abortar no solo fetch sino otras tareas asincrónicas también.
Su uso es muy sencillo:
El objeto AbortControllerCrear un controlador:

      
        
        
          let controller = new AbortController();
        
      
      
      Este controlador es un objeto extremadamente simple.

Tiene un único método abort(),
y una única propiedad signal que permite establecerle escuchadores de eventos.

Cuando abort() es invocado:

controller.signal emite el evento "abort".
La propiedad controller.signal.aborted toma el valor true.

Generalmente tenemos dos partes en el proceso:

El que ejecuta la operación de cancelación, genera un listener que escucha a controller.signal.
El que cancela: este llama a controller.abort() cuando es necesario.

Tal como se muestra a continuación (por ahora sin fetch):

      
        
        
          
            
          
          
            
          
        
        
          let controller = new AbortController();
let signal = controller.signal;

// La parte que ejecuta la operación de cancelación
// obtiene el objeto "signal"
// y genera un listener que se dispara cuando es llamado controller.abort()
signal.addEventListener('abort', () => alert("abort!"));

// El que cancela (más tarde en cualquier punto):
controller.abort(); // abort!

// El  evento se dispara y signal.aborted se vuelve true
alert(signal.aborted); // true
        
      
      
      Como podemos ver, AbortController es simplemente la via para pasar eventos abort cuando abort() es llamado sobre él.
Podríamos implementar alguna clase de escucha de evento en nuestro código por nuestra cuenta, sin el objeto AbortController en absoluto.
Pero lo valioso es que fetch sabe cómo trabajar con el objeto AbortController, está integrado con él.
Uso con fetchPara posibilitar la cancelación de fetch, pasa la propiedad signal de un AbortController como una opción de fetch:

      
        
        
          let controller = new AbortController();
fetch(url, {
  signal: controller.signal
});
        
      
      
      El método fetch conoce cómo trabajar con AbortController. Este escuchará eventos abort sobre signal.
Ahora, para abortar, llamamos controller.abort():

      
        
        
          controller.abort();
        
      
      
      Terminamos: fetch obtiene el evento desde signal y aborta el requerimiento.
Cuando un fetch es abortado, su promesa es rechazada con un error AbortError, así podemos manejarlo, por ejemplo en try..catch.
Aquí hay un ejemplo completo con fetch abortado después de 1 segundo:

      
        
        
          
            
          
          
            
          
        
        
          // Se abortara en un segundo
let controller = new AbortController();
setTimeout(() => controller.abort(), 1000);

try {
  let response = await fetch('/article/fetch-abort/demo/hang', {
    signal: controller.signal
  });
} catch(err) {
  if (err.name == 'AbortError') { // se maneja el abort()
    alert("Aborted!");
  } else {
    throw err;
  }
}
        
      
      
      AbortController es escalableAbortController es escalable, permite cancelar múltiples fetch de una vez.
Aquí hay un bosquejo de código que de muchos fetch de url en paralelo, y usa un simple controlador para abortarlos a todos:

      
        
        
          let urls = [...]; // una lista de urls para utilizar fetch en paralelo

let controller = new AbortController();

// un array de promesas fetch
let fetchJobs = urls.map(url => fetch(url, {
  signal: controller.signal
}));

let results = await Promise.all(fetchJobs);

// si controller.abort() es llamado,
// se abortaran todas las solicitudes fetch
        
      
      
      En el caso de tener nuestras propias tareas asincrónicas aparte de fetch, podemos utilizar un único AbortController para detenerlas junto con fetch.
Solo es necesario escuchar el evento abort en nuestras tareas:

      
        
        
          let urls = [...];
let controller = new AbortController();

let ourJob = new Promise((resolve, reject) => { // nuestra tarea
  ...
  controller.signal.addEventListener('abort', reject);
});

let fetchJobs = urls.map(url => fetch(url, { // varios fetch
  signal: controller.signal
}));

// Se espera por la finalización de los fetch y nuestra tarea
let results = await Promise.all([...fetchJobs, ourJob]);

// en caso de que se llame al método controller.abort() desde algún sitio,
// se abortan todos los fetch y nuestra tarea.
        
      
      
      Resumen
AbortController es un simple objeto que genera un evento abort sobre su propiedad signal cuando el método abort() es llamado (y también establece signal.aborted en true).
fetch está integrado con él: pasamos la propiedad signal como opción, y entonces fetch la escucha, así se vuelve posible abortar fetch.
Podemos usar AbortController en nuestro código. La interacción "llamar abort()" → "escuchar evento abort" es simple y universal. Podemos usarla incluso sin fetch.

",
	"url": "https://es.javascript.info/fetch-abort" 
},
{
	"docs_id": "140",
	"name": "Fetch: Cross-Origin Requests",
	"description": "Si enviamos una petición fetch hacia otro sitio seguramente fallará.",
	"content": "Si enviamos una petición fetch hacia otro sitio seguramente fallará.
Por ejemplo, probemos realizar una petición a http://example.com:

      
        
        
          
            
          
          
            
          
        
        
          try {
  await fetch('http://example.com');
} catch(err) {
  alert(err); // Failed to fetch
}
        
      
      
      El método fetch falla, tal como lo esperábamos.
El concepto clave aquí es el origen (origin), triple combinación de dominio/puerto/protocolo.
Las solicitudes de origen cruzado Cross-origin requests (aquellas que son enviadas hacia otro dominio --incluso subdominio–, protocolo o puerto), requieren de unas cabeceras especiales desde el sitio remoto.
Esta política es denominada “CORS”, por sus siglas en inglés Cross-Origin Resource Sharing.
¿Por que CORS es necesario?, Una breve historiaCORS existe para proteger Internet de los hackers malvados.
En verdad… Déjame contarte un breve resumen de esta historia.
Durante muchos años un script de un sitio no podía acceder al contenido de otro sitio.
Esta simple, pero poderosa regla, fue parte fundacional de la seguridad de Internet. Por ejemplo, un script malicioso desde el sitio hacker.com no podía acceder a la casilla de correo en el sitio gmail.com. La gente se podía sentir segura.
Así mismo en ese momento, JavaScript no tenía ningún método especial para realizar solicitudes de red. Simplemente era un lenguaje juguete para decorar páginas web.
Pero los desarrolladores web demandaron más poder. Una variedad de trucos fueron inventados para poder pasar por alto las limitaciones, y realizar solicitudes a otros sitios.
Utilizando formulariosUna forma de comunicarse con otros servidores es y era utilizando un <form>. Las personas lo utilizaban para enviar el resultado hacia un <iframe>, y de este modo mantenerse en el mismo sitio, de este modo:

      
        
        
          <!-- objetivo del form -->
<iframe name="iframe"></iframe>

<!-- Un formulario puede ser generado de forma dinámica y ser enviado por JavaScript -->
<form target="iframe" method="POST" action="http://another.com/…">
  ...
</form>
        
      
      
      Entonces, de este modo era posible realizar solicitudes GET/POST hacia otro sitio, incluso sin métodos de red, ya que los formularios pueden enviar mensajes a cualquier sitio. Pero ya que no es posible acceder al contenido de un <iframe> de otro sitio, esto evita que sea posible leer la respuesta.
Para ser precisos, en realidad había trucos para eso, requerían scripts especiales tanto en el iframe como en la página. Entonces la comunicación con el iframe era técnicamente posible. Pero ya no hay necesidad de entrar en detalles, dejemos a los dinosaurios descansar en paz.
Utilizando scriptsOtro truco es en el modo de utilizar la etiqueta script. Un script puede tener cualquier origen src, con cualquier dominio, tal como <script src="http://another.com/…">. De este modo es posible ejecutar un script de cualquier sitio web.
Si un sitio, por ejemplo, another.com requiere exponer datos con este tipo de acceso, se utilizaba el protocolo llamado en ese entonces “JSONP (JSON con padding)” .
Veamos como se utilizaba.
Digamos que, en nuestro sitio es necesario obtener datos de http://another.com, como podría ser el pronóstico del tiempo:


Primero, adelantándonos, creamos una función global para aceptar los datos, por ejemplo: gotWeather.

      
        
        
          // 1. Se declara la función para procesar los datos del tiempo
function gotWeather({ temperature, humidity }) {
  alert(`temperature: ${temperature}, humidity: ${humidity}`);
}
        
      
      
      

Entonces creamos una etiqueta <script> donde src="http://another.com/weather.json?callback=gotWeather", utilizando el nombre de nuestra función como un parámetro callback, dentro de la URL.

      
        
        
          let script = document.createElement('script');
script.src = `http://another.com/weather.json?callback=gotWeather`;
document.body.append(script);
        
      
      
      

El servidor remoto another.com de forma dinámica genera un script que invoca el método gotWeather(...) con los datos que nosotros necesitamos recibir.

      
        
        
          // The expected answer from the server looks like this:
gotWeather({
  temperature: 25,
  humidity: 78
});
        
      
      
      

Entonces el script remoto carga y es ejecutado, la función gotWeather se invoca, y ya que es nuestra función, obtenemos los datos.


Esto funciona, y no viola la seguridad, ya que ambos sitios acuerdan en intercambiar los datos de este modo. Y cuando ambos lados concuerdan, definitivamente no se trata de un hackeo. Aún hay servicios que proveen este tipo de acceso, lo que puede ser útil ya que funciona en navegadores obsoletos.
Tiempo después aparecieron métodos de red en los navegadores para JavaScript.
Al comienzo, las solicitudes de origen cruzado fueron prohibidas, pero luego de prolongadas discusiones se permitieron, requiriendo consentimiento explicito por parte del servidor, esto expresado en cabezales especiales.
Solicitudes segurasExisten dos tipos de solicitudes de origen cruzado:

Solicitudes seguras.
Todas las demás.

Las solicitudes seguras son más fáciles de hacer, comencemos con ellas.
Una solicitud es segura si cumple dos condiciones:

método seguro: GET, POST o HEAD
Cabeceras seguras – Las únicas cabeceras permitidas son:

Accept,
Accept-Language,
Content-Language,
Content-Type con el valor application/x-www-form-urlencoded, multipart/form-data o text/plain.



Cualquier otra solicitud es considerada “insegura”. Por lo tanto, una solicitud con el método PUT o con una cabecera HTTP API-Key no cumple con las limitaciones.
La diferencia esencial es que una solicitud segura puede ser realizada mediante un <form> o un <script>, sin la necesidad de utilizar un método especial.
Por lo tanto, incluso un servidor obsoleto debería ser capaz de aceptar una solicitud segura.
Contrario a esto, las solicitudes con cabeceras no estándar o métodos como el DELETE no pueden ser creados de este modo. Durante mucho tiempo no fue posible para JavaScript realizar este tipo de solicitudes. Por lo que un viejo servidor podía asumir que ese tipo de solicitudes provenía desde una fuente privilegiada, “ya que una página web es incapaz de enviarlas”.
Cuando intentamos realizar una solicitud insegura, el navegador envía una solicitud especial de “pre-vuelo” consultando al servidor: ¿está de acuerdo en aceptar tal solicitud de origen cruzado o no?
Y, salvo que el servidor lo confirme de forma explícita, cualquier solicitud insegura no es enviada.
Vayamos ahora a los detalles.
CORS para solicitudes segurasSi una solicitud es de origen cruzado, el navegador siempre le agregará una cabecera Origin.
Por ejemplo, si realizamos una solicitud de https://anywhere.com/request a https://javascript.info/page, las cabeceras podrían ser algo así:

      
        
        
          GET /request
Host: anywhere.com
Origin: https://javascript.info
...
        
      
      
      Tal como se puede ver, la cabecera Origin contiene exactamente el origen (protocolo/dominio/puerto), sin el path.
El servidor puede inspeccionar el origen Origin y, si esta de acuerdo en aceptar ese tipo de solicitudes, agrega una cabecera especial Access-Control-Allow-Origin a la respuesta. Esta cabecera debe contener el origen permitido (en nuestro caso https://javascript.info), o un asterisco *. En ese caso la respuesta es satisfactoria, de otro modo falla.
El navegador cumple el papel de mediador de confianza:

Ante una solicitud de origen cruzado, se asegura de que se envíe el origen correcto.
Chequea que la respuesta contenga la cabecera Access-Control-Allow-Origin, de ser así JavaScript tiene permitido acceder a la respuesta, de no ser así la solicitud falla con un error.


      
      
        
      
      Aquí tenemos un ejemplo de una respuesta permisiva desde el servidor:

      
        
        
          200 OK
Content-Type:text/html; charset=UTF-8
Access-Control-Allow-Origin: https://javascript.info
        
      
      
      Cabeceras de respuestaPara las respuestas de origen cruzado, por defecto JavaScript sólo puede acceder a las cabeceras llamadas “seguras”:

Cache-Control
Content-Language
Content-Type
Expires
Last-Modified
Pragma

El acceso a otro tipo de cabeceras de la respuesta generará un error.

            Por favor tome nota:
            Como se puede ver, ¡no está la cabecera Content-Length en la lista!
Esta cabecera contiene el tamaño total de la respuesta. Por lo que si queremos mostrar el progreso de la descarga, en ese caso necesitaremos un permiso adicional para acceder a ese campo de la cabecera.

Para permitirle a JavaScript acceso a otros tipos de cabeceras, el servidor debe incluir la cabecera Access-Control-Expose-Headers. Este campo contiene una lista separada por comas de las cabeceras inseguras que podrán ser accesibles.
Por ejemplo:

      
        
        
          200 OK
Content-Type:text/html; charset=UTF-8
Content-Length: 12345
API-Key: 2c9de507f2c54aa1
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Expose-Headers: Content-Length,API-Key
        
      
      
      Con este valor de Access-Control-Expose-Headers, el script tendrá permitido acceder a los valores de las cabeceras Content-Length y API-Key de la respuesta.
Solicitudes “inseguras”Podemos utilizar cualquier método HTTP: no únicamente GET/POST, sino también PATCH, DELETE y otros.
Hace algún tiempo nadie podía siquiera imaginar que un sitio web pudiera realizar ese tipo de solicitudes. Por lo que aún existen servicios web que cuando reciben un método no estándar los consideran como una señal de que: “Del otro lado no hay un navegador”. Ellos pueden tener en cuenta esto cuando revisan los derechos de acceso.
Por lo tanto, para evitar malentendidos, cualquier solicitud “insegura” (Estas que no podían ser realizadas en los viejos tiempos), no será realizada por el navegador en forma directa. Antes, enviará una solicitud preliminar llamada solicitud de “pre-vuelo”, solicitando que se le concedan los permisos.
Una solicitud de “pre-vuelo” utiliza el método OPTIONS, sin contenido en el cuerpo y con tres cabeceras:

Access-Control-Request-Method, cabecera que contiene el método de la solicitud “insegura”.
Access-Control-Request-Headers provee una lista separada por comas de las cabeceras inseguras de la solicitud.
Origin cabecera que informa de dónde viene la solicitud. (como https://javascript.info)

Si el servidor está de acuerdo con lo solicitado, entonces responderá con el código de estado 200 y un cuerpo vacío:

Access-Control-Allow-Origin debe ser * o el origen de la solicitud, tal como https://javascript.info, para permitir el acceso.
Access-Control-Allow-Methods contiene el método permitido.
Access-Control-Allow-Headers contiene un listado de las cabeceras permitidas.
Además, la cabecera Access-Control-Max-Age puede especificar el número máximo de segundos que puede recordar los permisos. Por lo que el navegador no necesita volver a requerirlos en las próximas solicitudes.


      
      
        
      
      Vamos a ver cómo funciona paso a paso, mediante un ejemplo para una solicitud de origen cruzado PATCH (este método suele utilizarse para actualizar datos):

      
        
        
          let response = await fetch('https://site.com/service.json', {
  method: 'PATCH',
  headers: {
    'Content-Type': 'application/json',
    'API-Key': 'secret'
  }
});
        
      
      
      Hay tres motivos por los cuales esta solicitud no es segura (una es suficiente):

Método PATCH
Content-Type no es del tipo: application/x-www-form-urlencoded, multipart/form-data, text/plain.
Cabecera API-Key “insegura”.

Paso 1 (solicitud de pre-vuelo)Antes de enviar una solicitud de este tipo, el navegador envía una solicitud de pre-vuelo que se ve de este modo:

      
        
        
          OPTIONS /service.json
Host: site.com
Origin: https://javascript.info
Access-Control-Request-Method: PATCH
Access-Control-Request-Headers: Content-Type,API-Key
        
      
      
      
Método: OPTIONS.
El path – exactamente el mismo que el de la solicitud principal: /service.json.
Cabeceras especiales de origen cruzado (Cross-origin):

Origin – el origen de la fuente.
Access-Control-Request-Method – método solicitado.
Access-Control-Request-Headers – listado separado por comas de las cabeceras “inseguras”.



Paso 2 (solicitud de pre-vuelo)El servidor debe responder con el código de estado 200 y las cabeceras:

Access-Control-Allow-Origin: https://javascript.info
Access-Control-Allow-Methods: PATCH
Access-Control-Allow-Headers: Content-Type,API-Key.

Esto permitirá la comunicación futura, de otro modo se disparará un error.
Si el servidor espera otro método y cabeceras en el futuro, tiene sentido permitirlos por adelantado agregándolos a la lista.
Por ejemplo, esta respuesta habilita además los métodos PUT, DELETE y otras cabeceras:

      
        
        
          200 OK
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Allow-Methods: PUT,PATCH,DELETE
Access-Control-Allow-Headers: API-Key,Content-Type,If-Modified-Since,Cache-Control
Access-Control-Max-Age: 86400
        
      
      
      Ahora el navegador puede ver que PATCH se encuentra dentro de la cabecera Access-Control-Allow-Methods y Content-Type,API-Key dentro de la lista Access-Control-Allow-Headers, por lo que permitirá enviar la solicitud principal.
Si se encuentra con una cabecera Access-Control-Max-Age con determinada cantidad de segundos, entonces los permisos son almacenados en el caché por ese determinado tiempo. La solicitud anterior será cacheada por 86400 segundos (un día). Durante ese marco de tiempo, las solicitudes siguientes no requerirán la solicitud de pre-vuelo. Asumiendo que están dentro de lo permitido en la respuesta cacheada, serán enviadas de forma directa.
Paso 3 (solicitud real)Una vez el pre-vuelo se realiza de forma satisfactoria, el navegador realiza la solicitud principal. El algoritmo aquí es el mismo que el utilizado para una solicitud segura.
La solicitud principal tiene la cabecera Origin (ya que se trata de una solicitud de origen cruzado):

      
        
        
          PATCH /service.json
Host: site.com
Content-Type: application/json
API-Key: secret
Origin: https://javascript.info
        
      
      
      Paso 4 (respuesta real)El server no debe olvidar agregar la cabecera Access-Control-Allow-Origin a la respuesta principal. Un pre-vuelo exitoso no lo libera de esto:

      
        
        
          Access-Control-Allow-Origin: https://javascript.info
        
      
      
      Entonces JavaScript es capaz de leer la respuesta principal del servidor.

            Por favor tome nota:
            La solicitud de pre-vuelo ocurre “detrás de escena”, es invisible a JavaScript.
JavaScript únicamente obtiene la respuesta a la solicitud principal o un error en caso de que el servidor no otorgue la autorización.

CredencialesUna solicitud de origen cruzado realizada por código JavaScript, por defecto no provee ningún tipo de credenciales (cookies o autenticación HTTP).
Esto es poco común para solicitudes HTTP. Usualmente una solicitud a un sitio http://site.com es acompañada por todas las cookies de ese dominio. Pero una solicitud de origen cruzado realizada por métodos de JavaScript son una excepción.
Por ejemplo, fetch('http://another.com') no enviará ninguna cookie, ni siquiera (!) esas que pertenecen al dominio another.com.
¿Por qué?
El motivo de esto es que una solicitud con credenciales es mucho más poderosa que sin ellas. Si se permitiera, esto garantizaría a JavaScript el completo poder de actuar en representación del usuario y de acceder a información sensible utilizando sus credenciales.
¿En verdad el servidor confía lo suficiente en el script? En ese caso el servidor debera enviar explicitamente que permite solicitudes con credenciales mediante otra cabecera especial.
Para permitir el envío de credenciales en fetch, necesitamos agregar la opción credentials: "include", de este modo:

      
        
        
          fetch('http://another.com', {
  credentials: "include"
});
        
      
      
      Ahora fetch envía cookies originadas desde another.com con las solicitudes a ese sitio.
Si el servidor está de acuerdo en aceptar solicitudes con credenciales, debe agregar la cabecera Access-Control-Allow-Credentials: true a la respuesta, además de Access-Control-Allow-Origin.
Por ejemplo:

      
        
        
          200 OK
Access-Control-Allow-Origin: https://javascript.info
Access-Control-Allow-Credentials: true
        
      
      
      Cabe destacar que: Access-Control-Allow-Origin no se puede utilizar con un asterisco * para solicitudes con credenciales. Tal como se muestra a arriba debe proveer el origen exacto. Esto es una medida adicional de seguridad, para asegurar de que el servidor conozca exactamente en quién confiar para que le envíe este tipo de solicitudes.
ResumenDesde el punto de vista del navegador, existen dos tipos de solicitudes de origen cruzado: solicitudes “seguras” y todas las demás.
Solicitudes seguras deben cumplir las siguientes condiciones:

Método: GET, POST o HEAD.
Cabeceras – solo podemos establecer:

Accept
Accept-Language
Content-Language
Content-Type con el valor application/x-www-form-urlencoded, multipart/form-data o text/plain.



La diferencia esencial es que las solicitudes seguras eran posibles desde los viejos tiempos utilizando las etiquetas <form> o <script>, mientras que las solicitudes “inseguras” fueron imposibles para el navegador durante mucho tiempo.
Por lo tanto, en la práctica, la diferencia se encuentra en que las solicitudes seguras son realizadas de forma directa, utilizando la cabecera Origin, mientras que para las otras el navegador realiza una solicitud extra de “pre-vuelo” para requerir la autorización.
Para una solicitud segura:

→ El navegador envía una cabecera Origin con el origen.
← Para solicitudes sin credenciales (no enviadas por defecto), el servidor debe establecer:

Access-Control-Allow-Origin como * o el mismo valor que en Origin.


← Para solicitudes con credenciales, el servidor deberá establecer:

Access-Control-Allow-Origin con el mismo valor que en Origin.
Access-Control-Allow-Credentials en true



Adicionalmente, para garantizar a JavaScript acceso a cualquier cabecera de la respuesta, con excepción de Cache-Control, Content-Language, Content-Type, Expires, Last-Modified o Pragma, el servidor debe agregarlas como permitidas en la lista de la cabecera Access-Control-Expose-Headers.
Para solicitudes inseguras, se utiliza una solicitud preliminar “pre-vuelo”  antes de la solicitud principal:

→ El navegador envía una solicitud del tipo OPTIONS a la misma URL, con las cabeceras:

Access-Control-Request-Method con el método requerido.
Access-Control-Request-Headers listado de las cabeceras inseguras.


← El servidor debe responder con el código de estado 200 y las cabeceras:

Access-Control-Allow-Methods con la lista de todos los métodos permitidos,
Access-Control-Allow-Headers con una lista de cabeceras permitidas,
Access-Control-Max-Age con los segundos en los que se podrá almacenar la autorización en caché.


Tras lo cual la solicitud es enviada, y se aplica el esquema previo “seguro”.

Tareas¿Por que necesitamos el origen (Origin)?importancia: 5Como seguramente ya sepas, existe la cabecera HTTP Referer, la cual por lo general contiene la url del sitio que generó la solicitud.
Por ejemplo, cuando solicitamos la url http://google.com desde http://javascript.info/alguna/url, las cabeceras se ven de este modo:

      
        
        
          Accept: */*
Accept-Charset: utf-8
Accept-Encoding: gzip,deflate,sdch
Connection: keep-alive
Host: google.com
Origin: http://javascript.info
Referer: http://javascript.info/alguna/url
        
      
      
      Tal como se puede ver, tanto Referer como Origin están presentes.
Las preguntas:

¿Por qué la cabecera Origin es necesaria, si Referer contiene incluso más información?
¿Es posible que no se incluya Referer u Origin, o que contengan datos incorrectos?

soluciónNecesitamos la cabecera Origin, ya que en algunos casos Referer no está presente. Por ejemplo, cuando realizamos un fetch a una página HTTP desde una HTTPS (acceder a un sitio menos seguro desde uno más seguro), en ese caso no tendremos el campo Referer.
La Política de seguridad de contenido puede prohibir el envío de Referer.
Como veremos, fetch tiene opciones con las que es posible evitar el envío de Referer e incluso permite su modificación (dentro del mismo sitio).
Por especificación, Referer es una cabecera HTTP opcional.
Por el hecho de que Referer no es confiable, la cabecera Origin ha sido creada. El navegador garantiza el envío correcto de Origin para las solicitudes de origen cruzado.
",
	"url": "https://es.javascript.info/fetch-crossorigin" 
},
{
	"docs_id": "141",
	"name": "Fetch API",
	"description": "Hasta ahora, sabemos bastante sobre fetch.",
	"content": "Hasta ahora, sabemos bastante sobre fetch.
Veamos el resto de API, para cubrir todas sus capacidades.

            Por favor tome nota:
            Ten en cuenta: la mayoría de estas opciones se utilizan con poca frecuencia. Puedes saltarte este capítulo y seguir utilizando bien fetch.
Aún así, es bueno saber lo que puede hacer fetch, por lo que si surge la necesidad, puedes regresar y leer los detalles.

Aquí está la lista completa de todas las posibles opciones de fetch con sus valores predeterminados (alternativas en los comentarios):

      
        
        
          let promise = fetch(url, {
  method: "GET", // POST, PUT, DELETE, etc.
  headers: {
    // el valor del encabezado Content-Type generalmente se establece automáticamente
    // dependiendo del cuerpo de la solicitud
    "Content-Type": "text/plain;charset=UTF-8"
  },
  body: undefined // string, FormData, Blob, BufferSource, o URLSearchParams
  referrer: "about:client", // o "" para no enviar encabezado de Referer,
  // o una URL del origen actual
  referrerPolicy: "no-referrer-when-downgrade", // no-referrer, origin, same-origin...
  mode: "cors", // same-origin, no-cors
  credentials: "same-origin", // omit, include
  cache: "default", // no-store, reload, no-cache, force-cache, o only-if-cached
  redirect: "follow", // manual, error
  integrity: "", // un hash, como "sha256-abcdef1234567890"
  keepalive: false, // true
  signal: undefined, // AbortController para cancelar la solicitud
  window: window // null
});
        
      
      
      Una lista impresionante, ¿verdad?
Cubrimos completamente method, headers y body en el capítulo Fetch.
La opción signal está cubierta en Fetch: Abort.
Ahora exploremos el resto de capacidades.
referrer, referrerPolicyEstas opciones gobiernan cómo fetch establece el encabezado HTTP Referer.
Por lo general, ese encabezado se establece automáticamente y contiene la URL de la página que realizó la solicitud. En la mayoría de los escenarios, no es importante en absoluto, a veces, por motivos de seguridad, tiene sentido eliminarlo o acortarlo.
La opción referrer permite establecer cualquier Referer (dentro del origen actual) o eliminarlo.
Para no enviar ningún referer, establece un string vacío:

      
        
        
          fetch('/page', {
  referrer: "" // sin encabezado Referer
});
        
      
      
      Para establecer otra URL dentro del origen actual:

      
        
        
          fetch('/page', {
  // asumiendo que estamos en https://javascript.info
  // podemos establecer cualquier encabezado Referer, pero solo dentro del origen actual
  referrer: "https://javascript.info/anotherpage"
});
        
      
      
      La opción referrerPolicy establece reglas generales para Referer.
Las solicitudes se dividen en 3 tipos:

Solicitud al mismo origen.
Solicitud a otro origen.
Solicitud de HTTPS a HTTP (de protocolo seguro a no seguro).

A diferencia de la opción referrer que permite establecer el valor exacto de Referer, referrerPolicy indica al navegador las reglas generales para cada tipo de solicitud.
Los valores posibles se describen en la Especificación de la política Referrer:

"no-referrer-when-downgrade" – el valor predeterminado: el Referer completo se envía siempre, a menos que enviemos una solicitud de HTTPS a HTTP (a un protocolo menos seguro).
"no-referrer" – nunca envía Referer.
"origin" – solo envía el origen en Referer, no la URL de la página completa. Por ejemplo, solo http://site.com en lugar de http://site.com/path.
"origin-when-cross-origin" – envía el Referrer completo al mismo origen, pero solo la parte de origen para solicitudes cross-origin (como se indica arriba).
"same-origin" – envía un Referer completo al mismo origen, pero no un Referer para solicitudes cross-origin.
"strict-origin" – envía solo el origen, no envía Referer para solicitudes HTTPS→HTTP.
"strict-origin-when-cross-origin" – para el mismo origen, envía el Referer completo. Para el envío cross-origin envía solo el origen, a menos que sea una solicitud HTTPS→HTTP, entonces no envía nada.
"unsafe-url" – envía siempre la URL completa en Referer, incluso para solicitudes HTTPS→HTTP.

Aquí hay una tabla con todas las combinaciones:



Valor
Al mismo origen
A otro origen
HTTPS→HTTP




"no-referrer"
-
-
-


"no-referrer-when-downgrade" o "" (predeterminado)
completo
completo
-


"origin"
origen
origen
origen


"origin-when-cross-origin"
completo
origen
origen


"same-origin"
completo
-
-


"strict-origin"
origen
origen
-


"strict-origin-when-cross-origin"
completo
origen
-


"unsafe-url"
completo
completo
completo



Digamos que tenemos una zona de administración con una estructura de URL que no debería conocerse desde fuera del sitio.
Si enviamos un fetch, entonces de forma predeterminada siempre envía el encabezado Referer con la URL completa de nuestra página (excepto cuando solicitamos de HTTPS a HTTP, entonces no hay Referer).
Por ejemplo, Referer: https://javascript.info/admin/secret/paths.
Si queremos que otros sitios web solo conozcan la parte del origen, no la ruta de la URL, podemos configurar la opción:

      
        
        
          fetch('https://another.com/page', {
  // ...
  referrerPolicy: "origin-when-cross-origin" // Referer: https://javascript.info
});
        
      
      
      Podemos ponerlo en todas las llamadas fetch, tal vez integrarlo en la biblioteca JavaScript de nuestro proyecto que hace todas las solicitudes y que usa fetch por dentro.
Su única diferencia en comparación con el comportamiento predeterminado es que para las solicitudes a otro origen, fetch envía solo la parte de origen de la URL (por ejemplo, https://javascript.info, sin ruta). Para las solicitudes a nuestro origen, todavía obtenemos el Referer completo (quizás útil para fines de depuración).

            La política Referrer no es solo para fetch
            La política Referrer, descrita en la especificación, no es solo para fetch, sino más global.
En particular, es posible establecer la política predeterminada para toda la página utilizando el encabezado HTTP Referrer-Policy, o por enlace, con <a rel="noreferrer">.

modeLa opción mode es una protección que evita solicitudes cross-origin ocasionales:

"cors" – por defecto, se permiten las solicitudes cross-origin predeterminadas, como se describe en Fetch: Cross-Origin Requests,
"same-origin" – las solicitudes cross-origin están prohibidas,
"no-cors" – solo se permiten solicitudes cross-origin seguras.

Esta opción puede ser útil cuando la URL de fetch proviene de un tercero y queremos un “interruptor de apagado” para limitar las capacidades cross-origin.
credentialsLa opción credentials especifica si fetch debe enviar cookies y encabezados de autorización HTTP con la solicitud.

"same-origin" – el valor predeterminado, no enviar solicitudes cross-origin,
"include" – enviar siempre, requiere Access-Control-Allow-Credentials del servidor cross-origin para que JavaScript acceda a la respuesta, que se cubrió en el capítulo Fetch: Cross-Origin Requests,
"omit" – nunca enviar, incluso para solicitudes del mismo origen.

cacheDe forma predeterminada, las solicitudes fetch utilizan el almacenamiento en caché HTTP estándar. Es decir, respeta los encabezados Expires, Cache-Control, envía If-Modified-Since, y así sucesivamente. Al igual que lo hacen las solicitudes HTTP habituales.
Las opciones de cache permiten ignorar el caché HTTP o ajustar su uso:

"default" – fetch utiliza reglas y encabezados de caché HTTP estándar,
"no-store" – ignoramos por completo el caché HTTP, este modo se convierte en el predeterminado si configuramos un encabezado If-Modified-Since, If-None-Match, If-Unmodified-Since, If-Match o If-Range,
"reload" – no toma el resultado del caché HTTP (si corresponde), pero completa el caché con la respuesta (si los encabezados de respuesta lo permiten),
"no-cache" – crea una solicitud condicional si hay una respuesta en caché y una solicitud normal en caso contrario. Llena el caché HTTP con la respuesta,
"force-cache" – usa una respuesta del caché HTTP, incluso si está obsoleta. Si no hay respuesta en el caché HTTP, hace una solicitud HTTP regular, se comporta normalmente,
"only-if-cached" – usa una respuesta del caché HTTP, incluso si está obsoleta. Si no hay respuesta en el caché HTTP, entonces envía un error. Solo funciona cuando mode es "same-origin".

redirectNormalmente, fetch sigue de forma transparente las redirecciones HTTP, como 301, 302, etc.
La opción redirect permite cambiar eso:

"follow" – el predeterminado, sigue las redirecciones HTTP,
"error" – error en caso de redireccionamiento HTTP,
"manual" – permite procesar redireccionamiento HTTP manualmente. En caso de redireccionamiento obtendremos un objeto response especial, con response.type="opaqueredirect" y cero o vacío en la mayor parte de las demás propiedades.

integrityLa opción integrity permite comprobar si la respuesta coincide con el known-ahead checksum.
Como se describe en la especificación, las funciones hash admitidas son SHA-256, SHA-384 y SHA-512. Puede haber otras dependiendo de un navegador.
Por ejemplo, estamos descargando un archivo y sabemos que su checksum SHA-256 es “abcdef” (un checksum real es más largo, por supuesto).
Lo podemos poner en la opción integrity, así:

      
        
        
          fetch('http://site.com/file', {
  integrity: 'sha256-abcdef'
});
        
      
      
      Luego, fetch calculará SHA-256 por sí solo y lo comparará con nuestro string. En caso de discrepancia, se activa un error.
keepaliveLa opción keepalive indica que la solicitud puede “vivir más allá” de la página web que la inició.
Por ejemplo, recopilamos estadísticas sobre cómo el visitante actual usa nuestra página (clics del mouse, fragmentos de página que ve), para analizar y mejorar la experiencia del usuario.
Cuando el visitante abandona nuestra página, nos gustaría guardar los datos en nuestro servidor.
Podemos usar el evento window.onunload para eso:

      
        
        
          
            
          
          
            
          
        
        
          window.onunload = function() {
  fetch('/analytics', {
    method: 'POST',
    body: "statistics",
    keepalive: true
  });
};
        
      
      
      Normalmente, cuando se descarga un documento, se cancelan todas las solicitudes de red asociadas. Pero la opción keepalive le dice al navegador que realice la solicitud en segundo plano, incluso después de salir de la página. Por tanto, esta opción es fundamental para que nuestra solicitud tenga éxito.
Tiene algunas limitaciones:

No podemos enviar megabytes: el límite de cuerpo para las solicitudes keepalive es de 64 KB.

Si necesitamos recopilar muchas estadísticas sobre la visita, deberíamos enviarlas regularmente en paquetes, de modo que no quede mucho para la última solicitud onunload.
Este límite se aplica a todas las solicitudes keepalive juntas. En otras palabras, podemos realizar múltiples solicitudes keepalive en paralelo, pero la suma de las longitudes de sus cuerpos no debe exceder los 64 KB.


No podemos manejar la respuesta del servidor si el documento no está cargado. Entonces, en nuestro ejemplo, fetch tendrá éxito debido a keepalive, pero las funciones posteriores no funcionarán.

En la mayoría de los casos, como enviar estadísticas, no es un problema, ya que el servidor simplemente acepta los datos y generalmente envía una respuesta vacía a tales solicitudes.



",
	"url": "https://es.javascript.info/fetch-api" 
},
{
	"docs_id": "142",
	"name": "Objetos URL",
	"description": "La clase URL incorporada brinda una interfaz conveniente para crear y analizar URLs.",
	"content": "La clase URL incorporada brinda una interfaz conveniente para crear y analizar URLs.
No hay métodos de networking que requieran exactamente un objeto URL, los strings son suficientemente buenos para eso. Así que técnicamente no tenemos que usar URL. Pero a veces puede ser realmente útil.
Creando una URLLa sintaxis para crear un nuevo objeto URL es:

      
        
        
          new URL(url, [base])
        
      
      
      
url – La URL completa o ruta única (si se establece base, mira a continuación),
base – una URL base opcional: si se establece y el argumento url solo tiene una ruta, entonces la URL se genera relativa a base.

Por ejemplo:

      
        
        
          let url = new URL('https://javascript.info/profile/admin');
        
      
      
      Estas dos URLs son las mismas:

      
        
        
          
            
          
          
            
          
        
        
          let url1 = new URL('https://javascript.info/profile/admin');
let url2 = new URL('/profile/admin', 'https://javascript.info');

alert(url1); // https://javascript.info/profile/admin
alert(url2); // https://javascript.info/profile/admin
        
      
      
      Fácilmente podemos crear una nueva URL basada en la ruta relativa a una URL existente:

      
        
        
          
            
          
          
            
          
        
        
          let url = new URL('https://javascript.info/profile/admin');
let newUrl = new URL('tester', url);

alert(newUrl); // https://javascript.info/profile/tester
        
      
      
      El objeto URL inmediatamente nos permite acceder a sus componentes, por lo que es una buena manera de analizar la url, por ej.:

      
        
        
          
            
          
          
            
          
        
        
          let url = new URL('https://javascript.info/url');

alert(url.protocol); // https:
alert(url.host);     // javascript.info
alert(url.pathname); // /url
        
      
      
      Aquí está la hoja de trucos para los componentes URL:

      
      
        
      
      
href es la url completa, igual que url.toString()
protocol acaba con el carácter dos puntos :
search – un string de parámetros, comienza con el signo de interrogación ?
hash comienza con el carácter de hash #
También puede haber propiedades user y password si la autenticación HTTP esta presente: http://login:password@site.com (no mostrados arriba, raramente usados)


            Podemos pasar objetos URL a métodos de red (y la mayoría de los demás) en lugar de un string
            Podemos usar un objeto URL en fetch o XMLHttpRequest, casi en todas partes donde se espera un URL-string.
Generalmente, un objeto URL puede pasarse a cualquier método en lugar de un string, ya que la mayoría de métodos llevarán a cabo la conversión del string, eso convierte un objeto URL en un string con URL completa.

Parámetros de búsqueda “?…”Digamos que queremos crear una url con determinados parámetros de búsqueda, por ejemplo, https://google.com/search?query=JavaScript.
Podemos proporcionarlos en el string URL:

      
        
        
          new URL('https://google.com/search?query=JavaScript')
        
      
      
      …Pero los parámetros necesitan estar codificados si contienen espacios, letras no latinas, entre otros (Más sobre eso debajo).
Por lo que existe una propiedad URL para eso: url.searchParams, un objeto de tipo URLSearchParams.
Esta proporciona métodos convenientes para los parámetros de búsqueda:

append(name, value) – añade el parámetro por name,
delete(name) – elimina el parámetro por name,
get(name) – obtiene el parámetro por name,
getAll(name) – obtiene todos los parámetros con el mismo name (Eso es posible, por ej. ?user=John&user=Pete),
has(name) – comprueba la existencia del parámetro por name,
set(name, value) – establece/reemplaza el parámetro,
sort() – ordena parámetros por name, raramente necesitado,
…y además es iterable, similar a Map.

Un ejemplo con parámetros que contienen espacios y signos de puntuación:

      
        
        
          
            
          
          
            
          
        
        
          let url = new URL('https://google.com/search');

url.searchParams.set('q', 'test me!'); // Parámetro añadido con un espacio y !

alert(url); // https://google.com/search?q=test+me%21

url.searchParams.set('tbs', 'qdr:y'); // Parámetro añadido con dos puntos :

// Los parámetros son automáticamente codificados
alert(url); // https://google.com/search?q=test+me%21&tbs=qdr%3Ay

// Iterar sobre los parametros de búsqueda (Decodificados)
for(let [name, value] of url.searchParams) {
  alert(`${name}=${value}`); // q=test me!, then tbs=qdr:y
}
        
      
      
      CodificaciónExiste un estándar RFC3986 que define cuales caracteres son permitidos en URLs y cuales no.
Esos que no son permitidos, deben ser codificados, por ejemplo letras no latinas y espacios – reemplazados con sus códigos UTF-8, con el prefijo %, tal como %20 (un espacio puede ser codificado con +, por razones históricas, pero esa es una excepción).
La buena noticia es que los objetos URL manejan todo eso automáticamente. Nosotros sólo proporcionamos todos los parámetros sin codificar, y luego convertimos la URL a string:

      
        
        
          
            
          
          
            
          
        
        
          // Usando algunos caracteres cirílicos para este ejemplo

let url = new URL('https://ru.wikipedia.org/wiki/Тест');

url.searchParams.set('key', 'ъ');
alert(url); //https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82?key=%D1%8A
        
      
      
      Como puedes ver, ambos Тест en la ruta url y ъ en el parámetro están codificados.
La URL se alarga, ya que cada letra cirílica es representada con dos bytes en UTF-8, por lo que hay dos entidades %...
Codificando stringsEn los viejos tiempos, antes de que los objetos URL aparecieran, la gente usaba strings para las URL.
A partir de ahora, los objetos URL son frecuentemente más convenientes, pero también aún pueden usarse los strings. En muchos casos usando un string se acorta el código.
Aunque si usamos un string, necesitamos codificar/decodificar caracteres especiales manualmente.
Existen funciones incorporadas para eso:

encodeURI – Codifica la URL como un todo.
decodeURI – La decodifica de vuelta.
encodeURIComponent – Codifica un componente URL, como un parametro de busqueda, un hash, o un pathname.
decodeURIComponent – La decodifica de vuelta.

Una pregunta natural es: "¿Cuál es la diferencia entre encodeURIComponent y encodeURI?¿Cuándo deberíamos usar una u otra?
Eso es fácil de entender si miramos a la URL, que está separada en componentes en la imagen de arriba:

      
        
        
          https://site.com:8080/path/page?p1=v1&p2=v2#hash
        
      
      
      Como podemos ver, caracteres tales como :, ?, =, &, # son admitidos en URL.
…Por otra parte, si miramos a un único componente URL, como un parámetro de búsqueda, estos caracteres deben estar codificados, para no romper el formateo.

encodeURI Codifica solo caracteres que están totalmente prohibidos en URL
encodeURIComponent Codifica los mismos caracteres, y, en adición a ellos, los caracteres #, $, &, +, ,, /, :, ;, =, ? y @.

Entonces, para una URL completa podemos usar encodeURI:

      
        
        
          
            
          
          
            
          
        
        
          // Usando caracteres cirílicos en el path URL
let url = encodeURI('http://site.com/привет');

alert(url); // http://site.com/%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82
        
      
      
      …Mientras que para parámetros URL deberíamos usar encodeURIComponent en su lugar:

      
        
        
          
            
          
          
            
          
        
        
          let music = encodeURIComponent('Rock&Roll');

let url = `https://google.com/search?q=${music}`;
alert(url); // https://google.com/search?q=Rock%26Roll
        
      
      
      Compáralo con encodeURI:

      
        
        
          
            
          
          
            
          
        
        
          let music = encodeURI('Rock&Roll');

let url = `https://google.com/search?q=${music}`;
alert(url); // https://google.com/search?q=Rock&Roll
        
      
      
      Como podemos ver, encodeURI no codifica &, ya que este es un carácter legítimo en la URL como un todo.
Pero debemos codificar & dentro de un parámetro de búsqueda, de otra manera, obtendremos q=Rock&Roll- que es realmente q=Rock más algún parámetro Roll oscuro. No según lo previsto.
Así que debemos usar solo encodeURIComponentpara cada parámetro de búsqueda, para insertarlo correctamente en el string URL. Lo más seguro es codificar tanto nombre como valor, a menos que estemos absolutamente seguros de que solo haya admitido caracteres

            Diferencia de codificación comparado con URL
            Las clases URL y URLSearchParams están basadas en la especificación URI mas reciente: RFC3986, mientras que las funciones encode* están basadas en la versión obsoleta RFC2396.
Existen algunas diferencias, por ej. las direcciones IPv6 se codifican de otra forma:

      
        
        
          
            
          
          
            
          
        
        
          // Url válida con dirección IPv6
let url = 'http://[2607:f8b0:4005:802::1007]/';

alert(encodeURI(url)); // http://%5B2607:f8b0:4005:802::1007%5D/
alert(new URL(url)); // http://[2607:f8b0:4005:802::1007]/
        
      
      
      Como podemos ver, encodeURI reemplazó los corchetes [...], eso es incorrecto, la razón es: las urls IPv6 no existían en el tiempo de RFC2396 (August 1998).
Tales casos son raros, las funciones encode* mayormente funcionan bien.

",
	"url": "https://es.javascript.info/url" 
},
{
	"docs_id": "143",
	"name": "XMLHttpRequest",
	"description": "XMLHttpRequest es un objeto nativo del navegador que permite hacer solicitudes HTTP desde JavaScript.",
	"content": "XMLHttpRequest es un objeto nativo del navegador que permite hacer solicitudes HTTP desde JavaScript.
A pesar de tener la palabra “XML” en su nombre, se puede operar sobre cualquier dato, no solo en formato XML. Podemos cargar y descargar archivos, dar seguimiento y mucho más.
Ahora hay un método más moderno fetch que en algún sentido hace obsoleto a XMLHttpRequest.
En el desarrollo web moderno XMLHttpRequest se usa por tres razones:

Razones históricas: necesitamos soportar scripts existentes con XMLHttpRequest.
Necesitamos soportar navegadores viejos, y no queremos polyfills (p.ej. para mantener los scripts pequeños).
Necesitamos hacer algo que fetch no puede todavía, ej. rastrear el progreso de subida.

¿Te suena familiar? Si es así, está bien, adelante con XMLHttpRequest. De otra forma, por favor, dirígete a Fetch.
Lo básicoXMLHttpRequest tiene dos modos de operación: sincrónica y asíncrona.
Veamos primero la asíncrona, ya que es utilizada en la mayoría de los casos.
Para hacer la petición, necesitamos seguir 3 pasos:


Crear el objeto XMLHttpRequest:

      
        
        
          let xhr = new XMLHttpRequest();
        
      
      
      El constructor no tiene argumentos.


Inicializarlo, usualmente justo después de new XMLHttpRequest:

      
        
        
          xhr.open(method, URL, [async, user, password])
        
      
      
      Este método especifica los parámetros principales para la petición:

method – método HTTP. Usualmente "GET" o "POST".
URL – la URL a solicitar, una cadena, puede ser un objeto URL.
async – si se asigna explícitamente a false, entonces la petición será asincrónica. Cubriremos esto un poco más adelante.
user, password – usuario y contraseña para autenticación HTTP básica (si se requiere).

Por favor, toma en cuenta que la llamada a open, contrario a su nombre, no abre la conexión. Solo configura la solicitud, pero la actividad de red solo empieza con la llamada del método send.


Enviar.

      
        
        
          xhr.send([body])
        
      
      
      Este método abre la conexión y envía ka solicitud al servidor. El parámetro adicional body contiene el cuerpo de la solicitud.
Algunos métodos como GET no tienen un cuerpo. Y otros como POST usan el parámetro body para enviar datos al servidor. Vamos a ver unos ejemplos de eso más tarde.


Escuchar los eventos de respuesta xhr.
Estos son los tres eventos más comúnmente utilizados:

load – cuando la solicitud está; completa (incluso si el estado HTTP es 400 o 500), y la respuesta se descargó por completo.
error – cuando la solicitud no pudo ser realizada satisfactoriamente, ej. red caída o una URL inválida.
progress – se dispara periódicamente mientras la respuesta está siendo descargada, reporta cuánto se ha descargado.


      
        
        
          xhr.onload = function() {
  alert(`Cargado: ${xhr.status} ${xhr.response}`);
};

xhr.onerror = function() { // solo se activa si la solicitud no se puede realizar
  alert(`Error de red`);
};

xhr.onprogress = function(event) { // se dispara periódicamente
  // event.loaded - cuántos bytes se han descargado
  // event.lengthComputable = devuelve true si el servidor envía la cabecera Content-Length (longitud del contenido)
  // event.total - número total de bytes (si `lengthComputable` es `true`)
  alert(`Recibido ${event.loaded} of ${event.total}`);
};
        
      
      
      

Aquí un ejemplo completo. El siguiente código carga la URL en /article/xmlhttprequest/example/load desde el servidor e imprime el progreso:

      
        
        
          
            
          
          
            
          
        
        
          // 1. Crea un nuevo objeto XMLHttpRequest
let xhr = new XMLHttpRequest();

// 2. Configuración: solicitud GET para la URL /article/.../load
xhr.open('GET', '/article/xmlhttprequest/example/load');

// 3. Envía la solicitud a la red
xhr.send();

// 4. Esto se llamará después de que la respuesta se reciba
xhr.onload = function() {
  if (xhr.status != 200) { // analiza el estado HTTP de la respuesta
    alert(`Error ${xhr.status}: ${xhr.statusText}`); // ej. 404: No encontrado
  } else { // muestra el resultado
    alert(`Hecho, obtenidos ${xhr.response.length} bytes`); // Respuesta del servidor
  }
};

xhr.onprogress = function(event) {
  if (event.lengthComputable) {
    alert(`Recibidos ${event.loaded} de ${event.total} bytes`);
  } else {
    alert(`Recibidos ${event.loaded} bytes`); // sin Content-Length
  }

};

xhr.onerror = function() {
  alert("Solicitud fallida");
};
        
      
      
      Una vez el servidor haya respondido, podemos recibir el resultado en las siguientes propiedades de xhr:

status
Código del estado HTTP (un número): 200, 404, 403 y así por el estilo, puede ser 0 en caso de una falla no HTTP.
statusText
Mensaje del estado HTTP (una cadena): usualmente OK para 200, Not Found para 404, Forbidden para 403 y así por el estilo.
response (scripts antiguos deben usar responseText)
El cuerpo de la respuesta del servidor.

También podemos especificar un tiempo límite usando la propiedad correspondiente:

      
        
        
          xhr.timeout = 10000; // límite de tiempo en milisegundos, 10 segundos
        
      
      
      Si la solicitud no es realizada con éxito dentro del tiempo dado, se cancela y el evento timeout se activa.

            Parámetros de búsqueda URL
            Para agregar los parámetros a la URL, como ?nombre=valor, y asegurar la codificación adecuada, podemos utilizar un objeto URL:

      
        
        
          let url = new URL('https://google.com/search');
url.searchParams.set('q', 'pruébame!');

// el parámetro 'q' está codificado
xhr.open('GET', url); // https://google.com/search?q=test+me%21
        
      
      
      
Tipo de respuestaPodemos usar la propiedad xhr.responseType para asignar el formato de la respuesta:

"" (default) – obtiene una cadena,
"text" – obtiene una cadena,
"arraybuffer" – obtiene un ArrayBuffer (para datos binarios, ve el capítulo ArrayBuffer, arrays binarios),
"blob" – obtiene un Blob (para datos binarios, ver el capítulo Blob),
"document" – obtiene un documento XML (puede usar XPath y otros métodos XML)  o un documento HTML (en base al tipo MIME del dato recibido),
"json" – obtiene un JSON (automáticamente analizado).

Por ejemplo, obtengamos una respuesta como JSON:

      
        
        
          
            
          
          
            
          
        
        
          let xhr = new XMLHttpRequest();

xhr.open('GET', '/article/xmlhttprequest/example/json');

xhr.responseType = 'json';

xhr.send();

// la respuesta es {"message": "Hola, Mundo!"}
xhr.onload = function() {
  let responseObj = xhr.response;
  alert(responseObj.message); // Hola, Mundo!
};
        
      
      
      
            Por favor tome nota:
            En los scripts antiguos puedes encontrar también las propiedades xhr.responseText e incluso xhr.responseXML.
Existen por razones históricas, para obtener ya sea una cadena o un documento XML. Hoy en día, debemos seleccionar el formato en xhr.responseType y obtener xhr.response como se demuestra debajo.

EstadosXMLHttpRequest cambia entre estados a medida que avanza. El estado actual es accesible como xhr.readyState.
Todos los estados, como en la especificación:

      
        
        
          UNSENT = 0; // estado inicial
OPENED = 1; // llamada abierta
HEADERS_RECEIVED = 2; // cabeceras de respuesta recibidas
LOADING = 3; // la respuesta está cargando (un paquete de datos es recibido)
DONE = 4; // solicitud completa
        
      
      
      Un objeto XMLHttpRequest escala en orden 0 → 1 → 2 → 3 → … → 3 → 4. El estado 3 se repite cada vez que un paquete de datos se recibe a través de la red.
Podemos seguirlos usando el evento readystatechange:

      
        
        
          xhr.onreadystatechange = function() {
  if (xhr.readyState == 3) {
    // cargando
  }
  if (xhr.readyState == 4) {
    // solicitud finalizada
  }
};
        
      
      
      Puedes encontrar oyentes del evento readystatechange en código realmente viejo, está ahí por razones históricas, había un tiempo cuando no existían load y otros eventos. Hoy en día los manipuladores load/error/progress lo hacen obsoleto.
Abortando solicitudesPodemos terminar la solicitud en cualquier momento. La llamada a xhr.abort() hace eso:

      
        
        
          xhr.abort(); // termina la solicitud
        
      
      
      Este dispara el evento abort, y el xhr.status se convierte en 0.
Solicitudes sincrónicasSi en el método open el tercer parámetro async se asigna como false, la solicitud se hace sincrónicamente.
En otras palabras, la ejecución de JavaScript se pausa en el send() y se reanuda cuando la respuesta es recibida. Algo como los comandos alert o prompt.
Aquí está el ejemplo reescrito, el tercer parámetro de open es false:

      
        
        
          let xhr = new XMLHttpRequest();

xhr.open('GET', '/article/xmlhttprequest/hello.txt', false);

try {
  xhr.send();
  if (xhr.status != 200) {
    alert(`Error ${xhr.status}: ${xhr.statusText}`);
  } else {
    alert(xhr.response);
  }
} catch(err) { // en lugar de onerror
  alert("Solicitud fallida");
}
        
      
      
      Puede verse bien, pero las llamadas sincrónicas son rara vez utilizadas porque bloquean todo el JavaScript de la página hasta que la carga está completa. En algunos navegadores se hace imposible hacer scroll. Si una llamada síncrona toma mucho tiempo, el navegador puede sugerir cerrar el sitio web “colgado”.
Algunas capacidades avanzadas de XMLHttpRequest, como solicitar desde otro dominio o especificar un tiempo límite, no están disponibles para solicitudes síncronas. Tampoco, como puedes ver, la indicación de progreso.
La razón de esto es que las solicitudes sincrónicas son utilizadas muy escasamente, casi nunca. No hablaremos más sobre ellas.
Cabeceras HTTPXMLHttpRequest permite tanto enviar cabeceras personalizadas como leer cabeceras de la respuesta.
Existen 3 métodos para las cabeceras HTTP:

setRequestHeader(name, value)

Asigna la cabecera de la solicitud con los valores name y value provistos.
Por ejemplo:

      
        
        
          xhr.setRequestHeader('Content-Type', 'application/json');
        
      
      
      
            Limitaciones de cabeceras
            Muchas cabeceras se administran exclusivamente por el navegador, ej. Referer y Host.
La lista completa está en la especificación.
XMLHttpRequest no está permitido cambiarlos, por motivos de seguridad del usuario y la exactitud de la solicitud.


            No se pueden eliminar cabeceras
            Otra peculiaridad de XMLHttpRequest es que no puede deshacer un setRequestHeader.
Una vez que una cabecera es asignada, ya está asignada. Llamadas adicionales agregan información a la cabecera, no la sobreescriben.
Por ejemplo:

      
        
        
          xhr.setRequestHeader('X-Auth', '123');
xhr.setRequestHeader('X-Auth', '456');

// la cabecera será:
// X-Auth: 123, 456
        
      
      
      

getResponseHeader(name)

Obtiene la cabecera de la respuesta con el name dado (excepto Set-Cookie y Set-Cookie2).
Por ejemplo:

      
        
        
          xhr.getResponseHeader('Content-Type')
        
      
      
      
getAllResponseHeaders()

Devuelve todas las cabeceras de la respuesta, excepto por Set-Cookie y Set-Cookie2.
Las cabeceras se devuelven como una sola línea, ej.:

      
        
        
          Cache-Control: max-age=31536000
Content-Length: 4260
Content-Type: image/png
Date: Sat, 08 Sep 2012 16:53:16 GMT
        
      
      
      El salto de línea entre las cabeceras siempre es un "\r\n" (independiente del SO), así podemos dividirlas en cabeceras individuales. El separador entre el nombre y el valor siempre es dos puntos seguido de un espacio ": ". Eso quedó establecido en la especificación.
Así, si queremos obtener un objeto con pares nombre/valor, necesitamos tratarlas con un poco de JS.
Como esto (asumiendo que si dos cabeceras tienen el mismo nombre, entonces el último sobreescribe al primero):

      
        
        
          let headers = xhr
  .getAllResponseHeaders()
  .split('\r\n')
  .reduce((result, current) => {
    let [name, value] = current.split(': ');
    result[name] = value;
    return result;
  }, {});

// headers['Content-Type'] = 'image/png'
        
      
      
      

POST, FormulariosPara hacer una solicitud POST, podemos utilizar el objeto FormData nativo.
La sintaxis:

      
        
        
          let formData = new FormData([form]); // crea un objeto, opcionalmente se completa con un <form>
formData.append(name, value); // añade un campo
        
      
      
      Lo creamos, opcionalmente lleno desde un formulario, append (agrega) más campos si se necesitan, y entonces:

xhr.open('POST', ...) – se utiliza el método POST.
xhr.send(formData) para enviar el formulario al servidor.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <form name="person">
  <input name="name" value="John">
  <input name="surname" value="Smith">
</form>

<script>
  // pre llenado del objeto FormData desde el formulario
  let formData = new FormData(document.forms.person);

  // agrega un campo más
  formData.append("middle", "Lee");

  // lo enviamos
  let xhr = new XMLHttpRequest();
  xhr.open("POST", "/article/xmlhttprequest/post/user");
  xhr.send(formData);

  xhr.onload = () => alert(xhr.response);
</script>
        
      
      
      El formulario fue enviado con codificación multipart/form-data.
O, si nos gusta más JSON, entonces, un JSON.stringify y lo enviamos como un string.
Solo no te olvides de asignar la cabecera Content-Type: application/json, muchos frameworks del lado del servidor decodifican automáticamente JSON con este:

      
        
        
          let xhr = new XMLHttpRequest();

let json = JSON.stringify({
  name: "John",
  surname: "Smith"
});

xhr.open("POST", '/submit')
xhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');

xhr.send(json);
        
      
      
      El método .send(body) es bastante omnívoro. Puede enviar casi cualquier body, incluyendo objetos Blob y BufferSource.
Progreso de cargaEl evento progress se dispara solo en la fase de descarga.
Esto es: si hacemos un POST de algo, XMLHttpRequest primero sube nuestros datos (el cuerpo de la respuesta), entonces descarga la respuesta.
Si estamos subiendo algo grande, entonces seguramente estaremos interesados en rastrear el progreso de nuestra carga. Pero xhr.onprogress no ayuda aquí.
Hay otro objeto, sin métodos, exclusivamente para rastrear los eventos de subida: xhr.upload.
Este genera eventos similares a xhr, pero xhr.upload se dispara solo en las subidas:

loadstart – carga iniciada.
progress – se dispara periódicamente durante la subida.
abort – carga abortada.
error – error no HTTP.
load – carga finalizada con éxito.
timeout – carga caducada (si la propiedad timeout está asignada).
loadend – carga finalizada con éxito o error.

Ejemplos de manejadores:

      
        
        
          xhr.upload.onprogress = function(event) {
  alert(`Uploaded ${event.loaded} of ${event.total} bytes`);
};

xhr.upload.onload = function() {
  alert(`Upload finished successfully.`);
};

xhr.upload.onerror = function() {
  alert(`Error durante la carga: ${xhr.status}`);
};
        
      
      
      Aquí un ejemplo de la vida real: indicación del progreso de subida de un archivo:

      
        
        
          
            
          
          
            
          
        
        
          <input type="file" onchange="upload(this.files[0])">

<script>
function upload(file) {
  let xhr = new XMLHttpRequest();

  // rastrea el progreso de la subida
  xhr.upload.onprogress = function(event) {
    console.log(`Uploaded ${event.loaded} of ${event.total}`);
  };

  // seguimiento completado: sea satisfactorio o no
  xhr.onloadend = function() {
    if (xhr.status == 200) {
      console.log("Logrado");
    } else {
      console.log("error " + this.status);
    }
  };

  xhr.open("POST", "/article/xmlhttprequest/post/upload");
  xhr.send(file);
}
</script>
        
      
      
      Solicitudes de origen cruzado (Cross-origin)XMLHttpRequest puede hacer solicitudes de origen cruzado, utilizando la misma política CORS que se solicita.
Tal como fetch, no envía cookies ni autorización HTTP a otro origen por omisión. Para activarlas, asigna xhr.withCredentials como true:

      
        
        
          let xhr = new XMLHttpRequest();
xhr.withCredentials = true;

xhr.open('POST', 'http://anywhere.com/request');
...
        
      
      
      Ve el capítulo Fetch: Cross-Origin Requests para detalles sobre las cabeceras de origen cruzado.
ResumenCodificación típica de la solicitud GET con XMLHttpRequest:

      
        
        
          let xhr = new XMLHttpRequest();

xhr.open('GET', '/my/url');

xhr.send();

xhr.onload = function() {
  if (xhr.status != 200) { // error HTTP?
    // maneja el error
    alert( 'Error: ' + xhr.status);
    return;
  }

  // obtiene la respuesta de xhr.response
};

xhr.onprogress = function(event) {
  // reporta progreso
  alert(`Loaded ${event.loaded} of ${event.total}`);
};

xhr.onerror = function() {
  // manejo de un error no HTTP (ej. red caída)
};
        
      
      
      De hecho hay más eventos, la especificación moderna los lista (en el orden del ciclo de vida):

loadstart – la solicitud ha empezado.
progress – un paquete de datos de la respuesta ha llegado, el cuerpo completo de la respuesta al momento está en response.
abort – la solicitud ha sido cancelada por la llamada de xhr.abort().
error – un error de conexión ha ocurrido, ej. nombre de dominio incorrecto. No pasa con errores HTTP como 404.
load – la solicitud se ha completado satisfactoriamente.
timeout – la solicitud fue cancelada debido a que caducó (solo pasa si fue configurado).
loadend – se dispara después de load, error, timeout o abort.

Los eventos error, abort, timeout, y load son mutuamente exclusivos. Solo uno de ellos puede pasar.
Los eventos más usados son la carga terminada (load), falla de carga (error), o podemos usar un solo manejador loadend y comprobar las propiedades del objeto solicitado xhr para ver qué ha pasado.
Ya hemos visto otro evento: readystatechange. Históricamente, apareció hace mucho tiempo, antes de que la especificación fuera publicada. Hoy en día no es necesario usarlo, podemos reemplazarlo con eventos más nuevos pero puede ser encontrado a menudo en scripts viejos.
Si necesitamos rastrear específicamente, entonces debemos escuchar a los mismos eventos en el objeto xhr.upload.
",
	"url": "https://es.javascript.info/xmlhttprequest" 
},
{
	"docs_id": "144",
	"name": "Carga de archivos reanudable",
	"description": "Con el método fetch es bastante fácil cargar un archivo.",
	"content": "Con el método fetch es bastante fácil cargar un archivo.
¿Cómo reanudar la carga de un archivo despues de perder la conexión? No hay una opción incorporada para eso, pero tenemos las piezas para implementarlo.
Las cargas reanudables deberían venir con indicación de progreso, ya que esperamos archivos grandes (Si necesitamos reanudar). Entonces, ya que fetch no permite rastrear el progreso de carga, usaremos XMLHttpRequest.
Evento de progreso poco útilPara reanudar la carga, necesitamos saber cuánto fue cargado hasta la pérdida de la conexión.
Disponemos de xhr.upload.onprogress para rastrear el progreso de carga.
Desafortunadamente, esto no nos ayudará a reanudar la descarga, Ya que se origina cuando los datos son enviados, ¿pero fue recibida por el servidor? el navegador no lo sabe.
Tal vez fue almacenada por un proxy de la red local, o quizá el proceso del servidor remoto solo murió y no pudo procesarla, o solo se perdió en el medio y no alcanzó al receptor.
Es por eso que este evento solo es útil para mostrar una barra de progreso bonita.
Para reanudar una carga, necesitamos saber exactamente el número de bytes recibidos por el servidor. Y eso solo lo sabe el servidor, por lo tanto haremos una solicitud adicional.
Algoritmos

Primero, crear un archivo id, para únicamente identificar el archivo que vamos a subir:

      
        
        
          let fileId = file.name + '-' + file.size + '-' + file.lastModified;
        
      
      
      Eso es necesario para reanudar la carga, para decirle al servidor lo que estamos reanudando.
Si el nombre o tamaño de la última fecha de modificación cambia, entonces habrá otro fileId.


Envía una solicitud al servidor, preguntando cuántos bytes tiene, así:

      
        
        
          let response = await fetch('status', {
  headers: {
    'X-File-Id': fileId
  }
});

// El servidor tiene tanta cantidad de bytes
let startByte = +await response.text();
        
      
      
      Esto asume que el servidor rastrea archivos cargados por el encabezado X-File-Id. Debe ser implementado en el lado del servidor.
Si el archivo no existe aún en el servidor, entonces su respuesta debe ser 0.


Entonces, podemos usar el método Blob slice para enviar el archivo desde startByte:

      
        
        
          xhr.open("POST", "upload", true);

// Archivo, de modo que el servidor sepa qué archivo subimos
xhr.setRequestHeader('X-File-Id', fileId);

// El byte desde el que estamos reanudando, así el servidor sabe que estamos reanudando
xhr.setRequestHeader('X-Start-Byte', startByte);

xhr.upload.onprogress = (e) => {
  console.log(`Uploaded ${startByte + e.loaded} of ${startByte + e.total}`);
};

// El archivo puede ser de input.files[0] u otra fuente
xhr.send(file.slice(startByte));
        
      
      
      Aquí enviamos al servidor ambos archivos id como X-File-Id, para que de esa manera sepa que archivos estamos cargando, y el byte inicial como X-Start-Byte, para que sepa que no lo estamos cargando inicialmente, si no reanudándolo.
El servidor debe verificar sus registros, y si hubo una carga de ese archivo, y si el tamaño de carga actual es exactamente X-Start-Byte,  entonces agregarle los datos.


Aquí esta la demostración con el código tanto del cliente como del servidor, escrito en Node.js.
Esto funciona solo parcialmente en este sitio, ya que Node.js esta detrás de otro servidor llamado Nginx, que almacena cargas, pasándolas a Node.js cuando esta completamente lleno.
Pero puedes cargarlo y ejecutarlo localmente para la demostración completa:
Resultadoserver.jsuploader.jsindex.htmllet http = require('http');
let static = require('node-static');
let fileServer = new static.Server('.');
let path = require('path');
let fs = require('fs');
let debug = require('debug')('example:resume-upload');

let uploads = Object.create(null);

function onUpload(req, res) {

  let fileId = req.headers['x-file-id'];
  let startByte = +req.headers['x-start-byte'];

  if (!fileId) {
    res.writeHead(400, "No file id");
    res.end();
  }

  // we'll files "nowhere"
  let filePath = '/dev/null';
  // could use a real path instead, e.g.
  // let filePath = path.join('/tmp', fileId);

  debug("onUpload fileId: ", fileId);

  // initialize a new upload
  if (!uploads[fileId]) uploads[fileId] = {};
  let upload = uploads[fileId];

  debug("bytesReceived:" + upload.bytesReceived + " startByte:" + startByte)

  let fileStream;

  // if startByte is 0 or not set, create a new file, otherwise check the size and append to existing one
  if (!startByte) {
    upload.bytesReceived = 0;
    fileStream = fs.createWriteStream(filePath, {
      flags: 'w'
    });
    debug("New file created: " + filePath);
  } else {
    // we can check on-disk file size as well to be sure
    if (upload.bytesReceived != startByte) {
      res.writeHead(400, "Wrong start byte");
      res.end(upload.bytesReceived);
      return;
    }
    // append to existing file
    fileStream = fs.createWriteStream(filePath, {
      flags: 'a'
    });
    debug("File reopened: " + filePath);
  }


  req.on('data', function(data) {
    debug("bytes received", upload.bytesReceived);
    upload.bytesReceived += data.length;
  });

  // send request body to file
  req.pipe(fileStream);

  // when the request is finished, and all its data is written
  fileStream.on('close', function() {
    if (upload.bytesReceived == req.headers['x-file-size']) {
      debug("Upload finished");
      delete uploads[fileId];

      // can do something else with the uploaded file here

      res.end("Success " + upload.bytesReceived);
    } else {
      // connection lost, we leave the unfinished file around
      debug("File unfinished, stopped at " + upload.bytesReceived);
      res.end();
    }
  });

  // in case of I/O error - finish the request
  fileStream.on('error', function(err) {
    debug("fileStream error");
    res.writeHead(500, "File error");
    res.end();
  });

}

function onStatus(req, res) {
  let fileId = req.headers['x-file-id'];
  let upload = uploads[fileId];
  debug("onStatus fileId:", fileId, " upload:", upload);
  if (!upload) {
    res.end("0")
  } else {
    res.end(String(upload.bytesReceived));
  }
}


function accept(req, res) {
  if (req.url == '/status') {
    onStatus(req, res);
  } else if (req.url == '/upload' && req.method == 'POST') {
    onUpload(req, res);
  } else {
    fileServer.serve(req, res);
  }

}




// -----------------------------------

if (!module.parent) {
  http.createServer(accept).listen(8080);
  console.log('Server listening at port 8080');
} else {
  exports.accept = accept;
}class Uploader {

  constructor({file, onProgress}) {
    this.file = file;
    this.onProgress = onProgress;

    // create fileId that uniquely identifies the file
    // we could also add user session identifier (if had one), to make it even more unique
    this.fileId = file.name + '-' + file.size + '-' + file.lastModified;
  }

  async getUploadedBytes() {
    let response = await fetch('status', {
      headers: {
        'X-File-Id': this.fileId
      }
    });

    if (response.status != 200) {
      throw new Error("Can't get uploaded bytes: " + response.statusText);
    }

    let text = await response.text();

    return +text;
  }

  async upload() {
    this.startByte = await this.getUploadedBytes();

    let xhr = this.xhr = new XMLHttpRequest();
    xhr.open("POST", "upload", true);

    // send file id, so that the server knows which file to resume
    xhr.setRequestHeader('X-File-Id', this.fileId);
    // send the byte we're resuming from, so the server knows we're resuming
    xhr.setRequestHeader('X-Start-Byte', this.startByte);

    xhr.upload.onprogress = (e) => {
      this.onProgress(this.startByte + e.loaded, this.startByte + e.total);
    };

    console.log("send the file, starting from", this.startByte);
    xhr.send(this.file.slice(this.startByte));

    // return
    //   true if upload was successful,
    //   false if aborted
    // throw in case of an error
    return await new Promise((resolve, reject) => {

      xhr.onload = xhr.onerror = () => {
        console.log("upload end status:" + xhr.status + " text:" + xhr.statusText);

        if (xhr.status == 200) {
          resolve(true);
        } else {
          reject(new Error("Upload failed: " + xhr.statusText));
        }
      };

      // onabort triggers only when xhr.abort() is called
      xhr.onabort = () => resolve(false);

    });

  }

  stop() {
    if (this.xhr) {
      this.xhr.abort();
    }
  }

}<!DOCTYPE HTML>

<script src="uploader.js"></script>

<form name="upload" method="POST" enctype="multipart/form-data" action="/upload">
  <input type="file" name="myfile">
  <input type="submit" name="submit" value="Upload (Resumes automatically)">
</form>

<button onclick="uploader.stop()">Stop upload</button>


<div id="log">Progress indication</div>

<script>
  function log(html) {
    document.getElementById('log').innerHTML = html;
    console.log(html);
  }

  function onProgress(loaded, total) {
    log("progress " + loaded + ' / ' + total);
  }

  let uploader;

  document.forms.upload.onsubmit = async function(e) {
    e.preventDefault();

    let file = this.elements.myfile.files[0];
    if (!file) return;

    uploader = new Uploader({file, onProgress});

    try {
      let uploaded = await uploader.upload();

      if (uploaded) {
        log('success');
      } else {
        log('stopped');
      }

    } catch(err) {
      console.error(err);
      log('error');
    }
  };

</script>Como podemos ver, los métodos de red modernos estan cerca de los gestores de archivos en sus capacidades – control sobre header, indicador de progreso, enviar partes de archivos, etc.
Podemos implementar la carga reanudable y mucho mas.
",
	"url": "https://es.javascript.info/resume-upload" 
},
{
	"docs_id": "145",
	"name": "Sondeo largo",
	"description": "Sondeo largo es la forma más sencilla de tener una conexión persistente con el servidor, que no utiliza ningún protocolo específico como WebSocket o Eventos enviados por el servidor.",
	"content": "Sondeo largo es la forma más sencilla de tener una conexión persistente con el servidor, que no utiliza ningún protocolo específico como WebSocket o Eventos enviados por el servidor.
Al ser muy fácil de implementar, también es suficientemente bueno en muchos casos.
Sondeo regularLa forma más sencilla de obtener nueva información del servidor es un sondeo periódico. Es decir, solicitudes regulares al servidor: “Hola, estoy aquí, ¿tienes información para mí?”. Por ejemplo, una vez cada 10 segundos.
En respuesta, el servidor primero se da cuenta de que el cliente está en línea, y segundo, envía un paquete de mensajes que recibió hasta ese momento.
Eso funciona, pero hay desventajas:

Los mensajes se transmiten con un retraso de hasta 10 segundos (entre solicitudes).
Incluso si no hay mensajes, el servidor se bombardea con solicitudes cada 10 segundos, aunque el usuario haya cambiado a otro lugar o esté dormido. Eso es bastante difícil de manejar, hablando en términos de rendimiento.

Entonces, si hablamos de un servicio muy pequeño, el enfoque puede ser viable, pero en general, necesita una mejora.
Sondeo largoEl llamado “sondeo largo” es una forma mucho mejor de sondear el servidor.
También es muy fácil de implementar y envía mensajes sin demoras.
El flujo:

Se envía una solicitud al servidor.
El servidor no cierra la conexión hasta que tiene un mensaje para enviar.
Cuando aparece un mensaje, el servidor responde a la solicitud con él.
El navegador realiza una nueva solicitud de inmediato.

La situación en la que el navegador envió una solicitud y tiene una conexión pendiente con el servidor, es estándar para este método. Solo cuando se entrega un mensaje, se restablece la conexión.

      
      
        
      
      Si se pierde la conexión, por ejemplo, debido a un error de red, el navegador envía inmediatamente una nueva solicitud.
Un esquema de la función de suscripción del lado del cliente que realiza solicitudes largas:

      
        
        
          async function subscribe() {
  let response = await fetch("/subscribe");

  if (response.status == 502) {
    // El estado 502 es un error de "tiempo de espera agotado" en la conexión,
    // puede suceder cuando la conexión estuvo pendiente durante demasiado tiempo,
    // y el servidor remoto o un proxy la cerró
    // vamos a reconectarnos
    await subscribe();
  } else if (response.status != 200) {
    // Un error : vamos a mostrarlo
    showMessage(response.statusText);
    // Vuelve a conectar en un segundo
    await new Promise(resolve => setTimeout(resolve, 1000));
    await subscribe();
  } else {
    // Recibe y muestra el mensaje
    let message = await response.text();
    showMessage(message);
    // Llama a subscribe () nuevamente para obtener el siguiente mensaje
    await subscribe();
  }
}

subscribe();
        
      
      
      Como puedes ver, la función subscribe realiza una búsqueda, luego espera la respuesta, la maneja y se llama a sí misma nuevamente.

            El servidor debería estar bien aún con muchas conexiones pendientes
            La arquitectura del servidor debe poder funcionar con muchas conexiones pendientes.
Algunas arquitecturas de servidor ejecutan un proceso por conexión, resultando en que habrá tantos procesos como conexiones y cada proceso requiere bastante memoria. Demasiadas conexiones la consumirán toda.
Este suele ser el caso de los backends escritos en lenguajes como PHP y Ruby.
Los servidores escritos con Node.js generalmente no tienen estos problemas.
Dicho esto, no es un problema del lenguaje sino de implementación. La mayoría de los lenguajes modernos, incluyendo PHP y Ruby permiten la implementación de un backend adecuado. Por favor asegúrate de que la arquitectura del servidor funcione bien con múltiples conexiones simultáneas.

Demostración: un chatAquí hay un chat de demostración, también puedes descargarlo y ejecutarlo localmente (si estás familiarizado con Node.js y puedes instalar módulos):
Resultadobrowser.jsserver.jsindex.html// Envío de mensajes, un simple POST
function PublishForm(form, url) {

  function sendMessage(message) {
    fetch(url, {
      method: 'POST',
      body: message
    });
  }

  form.onsubmit = function() {
    let message = form.message.value;
    if (message) {
      form.message.value = '';
      sendMessage(message);
    }
    return false;
  };
}

// Recibir mensajes con sondeo largo
function SubscribePane(elem, url) {

  function showMessage(message) {
    let messageElem = document.createElement('div');
    messageElem.append(message);
    elem.append(messageElem);
  }

  async function subscribe() {
    let response = await fetch(url);

    if (response.status == 502) {
      // El tiempo de conexión expiró
      // sucede cuando la conexión estuvo pendiente durante demasiado tiempo
      // vamos a reconectarnos
      await subscribe();
    } else if (response.status != 200) {
      // Mostrar Error
      showMessage(response.statusText);
      // Volver a conectar en un segundo
      await new Promise(resolve => setTimeout(resolve, 1000));
      await subscribe();
    } else {
      // Tengo un mensaje
      let message = await response.text();
      showMessage(message);
      await subscribe();
    }
  }

  subscribe();

}let http = require('http');
let url = require('url');
let querystring = require('querystring');
let static = require('node-static');

let fileServer = new static.Server('.');

let subscribers = Object.create(null);

function onSubscribe(req, res) {
  let id = Math.random();

  res.setHeader('Content-Type', 'text/plain;charset=utf-8');
  res.setHeader("Cache-Control", "no-cache, must-revalidate");

  subscribers[id] = res;

  req.on('close', function() {
    delete subscribers[id];
  });

}

function publish(message) {

  for (let id in subscribers) {
    let res = subscribers[id];
    res.end(message);
  }

  subscribers = Object.create(null);
}

function accept(req, res) {
  let urlParsed = url.parse(req.url, true);

  // El nuevo cliente quiere mensajes
  if (urlParsed.pathname == '/subscribe') {
    onSubscribe(req, res);
    return;
  }

  // enviando un mensaje
  if (urlParsed.pathname == '/publish' && req.method == 'POST') {
    // aceptar POST
    req.setEncoding('utf8');
    let message = '';
    req.on('data', function(chunk) {
      message += chunk;
    }).on('end', function() {
      publish(message); // publicarlo para todos
      res.end("ok");
    });

    return;
  }

  // el resto es estático
  fileServer.serve(req, res);

}

function close() {
  for (let id in subscribers) {
    let res = subscribers[id];
    res.end();
  }
}

// -----------------------------------

if (!module.parent) {
  http.createServer(accept).listen(8080);
  console.log('Servidor que se ejecuta en el puerto 8080');
} else {
  exports.accept = accept;

  if (process.send) {
     process.on('message', (msg) => {
       if (msg === 'shutdown') {
         close();
       }
     });
  }

  process.on('SIGINT', close);
}<!DOCTYPE html>
<script src="browser.js"></script>

Todos los visitantes de esta página verán mensajes entre ellos.

<form name="publish">
  <input type="text" name="message" />
  <input type="submit" value="Enviar" />
</form>

<div id="subscribe">
</div>

<script>
  new PublishForm(document.forms.publish, 'publish');
  // parámetro de url aleatorio para evitar problemas de almacenamiento en caché
  new SubscribePane(document.getElementById('subscribe'), 'subscribe?random=' + Math.random());
</script>El código del navegador está en browser.js.
Área de usoEl sondeo largo funciona muy bien en situaciones en las que es raro recibir mensajes.
Si los mensajes llegan con mucha frecuencia, entonces el gráfico de mensajes solicitados vs recibidos, pintado arriba, se vuelve en forma de sierra.
Cada mensaje es una solicitud separada, provista de encabezados, sobrecarga de autenticación, etc.
Entonces, en este caso, se prefiere otro método, como Websocket o Eventos enviados por el servidor.
",
	"url": "https://es.javascript.info/long-polling" 
},
{
	"docs_id": "146",
	"name": "WebSocket",
	"description": "El protocolo WebSocket, descrito en la especificación RFC 6455, brinda una forma de intercambiar datos entre el navegador y el servidor por medio de una conexión persistente. Los datos pueden ser pasados en ambas direcciones como paquetes “packets”, sin cortar la conexión y sin pedidos adicionales de HTTP “HTTP-requests”.",
	"content": "El protocolo WebSocket, descrito en la especificación RFC 6455, brinda una forma de intercambiar datos entre el navegador y el servidor por medio de una conexión persistente. Los datos pueden ser pasados en ambas direcciones como paquetes “packets”, sin cortar la conexión y sin pedidos adicionales de HTTP “HTTP-requests”.
WebSocket es especialmente bueno para servicios que requieren intercambio de información continua, por ejemplo juegos en línea, sistemas de negocios en tiempo real, entre otros.
Un ejemplo simplePara abrir una conexión websocket, necesitamos crearla new WebSocket usando el protocolo especial ws en la url:

      
        
        
          let socket = new WebSocket("ws://javascript.info");
        
      
      
      También hay una versión encriptada wss://. Equivale al HTTPS para los websockets.

            Siempre dé preferencia a wss://
            El protocolo wss:// no solamente está encriptado, también es más confiable.
Esto es porque los datos en ws:// no están encriptados y son visibles para cualquier intermediario. Entonces los servidores proxy viejos que no reconocen el protocolo WebSocket podrían interpretar los datos como cabeceras “extrañas” y abortar la conexión.
En cambio wss:// es WebSocket sobre TLS (al igual que HTTPS es HTTP sobre TLS), la seguridad de la capa de transporte encripta los datos en el envío y los desencripta en el destino. Así, los paquetes de datos pasan encriptados a través de los proxy, estos servidores no pueden ver lo que hay dentro y los dejan pasar.

Una vez que el socket es creado, debemos escuchar los eventos que ocurren en él. Hay en total 4 eventos:

open – conexión establecida,
message – datos recibidos,
error – error en websocket,
close – conexión cerrada.

…Y si queremos enviar algo, socket.send(data) lo hará.
Aquí un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let socket = new WebSocket("wss://javascript.info/article/websocket/demo/hello");

socket.onopen = function(e) {
  alert("[open] Conexión establecida");
  alert("Enviando al servidor");
  socket.send("Mi nombre es John");
};

socket.onmessage = function(event) {
  alert(`[message] Datos recibidos del servidor: ${event.data}`);
};

socket.onclose = function(event) {
  if (event.wasClean) {
    alert(`[close] Conexión cerrada limpiamente, código=${event.code} motivo=${event.reason}`);
  } else {
    // ej. El proceso del servidor se detuvo o la red está caída
    // event.code es usualmente 1006 en este caso
    alert('[close] La conexión se cayó');
  }
};

socket.onerror = function(error) {
  alert(`[error] ${error.message}`);
};
        
      
      
      Para propósitos de demostración, tenemos un pequeño servidor server.js, escrito en Node.js, ejecutándose para el ejemplo de arriba. Este responde con “Hello from server, John”, espera 5 segundos, y cierra la conexión.
Entonces verás los eventos open → message → close.
Eso es realmente todo, ya podemos conversar con WebSocket. Bastante simple, ¿no es cierto?
Ahora hablemos más en profundidad.
Abriendo un websocketCuando se crea new WebSocket(url), comienza la conexión de inmediato.
Durante la conexión, el navegador (usando cabeceras o “header”) le pregunta al servidor: “¿Soportas Websockets?” y si si el servidor responde “Sí”, la comunicación continúa en el protocolo WebSocket, que no es HTTP en absoluto.

      
      
        
      
      Aquí hay un ejemplo de cabeceras de navegador para una petición hecha por new WebSocket("wss://javascript.info/chat").

      
        
        
          GET /chat
Host: javascript.info
Origin: https://javascript.info
Connection: Upgrade
Upgrade: websocket
Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
Sec-WebSocket-Version: 13
        
      
      
      
Origin – La página de origen del cliente, ej. https://javascript.info. Los objetos WebSocket son cross-origin por naturaleza. No existen las cabeceras especiales ni otras limitaciones. De cualquier manera los servidores viejos son incapaces de manejar WebSocket, asi que no hay problemas de compatibilidad. Pero la cabecera Origin es importante, pues habilita al servidor decidir si permite o no la comunicación WebSocket con el sitio web.
Connection: Upgrade – señaliza que el cliente quiere cambiar el protocolo.
Upgrade: websocket – el protocolo requerido es “websocket”.
Sec-WebSocket-Key – una clave de seguridad aleatoria generada por el navegador.
Sec-WebSocket-Version – Versión del protocolo WebSocket, 13 es la actual.


            El intercambio WebSocket no puede ser emulado
            No podemos usar XMLHttpRequest o fetch para hacer este tipo de peticiones HTTP, porque JavaScript no tiene permitido establecer esas cabeceras.

Si el servidor concede el cambio a WebSocket, envía como respuesta el código 101:

      
        
        
          101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
        
      
      
      Aquí Sec-WebSocket-Accept es Sec-WebSocket-Key, recodificado usando un algoritmo especial. El navegador lo usa para asegurarse de que la respuesta se corresponde a la petición.
A continuación los datos son transferidos usando el protocolo WebSocket. Pronto veremos su estructura (“frames”, marcos o cuadros en español). Y no es HTTP en absoluto.
Extensiones y subprotocolosPuede tener las cabeceras adicionales Sec-WebSocket-Extensions y Sec-WebSocket-Protocol que describen extensiones y  subprotocolos.
Por ejemplo:


Sec-WebSocket-Extensions: deflate-frame significa que el navegador soporta compresión de datos. una extensión es algo relacionado a la transferencia de datos, funcionalidad que extiende el protocolo WebSocket. La cabecera Sec-WebSocket-Extensions es enviada automáticamente por el navegador, con la lista de todas las extensiones que soporta.


Sec-WebSocket-Protocol: soap, wamp significa que queremos transferir no cualquier dato, sino datos en protocolos SOAP o WAMP (“The WebSocket Application Messaging Protocol”). Los subprotocolos de WebSocket están registrados en el catálogo IANA. Entonces, esta cabecera describe los formatos de datos que vamos a usar.
Esta cabecera opcional se establece usando el segundo parámetro de new WebSocket, que es el array de subprotocolos. Por ejemplo, si queremos usar SOAP o WAMP:

      
        
        
          let socket = new WebSocket("wss://javascript.info/chat", ["soap", "wamp"]);
        
      
      
      

El servidor debería responder con una lista de protocolos o extensiones que acepta usar.
Por ejemplo, la petición:

      
        
        
          GET /chat
Host: javascript.info
Upgrade: websocket
Connection: Upgrade
Origin: https://javascript.info
Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
Sec-WebSocket-Version: 13
Sec-WebSocket-Extensions: deflate-frame
Sec-WebSocket-Protocol: soap, wamp
        
      
      
      Respuesta:

      
        
        
          101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
Sec-WebSocket-Extensions: deflate-frame
Sec-WebSocket-Protocol: soap
        
      
      
      Aquí el servidor responde que soporta la extensión “deflate-frame”, y únicamente SOAP de los subprotocolos solicitados.
Transferencia de datosLa comunicación WebSocket consiste de “frames” (cuadros) de fragmentos de datos, que pueden ser enviados de ambos lados y pueden ser de varias clases:

“text frames” – contiene datos de texto que las partes se mandan entre sí.
“binary data frames” – contiene datos binarios que las partes se mandan entre sí.
“ping/pong frames” son usados para testear la conexión; enviados desde el servidor, el navegador responde automáticamente.
También existe “connection close frame”, y algunos otros frames de servicio.

En el navegador, trabajamos directamente solamente con frames de texto y binarios.
El método WebSocket .send() puede enviar tanto datos de texto como binarios.
Una llamada socket.send(body) permite en body datos en formato string o binarios, incluyendo Blob, ArrayBuffer, etc. No se requiere configuración: simplemente se envían en cualquier formato.
Cuando recibimos datos, el texto siempre viene como string. Y para datos binarios, podemos elegir entre los formatos Blob y ArrayBuffer.
Esto se establece en la propiedad socket.binaryType, que es "blob" por defecto y entonces los datos binarios vienen como objetos Blob.
Blob es un objeto binario de alto nivel que se integra directamente con <a>, <img> y otras etiquetas, así que es una opción predeterminada saludable. Pero para procesamiento binario, para acceder a bytes individuales, podemos cambiarlo a "arraybuffer":

      
        
        
          socket.binaryType = "arraybuffer";
socket.onmessage = (event) => {
  // event.data puede ser string (si es texto) o arraybuffer (si es binario)
};
        
      
      
      Limitaciones de velocidadSupongamos que nuestra app está generando un montón de datos para enviar. Pero el usuario tiene una conexión de red lenta, posiblemente internet móvil fuera de la ciudad.
Podemos llamar socket.send(data) una y otra vez. Pero los datos serán acumulados en memoria (en un “buffer”) y enviados solamente tan rápido como la velocidad de la red lo permita.
La propiedad socket.bufferedAmount registra cuántos bytes quedan almacenados (“buffered”) hasta el momento esperando a ser enviados a la red.
Podemos examinarla  para ver si el “socket” está disponible para transmitir.

      
        
        
          // examina el socket cada 100ms y envía más datos
// solamente si todos los datos existentes ya fueron enviados
setInterval(() => {
  if (socket.bufferedAmount == 0) {
    socket.send(moreData());
  }
}, 100);
        
      
      
      Cierre de conexiónNormalmente, cuando una parte quiere cerrar la conexión (servidor o navegador, ambos tienen el mismo derecho), envía un “frame de cierre de conexión” con un código numérico y un texto con el motivo.
El método para eso es:

      
        
        
          socket.close([code], [reason]);
        
      
      
      
code es un código especial de cierre de WebSocket (opcional)
reason es un string que describe el motivo de cierre (opcional)

Entonces el manejador del evento close de la otra parte obtiene el código y el motivo, por ejemplo:

      
        
        
          // la parte que hace el cierre:
socket.close(1000, "Work complete");

// la otra parte:
socket.onclose = event => {
  // event.code === 1000
  // event.reason === "Work complete"
  // event.wasClean === true (clean close)
};
        
      
      
      Los códigos más comunes:

1000 – cierre normal. Es el predeterminado (usado si no se proporciona code),
1006 – no hay forma de establecerlo manualmente, indica que la conexión se perdió (no hay frame de cierre).

Hay otros códigos como:

1001 – una parte se va, por ejemplo el server se está apagando, o el navegador deja la página,
1009 – el mensaje es demasiado grande para procesar,
1011 – error inesperado en el servidor,
…y así.

La lista completa puede encontrarse en RFC6455, §7.4.1.
Los códigos de WebSocket son como los de HTTP pero diferentes. En particular, los códigos menores a 1000 son reservados, habrá un error si tratamos de establecerlos.

      
        
        
          // en caso de conexión que se rompe
socket.onclose = event => {
  // event.code === 1006
  // event.reason === ""
  // event.wasClean === false (no hay un frame de cierre)
};
        
      
      
      Estado de la conexiónPara obtener el estado (state) de la conexión, tenemos la propiedad socket.readyState con valores:

0 – “CONNECTING”: la conexión aún no fue establecida,
1 – “OPEN”: comunicando,
2 – “CLOSING”: la conexión se está cerrando,
3 – “CLOSED”: la conexión está cerrada.

Ejemplo ChatRevisemos un ejemplo de chat usando la API WebSocket del navegador y el módulo WebSocket de Node.js https://github.com/websockets/ws. Prestaremos atención al lado del cliente, pero el servidor es igual de simple.
HTML: necesitamos un <form> para enviar mensajes y un <div> para los mensajes entrantes:

      
        
        
          <!-- message form -->
<form name="publish">
  <input type="text" name="message">
  <input type="submit" value="Send">
</form>

<!-- div with messages -->
<div id="messages"></div>
        
      
      
      De JavaScript queremos tres cosas:

Abrir la conexión.
Ante el “submit” del form, enviar socket.send(message) el mensaje.
Al llegar un mensaje, agregarlo a div#messages.

Aquí el código:

      
        
        
          let socket = new WebSocket("wss://javascript.info/article/websocket/chat/ws");

// enviar el mensaje del form
document.forms.publish.onsubmit = function() {
  let outgoingMessage = this.message.value;

  socket.send(outgoingMessage);
  return false;
};

// mensaje recibido - muestra el mensaje en div#messages
socket.onmessage = function(event) {
  let message = event.data;

  let messageElem = document.createElement('div');
  messageElem.textContent = message;
  document.getElementById('messages').prepend(messageElem);
}
        
      
      
      El código de servidor está fuera de nuestro objetivo. Aquí usaremos Node.js pero no necesitas hacerlo. Otras plataformas también tienen sus formas de trabajar con WebSocket.
El algoritmo de lado de servidor será:

Crear clients = new Set() – un conjunto de sockets.
Para cada websocket aceptado, sumarlo al conjunto clients.add(socket) y establecer un “event listener” message para obtener sus mensajes.
Cuando un mensaje es recibido: iterar sobre los clientes y enviarlo a todos ellos.
Cuando una conexión se cierra: clients.delete(socket).


      
        
        
          const ws = new require('ws');
const wss = new ws.Server({noServer: true});

const clients = new Set();

http.createServer((req, res) => {
  // aquí solo manejamos conexiones websocket
  // en proyectos reales tendremos también algún código para manejar peticiones no websocket
  wss.handleUpgrade(req, req.socket, Buffer.alloc(0), onSocketConnect);
});

function onSocketConnect(ws) {
  clients.add(ws);

  ws.on('message', function(message) {
    message = message.slice(0, 50); // la longitud máxima del mensaje será 50

    for(let client of clients) {
      client.send(message);
    }
  });

  ws.on('close', function() {
    clients.delete(ws);
  });
}
        
      
      
      Aquí está el ejemplo funcionando:

    
        
      
      
    
  Puedes descargarlo (botón arriba/derecha en el iframe) y ejecutarlo localmente. No olvides instalar Node.js y npm install ws antes de hacerlo.
ResumenWebSocket es la forma moderna de tener conexiones persistentes entre navegador y servidor .

Los WebSockets no tienen limitaciones “cross-origin”.
Están muy bien soportados en los navegadores.
Pueden enviar y recibir datos string y binarios.

La API es simple.
Métodos:

socket.send(data),
socket.close([code], [reason]).

Eventos:

open,
message,
error,
close.

El WebSocket por sí mismo no incluye reconexión, autenticación ni otros mecanismos de alto nivel. Hay librerías cliente/servidor para eso, y también es posible implementar esas capacidades manualmente.
A veces, para integrar WebSocket a un proyecto existente, se ejecuta un servidor WebSocket en paralelo con el servidor HTTP principal compartiendo la misma base de datos. Las peticiones a WebSocket usan wss://ws.site.com, un subdominio que se dirige al servidor de WebSocket mientras que https://site.com va al servidor HTTP principal.
Seguro, otras formas de integración también son posibles.
",
	"url": "https://es.javascript.info/websocket" 
},
{
	"docs_id": "147",
	"name": "Eventos enviados por el servidor",
	"description": "La especificación de los Eventos enviados por el servidor describe una clase incorporada EventSource, que mantiene la conexión con el servidor y permite recibir eventos de él.",
	"content": "La especificación de los Eventos enviados por el servidor describe una clase incorporada EventSource, que mantiene la conexión con el servidor y permite recibir eventos de él.
Similar a WebSocket, la conexión es persistente.
Pero existen varias diferencias importantes:



WebSocket
EventSource




Bidireccional: tanto el cliente como el servidor pueden intercambiar mensajes
Unidireccional: solo el servidor envía datos


Datos binarios y de texto
Solo texto


Protocolo WebSocket
HTTP regular



EventSource es una forma menos poderosa de comunicarse con el servidor que WebSocket.
¿Por qué debería uno usarlo?
El motivo principal: es más sencillo. En muchas aplicaciones, el poder de WebSocket es demasiado.
Necesitamos recibir un flujo de datos del servidor: tal vez mensajes de chat o precios de mercado, o lo que sea. Para eso es bueno EventSource. También admite la reconexión automática, algo que debemos implementar manualmente con WebSocket. Además, es HTTP común, no un protocolo nuevo.
Recibir mensajesPara comenzar a recibir mensajes, solo necesitamos crear un new EventSource(url).
El navegador se conectará a la url y mantendrá la conexión abierta, esperando eventos.
El servidor debe responder con el estado 200 y el encabezado Content-Type:text/event-stream, entonces mantener la conexión y escribir mensajes en el formato especial, así:

      
        
        
          data: Mensaje 1

data: Mensaje 2

data: Mensaje 3
data: de dos líneas
        
      
      
      
Un mensaje de texto va después de data:, el espacio después de los dos puntos es opcional.
Los mensajes están delimitados con saltos de línea dobles \n\n.
Para enviar un salto de línea \n, podemos enviar inmediatamente un data: (tercer mensaje arriba) más.

En la práctica, los mensajes complejos generalmente se envían codificados en JSON. Los saltos de línea están codificados así \n dentro de los mensajes, por lo que los mensajes data: multilínea no son necesarios.
Por ejemplo:

      
        
        
          data: {"user":"John","message":"Primera línea\n Segunda línea"}
        
      
      
      … Entonces podemos asumir que un data: contiene exactamente un mensaje.
Para cada uno de estos mensajes, se genera el evento message:

      
        
        
          let eventSource = new EventSource("/events/subscribe");

eventSource.onmessage = function(event) {
  console.log("Nuevo mensaje", event.data);
  // registrará apuntes 3 veces para el flujo de datos anterior
};

// o eventSource.addEventListener('message', ...)
        
      
      
      Solicitudes Cross-originEventSource admite solicitudes cross-origin, como fetch o cualquier otro método de red. Podemos utilizar cualquier URL:

      
        
        
          let source = new EventSource("https://another-site.com/events");
        
      
      
      El servidor remoto obtendrá el encabezado Origin y debe responder con Access-Control-Allow-Origin para continuar.
Para pasar las credenciales, debemos configurar la opción adicional withCredentials, así:

      
        
        
          let source = new EventSource("https://another-site.com/events", {
  withCredentials: true
});
        
      
      
      Consulte el capítulo Fetch: Cross-Origin Requests para obtener más detalles sobre los encabezados cross-origin.
ReconexiónTras la creación con new EventSource, el cliente se conecta al servidor y, si la conexión se interrumpe, se vuelve a conectar.
Eso es muy conveniente, ya que no tenemos que preocuparnos por eso.
Hay un pequeño retraso entre las reconexiones, unos segundos por defecto.
El servidor puede establecer la demora recomendada usando retry: dentro de la respuesta (en milisegundos):

      
        
        
          retry: 15000
data: Hola, configuré el retraso de reconexión en 15 segundos
        
      
      
      El retry: puede venir junto con algunos datos, o como un mensaje independiente.
El navegador debe esperar esa cantidad de milisegundos antes de volver a conectarse. O más, por ejemplo: si el navegador sabe (desde el sistema operativo) que no hay conexión de red en este momento, puede esperar hasta que aparezca la conexión y luego volver a intentarlo.

Si el servidor desea que el navegador deje de volver a conectarse, debería responder con el estado HTTP 204.
Si el navegador quiere cerrar la conexión, debe llamar a eventSource.close():


      
        
        
          let eventSource = new EventSource(...);

eventSource.close();
        
      
      
      Además, no habrá reconexión si la respuesta tiene un Content-Type incorrecto o su estado HTTP difiere de 301, 307, 200 y 204. En tales casos, se emitirá el evento "error" y el navegador no se volverá a conectar.

            Por favor tome nota:
            Cuando una conexión finalmente se cierra, no hay forma de “reabrirla”. Si queremos conectarnos de nuevo, simplemente crea un nuevo EventSource.

ID del mensajeCuando una conexión se interrumpe debido a problemas de red, ninguna de las partes puede estar segura de qué mensajes se recibieron y cuáles no.
Para reanudar correctamente la conexión, cada mensaje debe tener un campo id, así:

      
        
        
          data: Mensaje 1
id: 1

data: Mensaje 2
id: 2

data: Mensaje 3
data: de dos líneas
id: 3
        
      
      
      Cuando se recibe un mensaje con id:, el navegador:

Establece la propiedad eventSource.lastEventId a su valor.
Tras la reconexión, el navegador envía el encabezado Last-Event-ID con ese id, para que el servidor pueda volver a enviar los siguientes mensajes.


            Pon id: después de data:
            Ten en cuenta: el id es adjuntado debajo del mensaje data por el servidor, para garantizar que lastEventId se actualice después de recibir el mensaje.

Estado de conexión: readyStateEl objeto EventSource tiene la propiedad readyState, que tiene uno de tres valores:

      
        
        
          EventSource.CONNECTING = 0; // conectando o reconectando
EventSource.OPEN = 1;       // conectado
EventSource.CLOSED = 2;     // conexión cerrada
        
      
      
      Cuando se crea un objeto, o la conexión no funciona, siempre es EventSource.CONNECTING (es igual a 0).
Podemos consultar esta propiedad para conocer el estado de EventSource.
Tipos de eventosPor defecto, el objeto EventSource genera tres eventos:

message – un mensaje recibido, disponible como event.data.
open – la conexión está abierta.
error – no se pudo establecer la conexión, por ejemplo, el servidor devolvió el estado HTTP 500.

El servidor puede especificar otro tipo de evento con event: ... al inicio del evento.
Por ejemplo:

      
        
        
          event: join
data: Bob

data: Hola

event: leave
data: Bob
        
      
      
      Para manejar eventos personalizados, debemos usar addEventListener, no onmessage:

      
        
        
          eventSource.addEventListener('join', event => {
  alert(`Se unió ${event.data}`);
});

eventSource.addEventListener('message', event => {
  alert(`Dijo: ${event.data}`);
});

eventSource.addEventListener('leave', event => {
  alert(`Salió ${event.data}`);
});
        
      
      
      Ejemplo completoAquí está el servidor que envía mensajes con 1, 2, 3, luego bye y cierra la conexión.
Luego, el navegador se vuelve a conectar automáticamente.
Resultadoserver.jsindex.htmllet http = require('http');
let url = require('url');
let querystring = require('querystring');
let static = require('node-static');
let fileServer = new static.Server('.');

function onDigits(req, res) {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream; charset=utf-8',
    'Cache-Control': 'no-cache'
  });

  let i = 0;

  let timer = setInterval(write, 1000);
  write();

  function write() {
    i++;

    if (i == 4) {
      res.write('event: bye\ndata: bye-bye\n\n');
      clearInterval(timer);
      res.end();
      return;
    }

    res.write('data: ' + i + '\n\n');

  }
}

function accept(req, res) {

  if (req.url == '/digits') {
    onDigits(req, res);
    return;
  }

  fileServer.serve(req, res);
}


if (!module.parent) {
  http.createServer(accept).listen(8080);
} else {
  exports.accept = accept;
}<!DOCTYPE html>
<script>
let eventSource;

function start() { // cuando se presiona el botón "Inicio"
  if (!window.EventSource) {
    // IE o un navegador antiguo
    alert("El navegador no es compatible con EventSource.");
    return;
  }

  eventSource = new EventSource('digits');

  eventSource.onopen = function(e) {
    log("Evento: open");
  };

  eventSource.onerror = function(e) {
    log("Evento: error");
    if (this.readyState == EventSource.CONNECTING) {
      log(`Reconectando (readyState=${this.readyState})...`);
    } else {
      log("Un error ha ocurrido.");
    }
  };

  eventSource.addEventListener('bye', function(e) {
    log("Evento: bye, datos: " + e.data);
  });

  eventSource.onmessage = function(e) {
    log("Evento: message, datos: " + e.data);
  };
}

function stop() { // when "Stop" button pressed
  eventSource.close();
  log("eventSource.close()");
}

function log(msg) {
  logElem.innerHTML += msg + "<br>";
  document.documentElement.scrollTop = 99999999;
}
</script>

<button onclick="start()">Inicio</button> Presiona "Inicio" para comenzar.
<div id="logElem" style="margin: 6px 0"></div>

<button onclick="stop()">Detener</button> "Detener" para terminar.ResumenEl objeto EventSource establece automáticamente una conexión persistente y permite al servidor enviar mensajes a través de él.
Ofrece:

Reconexión automática, con tiempo de espera de reintento ajustable.
IDs en cada mensaje para reanudar los eventos, el último identificador recibido se envía en el encabezado Last-Event-ID al volver a conectarse.
El estado actual está en la propiedad readyState.

Eso hace que EventSource sea una alternativa viable a WebSocket, ya que es de un nivel más bajo y carece de esas características integradas (aunque se pueden implementar).
En muchas aplicaciones de la vida real, el poder de EventSource es suficiente.
Compatible con todos los navegadores modernos (no IE).
La sintaxis es:

      
        
        
          let source = new EventSource(url, [credentials]);
        
      
      
      El segundo argumento tiene solo una opción posible: {withCredentials: true}, permite enviar credenciales de cross-origin.
La seguridad general de cross-origin es la misma que para fetch y otros métodos de red.
Propiedades de un objeto EventSource
readyState
El estado de conexión actual: EventSource.CONNECTING (=0), EventSource.OPEN (=1) o EventSource.CLOSED (=2).
lastEventId
El último id recibido. Tras la reconexión, el navegador lo envía en el encabezado Last-Event-ID.

Métodos
close()
Cierra la conexión.

Eventos
message
Mensaje recibido, los datos están en event.data.
open
Se establece la conexión.
error
En caso de error, se incluyen tanto la pérdida de conexión (se reconectará automáticamente) como los errores fatales. Podemos comprobar readyState para ver si se está intentando la reconexión.

El servidor puede establecer un nombre de evento personalizado en event:. Tales eventos deben manejarse usando addEventListener, no on<evento>.
Formato de respuesta del servidorEl servidor envía mensajes, delimitados por \n\n.
Un mensaje puede tener los siguientes campos:

data: – cuerpo del mensaje, una secuencia de múltiples datos se interpreta como un solo mensaje, con \n entre las partes.
id: – renueva lastEventId, enviado en el encabezado Last-Event-ID al volver a conectarse.
retry: – recomienda una demora de reintento para las reconexiones en milisegundos. No hay forma de configurarlo desde JavaScript.
event: – nombre del evento, debe preceder a data:.

Un mensaje puede incluir uno o más campos en cualquier orden, pero id: suele ser el último.
",
	"url": "https://es.javascript.info/server-sent-events" 
},
{
	"docs_id": "148",
	"name": "",
	"description": "Aquí aprenderemos JavaScript, empezando desde cero y llegaremos hasta conceptos avanzados como POO.",
	"content": "Parte 1El lenguaje JavaScriptParte 2El navegador: Documentos, Eventos e InterfacesParte 3Artículos adicionalesEl lenguaje JavaScriptAquí aprenderemos JavaScript, empezando desde cero y llegaremos hasta conceptos avanzados como POO.
Nos concentraremos en el lenguaje mismo con el mínimo de notas específicas del entorno.
Una introducciónUna introducción a JavaScriptManuales y especificacionesEditores de CódigoConsola de desarrolladorFundamentos de JavaScript¡Hola, mundo!Estructura del códigoEl modo moderno, "use strict"VariablesTipos de datosInteracción: alert, prompt, confirmConversiones de TiposOperadores básicos, matemáticasComparacionesEjecución condicional: if, '?'Operadores LógicosOperador Nullish Coalescing '??'Bucles: while y forLa sentencia "switch"FuncionesExpresiones de funciónFunciones Flecha, lo básicoEspeciales JavaScriptMás…Calidad del códigoDebugging en el navegadorEstilo de codificaciónComentariosCódigo ninjaTest automatizados con MochaPolyfills y transpiladoresObjetos: lo básicoObjetosReferencias de objetos y copiaRecolección de basuraMétodos del objeto, "this"Constructor, operador "new"Encadenamiento opcional '?.'Tipo SymbolConversión de objeto a valor primitivoTipos de datosMétodos en tipos primitivosNúmerosStringsArraysMétodos de arraysIterablesMap y SetWeakMap y WeakSetObject.keys, values, entriesAsignación desestructuranteFecha y HoraMétodos JSON, toJSONMás…Trabajo avanzado con funcionesRecursión y pilaParámetros Rest y operador SpreadÁmbito de Variable y el concepto "closure"La vieja "var"Objeto GlobalFunción como objeto, NFELa sintaxis "new Function"Planificación: setTimeout y setIntervalDecoradores y redirecciones, call/applyFunción bind: vinculación de funcionesFunciones de flecha revisadasMás…Configuración de las propiedades de objetosIndicadores y descriptores de propiedad"Getters" y "setters" de propiedadPrototipos y herenciaHerencia prototípicaF.prototypePrototipos nativosMétodos prototipo, objetos sin __proto__ClasesSintaxis básica de `class`Herencia de clasePropiedades y métodos estáticos.Propiedades y métodos privados y protegidos.Ampliación de clases integradasComprobación de clase: "instanceof"Los MixinsManejo de erroresManejo de errores, "try...catch"Errores personalizados, extendiendo ErrorPromesas y async/awaitIntroducción: callbacksPromesaEncadenamiento de promesasManejo de errores con promesasPromise APIPromisificaciónMicrotareas (Microtasks)Async/awaitGeneradores e iteración avanzadaGeneradoresIteradores y generadores asíncronosMódulosMódulos, introducciónExport e ImportImportaciones dinámicasTemas diversosProxy y ReflectEval: ejecutando una cadena de códigoCurrificaciónTipo de ReferenciaBigIntEl navegador: Documentos, Eventos e InterfacesAprenderemos a manejar la página del navegador: agregar elementos, manipular su tamaño y posición, crear interfaces dinámicamente e interactuar con el visitante.
DocumentoEntorno del navegador, especificacionesÁrbol del Modelo de Objetos del Documento (DOM)Recorriendo el DOMBuscar: getElement*, querySelector*Propiedades del nodo: tipo, etiqueta y contenidoAtributos y propiedadesModificando el documentoEstilos y clasesTamaño de elementos y desplazamientoTamaño de ventana y desplazamientoCoordenadasMás…Introducción a los eventosIntroducción a los eventos en el navegadorPropagación y capturaDelegación de eventosAcciones predeterminadas del navegadorEnvío de eventos personalizadosEventos en la UIEventos del MouseMoviendo el mouse: mouseover/out, mouseenter/leaveArrastrar y Soltar con eventos del ratónEventos de punteroTeclado: keydown y keyupDesplazamientoFormularios y controlesPropiedades y Métodos de FormulariosEnfocado: enfoque/desenfoqueEventos: change, input, cut, copy, pasteFormularios: evento y método submitEl documento y carga de recursosPágina: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferCarga de recursos: onload y onerrorTemas diversosMutation observerSelection y RangeLoop de eventos: microtareas y macrotareasArtículos adicionalesLista de temas adicionales que supone que ha cubierto las dos primeras partes del tutorial. Aquí no hay una jerarquía clara, puede leer los artículos en el orden que desee.Marcos y ventanasVentanas emergentes y métodos de ventanaComunicación entre ventanasEl ataque de secuestro de clicsDatos binarios y archivosArrayBuffer, arrays binariosTextDecoder y TextEncoderBlobFile y FileReaderSolicitudes de redFetchFormDataFetch: Progreso de la descargaFetch: AbortFetch: Cross-Origin RequestsFetch APIObjetos URLXMLHttpRequestCarga de archivos reanudableSondeo largoWebSocketEventos enviados por el servidorMás…Almacenando datos en el navegadorCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimacionesCurva de BézierAnimaciones CSSAnimaciones JavaScriptComponentes WebDesde la altura orbitalElementos personalizadosShadow DOMElemento templateShadow DOM slots, composiciónEstilo Shadow DOMShadow DOM y eventosExpresiones RegularesPatrones y banderas (flags)Clases de caracteresUnicode: bandera "u" y clase \p{...}Anclas: inicio ^ y final $ de cadenaModo multilínea de anclas ^ $, bandera "m"Límite de palabra: \bEscapando, caracteres especialesConjuntos y rangos [...]Cuantificadores +, *, ? y {n}Cuantificadores codiciosos y perezososGrupos de capturaReferencias inversas en patrones: \N y \k<nombre>Alternancia (O) |Lookahead y lookbehind (revisar delante/detrás)Backtracking catastróficoIndicador adhesivo “y”, buscando en una posición.Métodos de RegExp y StringMás…{
  "@context": "http://schema.org",
  "@type": "WebSite",
  "url": "https://es.javascript.info/",
  "potentialAction": {
    "@type": "SearchAction",
    "target": "https://es.javascript.info/search?query={search_term_string}",
    "query-input": "required name=search_term_string"
  }
}",
	"url": "https://es.javascript.info#" 
},
{
	"docs_id": "149",
	"name": "Cookies, document.cookie",
	"description": "Las cookies son pequeñas cadenas de datos que se almacenan directamente en el navegador. Son parte del protocolo HTTP, definido por la especificación RFC 6265.",
	"content": "Las cookies son pequeñas cadenas de datos que se almacenan directamente en el navegador. Son parte del protocolo HTTP, definido por la especificación RFC 6265.
Las cookies son usualmente establecidos por un servidor web utilizando la cabecera de respuesta HTTP Set-Cookie. Entonces, el navegador los agrega automáticamente a (casi) toda solicitud del mismo dominio usando la cabecera HTTP Cookie.
Uno de los casos de uso más difundidos es la autenticación:

Al  iniciar sesión, el servidor usa la cabecera HTTP Set-Cookie en respuesta para establecer una cookie con un “identificador de sesión” único.
Al enviar la siguiente solicitud al mismo dominio, el navegador envía la cookie usando la cabecera HTTP Cookie.
Así el servidor sabe quién hizo la solicitud.

También podemos acceder a las cookies desde el navegador usando la propiedad document.cookie.
Hay muchas cosas intrincadas acerca de las cookies y sus opciones. En este artículo las vamos a ver en detalle.
Leyendo a document.cookie¿Puede tu navegador almacenar cookies de este sitio? Veamos:

      
        
        
          
            
          
          
            
          
        
        
          // En javascript.info, usamos Google Analytics para estadísticas,
// así que debería haber algunas cookies
alert( document.cookie ); // cookie1=value1; cookie2=value2;...
        
      
      
      El valor de document.cookie consiste de pares name=value delimitados por ;. Cada uno es una cookie separada.
Para encontrar una cookie particular, podemos separar (split) document.cookie por ; y encontrar el nombre correcto. Podemos usar tanto una expresión regular como funciones de array para ello.
Lo dejamos como ejercicio para el lector. Al final del artículo encontrarás funciones de ayuda para manipular cookies.
Escribiendo en document.cookiePodemos escribir en document.cookie. Pero no es una propiedad de datos, es un accessor (getter/setter). Una asignación a él se trata especialmente.
Una operación de escritura a document.cookie actualiza solo las cookies mencionadas en ella, y no toca las demás.
Por ejemplo, este llamado establece una cookie con el nombre user y el valor John:

      
        
        
          
            
          
          
            
          
        
        
          document.cookie = "user=John"; // modifica solo la cookie llamada 'user'
alert(document.cookie); // muestra todas las cookies
        
      
      
      Si lo ejecutas, probablemente verás múltiples cookies. Esto es porque la operación document.cookie= no sobrescribe todas las cookies. Solo configura la cookie mencionada user.
Técnicamente, nombre y valor pueden tener cualquier carácter. Pero para mantener un formato válido, los caracteres especiales deben escaparse usando la función integrada encodeURIComponent:

      
        
        
          
            
          
          
            
          
        
        
          // los caracteres especiales (espacios), necesitan codificarse
let name = "my name";
let value = "John Smith"

// codifica la cookie como my%20name=John%20Smith
document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value);

alert(document.cookie); // ...; my%20name=John%20Smith
        
      
      
      
            Limitaciones
            Hay algunas limitaciones:

El par name=value, después de encodeURIComponent, no debe exceder 4KB. Así que no podemos almacenar algo enorme en una cookie.
La cantidad total de cookies por dominio está limitada a alrededor de 20+, el límite exacto depende del navegador.


Las cookies tienen varias opciones, muchas de ellas importantes y deberían ser configuradas.
Las opciones son listadas después de key=value, delimitadas por un ;:

      
        
        
          
            
          
          
            
          
        
        
          document.cookie = "user=John; path=/; expires=Tue, 19 Jan 2038 03:14:07 GMT"
        
      
      
      path
path=/mypath

La ruta del prefijo path debe ser absoluto. Esto hace la cookie accesible a las páginas bajo esa ruta. La forma predeterminada es la ruta actual.
Si una cookie es establecida con path=/admin, será visible en las páginas /admin y /admin/something, pero no en /home o /adminpage.
Usualmente, debemos configurarlo en la raíz: path=/ para hacer la cookie accesible a todas las páginas del sitio web.
domain
domain=site.com

Un dominio define dónde la cookie es accesible. Aunque en la práctica hay limitaciones y no podemos configurar cualquier dominio.
No hay forma de hacer que una cookie sea accesible desde otro dominio de segundo nivel, entonces other.com nunca recibirá una cookie establecida en site.com.
Es una restricción de seguridad, para permitirnos almacenar datos sensibles en cookies que deben estar disponibles para un único sitio solamente.
De forma predeterminada, una cookie solo es accesible en el dominio que la establece.
Pero por favor toma nota: de forma predeterminada una cookie tampoco es compartida por un subdominio, como forum.site.com.

      
        
        
          // en site.com
document.cookie = "user=John"

// en forum.site.com
alert(document.cookie); // no user
        
      
      
      …aunque esto puede cambiarse. Si queremos permitir que un subdominio como forum.site.com obtenga una cookie establecida por site.com, eso es posible.
Para ello, cuando establecemos una cookie en site.com, debemos configurar explícitamente la raíz del dominio en la opción domain: domain=site.com. Entonces todos los subdominios verán la cookie.
Por ejemplo:

      
        
        
          // en site.com
// hacer la cookie accesible en cualquier subdominio *.site.com:
document.cookie = "user=John; domain=site.com"

// ...luego

// en forum.site.com
alert(document.cookie); // tiene la cookie user=John
        
      
      
      Por razones históricas, domain=.site.com (con un punto antes de site.com) también funciona de la misma forma, permitiendo acceso a la cookie desde subdominios. Esto es una vieja notación y debe ser usada si necesitamos dar soporte a navegadores muy viejos.
Entonces: la opción domain permite que las cookies sean accesibles en los subdominios.
expires, max-ageDe forma predeterminada, si una cookie no tiene una de estas opciones, desaparece cuando el navegador se cierra. Tales cookies se denominan “cookies de sesión”.
Para que las cookies sobrevivan al cierre del navegador, podemos usar las opciones expires o max-age.

expires=Tue, 19 Jan 2038 03:14:07 GMT

La fecha de expiración define el momento en que el navegador la borra automáticamente.
La fecha debe estar exactamente en ese formato, en el huso horario GMT. Podemos obtenerlo con date.toUTCString. Por ejemplo, podemos configurar que la cookie expire en un día:

      
        
        
          // +1 día desde ahora
let date = new Date(Date.now() + 86400e3);
date = date.toUTCString();
document.cookie = "user=John; expires=" + date;
        
      
      
      Si establecemos expires en una fecha en el pasado, la cookie es eliminada.

max-age=3600

max-age es una alternativa a expires y especifica la expiración de la cookie en segundos desde el momento actual.
Si la configuramos a cero o un valor negativo, la cookie es eliminada:

      
        
        
          // la cookie morirá en +1 hora a partir de ahora
document.cookie = "user=John; max-age=3600";

// borra la cookie (la hacemos expirar ya)
document.cookie = "user=John; max-age=0";
        
      
      
      secure
secure

La cookie debe ser transferida solamente a través de HTTPS.
De forma predeterminada, si establecemos una cookie en http://site.com, entonces también aparece en https://site.com y viceversa.
Esto es, las cookies están basadas en el dominio, no distinguen entre protocolos.
Con la opción secure, si una cookie se establece por https://site.com, entonces no aparecerá cuando el mismo sitio es accedido por HTTP, como http://site.com. Entonces, si una cookie tiene información sensible que nunca debe ser enviada sobre HTTP sin encriptar, debe configurarse secure.

      
        
        
          // asumiendo que estamos en https:// ahora
// configuramos la cookie para ser segura (solo accesible sobre HTTPS)
document.cookie = "user=John; secure";
        
      
      
      samesiteEste es otro atributo de seguridad. samesite sirve para proteger contra los ataques llamados XSRF (falsificación de solicitud entre sitios, cross-site request forgery).
Para entender cómo funciona y su utilidad, veamos primero los ataques XSRF.
ataque XSRFImagina que tienes una sesión en el sitio bank.com. Esto es: tienes una cookie de autenticación para ese sitio. Tu navegador lo envía a bank.com en cada solicitud, así aquel te reconoce y ejecuta todas las operaciones financieras sensibles.
Ahora, mientras navegas la red en otra ventana, accidentalmente entras en otro sitio evil.com. Este sitio tiene código JavaScript que envía un formulario <form action="https://bank.com/pay"> a bank.com con los campos que inician una transacción a la cuenta el hacker.
El navegador envía cookies cada vez que visitas el sitio bank.com, incluso si el form fue enviado desde evil.com. Entonces el banco te reconoce y realmente ejecuta el pago.

      
      
        
      
      Ese es el ataque llamado “Cross-Site Request Forgery” (XSRF).
Los bancos reales están protegidos contra esto por supuesto. Todos los formularios generados por bank.com tienen un campo especial, llamado “token de protección XSRF”, que una página maliciosa no puede generar o extraer desde una página remota. Puede enviar el form, pero no obtiene respuesta a la solicitud. El sitio bank.com verifica tal token en cada form que recibe.
Tal protección toma tiempo para implementarla. Necesitamos asegurarnos de que cada form tiene dicho campo token, y debemos verificar todas las solicitudes.
Opción de cookie samesiteLa opción samesite brinda otra forma de proteger tales ataques, que (en teoría) no requiere el “token de protección XSRF”.
Tiene dos valores posibles:

samesite=strict (lo mismo que samesite sin valor)

Una cookie con samesite=strict nunca es enviada si el usuario viene desde fuera del mismo sitio.
En otras palabras, si el usuario sigue un enlace desde su correo, envía un form desde evil.com, o hace cualquier operación originada desde otro dominio, la cookie no será enviada.
Si las cookies de autenticación tienen la opción samesite, un ataque XSRF no tiene posibilidad de éxito porque el envío de evil.com llega sin cookies. Así bank.com no reconoce el usuario y no procederá con el pago.
La protección es muy confiable. Solo las operaciones que vienen de bank.com enviarán la cookie samesite, por ejemplo un form desde otra página de bank.com.
Aunque hay un pequeño inconveniente.
Cuando el usuario sigue un enlace legítimo a bank.com, por ejemplo desde sus propio correo, será sorprendido con que bank.com no lo reconoce. Efectivamente, las cookies samesite=strict no son enviadas en ese caso.
Podemos sortear esto usando dos cookies: una para el “reconocimiento general”, con el solo propósito de decir: “Hola, John”, y la otra para operaciones de datos con samesite=strict. Entonces, la persona que venga desde fuera del sitio llega a la página de bienvenida, pero los pagos serán iniciados desde dentro del sitio web del banco, entonces la segunda cookie sí será enviada.

samesite=lax

Un enfoque más laxo que también protege de ataques XSRF y no afecta la experiencia de usuario.
El modo lax, como strict, prohíbe al navegador enviar cookies cuando viene desde fuera del sitio, pero agrega una excepción.
Una cookie samesite=lax es enviada si se cumplen dos condiciones:


El método HTTP es seguro (por ejemplo GET, pero no POST).
La lista completa de métodos seguros HTTP está en la especificación RFC7231. Básicamente son métodos usados para leer, pero no escribir datos. Los que no ejecutan ninguna operación de alteración de datos. Seguir un enlace es siempre GET, el método seguro.


La operación ejecuta una navegación del más alto nivel (cambia la URL en la barra de dirección del navegador).
Esto es usualmente verdad, pero si la navegación en ejecutada dentro de un <iframe>, entonces no es de alto nivel. Tampoco encajan aquí los métodos JavaScript para solicitudes de red porque no ejecutan ninguna navegación.


Entonces, lo que hace samesite=lax es básicamente permitir la operación más común “ir a URL” para obtener cookies. Por ejemplo, abrir un sitio desde la agenda satisface estas condiciones.
Pero cualquier cosa más complicada, como solicitudes de red desde otro sitio, o un “form submit”, pierde las cookies.
Si esto es adecuado para ti, entonces agregar samesite=lax probablemente no dañe la experiencia de usuario y agrega protección.
Por sobre todo, samesite es una excelente opción.
Tiene una importante debilidad:

samesite es ignorado (no soportado) por navegadores viejos, de alrededor de 2017.

Así que si solo confiamos en samesite para brindar protección, habrá navegadores que serán vulnerables.
Pero con seguridad podemos usar samesite, junto con otras medidas de protección como los tokens xsrf, para agregar una capa adicional de defensa. En el futuro probablemente podamos descartar la necesidad de tokens xsrf.
httpOnlyEsta opción no tiene nada que ver con JavaScript, pero tenemos que mencionarla para completar la guía.
El servidor web usa la cabecera Set-Cookie para establecer la cookie. También puede configurar la opción httpOnly.
Esta opción impide a JavaScript el acceso a la cookie. No podemos ver ni manipular tal cookie usando document.cookie.
Esto es usado como medida de precaución, para proteger de ciertos ataques donde el hacker inyecta su propio código en una página y espera que el usuario visite esa página. Esto no debería ser posible en absoluto, los hackers bo deberían poder insertar su código en nuestro sitio, pero puede haber bugs que les permite hacerlo.
Normalmente, si eso sucede y el usuario visita una página web con el código JavaScript del hacker, entonces ese código se ejecuta y gana acceso a document.cookie con las cookies del usuario conteniendo información de autenticación. Eso es malo.
Pero si una cookie es httpOnly, document.cookie no la ve y está protegida.
Apéndice: Funciones de cookiesAquí hay un pequeño conjunto de funciones para trabajar con cookies, más conveniente que la modificación manual de document.cookie.
Existen muchas librerías de cookies para eso, asi que estas son para demostración solamente. Aunque completamente funcionales.
getCookie(name)La forma más corta de acceder a una cookie es usar una expresión regular.
La función getCookie(name) devuelve la cookie con el nombre name dado:

      
        
        
          // devuelve la cookie con el nombre dado,
// o undefined si no la encuentra
function getCookie(name) {
  let matches = document.cookie.match(new RegExp(
    "(?:^|; )" + name.replace(/([\.$?*|{}\(\)\[\]\\\/\+^])/g, '\\$1') + "=([^;]*)"
  ));
  return matches ? decodeURIComponent(matches[1]) : undefined;
}
        
      
      
      Aquí new RegExp se genera dinámicamente para coincidir ; name=<value>.
Nota que el valor de una cookie está codificado, entonces getCookie usa una función integrada decodeURIComponent para decodificarla.
setCookie(name, value, options)Establece el nombre de la cookie name al valor dado value, con la ruta por defecto path=/, y puede ser modificada para agregar otros valores predeterminados:

      
        
        
          
            
          
          
            
          
        
        
          function setCookie(name, value, options = {}) {

  options = {
    path: '/',
    // agregar otros valores predeterminados si es necesario
    ...options
  };

  if (options.expires instanceof Date) {
    options.expires = options.expires.toUTCString();
  }

  let updatedCookie = encodeURIComponent(name) + "=" + encodeURIComponent(value);

  for (let optionKey in options) {
    updatedCookie += "; " + optionKey;
    let optionValue = options[optionKey];
    if (optionValue !== true) {
      updatedCookie += "=" + optionValue;
    }
  }

  document.cookie = updatedCookie;
}

// Ejemplo de uso:
setCookie('user', 'John', {secure: true, 'max-age': 3600});
        
      
      
      deleteCookie(name)Para borrar una cookie, podemos llamarla con una fecha de expiración negativa:

      
        
        
          function deleteCookie(name) {
  setCookie(name, "", {
    'max-age': -1
  })
}
        
      
      
      
            La modificación o eliminación debe usar la misma ruta y dominio
            Por favor nota que cuando alteramos o borramos una cookie debemos usar exactamente el mismo “path” y “domain” que cuando la establecimos.

Completo: cookie.js.
Apéndice: Cookies de tercerosUna cookie es llamada “third-party” o “de terceros” si es colocada por un dominio distinto al de la página que el usuario está visitando.
Por ejemplo:


Una página en site.com carga un banner desde otro sitio: <img src="https://ads.com/banner.png">.


Junto con el banner, el servidor remoto en ads.com puede configurar la cabecera Set-Cookie con una cookie como id=1234. Tal cookie tiene origen en el dominio ads.com, y será visible solamente en ads.com:

      
      
        
      
      

La próxima vez que se accede a ads.com, el servidor remoto obtiene la cookie id y reconoce al usuario:

      
      
        
      
      

Lo que es más importante aquí, cuando el usuario cambia de site.com a otro sitio other.com que también tiene un banner, entonces ads.com obtiene la cookie porque pertenece a ads.com, reconociendo al visitante y su movimiento entre sitios:

      
      
        
      
      

Las cookies de terceros son tradicionalmente usados para rastreo y servicios de publicidad (ads) debido a su naturaleza. Ellas están vinculadas al dominio de origen, entonces ads.com puede rastrear al mismo usuario a través de diferentes sitios si ellos los acceden.
Naturalmente, a algunos no les gusta ser seguidos, así que los navegadores permiten deshabilitar tales cookies.
Además, algunos navegadores modernos emplean políticas especiales para tales cookies:

Safari no permite cookies de terceros en absoluto.
Firefox viene con una “lista negra” de dominios de terceros y bloquea las cookies de tales orígenes.


            Por favor tome nota:
            Si cargamos un script desde un dominio de terceros, como <script src="https://google-analytics.com/analytics.js">, y ese script usa document.cookie para configurar una cookie, tal cookie no es “de terceros”.
Si un script configura una cookie, no importa de dónde viene el script: la cookie pertenece al dominio de la página web actual.

Apéndice: GDPREste tópico no está relacionado a JavaScript en absoluto, solo es algo para tener en mente cuando configuramos cookies.
Hay una legislación en Europa llamada GDPR que es un conjunto de reglas que fuerza a los sitios web a respetar la privacidad del usuario. Una de estas reglas es requerir un permiso explícito del usuario para el uso de cookies de seguimiento.
Nota que esto solo se refiere a cookies de seguimiento, identificación y autorización.
Así que si queremos configurar una cookie que solo guarda alguna información pero no hace seguimiento ni identificación del usuario, somos libres de hacerlo.
Pero si vamos a configurar una  cookie con una sesión de autenticación o un id de seguimiento, el usuario debe dar su permiso.
Los sitios web generalmente tienen dos variantes para cumplir con el GDPR. Debes de haberlas visto en la web:


Si un sitio web quiere establecer cookies de seguimiento solo para usuarios autenticados.
Para hacerlo, el form de registro debe tener un checkbox como: “aceptar la política de privacidad” (que describe cómo las cookies son usadas), el usuario debe marcarlo, entonces el sitio web es libre para establecer cookies de autenticación.


Si un sitio web quiere establecer cookies de seguimiento a todo visitante.
Para hacerlo legalmente, el sitio web muestra un mensaje del tipo “pantalla de bienvenida (splash screen)” a los recién llegados que les pide aceptar las cookies. Entonces el sitio web puede configurarlas y les deja ver el contenido. Esto puede ser molesto para el visitante. A nadie le gusta que aparezca una pantalla modal con la obligación de cliquear en ella en lugar del contenido. Pero el GDPR requiere el acuerdo explícito.


El GDPR no trata solo de cookies, también es acerca de otros problemas relacionados a la privacidad, pero eso va más allá de nuestro objetivo.
Resumendocument.cookie brinda acceso a las cookies.

la operación de escritura modifica solo cookies mencionadas en ella.
nombre y valor deben estar codificados.
Una cookie no debe exceder los 4KB, y están limitadas a unas 20+ cookies por sitio (depende del navegador).

Opciones de Cookie:

path=/, por defecto la ruta actual, hace la cookie visible solo bajo esa ruta.
domain=site.com, por defecto una cookie es visible solo en el dominio actual. Si el domino se establece explícitamente, la cookie se hace visible a los subdominios.
expires o max-age configuran el tiempo de expiración de la cookie. Sin ellas la cookie muere cuando el navegador es cerrado.
secure hace la cookie solo para HTTPS.
samesite prohíbe al navegador enviar la cookie a solicitudes que vengan desde fuera del sitio. Esto ayuda a prevenir ataques XSRF.

Adicionalmente:

Las cookies de terceros pueden estar prohibidas por el navegador, por ejemplo Safari lo hace por defecto.
Cuando se configuran cookies de seguimiento para ciudadanos de la UE, la regulación GDPR requiere la autorización del usuario.

",
	"url": "https://es.javascript.info/cookie" 
},
{
	"docs_id": "150",
	"name": "LocalStorage, sessionStorage",
	"description": "Los objetos de almacenaje web localStorage y sessionStorage permiten guardar pares de clave/valor en el navegador.",
	"content": "Los objetos de almacenaje web localStorage y sessionStorage permiten guardar pares de clave/valor en el navegador.
Lo que es interesante sobre ellos es que los datos sobreviven a una recarga de página (en el caso de sessionStorage) y hasta un reinicio completo de navegador (en el caso de localStorage). Lo veremos en breve.
Ya tenemos cookies. ¿Por qué tener objetos adicionales?

Al contrario que las cookies, los objetos de almacenaje web no se envían al servidor en cada petición. Debido a esto, podemos almacenar mucha más información. La mayoría de los navegadores modernos permiten almacenar, como mínimo, 5 megabytes de datos y tienen opciones para configurar estos límites.
También diferente de las cookies es que el servidor no puede manipular los objetos de almacenaje via cabeceras HTTP, todo se hace via JavaScript.
El almacenaje está vinculado al orígen (al triplete dominio/protocolo/puerto). Esto significa que distintos protocolos o subdominios tienen distintos objetos de almacenaje, no pueden acceder a otros datos que no sean los suyos.

Ambos objetos de almacenaje proveen los mismos métodos y propiedades:

setItem(clave, valor) – almacenar un par clave/valor.
getItem(clave) – obtener el valor por medio de la clave.
removeItem(clave) – eliminar la clave y su valor.
clear() – borrar todo.
key(índice) – obtener la clave de una posición dada.
length – el número de ítems almacenados.

Como puedes ver, es como una colección Map (setItem/getItem/removeItem), pero también permite el acceso a través de index con key(index).
Vamos a ver cómo funciona.
Demo de localStorageLas principales funcionalidades de localStorage son:

Es compartido entre todas las pestañas y ventanas del mismo origen.
Los datos no expiran. Persisten a los reinicios de navegador y hasta del sistema operativo.

Por ejemplo, si ejecutas éste código…

      
        
        
          
            
          
          
            
          
        
        
          localStorage.setItem('test', 1);
        
      
      
      … y cierras/abres el navegador, o simplemente abres la misma página en otra ventana, puedes coger el ítem que hemos guardado de este modo:

      
        
        
          
            
          
          
            
          
        
        
          alert( localStorage.getItem('test') ); // 1
        
      
      
      Solo tenemos que estar en el mismo dominio/puerto/protocolo, la url puede ser distinta.
localStorage es compartido por toda las ventanas del mismo origen, de modo que si guardamos datos en una ventana, el cambio es visible en la otra.
Acceso tipo ObjetoTambién podemos utilizar un modo de acceder/guardar claves del mismo modo que se hace con objetos, así:

      
        
        
          
            
          
          
            
          
        
        
          // guarda una clave
localStorage.test = 2;

// coge una clave
alert( localStorage.test ); // 2

// borra una clave
delete localStorage.test;
        
      
      
      Esto se permite por razones históricas, y principalmente funciona, pero en general no se recomienda por dos motivos:


Si la clave es generada por el usuario, puede ser cualquier cosa, como length o toString, u otro método propio de localStorage. En este caso getItem/setItem funcionan correctamente, pero el acceso de simil-objeto falla;

      
        
        
          
            
          
          
            
          
        
        
          let key = 'length';
localStorage[key] = 5; // Error, no se puede asignar 'length'
        
      
      
      

Existe un evento storage, que se dispara cuando modificamos los datos. Este evento no se dispara si utilizamos el acceso tipo objeto. Lo veremos más tarde en este capítulo.


Iterando sobre las clavesLos métodos proporcionan la funcionalidad get / set / remove. ¿Pero cómo conseguimos todas las claves o valores guardados?
Desafortunadamente, los objetos de almacenaje no son iterables.
Una opción es utilizar iteración sobre un array:

      
        
        
          
            
          
          
            
          
        
        
          for(let i=0; i<localStorage.length; i++) {
  let key = localStorage.key(i);
  alert(`${key}: ${localStorage.getItem(key)}`);
}
        
      
      
      Otra opción es utilizar el loop específico para objetos for key in localStorage tal como hacemos en objetos comunes.
Esta opción itera sobre las claves, pero también devuelve campos propios de localStorage que no necesitamos:

      
        
        
          
            
          
          
            
          
        
        
          // mal intento
for(let key in localStorage) {
  alert(key); // muestra getItem, setItem y otros campos que no nos interesan
}
        
      
      
      … De modo que necesitamos o bien filtrar campos des del prototipo con la validación hasOwnProperty:

      
        
        
          
            
          
          
            
          
        
        
          for(let key in localStorage) {
  if (!localStorage.hasOwnProperty(key)) {
    continue; // se salta claves como "setItem", "getItem" etc
  }
  alert(`${key}: ${localStorage.getItem(key)}`);
}
        
      
      
      … O simplemente acceder a las claves “propias” con Object.keys y iterar sobre éstas si es necesario:

      
        
        
          
            
          
          
            
          
        
        
          let keys = Object.keys(localStorage);
for(let key of keys) {
  alert(`${key}: ${localStorage.getItem(key)}`);
}
        
      
      
      Esta última opción funciona, ya que Object.keys solo devuelve las claves que pertenecen al objeto, ignorando el prototipo.
Solo stringsHay que tener en cuenta que tanto la clave como el valor deben ser strings.
Cualquier otro tipo, como un número o un objeto, se convierte a cadena de texto automáticamente:

      
        
        
          
            
          
          
            
          
        
        
          localStorage.user = {name: "John"};
alert(localStorage.user); // [object Object]
        
      
      
      A pesar de eso, podemos utilizar JSON para almacenar objetos:

      
        
        
          
            
          
          
            
          
        
        
          localStorage.user = JSON.stringify({name: "John"});

// en algún momento más tarde
let user = JSON.parse( localStorage.user );
alert( user.name ); // John
        
      
      
      También es posible pasar a texto todo el objeto de almacenaje, por ejemplo para debugear:

      
        
        
          
            
          
          
            
          
        
        
          // se ha añadido opciones de formato a JSON.stringify para que el objeto se lea mejor
alert( JSON.stringify(localStorage, null, 2) );
        
      
      
      sessionStorageEl objeto sessionStorage se utiliza mucho menos que localStorage.
Las propiedades y métodos son los mismos, pero es mucho más limitado:

sessionStorage solo existe dentro de la pestaña actual del navegador.

Otra pestaña con la misma página tendrá un almacenaje distinto.
Pero se comparte entre iframes en la pestaña (asumiendo que tengan el mismo orígen).


Los datos sobreviven un refresco de página, pero no cerrar/abrir la pestaña.

Vamos a verlo en acción.
Ejecuta éste código…

      
        
        
          
            
          
          
            
          
        
        
          sessionStorage.setItem('test', 1);
        
      
      
      … Y recarga la página. Aún puedes acceder a los datos:

      
        
        
          
            
          
          
            
          
        
        
          alert( sessionStorage.getItem('test') ); // después de la recarga: 1
        
      
      
      … Pero si abres la misma página en otra pestaña, y lo intentas de nuevo, el código anterior devuelve null, que significa que no se ha encontrado nada.
Esto es exactamente porque sessionStorage no está vinculado solamente al orígen, sino también a la pestaña del navegador. Por ésta razón sessionStorage se usa relativamente poco.
Evento storageCuando los datos se actualizan en localStorage o en sessionStorage, se dispara el evento storage con las propiedades:

key – la clave que ha cambiado, (null si se llama .clear()).
oldValue – el anterior valor (null si se añade una clave).
newValue – el nuevo valor (null si se borra una clave).
url – la url del documento donde ha pasado la actualización.
storageArea – bien el objeto localStorage o sessionStorage, donde se ha producido la actualización.

El hecho importante es: el evento se dispara en todos los objetos window donde el almacenaje es accesible, excepto en el que lo ha causado.
Vamos a desarrollarlo.
Imagina que tienes dos ventanas con el mismo sitio en cada una, de modo que localStorage es compartido entre ellas.
Quizá quieras abrir ésta página en dos ventanas distintas para probar el código que sigue.
Si ambas ventanas están escuchando el evento window.onstorage, cada una reaccionará a las actualizaciones que pasen en la otra.

      
        
        
          
            
          
          
            
          
        
        
          // se dispara en actualizaciones hechas en el mismo almacenaje, desde otros documentos
window.onstorage = event => {  // también puede usar window.addEventListener('storage', event => {
  if (event.key != 'now') return;
  alert(event.key + ':' + event.newValue + " at " + event.url);
};

localStorage.setItem('now', Date.now());
        
      
      
      Hay que tener en cuenta que el evento también contiene: event.url – la url del documento en que se actualizaron los datos.
También que event.storageArea contiene el objeto de almacenaje – el evento es el mismo para sessionStorage y localStorage --, de modo que storageArea referencia el que se modificó. Podemos hasta querer cambiar datos en él, para “responder” a un cambio.
Esto permite que distintas ventanas del mismo orígen puedan intercambiar mensajes.
Los navegadores modernos también soportan la API de Broadcast channel API, la API específica para la comunicación entre ventanas del mismo orígen. Es más completa, pero tiene menos soporte. Hay librerías que añaden polyfills para ésta API basados en localStorage para que se pueda utilizar en cualquier entorno.
ResumenLos objetos de almacenaje web localStorage y sessionStorage permiten guardar pares de clave/valor en el navegador.

Tanto la clave como el valor deben ser strings.
El límite es de más de 5mb+, dependiendo del navegador.
No expiran.
Los datos están vinculados al origen (dominio/puerto/protocolo).




localStorage
sessionStorage




Compartida entre todas las pestañas y ventanas que tengan el mismo orígen
Accesible en una pestaña del navegador, incluyendo iframes del mismo origen


Sobrevive a reinicios del navegador
Muere al cerrar la pestaña



API:

setItem(clave, valor) – guarda pares clave/valor.
getItem(clave) – coge el valor de una clave.
removeItem(clave) – borra una clave con su valor.
clear() – borra todo.
key(índice) – coge la clave en una posición determinada.
length – el número de ítems almacenados.
Utiliza Object.keys para conseguir todas las claves.
Puede utilizar las claves como propiedades de objetor, pero en ese caso el evento storage no se dispara

Evento storage:

Se dispara en las llamadas a setItem, removeItem, clear.
Contiene todos los datos relativos a la operación (key/oldValue/newValue), la url del documento y el objeto de almacenaje.
Se dispara en todos los objetos window que tienen acceso al almacenaje excepto el que ha generado el evento (en una pestaña en el caso de sessionStorage o globalmente en el caso de localStorage).

TareasGuardar automáticamente un campo de formularioCrea un campo textarea que “autoguarde” sus valores en cada cambio.
Entonces, si el usuario cierra accidentalmente la página y la abre de nuevo, encontrará su entrada inacabada en su lugar.
Como esto:

    
    
  Abrir un entorno controlado para la tarea.soluciónAbrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/localstorage" 
},
{
	"docs_id": "151",
	"name": "IndexedDB",
	"description": "IndexedDB es una base de datos construida dentro del navegador, mucho más potente que localStorage.",
	"content": "IndexedDB es una base de datos construida dentro del navegador, mucho más potente que localStorage.

Almacena casi todo tipo de valores por claves, tipos de clave múltiple.
Soporta transacciones para confiabilidad.
Soporta consultas de rango por clave, e índices.
Puede almacenar mucho mayor volumen de datos que localStorage.

Toda esta potencia es normalmente excesiva para las aplicaciones cliente-servidor tradicionales. IndexedDB está previsto para aplicaciones fuera de línea, para ser combinado con ServiceWorkers y otras tecnologías.
La interfaz nativa de IndexedDB, descrita en la https://www.w3.org/TR/IndexedDB, está basada en eventos.
También podemos usar async/await con la ayuda de un contenedor basado en promesas como idb https://github.com/jakearchibald/idb. Aunque esto es muy conveniente, hay que tener en cuenta que el contenedor no es perfecto y no puede reemplazar a los eventos en todos los casos. Así que comenzaremos con eventos y, cuando hayamos avanzado en el entendimiento de IndexedDb, usaremos el contenedor.

            ¿Dónde están los datos?
            Técnicamente, los datos son almacenados bajo el directorio raíz del usuario junto con la configuración personal del navegador, extensiones, etc.
Navegadores y usuarios diferentes tendrán cada uno su propio almacenamiento independiente.

Apertura de una base de datos, “open”Para empezar a trabajar con IndexedDB, primero necesitamos conectarnos o “abrir” (open) una base de datos.
La sintaxis:

      
        
        
          let openRequest = indexedDB.open(name, version);
        
      
      
      
name – un string, el nombre de la base de datos.
version – un entero positivo, predeterminado en 1 (explicado más abajo).

Podemos tener muchas bases de datos con nombres diferentes, pero todas ellas existen dentro del mismo origen (dominio/protocolo/puerto). Un sitio web no puede acceder bases de datos de otro.
La llamada devuelve un objeto openRequest, debemos escuchar en él los eventos:

success: la base de datos está lista. Hay un “objeto database” en openRequest.result que habremos de usar en las llamadas subsiguientes.
error: Apertura fallida.
upgradeneeded: La base de datos está lista, pero su versión es obsoleta (ver abajo).

IndexedDB tiene incorporado un mecanismo de “versión de esquema”, ausente en bases de datos de servidor.
A diferencia de las bases de datos del lado del servidor, IndexedDB se ejecuta en el lado del cliente y los datos son almacenados en el navegador, así que nosotros, desarrolladores, no tenemos acceso permanente a esas bases. Entonces, cuando publicamos una nueva versión de nuestra app y el usuario visita nuestra página web, podemos necesitar actualizar la estructura de su base de datos.
Si la versión de la base es menor a la especificada en open, entonces se dispara un evento especial upgradeneeded (actualización-requerida), donde podemos comparar versiones y hacer la actualización de la estructura de datos que se necesite.
El evento upgradeneeded también se dispara cuando la base aún no existe (técnicamente, su versión es 0), lo cual nos permite llevar a cabo su inicialización.
Digamos que publicamos la primera versión de nuestra app.
Entonces podemos abrir la base con version 1 y hacer la inicialización en un manejador upgradeneeded:

      
        
        
          let openRequest = indexedDB.open("store", 1);

openRequest.onupgradeneeded = function() {
  // se dispara si el cliente no tiene la base de datos
  // ...ejecuta la inicialización...
};

openRequest.onerror = function() {
  console.error("Error", openRequest.error);
};

openRequest.onsuccess = function() {
  let db = openRequest.result;
  // continúa trabajando con la base de datos usando el objeto db
};
        
      
      
      Luego, más tarde, publicamos la segunda versión.
Podemos abrirla con version 2 y ejecutar la actualización así:

      
        
        
          let openRequest = indexedDB.open("store", 2);

openRequest.onupgradeneeded = function(event) {
  // la versión de la base existente es menor que 2 (o ni siquiera existe)
  let db = openRequest.result;
  switch(event.oldVersion) { // versión de db existente
    case 0:
      // version 0 significa que el cliente no tiene base de datos
      // ejecutar inicialización
    case 1:
      // el cliente tiene la versión 1
      // actualizar
  }
};
        
      
      
      Tenlo en cuenta: como nuestra versión actual es 2, el manejador onupgradeneeded tiene una rama de código para la versión 0, adecuada para usuarios que acceden por primera vez y no tienen una base de datos, y otra rama para la versión 1, para su actualización.
Entonces, y solamente si el manejador de onupgradeneeded finaliza sin errores, se dispara el evento openRequest.onsuccess y se considera que la base de datos fue abierta con éxito.
Para borrar una base de datos:

      
        
        
          let deleteRequest = indexedDB.deleteDatabase(name)
// deleteRequest.onsuccess/onerror rastrea el resultado
        
      
      
      
            No se puede abrir una base de datos usando una versión más vieja de open
            Si la base del usuario tiene una versión mayor que el open que la abre, por ejemplo: la base existente tiene versión 3 e intentamos open(...2), se producirá un error que disparará openRequest.onerror.
Es una situación rara pero puede ocurrir cuando un visitante carga código JavaScript viejo, por ejemplo desde un caché proxy. Así el código es viejo pero la base de datos nueva.
Para prevenir errores, debemos verificar db.version y sugerir la recarga de página. Usa cabeceras HTTP de caché apropiadas para evitar la carga de código viejo, así nunca tendrás tales problemas.

El problema de la actualización paralelaHablando de versionado, encaremos un pequeño problema relacionado.
Supongamos que:

Un visitante, en una pestaña de su navegador, abrió nuestro sitio con un base de datos con la versión 1.
Luego publicamos una actualización, así que nuestro código es más reciente.
Y el mismo visitante abre nuestro sitio en otra pestaña.

Entonces hay una primera pestaña con una conexión abierta a una base con versión 1, mientras la segunda intenta actualizarla a la versión 2 en su manejador upgradeneeded.
El problema es que la misma base está compartida entre las dos pestañas, por ser del mismo sitio y origen. Y no puede ser versión 1 y 2 al mismo tiempo. Para ejecutar la actualización a la versión 2, todas las conexiones a la versión 1 deben ser cerradas, incluyendo las de la primera pestaña.
Para detectar estas situaciones, se dispara automáticamente el evento versionchange (cambio-de-versión) en el objeto de base de datos. Debemos escuchar dicho evento y cerrar la conexión vieja (y probablemente sugerir una recarga de página, para cargar el código actualizado).
Si no escuchamos el evento versionchange y no cerramos la conexión vieja, entonces la segunda y más nueva no se podrá hacer. El objeto openRequest emitirá el evento blocked en lugar de success. Entonces la segunda pestaña no funcionará.
Aquí tenemos el código para manejar correctamente la actualización paralela. Este instala un manejador onversionchange que se dispara si la conexión actual queda obsoleta y la cierra (la versión se actualiza en algún otro lado):

      
        
        
          let openRequest = indexedDB.open("store", 2);

openRequest.onupgradeneeded = ...;
openRequest.onerror = ...;

openRequest.onsuccess = function() {
  let db = openRequest.result;

  db.onversionchange = function() {
    db.close();
    alert("La base de datos está desactualizada, por favor recargue la página.")
  };

  // ...la base db está lista, úsala...
};

openRequest.onblocked = function() {
  // este evento no debería dispararse si hemos manejado onversionchange correctamente

  // significa que hay otra conexión abierta a la misma base
  // que no fue cerrada después de que se disparó db.onversionchange
};
        
      
      
      Aquí hacemos dos cosas:

La escucha a db.onversionchange nos informa de un intento de actualización paralela si la conexión actual se volvió obsoleta.
La escucha a openRequest.onblocked nos informa de la situación opuesta: hay una conexión obsoleta en algún otro lugar que no fue cerrada y por eso la conexión nueva no se pudo realizar.

Podemos manejar las cosas más suavemente en db.onversionchange, como pedirle al visitante que guarde los datos antes de cerrar la conexión.
Como alternativa podríamos no cerrar la base en db.onversionchange sino usar onblocked de la nueva pestaña para advertirle que no puede crear una nueva conexión hasta que cierre las viejas.
Estas colisiones ocurren raramente, pero deberíamos tener algún manejo de ella, como mínimo un manejador onblocked para evitar que nuestro script muera silenciosamente.
Almacén de objetos, “store”Para almacenar algo en IndexedDB, necesitamos un “almacén de objetos” object store.
Un almacén de objetos es un concepto central de IndexedDB. Equivale a lo que en otras bases de datos se denominan “tablas” o “colecciones”. Es donde los datos son almacenados. Una base de datos puede tener múltiples almacenes: uno para usuarios, otro para bienes, etc.
A pesar de llamarse “almacén de objetos”, también puede almacenar tipos primitivos.
Podemos almacenar casi cualquier valor, incluyendo objetos complejos.
IndexedDB usa el algoritmo de serialización estándar para clonar-y-almacenar un objeto. Es como JSON.stringify pero más poderoso, capaz de almacenar muchos tipos de datos más.
Hay objetos que no pueden ser almacenados, por ejemplo los que tienen referencias circulares. Tales objetos no son serializables. JSON.stringify también falla con ellos.
Debe haber una clave key única para cada valor del almacén.
Una clave debe ser de uno de estos tipos: number, date, string, binary, o array. Es un identificador único, así podemos buscar/borrar/modificar valores por medio de la clave.

      
      
        
      
      Como veremos pronto, cuando agregamos un valor al almacén podemos proporcionarle una clave, de forma similar a localStorage. Pero cuando lo que almacenamos son objetos, IndexedDB permite asignar una propiedad del objeto como clave, lo que es mucho más conveniente. También podemos usar claves que se generan automáticamente.
Pero primero, necesitamos crear el almacén de objetos.
La sintaxis para crear un almacén de objetos u “object store”:

      
        
        
          db.createObjectStore(name[, keyOptions]);
        
      
      
      Ten en cuenta que esta operación es sincrónica, no requiere await.

name es el nombre del almacén, por ejemplo "books",
keyOptions es un objeto opcional con una de estas dos propiedades:

keyPath – la ruta a una propiedad del objeto que IndexedDB usará como clave, por ejemplo id.
autoIncrement – si es true, la clave para el objeto nuevo que se almacene se generará automáticamente con un número autoincremental.



Si no establecemos keyOptions, necesitaremos proporcionar una clave explícitamente más tarde: al momento de almacenar un objeto.
Por ejemplo, este objeto usa la propiedad id como clave:

      
        
        
          db.createObjectStore('books', {keyPath: 'id'});
        
      
      
      Un almacén de objetos solo puede ser creado o modificado durante la actualización de su versión, esto es, en el manejador upgradeneeded.
Esto es una limitación técnica. Fuera del manejador podremos agregar/borrar/modificar los datos, pero los almacenes de objetos solo pueden ser creados/borrados/alterados durante la actualización de versión.
Para hacer una actualización de base de datos, hay principalmente dos enfoques:

Podemos implementar una función de actualización por versión: desde 1 a 2, de 2 a 3, de 3 a 4, etc. Así en upgradeneeded podemos comparar versiones (ejemplo: vieja 2, ahora 4) y ejecutar actualizaciones por versión paso a paso para cada versión intermedia (en el ejemplo: 2 a 3, luego 3 a 4).
O podemos simplemente examinar la base y alterarla en un paso. Obtenemos una lista de los almacenes existentes como db.objectStoreNames. Este objeto es un DOMStringList que brinda el método contains(name) para chequear existencias. Y podemos entonces hacer actualizaciones dependiendo de lo que existe y lo que no.

En bases de datos pequeñas la segunda variante puede ser más simple.
Aquí hay un demo del segundo enfoque:

      
        
        
          let openRequest = indexedDB.open("db", 2);

// crea/actualiza la base de datos sin chequeo de versiones
openRequest.onupgradeneeded = function() {
  let db = openRequest.result;
  if (!db.objectStoreNames.contains('books')) { // si no hay un almacén de libros ("books"),
    db.createObjectStore('books', {keyPath: 'id'}); // crearlo
  }
};
        
      
      
      Para borrar un almacén de objetos:

      
        
        
          db.deleteObjectStore('books')
        
      
      
      TransaccionesEl término transacción es genérico, usado por muchos tipos de bases de datos.
Una transacción es un grupo de operaciones cuyos resultados están vinculados: todas deben ser exitosas o todas fallar.
Por ejemplo, cuando una persona compra algo, necesitamos:

Restar el dinero de su cuenta personal.
Agregar el ítem a su inventario.

Sería muy malo que si se completara la primera operación y algo saliera mal (como un corte de luz), fallara la segunda. Ambas deberían ser exitosas (compra completa, ¡bien!) o ambas fallar (al menos la persona mantuvo su dinero y puede reintentar).
Las transacciones garantizan eso.
Todas las operaciones deben ser hechas dentro de una transacción en IndexedDB.
Para iniciar una transacción:

      
        
        
          db.transaction(store[, type]);
        
      
      
      
store – el nombre de almacén al que la transacción va a acceder, por ejemplo "books". Puede ser un array de nombres de almacenes si vamos a acceder a múltiples almacenes.
type – el tipo de transacción, uno de estos dos:

readonly – solo puede leer (es el predeterminado).
readwrite – puede leer o escribir datos (pero no crear/quitar/alterar almacenes de objetos).



También existe el tipo de transacción versionchange: tal transacción puede hacer de todo, pero no podemos crearla nosotros a mano. IndexedDB la crea automáticamente cuando abre la base de datos para el manejador upgradeneeded. Por ello, es el único lugar donde podemos actualizar la estructura de base de datos, crear o quitar almacenes de objetos.

            ¿Por qué hay diferentes tipos de transacciones?
            El rendimiento es la razón por la que necesitamos identificar las transacciones como readonly (lectura solamente) o readwrite (lectura y escritura).
Muchas transacciones readonly pueden leer en un mismo almacén concurrentemente, en cambio las transacciones de escritura readwrite, no. Una transacción readwrite bloquea el almacén para escribir en él. La siguiente transacción debe esperar a que la anterior termine antes de acceder al mismo almacén.

Una vez que la transacción ha sido creada, podemos agregar un ítem al almacén:

      
        
        
          let transaction = db.transaction("books", "readwrite"); // (1)

// obtiene un almacén de objetos para operar con él
let books = transaction.objectStore("books"); // (2)

let book = {
  id: 'js',
  price: 10,
  created: new Date()
};

let request = books.add(book); // (3)

request.onsuccess = function() { // (4)
  console.log("Libro agregado al almacén", request.result);
};

request.onerror = function() {
  console.log("Error", request.error);
};
        
      
      
      Básicamente, hay cuatro pasos:

Crea una transacción, mencionando todos los almacenes a los que irá a acceder, en (1).
Obtiene el almacén usando transaction.objectStore(name), en (2).
Ejecuta lo petición al almacén books.add(book), en (3).
…Maneja el éxito o fracaso de la petición (4), a continuación podemos hacer otras peticiones si lo necesitamos, etc.

Los almacenes de objetos soportan dos métodos para almacenar un valor:


put(value, [key])
Agrega value al almacén. La clave key debe ser suministrada solo si al almacén no se le asignó la opción keyPath o autoIncrement. Si ya hay un valor con la misma clave, este será reemplazado.


add(value, [key])
Lo mismo que put, pero si ya hay un valor con la misma clave, la petición falla y se genera un error con el nombre "ConstraintError".


Al igual que al abrir una base de datos, podemos enviar una petición: books.add(book) y quedar a la espera  de los eventos success/error.

El resultado request.result de add es la clave del nuevo objeto.
El error, si lo hay, está en request.error.

Commit, culminación automática de las transaccionesEn el ejemplo anterior, empezamos la transacción e hicimos una petición add. Pero, como explicamos antes, una transacción puede tener muchas peticiones asociadas, que deben todas ser exitosas o todas fallar. ¿Cómo marcamos que una transacción se da por finalizada, que no tendrá más peticiones asociadas?
Respuesta corta: no lo hacemos.
En la siguiente versión 3.0 de la especificación, probablemente haya una manera de finalizarla manualmente, pero ahora mismo en la 2.0 no la hay.
Cuando todas las peticiones de una transacción terminaron y la cola de microtareas está vacía, se hace un commit (consumación) automático.
De forma general, podemos asumir que una transacción se consuma cuando todas sus peticiones fueron completadas y el código actual finaliza.
Entonces, en el ejemplo anterior no se necesita una llamada especial para finalizar la transacción.
El principio de auto-commit de las transacciones tiene un efecto colateral importante. No podemos insertar una operación asincrónica como fetch, setTimeout en mitad de una transacción. IndexedDB no mantendrá la transacción esperando a que terminen.
En el siguiente código, request2 en la línea (*) falla, porque la transacción ya está finalizada y no podemos hacer más peticiones sobre ella:

      
        
        
          let request1 = books.add(book);

request1.onsuccess = function() {
  fetch('/').then(response => {
    let request2 = books.add(anotherBook); // (*)
    request2.onerror = function() {
      console.log(request2.error.name); // TransactionInactiveError
    };
  });
};
        
      
      
      Esto es porque fetch es una operación asincrónica, una macrotarea. Las transacciones se cierran antes de que el navegador comience con las macrotareas.
Los autores de la especificación de IndexedDB creen que las transacciones deben ser de corta vida. Mayormente por razones de rendimiento.
Es de notar que las transacciones readwrite “traban” los almacenes para escritura. Entonces si una parte de la aplicación inició readwrite en el almacén books, cuando otra parte quiera hacer lo mismo tendrá que esperar: la nueva transacción “se cuelga” hasta que la primera termine. Esto puede llevar a extraños retardos si las transacciones toman un tiempo largo.
Entonces, ¿qué hacer?
En el ejemplo de arriba podemos hacer una nueva db.transaction justo antes de la nueva petición (*).
Pero, si queremos mantener las operaciones juntas en una transacción, será mucho mejor separar las transacciones IndexedDB de la parte asincrónica.
Primero, hacer fetch y preparar todos los datos que fueran necesarios y, solo entonces, crear una transacción y ejecutar todas las peticiones de base de datos. Así, funcionaría.
Para detectar el momento de finalización exitosa, podemos escuchar al evento transaction.oncomplete:

      
        
        
          let transaction = db.transaction("books", "readwrite");

// ...ejecutar las operaciones...

transaction.oncomplete = function() {
  console.log("Transacción completa");
};
        
      
      
      Solo complete garantiza que la transacción fue guardada como un todo. Las peticiones individuales pueden ser exitosas, pero la operación final de escritura puede ir mal (por ejemplo por un error de Entrada/Salida u otra cosa).
Para abortar una transacción manualmente:

      
        
        
          transaction.abort();
        
      
      
      Esto cancela todas las modificaciones hechas por las peticiones y dispara el evento transaction.onabort.
Manejo de errorLas peticiones de escritura pueden fallar.
Esto es esperable, no solo por posibles errores de nuestro lado, sino también por razones no relacionadas con la transacción en si misma. Por ejemplo, la cuota de almacenamiento podría haberse exedido. Por tanto, debemos estar preparados para manejar tal caso.
Una petición fallida automáticamente aborta la transacción, cancelando todos sus cambios.
En algunas situaciones, podemos querer manejar el fallo (por ejemplo, intentar otra petición) sin cancelar los cambios en curso, y continuar la transacción. Eso es posible. El manejador request.onerror es capaz de evitar el aborto de la transacción llamando a event.preventDefault().
En el ejemplo que sigue, un libro nuevo es agregado con la misma clave (id) que otro existente. El método store.add genera un "ConstraintError" en ese caso. Lo manejamos sin cancelar la transacción:

      
        
        
          let transaction = db.transaction("books", "readwrite");

let book = { id: 'js', price: 10 };

let request = transaction.objectStore("books").add(book);

request.onerror = function(event) {
  // ConstraintError ocurre cuando un objeto con el mismo id ya existe
  if (request.error.name == "ConstraintError") {
    console.log("Ya existe un libro con ese id"); // manejo del error
    event.preventDefault(); // no abortar la transacción
    // ¿usar otra clave para el libro?
  } else {
    // error inesperado, no podemos manejarlo
    // la transacción se abortará
  }
};

transaction.onabort = function() {
  console.log("Error", transaction.error);
};
        
      
      
      Delegación de eventos¿Necesitamos onerror/onsuccess en cada petición? No siempre. En su lugar podemos usar la delegación de eventos.
Propagación de eventos IndexedDB: request → transaction → database.
Todos los eventos son eventos DOM, con captura y propagación, pero generalmente solo se usa el escenario de la propagación.
Así que podemos capturar todos los errores usando el manejador db.onerror, para reportarlos u otros propósitos:

      
        
        
          db.onerror = function(event) {
  let request = event.target; // la petición (request) que causó el error

  console.log("Error", request.error);
};
        
      
      
      …Pero ¿y si el error fue completamente manejado? No queremos elevarlo en ese caso.
Podemos detener la propagación y en consecuencia db.onerror usando event.stopPropagation() en request.onerror.

      
        
        
          request.onerror = function(event) {
  if (request.error.name == "ConstraintError") {
    console.log("Ya existe un libro con ese id"); // manejo de error
    event.preventDefault(); // no abortar la transacción
    event.stopPropagation(); // no propagar el error
  } else {
    // no hacer nada
    // la transacción será abortada
    // podemos encargarnos del error en transaction.onabort
  }
};
        
      
      
      BúsquedasHay dos maneras principales de buscar en un almacén de objetos:

Por clave o por rango de claves. En nuestro almacén “books”, puede ser por un valor o por un rango de valores de book.id.
Por algún otro campo del objeto, por ejemplo book.price. Esto requiere una estructura de datos adicional llamada índice “index”.

Por claveVeamos el primer tipo de búsqueda: por clave.
Los métodos de búsqueda soportan tanto las claves exactas como las denominadas “consultas por rango” que son objetos IDBKeyRange que especifican un “rango de claves” aceptable.
Los objetos IDBKeyRange son creados con las siguientes llamadas:

IDBKeyRange.lowerBound(lower, [open]) significa: ≥ lower (o > lower si open es true)
IDBKeyRange.upperBound(upper, [open]) significa: ≤ upper (o < upper si open es true)
IDBKeyRange.bound(lower, upper, [lowerOpen], [upperOpen]) significa: entre lower y upper. Si el indicador “open” es true, la clave correspondiente no es incluida en el rango.
IDBKeyRange.only(key) – es un rango compuesto solamente por una clave key, es raramente usado.

Veremos ejemplos prácticos de uso muy pronto.
Para efectuar la búsqueda, existen los siguientes métodos. Ellos aceptan un argumento query que puede ser una clave exacta o un rango de claves:

store.get(query) – busca el primer valor, por clave o por rango.
store.getAll([query], [count]) – busca todos los valores, limitado a la cantidad count si esta se especifica.
store.getKey(query) – busca la primera clave que satisface la consulta, usualmente un rango.
store.getAllKeys([query], [count]) – busca todas las claves que satisfacen la consulta, usualmente un rango, hasta la cantidad count si es suministrada.
store.count([query]) – obtiene la cantidad de claves que satisfacen la consulta, usualmente un rango.

Por ejemplo, tenemos un montón de libros en nuestro almacén. Recuerda, el campo id es la clave, así que todos estos métodos pueden buscar por id.
Ejemplos de peticiones:

      
        
        
          // obtiene un libro
books.get('js')

// obtiene libros con: 'css' <= id <= 'html'
books.getAll(IDBKeyRange.bound('css', 'html'))

// obtiene libros con  id < 'html'
books.getAll(IDBKeyRange.upperBound('html', true))

// obtiene todos los libros
books.getAll()

// obtiene todas las claves donde id > 'js'
books.getAllKeys(IDBKeyRange.lowerBound('js', true))
        
      
      
      
            El almacén de objetos siempre está ordenado
            El almacén internamente guarda los valores ordenados por clave.
Entonces, en las peticiones que devuelvan varios valores, estos siempre estarán ordenados por la clave.

Buscando por cualquier campo con un índicePara buscar por otro campo del objeto, necesitamos crear una estructura de datos adicional llamada “índice (index)”.
Un índice es un agregado al almacén que rastrea un campo determinado del objeto dado. Para cada valor de ese campo, almacena una lista de claves de objetos que tienen ese valor. Veremos una imagen más detallada abajo.
La sintaxis:

      
        
        
          objectStore.createIndex(name, keyPath, [options]);
        
      
      
      
name – nombre del índice,
keyPath – ruta al campo del objeto que el índice debe seguir (vamos a buscar por ese campo),
option – un objeto opcional con las propiedades:

unique – si es true, un valor no podrá repetirse en el índice. Solamente puede haber un único objeto en el almacén con un valor dado de su keyPath. El índice forzará esto generando un error si intentamos agregar un duplicado.
multiEntry – solo se usa si el valor en keyPath es un array. En ese caso, de manera predeterminada, el índice tratará el array completo como clave. Pero si multiEntry es true, entonces el índice mantendrá una lista de objetos almacenados para cada valor en ese array. Así los miembros del array se vuelven claves de ese índice.



En nuestro ejemplo, almacenamos libros usando la propiedad id como clave.
Digamos que queremos buscar por precio price.
Primero necesitamos crear un índice. Esto debe hacerse en upgradeneeded, al igual que hacíamos la creación del almacén de objetos.

      
        
        
          openRequest.onupgradeneeded = function() {
  // debemos crear el índice aquí, en la transacción versionchange
  let books = db.createObjectStore('books', {keyPath: 'id'});
  let index = books.createIndex('price_idx', 'price');
};
        
      
      
      
El índice hará seguimiento del campo price.
El precio no es único, puede haber múltiples libros con el mismo precio así que no establecemos la opción unique.
El precio no es un array, entonces el indicador multiEntry no es aplicable.

Imagine que nuestro inventory tiene 4 libros. Aquí la imagen muestra exactamente lo que es el índice:

      
      
        
      
      Como se dijo, el índice para cada valor de price (segundo argumento) mantiene la lista de claves que tienen ese precio.
El índice se mantiene actualizado automáticamente, no necesitamos preocuparnos de eso.
Ahora, cuando queremos buscar por un determinado precio, simplemente aplicamos el mismo método de búsqueda al índice:

      
        
        
          let transaction = db.transaction("books"); // readonly
let books = transaction.objectStore("books");
let priceIndex = books.index("price_idx");

let request = priceIndex.getAll(10);

request.onsuccess = function() {
  if (request.result !== undefined) {
    console.log("Books", request.result); // array de libros con precio = 10
  } else {
    console.log("No hay libros así");
  }
};
        
      
      
      También podemos usar IDBKeyRange para crear rangos y vistas de libros baratos/caros:

      
        
        
          // encontrar libros donde price <= 5
let request = priceIndex.getAll(IDBKeyRange.upperBound(5));
        
      
      
      Los índices están ordenados internamente por el campo del índice, en nuestro caso price. Entonces cuando hacemos la búsqueda, los resultados también estarán ordenados por price.
Borrando del almacénEl método delete (eliminar) busca a través de una consulta valores para borrarlos. El formato de la llamada es similar a getAll:

delete(query) – elimina valores coincidentes con una consulta (query).

Por ejemplo:

      
        
        
          // borra el libro cuyo id='js'
books.delete('js');
        
      
      
      Si queremos borrar libros basados en un precio u otro campo del objeto, debemos primero encontrar la clave en el índice, luego llamar a delete con dicha clave:

      
        
        
          // encuentra la clave donde price = 5
let request = priceIndex.getKey(5);

request.onsuccess = function() {
  let id = request.result;
  let deleteRequest = books.delete(id);
};
        
      
      
      Para borrar todo:

      
        
        
          books.clear(); // clear "limpia" el almacén.
        
      
      
      CursoresMétodos como getAll/getAllKeys devuelven un array de claves/valores.
Pero un almacén de objetos puede ser enorme, incluso más que la memoria disponible. Entonces getAll fallaría al tratar de llenar de registros el array.
¿Qué hacer?
Los cursores brindan los medios para manejar esta situación.
Un cursor es un objeto especial que, dada una consulta, recorre el almacén y devuelve un solo par clave/valor cada vez, ahorrando así memoria.
Como un almacén está ordenado internamente por clave, un cursor lo recorre en el orden de la clave (ascendente de forma predeterminada).
La sintaxis:

      
        
        
          // como getAll, pero con un cursor:
let request = store.openCursor(query, [direction]);

// para obtener las claves y no sus valores (como getAllKeys): store.openKeyCursor
        
      
      
      
query (consulta) es una clave o un rango de claves, al igual que para getAll.
direction es un argumento opcional, el orden que se va a usar:

"next" – el predeterminado: el cursor recorre en orden ascendente comenzando por la clave más baja.
"prev" – el orden inverso: decrece comenzando con el registro con la clave más alta.
"nextunique", "prevunique" – igual que las anteriores, pero saltando los registros con la misma clave (válido solo para cursores sobre índices; por ejemplo, de múltiples libros con price=5, solamente el primero será devuelto).



La diferencia principal del cursor es que request.onsuccess se dispara múltiples veces: una por cada resultado.
Aquí hay un ejemplo de cómo usar un cursor:

      
        
        
          let transaction = db.transaction("books");
let books = transaction.objectStore("books");

let request = books.openCursor();

// llamado por cada libro encontrado por el cursor
request.onsuccess = function() {
  let cursor = request.result;
  if (cursor) {
    let key = cursor.key; // clave del libro (el campo id)
    let value = cursor.value; // el objeto libro
    console.log(key, value);
    cursor.continue();
  } else {
    console.log("No hay más libros");
  }
};
        
      
      
      Los principales métodos de cursor son:

advance(count) – avanza el cursor count veces, saltando valores.
continue([key]) – avanza el cursor al siguiente valor en el rango o, si se provee la clave key, al valor inmediatamente posterior a key.

El evento onsuccess será llamado haya o no más valores coincidentes, y en result obtenemos el cursor apuntando al siguiente registro o undefined.
En el ejemplo anterior, el cursor fue hecho sobre el almacén de objetos.
Pero también podemos hacerlo sobre un índice. Recordamos, los índices nos permiten buscar por los campos del objeto. Los cursores sobre índices hacen precisamente lo mismo que sobre el almacén de objetos: ahorran memoria al devolver un solo valor cada vez.
Para cursores sobre índices, cursor.key es la clave del índice (es decir “price”), y debemos usar la propiedad cursor.primaryKey para la clave del objeto:

      
        
        
          let request = priceIdx.openCursor(IDBKeyRange.upperBound(5));

// es llamado para cada registro
request.onsuccess = function() {
  let cursor = request.result;
  if (cursor) {
    let primaryKey = cursor.primaryKey; // la siguiente clave (campo id) del almacén
    let value = cursor.value; // el siguiente objeto (objeto book) del almacén
    let key = cursor.key; // siguiente clave del índice (price)
    console.log(key, value);
    cursor.continue();
  } else {
    console.log("No hay más libros");
  }
};
        
      
      
      Contenedor promisificadorAgregar onsuccess/onerror a cada petición es una tarea agobiante. A veces podemos hacernos la vida más fácil usando delegación de eventos (por ejemplo, estableciendo manejadores para las transacciones completas), pero async/await es mucho más conveniente.
Usemos en adelante para este capítulo un contenedor (wrapper) liviano que añade promesas https://github.com/jakearchibald/idb. Este contenedor crea un objeto global idb con métodos IndexedDB promisificados.
Entonces, en lugar de onsuccess/onerror, podemos escribir:

      
        
        
          let db = await idb.openDB('store', 1, db => {
  if (db.oldVersion == 0) {
    // ejecuta la inicialización
    db.createObjectStore('books', {keyPath: 'id'});
  }
});

let transaction = db.transaction('books', 'readwrite');
let books = transaction.objectStore('books');

try {
  await books.add(...);
  await books.add(...);

  await transaction.complete;

  console.log('jsbook saved');
} catch(err) {
  console.log('error', err.message);
}
        
      
      
      Así tenemos todo lo dulce de “código async plano” y “try…catch”.
Manejo de ErrorSi no atrapamos un error, este se propaga hasta el try..catch externo más cercano.
Un error no atrapado se vuelve un evento “rechazo de promesa no manejado” sobre el objeto window.
Podemos manejar tales errores así:

      
        
        
          window.addEventListener('unhandledrejection', event => {
  let request = event.target; // objeto request nativo de IndexedDB
  let error = event.reason; //  objeto error no manejado, igual que request.error
  ...reportar el error...
});
        
      
      
      La trampa “transacción inactiva”Como sabemos, una transacción se autofinaliza tan pronto como el navegador termina el código actual y las microtareas. Por tanto, si ponemos una macrotarea como fetch en el medio de una transacción, la transacción no esperará a que termine. Simplemente se autofinaliza. Así la siguiente petición fallaría.
Para el contenedor de promisificación y async/await la situación es la misma.
Este es un ejemplo de fetch en el medio de una transacción:

      
        
        
          let transaction = db.transaction("inventory", "readwrite");
let inventory = transaction.objectStore("inventory");

await inventory.add({ id: 'js', price: 10, created: new Date() });

await fetch(...); // (*)

await inventory.add({ id: 'js', price: 10, created: new Date() }); // Error
        
      
      
      El inventory.add que sigue a fetch (*) falla con el error “transacción inactiva”, porque la transacción se autocompletó y, llegado ese momento, ya está cerrada.
La forma de sortear esto es la misma que con el IndexedDB nativo: Hacer una nueva transacción o simplemente partir las cosas.

Preparar los datos y buscar todo lo que sea necesario primero.
Solo entonces, grabar en la base de datos.

Obtener objetos nativosInternamente, el contenedor ejecuta una petición IndexedDB nativa, agregándole onerror/onsuccess y devolviendo una promesa que rechaza/resuelve con el resultado.
Esto funciona bien la mayor parte del tiempo. Los ejemplos están en la página lib de idb https://github.com/jakearchibald/idb.
En algunos raros casos necesitamos el objeto request original. Podemos accederlo con la propiedad promise.request de la promesa:

      
        
        
          let promise = books.add(book); // obtiene una promesa (no espera por su resultado)

let request = promise.request; // objeto request nativo
let transaction = request.transaction; // objeto transaction nativo

// ...hace algún vudú IndexedDB...

let result = await promise; // si aún se necesita
        
      
      
      ResumenIndexedDB puede considerarse como “localStorage con esteroides”. Es una simple base de datos de clave-valor, suficientemente poderosa para apps fuera de línea y fácil de usar.
El mejor manual es la especificación, la actual es 2.0, pero algunos métodos de 3.0 (no muy diferente) están soportados parcialmente.
El uso básico puede ser descrito en pocas frases:

Obtenga un contenedor promisificador como idb.
Abra la base de datos: idb.openDb(name, version, onupgradeneeded)

Cree almacenes de objetos e índices en el manejador onupgradeneeded o ejecute la actualización de versión cuando sea necesario.


Para peticiones:

Cree una transacción db.transaction('books') (readwrite si es necesario).
Obtenga el almacén de objetos transaction.objectStore('books').


Entonces, para buscar por clave, llame métodos sobre el almacén directamente.

Para buscar por un campo de objeto, cree un índice.


Si los datos son demasiados para la memoria, use un cursor.

Una pequeña app de demo:
Resultadoindex.html<!doctype html>
<script src="https://cdn.jsdelivr.net/npm/idb@3.0.2/build/idb.min.js"></script>

<button onclick="addBook()">Add a book</button>
<button onclick="clearBooks()">Clear books</button>

<p>Books list:</p>

<ul id="listElem"></ul>

<script>
let db;

init();

async function init() {
  db = await idb.openDb('booksDb', 1, db => {
    db.createObjectStore('books', {keyPath: 'name'});
  });

  list();
}

async function list() {
  let tx = db.transaction('books');
  let bookStore = tx.objectStore('books');

  let books = await bookStore.getAll();

  if (books.length) {
    listElem.innerHTML = books.map(book => `<li>
        name: ${book.name}, price: ${book.price}
      </li>`).join('');
  } else {
    listElem.innerHTML = '<li>No books yet. Please add books.</li>'
  }


}

async function clearBooks() {
  let tx = db.transaction('books', 'readwrite');
  await tx.objectStore('books').clear();
  await list();
}

async function addBook() {
  let name = prompt("Book name?");
  let price = +prompt("Book price?");

  let tx = db.transaction('books', 'readwrite');

  try {
    await tx.objectStore('books').add({name, price});
    await list();
  } catch(err) {
    if (err.name == 'ConstraintError') {
      alert("Such book exists already");
      await addBook();
    } else {
      throw err;
    }
  }
}

window.addEventListener('unhandledrejection', event => {
  alert("Error: " + event.reason.message);
});

</script>",
	"url": "https://es.javascript.info/indexeddb" 
},
{
	"docs_id": "152",
	"name": "Curva de Bézier",
	"description": "Las curvas de Bézier se utilizan en gráficos por ordenador para dibujar formas, para animación CSS y en muchos otros lugares.",
	"content": "Las curvas de Bézier se utilizan en gráficos por ordenador para dibujar formas, para animación CSS y en muchos otros lugares.
En realidad, son algo muy sencillo, vale la pena estudiarlos una vez y luego sentirse cómodo en el mundo de los gráficos vectoriales y las animaciones avanzadas.

            Un poco de teoría, por favor
            Este artículo brinda una base teórica, pero muy necesaria, de lo que son las curvas Bezier; mientras que el próximo muestra cómo podemos usarlas en animaciones CSS.
Por favor toma tu tiempo en leer y entender el concepto, te servirá bien.

Puntos de ControlUna curva de Bézier está definida por puntos de control.
Puede haber 2, 3, 4 o más.
Por ejemplo, curva de dos puntos:

      
      
        
      
      Curva de tres puntos:

      
      
        
      
      Curva de cuatro puntos:

      
      
        
      
      Si observas detenidamente estas curvas, puedes notar inmediatamente que:


Los puntos no siempre están en la curva. Eso es perfectamente normal, luego veremos cómo se construye la curva.


El orden de la curva es igual al número de puntos menos uno.
Para dos puntos tenemos una curva lineal (que es una línea recta), para tres puntos – curva cuadrática (parabólica), para cuatro puntos – curva cúbica.


Una curva siempre está dentro del casco convexo de los puntos de control:
 


Debido a esa última propiedad, en gráficos por ordenador es posible optimizar las pruebas de intersección. Si los cascos convexos no se intersecan, las curvas tampoco. Por tanto, comprobar primero la intersección de los cascos convexos puede dar un resultado “sin intersección” muy rápido.  La comprobación de la intersección o los cascos convexos es mucho más fácil, porque son rectángulos, triángulos, etc. (vea la imagen de arriba), figuras mucho más simples que la curva.
El valor principal de las curvas de Bézier para dibujar: al mover los puntos, la curva cambia de manera intuitiva.
Intenta mover los puntos de control con el ratón en el siguiente ejemplo:

    
    
  Como puedes observar, la curva se extiende a lo largo de las lineas tangenciales 1 → 2 y 3 → 4.
Después de algo de práctica, se vuelve obvio cómo colocar puntos para obtener la curva necesaria. Y al conectar varias curvas podemos obtener prácticamente cualquier cosa.
Aquí tenemos algunos ejemplos:
  
Algoritmo de De CasteljauHay una fórmula matemática para las curvas de Bézier, pero la veremos un poco más tarde, porque el
algoritmo de De Casteljau es idéntico a la definición matemática y muestra visualmente cómo se construye.
Primero veamos el ejemplo de los 3 puntos.
Aquí está la demostración, y la explicación a continuación.
Los puntos de control (1,2 y 3) se pueden mover con el ratón. Presiona el botón “play” para ejecutarlo.

    
    
  El algoritmo de De Casteljau para construir la curva de Bézier de 3 puntos:


Dibujar puntos de control. En la demostración anterior están etiquetados: 1, 2, 3.


Construir segmentos entre los puntos de control 1 → 2 → 3. En la demo anterior son marrones.


El parámetro t se mueve de 0 a 1. En el ejemplo de arriba se usa el paso 0.05: el bucle pasa por 0, 0.05, 0.1, 0.15, ... 0.95, 1.
Para cada uno de estos valores de t:


En cada segmento marrón tomamos un punto ubicado en la distancia proporcional a t desde su comienzo. Como hay dos segmentos, tenemos dos puntos.
Por ejemplo, para t=0 – ambos puntos estarán al comienzo de los segmentos, y para t=0.25 – en el 25% de la longitud del segmento desde el comienzo, para t=0.5 – 50%(el medio), for t=1 – al final de los segmentos.


Conecta los puntos. En la imagen de abajo el segmento de conexión está pintado de azul.







Para t=0.25
Para t=0.5











Ahora, en el segmento azul, toma un punto en la distancia proporcional al mismo valor de t. Es decir, para t=0.25 (la imagen de la izquierda) tenemos un punto al final del cuarto izquierdo del segmento, y para t=0.5 (la imagen de la derecha) – en la mitad del segmento. En las imágenes de arriba ese punto es rojo.


Como t va de 0 a 1, cada valor de t añade un punto a la curva. El conjunto de tales puntos forma la curva de Bézier. Es rojo y parabólico en las imágenes de arriba.


Este fue el proceso para 3 puntos. Sería lo mismo para 4 puntos.
La demo para 4 puntos (los puntos se pueden mover con el ratón):

    
    
  El algoritmo para 4 puntos:

Conectar puntos de control por segmentos: 1 → 2, 2 → 3, 3 → 4. Habrá 3 segmentos marrones.
Para cada t en el intervalo de 0 a 1:

Tomamos puntos en estos segmentos en la distancia proporcional a t desde el principio. Estos puntos están conectados, por lo que tenemos dos segmentos verdes.
En estos segmentos tomamos puntos proporcionales a t. Obtenemos un segmento azul.
En el segmento azul tomamos un punto proporcional a t. En el ejemplo anterior es rojo.


Estos puntos juntos forman la curva.

El algoritmo es recursivo y se puede generalizar para cualquier número de puntos de control.
Dados N de puntos de control:

Los conectamos para obtener inicialmente N-1 segmentos.
Entonces, para cada t de 0 a 1, tomamos un punto en cada segmento en la distancia proporcional a t y los conectamos. Habrá N-2 segmentos.
Repetimos el paso 2 hasta que solo quede un punto.

Estos puntos forman la curva.
Ejecuta y pausa los ejemplos para ver claramente los segmentos y cómo se construye la curva.
Una curva que se parece a y=1/t:

    
    
  Los puntos de control en zig-zag también funcionan bien:

    
    
  Es posible hacer un bucle:

    
    
  Una curva de Bézier no suave (sí, eso también es posible):

    
    
  Si hay algo que no está claro en la descripción del algoritmo, los ejemplos en vivo de arriba muestran cómo se construye la curva.
Como el algoritmo es recursivo, podemos construir curvas de Bézier de cualquier orden, es decir, usando 5, 6 o más puntos de control. Pero en la práctica muchos puntos son menos útiles. Por lo general, tomamos 2-3 puntos, y para líneas complejas pegamos varias curvas juntas. Eso es más simple de desarrollar y calcular.

            ¿Cómo dibujar una curva a través de puntos dados?
            Para especificar una curva de Bézier se utilizan puntos de control. Como podemos ver, no están en la curva, excepto el primero y el último.
A veces tenemos otra tarea: dibujar una curva a traves de varios puntos, de modo que todos ellos estén en una sola curva suave. Esta tarea se llama   interpolación, y aquí no la cubrimos.
Hay fórmulas matemáticas para tales curvas, por ejemplo el polinomio de Lagrange. En gráficos por ordenador la interpolación de spline se usa a menudo para construir curvas suaves que conectan muchos puntos.

MatemáticasUna curva de Bézier se puede describir usando una fórmula matemática.
Como vimos, en realidad no hay necesidad de saberlo, la mayoría de la gente simplemente dibuja la curva moviendo los puntos con un mouse. Pero si te gustan las matemáticas, aquí están.
Dadas las coordenadas de los puntos de control Pi: el primer punto de control tiene las coordenadas P1 = (x1, y1), el segundo: P2 = (x2, y2), y así sucesivamente, las coordenadas de la curva se describen mediante la ecuación que depende del parámetro t del segmento [0,1].


La fórmula para una curva de 2 puntos:
P = (1-t)P1 + tP2


Para 3 puntos de control:
P = (1−t)2P1 + 2(1−t)tP2 + t2P3


Para 4 puntos de control:
P = (1−t)3P1 + 3(1−t)2tP2  +3(1−t)t2P3 + t3P4


Estas son las ecuaciones vectoriales. En otras palabras, podemos poner x e y en lugar de P para obtener las coordenadas correspondientes.
Por ejemplo, la curva de 3 puntos está formada por puntos (x, y) calculados como:

x = (1−t)2x1 + 2(1−t)tx2 + t2x3
y = (1−t)2y1 + 2(1−t)ty2 + t2y3

En lugar de x1, y1, x2, y2, x3, y3 deberíamos poner coordenadas de 3 puntos de control, y luego a medida que te t se mueve de 0 a 1, para cada valor de t tendremos (x,y) de la curva.
Por ejemplo, si los puntos de control son  (0,0), (0.5, 1) y (1, 0), las ecuaciones se convierten en:

x = (1−t)2 * 0 + 2(1−t)t * 0.5 + t2 * 1 = (1-t)t + t2 = t
y = (1−t)2 * 0 + 2(1−t)t * 1 + t2 * 0 = 2(1-t)t = –2t2 + 2t

Ahora como t se ejecuta desde 0 a 1, el conjunto de valores (x,y) para cada t forman la curva para dichos puntos de control.
ResumenLas curvas de Bézier se definen por sus puntos de control.
Vimos dos definiciones de curvas de Bézier:

Utilizando un proceso de dibujo: el algoritmo de De Casteljau.
Utilizando una fórmula matemática.

Buenas propiedades de las curvas de Bezier:

Podemos dibujar líneas suaves con un ratón moviendo los puntos de control.
Las formas complejas se pueden construir con varias curvas Bezier.

Uso:

En gráficos por ordenador, modelado, editores gráficos vectoriales. Las fuentes están descritas por curvas de Bézier.
En desarrollo web – para gráficos en Canvas y en formato SVG. Por cierto, los ejemplos “en vivo” de arriba están escritos en SVG. En realidad, son un solo documento SVG que recibe diferentes puntos como parámetros. Puede abrirlo en una ventana separada y ver el código fuente: demo.svg.
En animación CSS para describir la trayectoria y la velocidad de la animación.

",
	"url": "https://es.javascript.info/bezier-curve" 
},
{
	"docs_id": "153",
	"name": "Animaciones CSS",
	"description": "Las animaciones CSS permiten hacer animaciones simples sin JavaScript en absoluto.",
	"content": "Las animaciones CSS permiten hacer animaciones simples sin JavaScript en absoluto.
Se puede utilizar JavaScript para controlar la animación CSS y mejorarla con un poco de código.
Transiciones CSSLa idea de las transiciones CSS es simple. Describimos una propiedad y cómo se deberían animar sus cambios. Cuando la propiedad cambia, el navegador pinta la animación.
Es decir: todo lo que necesitamos es cambiar la propiedad, y la transición fluida la hará el navegador.
Por ejemplo, el CSS a continuación anima los cambios de background-color durante 3 segundos:

      
        
        
          .animated {
  transition-property: background-color;
  transition-duration: 3s;
}
        
      
      
      Ahora, si un elemento tiene la clase .animated, cualquier cambio de background-color es animado durante 3 segundos.
Haz clic en el botón de abajo para animar el fondo:

      
        
        
          
            
          
          
            
          
        
        
          <button id="color">Haz clic en mi</button>

<style>
  #color {
    transition-property: background-color;
    transition-duration: 3s;
  }
</style>

<script>
  color.onclick = function() {
    this.style.backgroundColor = 'red';
  };
</script>
        
      
      
          
        
      Hay 4 propiedades para describir las transiciones CSS:

transition-property
transition-duration
transition-timing-function
transition-delay

Las cubriremos en un momento, por ahora tengamos en cuenta que la propiedad común transition permite declararlas juntas en el orden: property duration timing-function delay, y también animar múltiples propiedades a la vez.
Por ejemplo, este botón anima tanto color como font-size:

      
        
        
          
            
          
          
            
          
        
        
          <button id="growing">Haz clic en mi</button>

<style>
#growing {
  transition: font-size 3s, color 2s;
}
</style>

<script>
growing.onclick = function() {
  this.style.fontSize = '36px';
  this.style.color = 'red';
};
</script>
        
      
      
          
        
      Ahora cubramos las propiedades de animación una por una.
transition-propertyEn transition-property escribimos una lista de propiedades para animar, por ejemplo: left, margin-left, height, color. O podemos escribir all, que significa “animar todas las propiedades”.
No todas las propiedades pueden ser animadas, pero sí la mayoría de las generalmente usadas.
transition-durationEn transition-duration podemos especificar cuánto tiempo debe durar la animación. El tiempo debe estar en formato de tiempo CSS: en segundos s o milisegundos ms.
transition-delayEn transition-delay podemos especificar el retraso antes de la animación. Por ejemplo, si transition-delay es 1s y transition-duration es 2s, la animación comienza después de 1 segundo tras el cambio de la propiedad y la duración total será de 2 segundos.
Los valores negativos también son posibles. De esta manera la animación comienza inmediatamente, pero el punto de inicio de la animación será el del valor dado (tiempo). Por ejemplo, si transition-delay es -1s y transition-duration es 2s, entonces la animación comienza desde la mitad y la duración total será de 1 segundo.
Aquí la animación cambia los números de 0 a 9 usando la propiedad CSS translate:
Resultadoscript.jsstyle.cssindex.htmlstripe.onclick = function() {
  stripe.classList.add('animate');
};#digit {
  width: .5em;
  overflow: hidden;
  font: 32px monospace;
  cursor: pointer;
}

#stripe {
  display: inline-block
}

#stripe.animate {
  transform: translate(-90%);
  transition-property: transform;
  transition-duration: 9s;
  transition-timing-function: linear;
}<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  Haz clic a continuación para animar:

  <div id="digit"><div id="stripe">0123456789</div></div>

  <script src="script.js"></script>
</body>

</html>La propiedad transform se anima así:

      
        
        
          #stripe.animate {
  transform: translate(-90%);
  transition-property: transform;
  transition-duration: 9s;
}
        
      
      
      En el ejemplo anterior, JavaScript agrega la clase .animate al elemento, y comienza la animación:

      
        
        
          stripe.classList.add('animate');
        
      
      
      También podemos comenzar “desde el medio”, desde el número exacto, p. ej. correspondiente al segundo actual, usando el negativo transition-delay.
Aquí, si haces clic en el dígito, comienza la animación desde el segundo actual:
Resultadoscript.jsstyle.cssindex.htmlstripe.onclick = function() {
  let sec = new Date().getSeconds() % 10;
  stripe.style.transitionDelay = '-' + sec + 's';
  stripe.classList.add('animate');
};#digit {
  width: .5em;
  overflow: hidden;
  font: 32px monospace;
  cursor: pointer;
}

#stripe {
  display: inline-block
}

#stripe.animate {
  transform: translate(-90%);
  transition-property: transform;
  transition-duration: 9s;
  transition-timing-function: linear;
}<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  Haz clic a continuación para animar:
  <div id="digit"><div id="stripe">0123456789</div></div>

  <script src="script.js"></script>
</body>
</html>JavaScript lo hace con una línea extra:

      
        
        
          stripe.onclick = function() {
  let sec = new Date().getSeconds() % 10;
  // por ejemplo, -3s aquí comienza la animación desde el 3er segundo
  stripe.style.transitionDelay = '-' + sec + 's';
  stripe.classList.add('animate');
};
        
      
      
      transition-timing-functionLa función de temporización describe cómo se distribuye el proceso de animación a lo largo del tiempo. Comenzará lentamente y luego irá rápido o viceversa.
Es la propiedad más complicada a primera vista. Pero se vuelve muy simple si le dedicamos un poco de tiempo.
Esa propiedad acepta dos tipos de valores: una curva de Bézier o pasos. Comencemos por la curva, ya que se usa con más frecuencia.
Curva de BézierLa función de temporización se puede establecer como una curva de Bézier con 4 puntos de control que satisfacen las condiciones:

Primer punto de control: (0,0).
Último punto de control: (1,1).
Para los puntos intermedios, los valores de x deben estar en el intervalo 0..1, y puede ser cualquier cosa.

La sintaxis de una curva de Bézier en CSS: cubic-bezier(x2, y2, x3, y3). Aquí necesitamos especificar solo los puntos de control segundo y tercero, porque el primero está fijado a (0,0) y el cuarto es (1,1).
La función de temporización determina qué tan rápido ocurre el proceso de animación.

El eje x es el tiempo: 0 – el momento inicial, 1 – el último momento de transition-duration.
El eje y especifica la finalización del proceso: 0 – el valor inicial de la propiedad, 1 – el valor final.

La variante más simple es cuando la animación es uniforme, con la misma velocidad lineal. Eso puede especificarse mediante la curva cubic-bezier(0, 0, 1, 1).
Así es como se ve esa curva:

      
      
        
      
      … Como podemos ver, es solo una línea recta. A medida que pasa el tiempo (x), la finalización (y) de la animación pasa constantemente de 0 a1.
El tren, en el ejemplo a continuación, va de izquierda a derecha con velocidad constante (haz clic en él):
Resultadostyle.cssindex.html.train {
  position: relative;
  cursor: pointer;
  width: 177px;
  height: 160px;
  left: 0;
  transition: left 5s cubic-bezier(0, 0, 1, 1);
}<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <img class="train" src="https://js.cx/clipart/train.gif" onclick="this.style.left='450px'">

</body>

</html>La transition de CSS se basa en esa curva:

      
        
        
          .train {
  left: 0;
  transition: left 5s cubic-bezier(0, 0, 1, 1);
  /* el clic en un tren establece left a 450px, disparando la animación */
}
        
      
      
      … ¿Y cómo podemos mostrar un tren desacelerando?
Podemos usar otra curva de Bézier: cubic-bezier(0.0, 0.5, 0.5, 1.0).
La gráfica:

      
      
        
      
      Como podemos ver, el proceso comienza rápido: la curva se eleva mucho, y luego más y más despacio.
Aquí está la función de temporización en acción (haz clic en el tren):
Resultadostyle.cssindex.html.train {
  position: relative;
  cursor: pointer;
  width: 177px;
  height: 160px;
  left: 0px;
  transition: left 5s cubic-bezier(0.0, 0.5, 0.5, 1.0);
}<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <img class="train" src="https://js.cx/clipart/train.gif" onclick="this.style.left='450px'">

</body>

</html>CSS:

      
        
        
          .train {
  left: 0;
  transition: left 5s cubic-bezier(0, .5, .5, 1);
  /* el clic en un tren establece left a 450px, disparando la animación */
}
        
      
      
      Hay varias curvas incorporadas: linear,ease, ease-in,ease-out y ease-in-out.
La linear es una abreviatura de cubic-bezier(0, 0, 1, 1) – una línea recta, como ya vimos.
Otros nombres son abreviaturas para la siguiente cubic-bezier:



ease*
ease-in
ease-out
ease-in-out




(0.25, 0.1, 0.25, 1.0)
(0.42, 0, 1.0, 1.0)
(0, 0, 0.58, 1.0)
(0.42, 0, 0.58, 1.0)



      
      
        
      
      

      
      
        
      
      

      
      
        
      
      

      
      
        
      
      



* – por defecto, si no hay una función de temporización, se utiliza ease.
Por lo tanto, podríamos usar ease-out para nuestro tren desacelerando:

      
        
        
          .train {
  left: 0;
  transition: left 5s ease-out;
  /* igual que transition: left 5s cubic-bezier(0, .5, .5, 1); */
}
        
      
      
      Pero se ve un poco diferente.
Una curva de Bézier puede hacer que la animación exceda su rango.
Los puntos de control en la curva pueden tener cualquier coordenada y: incluso negativa o enorme. Entonces la curva de Bézier también saltaría muy bajo o alto, haciendo que la animación vaya más allá de su rango normal.
En el siguiente ejemplo, el código de animación es:

      
        
        
          .train {
  left: 100px;
  transition: left 5s cubic-bezier(.5, -1, .5, 2);
  /* clic en un tren establece left a 400px */
}
        
      
      
      La propiedad left debería animarse de 100px a 400px.
Pero si haces clic en el tren, verás que:

Primero, el tren va atrás: left llega a ser menor que 100px.
Luego avanza, un poco más allá de 400px.
Y luego de vuelve a 400px.

Resultadostyle.cssindex.html.train {
  position: relative;
  cursor: pointer;
  width: 177px;
  height: 160px;
  left: 100px;
  transition: left 5s cubic-bezier(.5, -1, .5, 2);
}<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <img class="train" src="https://js.cx/clipart/train.gif" onclick="this.style.left='400px'">

</body>

</html>¿Por qué sucede? es bastante obvio si miramos la gráfica de la curva de Bézier dada:

      
      
        
      
      Movimos la coordenada y del segundo punto por debajo de cero, y para el tercer punto lo colocamos sobre 1, de modo que la curva sale del cuadrante “regular”. La y está fuera del rango “estándar” 0..1.
Como sabemos, y mide “la finalización del proceso de animación”. El valor y = 0 corresponde al valor inicial de la propiedad e y = 1 al valor final. Por lo tanto, los valores y<0 mueven la propiedad por debajo del left inicial e y>1 por encima del left final.
Esa es una variante “suave” sin duda. Si ponemos valores y como -99 y 99, entonces el tren saltaría mucho más fuera del rango.
Pero, ¿cómo hacer la curva de Bézier para una tarea específica? Hay muchas herramientas.

Por ejemplo, podemos hacerlo en el sitio http://cubic-bezier.com/.
El navegador también tiene soporte especial para curvas Bezier en CSS:

Abre las herramientas de desarrollador con F12 (Mac: Cmd+Opt+I).
Selecciona la pestaña Elementos y presta atención al subpanel Estilos.
Las propiedades CSS que contengan la palabra cubic-bezier tendrán un icono antes de esta palabra.
Haz clic en este icono para editar la curva.



PasosLa función de temporización steps(number of steps[, start/end]) permite dividir la animación en múltiples pasos.
Veamos eso en un ejemplo con dígitos.
Aquí tenemos una lista de dígitos, sin animaciones, solo como fuente:
Resultadostyle.cssindex.html#digit {
  border: 1px solid red;
  width: 1.2em;
}

#stripe {
  display: inline-block;
  font: 32px monospace;
}<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <div id="digit"><div id="stripe">0123456789</div></div>

</body>
</html>En el HTML, una línea de dígitos está encerrada en un div de largo fijo<div id="digits">:

      
        
        
          <div id="digit">
  <div id="stripe">0123456789</div>
</div>
        
      
      
      El div #digittiene ancho fijo y un borde, entonces se ve como una ventana roja.
Haremos un temporizador: los dígitos aparecerán uno por uno, de una manera discreta.
Para lograr esto, ocultaremos el #stripe fuera de #digit usando overflow: hidden, y luego desplazamos el #stripe a la izquierda paso a paso.
Habrá 9 pasos, un paso para cada dígito:

      
        
        
          #stripe.animate  {
  transform: translate(-90%);
  transition: transform 9s steps(9, start);
}
        
      
      
      El primer argumento de steps(9, start) es el número de pasos. La transformación se dividirá en 9 partes (10% cada una). El intervalo de tiempo también se divide automáticamente en 9 partes, por lo que transition: 9s nos da 9 segundos para toda la animación: 1 segundo por dígito.
El segundo argumento es una de dos palabras: start o end.
El start significa que al comienzo de la animación debemos hacer el primer paso de inmediato.
En acción:
Resultadostyle.cssindex.html#digit {
  width: .5em;
  overflow: hidden;
  font: 32px monospace;
  cursor: pointer;
}

#stripe {
  display: inline-block
}

#stripe.animate {
  transform: translate(-90%);
  transition-property: transform;
  transition-duration: 9s;
  transition-timing-function: steps(9, start);
}<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  Haz clic a continuación para animar:

  <div id="digit"><div id="stripe">0123456789</div></div>

  <script>
    digit.onclick = function() {
      stripe.classList.add('animate');
    }
  </script>


</body>

</html>Un clic en el dígito lo cambia a 1 (el primer paso) inmediatamente, y luego cambia al comienzo del siguiente segundo.
El proceso está progresando así:

0s – -10% (primer cambio al comienzo del primer segundo, inmediatamente)
1s – -20%
…
8s – -90%
(el último segundo muestra el valor final).

Aquí el primer cambio fue inmediato por elstart en el steps
El valor alternativo ‘end’ haría que el cambio se aplicara no al principio sino al final de cada segundo.
Entonces el proceso para steps(9, end) sería así:

0s – 0 (durante el primer segundo nada cambia)
1s – -10% (primer cambio al final del primer segundo)
2s – -20%
…
9s – -90%

Aquí está el step(9, end) en acción (observa la pausa antes del primer cambio de dígitos):
Resultadostyle.cssindex.html#digit {
  width: .5em;
  overflow: hidden;
  font: 32px monospace;
  cursor: pointer;
}

#stripe {
  display: inline-block
}

#stripe.animate {
  transform: translate(-90%);
  transition-property: transform;
  transition-duration: 9s;
  transition-timing-function: steps(9, end);
}<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  Haz clic a continuación para animar:

  <div id="digit"><div id="stripe">0123456789</div></div>

  <script>
    digit.onclick = function() {
      stripe.classList.add('animate');
    }
  </script>


</body>

</html>También hay algunas formas abreviadas predefinidas para steps(...):

step-start – es lo mismo questeps(1, start). Es decir, la animación comienza de inmediato y toma 1 paso. Entonces comienza y termina inmediatamente, como si no hubiera animación.
step-end – lo mismo que steps(1, end): realiza la animación en un solo paso al final de transition-duration.

Estos valores rara vez se usan porque no representan una verdadera animación sino un cambio de un solo paso.
Evento transitionendCuando finaliza la animación CSS, se dispara el evento transitionend.
Es ampliamente utilizado para hacer una acción después de que se realiza la animación. También podemos unir animaciones.
Por ejemplo, el barco a continuación comienza a navegar ida y vuelta al hacer clic, cada vez más y más a la derecha:

    
        
      
      
        
      
      
    
  La animación se inicia mediante la función go que se vuelve a ejecutar cada vez que finaliza la transición y cambia la dirección:

      
        
        
          boat.onclick = function() {
  //...
  let times = 1;

  function go() {
    if (times % 2) {
      // navegar a la derecha
      boat.classList.remove('back');
      boat.style.marginLeft = 100 * times + 200 + 'px';
    } else {
      // navegar a la izquierda
      boat.classList.add('back');
      boat.style.marginLeft = 100 * times - 200 + 'px';
    }

  }

  go();

  boat.addEventListener('transitionend', function() {
    times++;
    go();
  });
};
        
      
      
      El objeto de evento para transitionend tiene pocas propiedades específicas:

event.propertyName
La propiedad que ha terminado de animarse. Puede ser bueno si animamos múltiples propiedades simultáneamente.
event.elapsedTime
El tiempo (en segundos) que duró la animación, sin transition-delay.

Fotogramas clave  (Keyframes)Podemos unir múltiples animaciones simples juntas usando la regla CSS @keyframes.
Especifica el “nombre” de la animación y las reglas: qué, cuándo y dónde animar. Luego, usando la propiedad animation, adjuntamos la animación al elemento y especificamos parámetros adicionales para él.
Aquí tenemos un ejemplo con explicaciones:

      
        
        
          
            
          
          
            
          
        
        
          <div class="progress"></div>

<style>
  @keyframes go-left-right {        /* dale un nombre: "go-left-right" */
    from { left: 0px; }             /* animar desde la izquierda: 0px */
    to { left: calc(100% - 50px); } /* animar a la izquierda: 100%-50px */
  }

  .progress {
    animation: go-left-right 3s infinite alternate;
    /* aplicar la animación "go-left-right" al elemento
       duración 3 segundos
       número de veces: infinitas
       alternar la dirección cada vez
    */

    position: relative;
    border: 2px solid green;
    width: 50px;
    height: 20px;
    background: lime;
  }
</style>
        
      
      
          
        
      Hay muchos artículos sobre @keyframes y una especificación detallada.
Probablemente no necesitarás @keyframes a menudo, a menos que todo esté en constante movimiento en tus sitios.
PerformanceLa mayoría de las propiedades CSS pueden ser animadas, porque la mayoría son valores numéricos. Por ejemplo width, color, font-size son todas números. Cuando las animamos, el navegador cambia estos valores gradualmente grama por grama, creando un efecto suave.
Sin embargo, no todas las animaciones se verán tan suaves como quisieras, porque diferentes propiedades CSS tienen diferente costo para cambiar.
En detalles más técnicos, cuando hay un cambio de estilo, el navegador atraviesa 3 pasos para renderizar la nueva vista:

Layout: (diagrama) recalcula la geometría y posición de cada elemento, luego
Paint: (dibuja) recalcula cómo debe verse todo en sus lugares, incluyendo background, colores,
Composite: (render) despliega el resultado final en pixels de la pantalla, aplicando transformaciones CSS si existen.

Durante una animación CSS , este proceso se repite para cada frame. Sin embargo las propiedades CSS que nunca afectan geometría o posición, como color, pueden saltar el paso “Layout”. Si un color cambia, el navegador no recalcula geometría, va a Paint → Composite. Y hay unas pocas propiedades que saltan directo a “Composite”. Puedes encontrar la lista de propiedades CSS y cuáles estados disparan en https://csstriggers.com.
Los cálculos pueden tomar un tiempo, especialmente en páginas con muchos elementos y diagramación compleja. Y los retrasos pueden ser notorios en muchos dispositivos, provocando “jitter”: animaciones irregulares, menos fluidas.
La animación de propiedades que salten el paso “Layout” son más rápidas. Mucho mejor si el paso “Paint” se salta también.
La propiedad transform es una excelente opción porque:

CSS transform afecta el elemento objetivo como un todo (rotar, tornar, estirar, desplazar).
CSS transform nunca afecta a los elementos vecinos.

…entonces los navegadores aplican transform “por encima” de “Layout” y “Paint” ya calculados, en el paso “Composite”.
En otras palabras, el navegador calcula la diagramación en la etapa Layout (tamaños, posiciones); lo dibuja con colores, backgrounds, etc., en la etapa “Paint”; y luego aplica transform a los elementos que lo necesitan.
Cambios (animaciones) de la propiedad transform nunca disparan los pasos Layout y Paint. Aún más, el navegador delega las transformaciones CSS en el acelerador gráfico (un chip especial en la CPU o placa gráfica), haciéndolas muy eficientes.
Afortunadamente la propiedad  transform es muy poderosa. Usando transform en un elemento, puedes rotarlo, darlo vuelta, estirarlo o comprimirlo, desplazarlo y mucho más. Así que en lugar de las propiedades left/margin-left podemos usar transform: translateX(…), o usar transform: scale para incrementar su tamaño, etc.
La propiedad opacity tampoco dispara “Layout” (también se salta “Paint” en Gecko de Mozilla). Podemos usarlo para efectos de mostrar/ocultar o desvanecer/aparecer.
Aparear transform con opacity puede usualmente resolver la mayoría de nuestras necesidades brindando animaciones vistosas y fluidas.
Aquí por ejemplo, clic en el elemento #boat le agrega la clase con transform: translateX(300) y opacity: 0, haciendo que se mueva 300px a la derecha y desaparezca:

      
        
        
          
            
          
          
            
          
        
        
          <img src="https://js.cx/clipart/boat.png" id="boat">

<style>
#boat {
  cursor: pointer;
  transition: transform 2s ease-in-out, opacity 2s ease-in-out;
}

.move {
  transform: translateX(300px);
  opacity: 0;
}
</style>
<script>
  boat.onclick = () => boat.classList.add('move');
</script>
        
      
      
          
        
      Un ejemplo más complejo con @keyframes:

      
        
        
          
            
          
          
            
          
        
        
          <h2 onclick="this.classList.toggle('animated')">click me to start / stop</h2>
<style>
  .animated {
    animation: hello-goodbye 1.8s infinite;
    width: fit-content;
  }
  @keyframes hello-goodbye {
    0% {
      transform: translateY(-60px) rotateX(0.7turn);
      opacity: 0;
    }
    50% {
      transform: none;
      opacity: 1;
    }
    100% {
      transform: translateX(230px) rotateZ(90deg) scale(0.5);
      opacity: 0;
    }
  }
</style>
        
      
      
          
        
      ResumenLas animaciones CSS permiten animar, suavemente o por pasos, los cambios de una o varias propiedades CSS.
Son buenas para la mayoría de las tareas de animación. También podemos usar JavaScript para animaciones, el siguiente capítulo está dedicado a eso.
Limitaciones de las animaciones CSS en comparación con las animaciones JavaScript:
+ Cosas simples hechas simplemente.
+ Rápido y ligero para la CPU.
- Las animaciones de JavaScript son flexibles. Pueden implementar cualquier lógica de animación, como una "explosión" de un elemento.
- No solo cambios de propiedad. Podemos crear nuevos elementos en JavaScript para fines de animación.

En los ejemplos de este artículo animamos font-size, left, width, height, etc. En proyectos de la vida real es preferible usar transform: scale() y transform: translate() para obtener mejor performance.
La mayoría de las animaciones se pueden implementar usando CSS como se describe en este capítulo. Y el evento transitionend permite ejecutar JavaScript después de la animación, por lo que se integra bien con el código.
Pero en el próximo capítulo haremos algunas animaciones en JavaScript para cubrir casos más complejos.
TareasAnimar un avión (CSS)importancia: 5Muestra la animación como en la imagen a continuación (haz clic en el avión):

    
    
  
La imagen crece al hacer clic de 40x24px a 400x240px (10 veces más grande).
La animación dura 3 segundos.
Al final muestra: “¡Listo!”.
Durante el proceso de animación, puede haber más clics en el avión. No deberían “romper” nada.

Abrir un entorno controlado para la tarea.soluciónCSS para animar tanto width como height:

      
        
        
          /* clase original */

#flyjet {
  transition: all 3s;
}

/* JS añade .growing */
#flyjet.growing {
  width: 400px;
  height: 240px;
}
        
      
      
      Ten en cuenta que transitionend se dispara dos veces, una para cada propiedad. Entonces, si no realizamos una verificación adicional, el mensaje aparecería 2 veces.
Abrir la solución en un entorno controlado.Animar el avión volando (CSS)importancia: 5Modifica la solución de la tarea anterior Animar un avión (CSS) para hacer que el avión crezca más que su tamaño original 400x240px (saltar fuera), y luego vuelva a ese tamaño.
Así es como debería verse (haz clic en el avión):

    
    
  Toma la solución de la tarea anterior como punto de partida.
soluciónNecesitamos elegir la curva de Bézier correcta para esa animación. Debe tener y>1 en algún punto para que el avión “salte”.
Por ejemplo, podemos tomar ambos puntos de control con y>1, como: cubic-bezier(0.25, 1.5, 0.75, 1.5).
La gráfica:

      
      
        
      
      Abrir la solución en un entorno controlado.Círculo animadoimportancia: 5Crea una función showCircle(cx, cy, radius) que muestre un círculo animado creciendo.

cx,cy son coordenadas relativas a la ventana del centro del círculo,
radius es el radio del círculo.

Haz clic en el botón de abajo para ver cómo debería verse:

    
    
  El documento fuente tiene un ejemplo de un círculo con estilos correctos, por lo que la tarea es precisamente hacer la animación correctamente.
Abrir un entorno controlado para la tarea.soluciónAbrir la solución en un entorno controlado.Círculo animado con función de callbackEn la tarea Círculo animado se muestra un círculo creciente animado.
Ahora digamos que necesitamos no solo un círculo, sino mostrar un mensaje dentro de él. El mensaje debería aparecer después de que la animación esté completa (el círculo es desarrollado completamente), de lo contrario se vería feo.
En la solución de la tarea, la función showCircle(cx, cy, radius) dibuja el círculo, pero no hay forma de saber cuando lo termina.
Agrega un argumento callback: showCircle(cx, cy, radius, callback) que se llamará cuando se complete la animación. El callback debería recibir el círculo <div> como argumento.
Aqui el ejemplo:

      
        
        
          showCircle(150, 150, 100, div => {
  div.classList.add('message-ball');
  div.append("Hola, mundo!");
});
        
      
      
      Demostración:

    
    
  Toma la solución de la tarea Círculo animado como base.
soluciónAbrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/css-animations" 
},
{
	"docs_id": "154",
	"name": "Animaciones JavaScript",
	"description": "Las animaciones de JavaScript pueden manejar cosas que CSS no puede.",
	"content": "Las animaciones de JavaScript pueden manejar cosas que CSS no puede.
Por ejemplo, moverse a lo largo de una ruta compleja, con una función de sincronización diferente a las curvas de Bézier, o una animación en un canvas.
Usando setIntervalUna animación se puede implementar como una secuencia de frames, generalmente pequeños cambios en las propiedades de HTML/CSS.
Por ejemplo, cambiar style.left de 0px a 100px mueve el elemento. Y si lo aumentamos en setInterval, cambiando en 2px con un pequeño retraso, como 50 veces por segundo, entonces se ve suave. Ese es el mismo principio que en el cine: 24 frames por segundo son suficientes para que se vea suave.
El pseudocódigo puede verse así:

      
        
        
          let timer = setInterval(function() {
  if (animation complete) clearInterval(timer);
  else increase style.left by 2px
}, 20); // cambiar en 2px cada 20ms, aproximadamente 50 frames por segundo
        
      
      
      Ejemplo más completo de la animación:

      
        
        
          let start = Date.now(); // recordar la hora de inicio

let timer = setInterval(function() {
  // ¿Cuánto tiempo pasó desde el principio?
  let timePassed = Date.now() - start;

  if (timePassed >= 2000) {
    clearInterval(timer); // terminar la animación después de 2 segundos
    return;
  }

  // dibujar la animación en el momento timePassed
  draw(timePassed);

}, 20);

// mientras timePassed va de 0 a 2000
// left obtiene valores de 0px a 400px
function draw(timePassed) {
  train.style.left = timePassed / 5 + 'px';
}
        
      
      
      Haz clic para ver la demostración:
Resultadoindex.html<!DOCTYPE HTML>
<html>

<head>
  <style>
    #train {
      position: relative;
      cursor: pointer;
    }
  </style>
</head>

<body>

  <img id="train" src="https://js.cx/clipart/train.gif">


  <script>
    train.onclick = function() {
      let start = Date.now();

      let timer = setInterval(function() {
        let timePassed = Date.now() - start;

        train.style.left = timePassed / 5 + 'px';

        if (timePassed > 2000) clearInterval(timer);

      }, 20);
    }
  </script>


</body>

</html>Usando requestAnimationFrameImaginemos que tenemos varias animaciones ejecutándose simultáneamente.
Si las ejecutamos por separado, aunque cada una tenga setInterval (..., 20), el navegador tendría que volver a pintar con mucha más frecuencia que cada 20ms.
Eso es porque tienen un tiempo de inicio diferente, por lo que “cada 20ms” difiere entre las diferentes animaciones. Los intervalos no están alineados. Así que tendremos varias ejecuciones independientes dentro de 20ms.
En otras palabras, esto:

      
        
        
          setInterval(function() {
  animate1();
  animate2();
  animate3();
}, 20)
        
      
      
      …Es más ligero que tres llamadas independientes:

      
        
        
          setInterval(animate1, 20); // animaciones independientes
setInterval(animate2, 20); // en diferentes lugares del script
setInterval(animate3, 20);
        
      
      
      Estos varios redibujos independientes deben agruparse para facilitar el redibujado al navegador y, por lo tanto, cargar menos CPU y verse más fluido.
Hay una cosa más a tener en cuenta. A veces, cuando el CPU está sobrecargado, o hay otras razones para volver a dibujar con menos frecuencia (como cuando la pestaña del navegador está oculta), no deberíamos ejecutarlo cada 20ms.
Pero, ¿cómo sabemos eso en JavaScript? Hay una especificación Sincronización de animación que proporciona la función requestAnimationFrame. Aborda todos estos problemas y aún más.
La sintaxis:

      
        
        
          let requestId = requestAnimationFrame(callback)
        
      
      
      Eso programa la función callback para que se ejecute en el tiempo más cercano cuando el navegador quiera hacer una animación.
Si hacemos cambios en los elementos dentro de callback, entonces se agruparán con otros callbacks de requestAnimationFrame y con animaciones CSS. Así que habrá un recálculo y repintado de geometría en lugar de muchos.
El valor devuelto requestId se puede utilizar para cancelar la llamada:

      
        
        
          // cancelar la ejecución programada del callback
cancelAnimationFrame(requestId);
        
      
      
      El callback obtiene un argumento: el tiempo transcurrido desde el inicio de la carga de la página en microsegundos. Este tiempo también se puede obtener llamando a performance.now().
Por lo general, el callback se ejecuta muy pronto, a menos que el CPU esté sobrecargado o la batería de la laptop esté casi descargada, o haya otra razón.
El siguiente código muestra el tiempo entre las primeras 10 ejecuciones de requestAnimationFrame. Por lo general, son 10-20ms:

      
        
        
          
            
          
          
            
          
        
        
          <script>
  let prev = performance.now();
  let times = 0;

  requestAnimationFrame(function measure(time) {
    document.body.insertAdjacentHTML("beforeEnd", Math.floor(time - prev) + " ");
    prev = time;

    if (times++ < 10) requestAnimationFrame(measure);
  })
</script>
        
      
      
      Animación estructuradaAhora podemos hacer una función de animación más universal basada en requestAnimationFrame:

      
        
        
          function animate({timing, draw, duration}) {

  let start = performance.now();

  requestAnimationFrame(function animate(time) {
    // timeFraction va de 0 a 1
    let timeFraction = (time - start) / duration;
    if (timeFraction > 1) timeFraction = 1;

    // calcular el estado actual de la animación
    let progress = timing(timeFraction)

    draw(progress); // dibujar

    if (timeFraction < 1) {
      requestAnimationFrame(animate);
    }

  });
}
        
      
      
      La función animate acepta 3 parámetros que básicamente describen la animación:

duration

Tiempo total de animación. Como: 1000.

timing(timeFraction)

Función de sincronización, como la propiedad CSS transition-timing-function que obtiene la fracción de tiempo que pasó (0 al inicio, 1 al final) y devuelve la finalización de la animación (como y en la curva de Bézier).
Por ejemplo, una función lineal significa que la animación continúa uniformemente con la misma velocidad:

      
        
        
          function linear(timeFraction) {
  return timeFraction;
}
        
      
      
      Su gráfico:

Eso es como transition-timing-function: linear. A continuación se muestran variantes más interesantes.

draw(progress)

La función que toma el estado de finalización de la animación y la dibuja. El valor progress=0 denota el estado inicial de la animación y progress=1 – el estado final.
Esta es la función que realmente dibuja la animación.
Puede mover el elemento:

      
        
        
          function draw(progress) {
  train.style.left = progress + 'px';
}
        
      
      
      …O hacer cualquier otra cosa, podemos animar cualquier cosa, de cualquier forma.


Vamos a animar el elemento width de 0 a 100% usando nuestra función.
Haz clic en el elemento de la demostración:
Resultadoanimate.jsindex.htmlfunction animate({duration, draw, timing}) {

  let start = performance.now();

  requestAnimationFrame(function animate(time) {
    let timeFraction = (time - start) / duration;
    if (timeFraction > 1) timeFraction = 1;

    let progress = timing(timeFraction)

    draw(progress);

    if (timeFraction < 1) {
      requestAnimationFrame(animate);
    }

  });
}<!DOCTYPE HTML>
<html>

<head>
  <meta charset="utf-8">
  <style>
    progress {
      width: 5%;
    }
  </style>
  <script src="animate.js"></script>
</head>

<body>


  <progress id="elem"></progress>

  <script>
    elem.onclick = function() {
      animate({
        duration: 1000,
        timing: function(timeFraction) {
          return timeFraction;
        },
        draw: function(progress) {
          elem.style.width = progress * 100 + '%';
        }
      });
    };
  </script>


</body>

</html>El código para ello:

      
        
        
          animate({
  duration: 1000,
  timing(timeFraction) {
    return timeFraction;
  },
  draw(progress) {
    elem.style.width = progress * 100 + '%';
  }
});
        
      
      
      A diferencia de la animación CSS, aquí podemos hacer cualquier función de sincronización y cualquier función de dibujo. La función de sincronización no está limitada por las curvas de Bézier. Y draw puede ir más allá de las propiedades, crear nuevos elementos para la animación de fuegos artificiales o algo así.
Funciones de sincronizaciónVimos arriba la función de sincronización lineal más simple.
Veamos más de ellas. Intentaremos animaciones de movimiento con diferentes funciones de sincronización para ver cómo funcionan.
Potencia de nSi queremos acelerar la animación, podemos usar progress en la potencia n.
Por ejemplo, una curva parabólica:

      
        
        
          function quad(timeFraction) {
  return Math.pow(timeFraction, 2)
}
        
      
      
      La gráfica:

      
      
        
      
      Velo en acción (haz clic para activar):

    
        
      
      
    
  …O la curva cúbica o incluso mayor n. Aumentar la potencia hace que se acelere más rápido.
Aquí está el gráfico de progress en la potencia 5:

      
      
        
      
      En acción:

    
        
      
      
    
  El arcoFunción:

      
        
        
          function circ(timeFraction) {
  return 1 - Math.sin(Math.acos(timeFraction));
}
        
      
      
      La gráfica:

      
      
        
      
      
    
        
      
      
    
  Back: tiro con arcoEsta función realiza el “tiro con arco”. Primero “tiramos de la cuerda del arco”, y luego “disparamos”.
A diferencia de las funciones anteriores, depende de un parámetro adicional x, el “coeficiente de elasticidad”. La distancia de “tirar de la cuerda del arco” está definida por él.
El código:

      
        
        
          function back(x, timeFraction) {
  return Math.pow(timeFraction, 2) * ((x + 1) * timeFraction - x)
}
        
      
      
      The graph for x = 1.5:

      
      
        
      
      Para la animación lo usamos con un valor específico de x. Ejemplo de x = 1.5:

    
        
      
      
    
  RebotarImagina que dejamos caer una pelota. Se cae, luego rebota unas cuantas veces y se detiene.
La función bounce hace lo mismo, pero en orden inverso: el “rebote” comienza inmediatamente. Utiliza algunos coeficientes especiales para eso:

      
        
        
          function bounce(timeFraction) {
  for (let a = 0, b = 1; 1; a += b, b /= 2) {
    if (timeFraction >= (7 - 4 * a) / 11) {
      return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)
    }
  }
}
        
      
      
      En acción:

    
        
      
      
    
  Animación elásticaUna función “elástica” más que acepta un parámetro adicional x para el “rango inicial”.

      
        
        
          function elastic(x, timeFraction) {
  return Math.pow(2, 10 * (timeFraction - 1)) * Math.cos(20 * Math.PI * x / 3 * timeFraction)
}
        
      
      
      La gráfica para x=1.5:

En acción para x=1.5:

    
        
      
      
    
  Inversión: ease*Entonces tenemos una colección de funciones de sincronización. Su aplicación directa se llama “easyIn”.
A veces necesitamos mostrar la animación en orden inverso. Eso se hace con la transformación “easyOut”.
easeOutEn el modo “easyOut”, la función de sincronización se coloca en un wrapper timingEaseOut:

      
        
        
          timingEaseOut(timeFraction) = 1 - timing(1 - timeFraction)
        
      
      
      En otras palabras, tenemos una función de “transformación” makeEaseOut que toma una función de sincronización “regular” y devuelve el wrapper envolviéndola:

      
        
        
          // acepta una función de sincronización, devuelve la variante transformada
function makeEaseOut(timing) {
  return function(timeFraction) {
    return 1 - timing(1 - timeFraction);
  }
}
        
      
      
      Por ejemplo, podemos tomar la función bounce descrita anteriormente y aplicarla:

      
        
        
          let bounceEaseOut = makeEaseOut(bounce);
        
      
      
      Entonces el rebote no estará al principio, sino al final de la animación. Se ve aún mejor:
Resultadostyle.cssindex.html#brick {
  width: 40px;
  height: 20px;
  background: #EE6B47;
  position: relative;
  cursor: pointer;
}

#path {
  outline: 1px solid #E8C48E;
  width: 540px;
  height: 20px;
}<!DOCTYPE HTML>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="style.css">
  <script src="https://js.cx/libs/animate.js"></script>
</head>

<body>


  <div id="path">
    <div id="brick"></div>
  </div>

  <script>
    function makeEaseOut(timing) {
      return function(timeFraction) {
        return 1 - timing(1 - timeFraction);
      }
    }

    function bounce(timeFraction) {
      for (let a = 0, b = 1; 1; a += b, b /= 2) {
        if (timeFraction >= (7 - 4 * a) / 11) {
          return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)
        }
      }
    }

    let bounceEaseOut = makeEaseOut(bounce);

    brick.onclick = function() {
      animate({
        duration: 3000,
        timing: bounceEaseOut,
        draw: function(progress) {
          brick.style.left = progress * 500 + 'px';
        }
      });
    };
  </script>


</body>

</html>Aquí podemos ver cómo la transformación cambia el comportamiento de la función:

      
      
        
      
      Si hay un efecto de animación al principio, como rebotar, se mostrará al final.
En el gráfico anterior, el rebote regular tiene el color rojo y el rebote easyOut es azul.

Rebote regular: el objeto rebota en la parte inferior y luego, al final, salta bruscamente hacia la parte superior.
Después de easyOut – primero salta a la parte superior, luego rebota allí.

easeInOutTambién podemos mostrar el efecto tanto al principio como al final de la animación. La transformación se llama “easyInOut”.
Dada la función de tiempo, calculamos el estado de la animación de la siguiente manera:

      
        
        
          if (timeFraction <= 0.5) { // primera mitad de la animación
  return timing(2 * timeFraction) / 2;
} else { // segunda mitad de la animación
  return (2 - timing(2 * (1 - timeFraction))) / 2;
}
        
      
      
      El código wrapper:

      
        
        
          function makeEaseInOut(timing) {
  return function(timeFraction) {
    if (timeFraction < .5)
      return timing(2 * timeFraction) / 2;
    else
      return (2 - timing(2 * (1 - timeFraction))) / 2;
  }
}

bounceEaseInOut = makeEaseInOut(bounce);
        
      
      
      En acción, bounceEaseInOut:
Resultadostyle.cssindex.html#brick {
  width: 40px;
  height: 20px;
  background: #EE6B47;
  position: relative;
  cursor: pointer;
}

#path {
  outline: 1px solid #E8C48E;
  width: 540px;
  height: 20px;
}<!DOCTYPE HTML>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="style.css">
  <script src="https://js.cx/libs/animate.js"></script>
</head>

<body>


  <div id="path">
    <div id="brick"></div>
  </div>

  <script>
    function makeEaseInOut(timing) {
      return function(timeFraction) {
        if (timeFraction < .5)
          return timing(2 * timeFraction) / 2;
        else
          return (2 - timing(2 * (1 - timeFraction))) / 2;
      }
    }


    function bounce(timeFraction) {
      for (let a = 0, b = 1; 1; a += b, b /= 2) {
        if (timeFraction >= (7 - 4 * a) / 11) {
          return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)
        }
      }
    }

    let bounceEaseInOut = makeEaseInOut(bounce);

    brick.onclick = function() {
      animate({
        duration: 3000,
        timing: bounceEaseInOut,
        draw: function(progress) {
          brick.style.left = progress * 500 + 'px';
        }
      });
    };
  </script>


</body>

</html>La transformación “easyInOut” une dos gráficos en uno: easyIn (regular) para la primera mitad de la animación y easyOut (invertido) – para la segunda parte.
El efecto se ve claramente si comparamos las gráficas de easyIn, easyOut y easyInOut de la función de sincronización circ:

      
      
        
      
      
Rojo es la variante regular de circ (easeIn).
Verde – easeOut.
Azul – easeInOut.

Como podemos ver, el gráfico de la primera mitad de la animación es el easyIn reducido y la segunda mitad es el easyOut reducido. Como resultado, la animación comienza y termina con el mismo efecto.
“Dibujar” más interesanteEn lugar de mover el elemento podemos hacer otra cosa. Todo lo que necesitamos es escribir la función draw adecuada.
Aquí está la escritura de texto animada “rebotando”:
Resultadostyle.cssindex.htmltextarea {
  display: block;
  border: 1px solid #BBB;
  color: #444;
  font-size: 110%;
}

button {
  margin-top: 10px;
}<!DOCTYPE HTML>
<html>

<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="style.css">
  <script src="https://js.cx/libs/animate.js"></script>
</head>

<body>


  <textarea id="textExample" rows="5" cols="60">Tomó su espada vorpal en mano:
Hace mucho tiempo que el enemigo manxome buscaba—
Así descansó junto al árbol Tumtum,
Y se quedó un rato en el pensamiento.
  </textarea>

  <button onclick="animateText(textExample)">¡Ejecuta la escritura animada!</button>

  <script>
    function animateText(textArea) {
      let text = textArea.value;
      let to = text.length,
        from = 0;

      animate({
        duration: 5000,
        timing: bounce,
        draw: function(progress) {
          let result = (to - from) * progress + from;
          textArea.value = text.substr(0, Math.ceil(result))
        }
      });
    }


    function bounce(timeFraction) {
      for (let a = 0, b = 1; 1; a += b, b /= 2) {
        if (timeFraction >= (7 - 4 * a) / 11) {
          return -Math.pow((11 - 6 * a - 11 * timeFraction) / 4, 2) + Math.pow(b, 2)
        }
      }
    }
  </script>


</body>

</html>ResumenPara animaciones que CSS no puede manejar bien, o aquellas que necesitan un control estricto, JavaScript puede ayudar. Las animaciones de JavaScript deben implementarse a través de requestAnimationFrame. Ese método integrado permite configurar una función callback para que se ejecute cuando el navegador esté preparando un repintado. Por lo general, es muy pronto, pero el tiempo exacto depende del navegador.
Cuando una página está en segundo plano, no se repinta en absoluto, por lo que el callback no se ejecutará: la animación se suspenderá y no consumirá recursos. Eso es genial.
Aquí está la función auxiliar animate para configurar la mayoría de las animaciones:

      
        
        
          function animate({timing, draw, duration}) {

  let start = performance.now();

  requestAnimationFrame(function animate(time) {
    // timeFraction va de 0 a 1
    let timeFraction = (time - start) / duration;
    if (timeFraction > 1) timeFraction = 1;

    // calcular el estado actual de la animación
    let progress = timing(timeFraction);

    draw(progress); // dibujar

    if (timeFraction < 1) {
      requestAnimationFrame(animate);
    }

  });
}
        
      
      
      Opciones:

duration – el tiempo total de animación en ms.
timing – la función para calcular el progreso de la animación. Obtiene una fracción de tiempo de 0 a 1, devuelve el progreso de la animación, generalmente de 0 a 1.
draw – la función para dibujar la animación.

Seguramente podríamos mejorarlo, agregar más campanas y silbidos, pero las animaciones de JavaScript no se aplican a diario. Se utilizan para hacer algo interesante y no estándar. Por lo tanto, querrás agregar las funciones que necesitas cuando las necesites.
Las animaciones JavaScript pueden utilizar cualquier función de sincronización. Cubrimos muchos ejemplos y transformaciones para hacerlos aún más versátiles. A diferencia de CSS, aquí no estamos limitados a las curvas de Bézier.
Lo mismo ocurre con draw: podemos animar cualquier cosa, no solo propiedades CSS.
TareasAnimar la pelota que rebotaimportancia: 5Haz una pelota que rebote. Haz clic para ver cómo debería verse:

    
    
  Abrir un entorno controlado para la tarea.soluciónPara rebotar podemos usar la propiedad CSS top y position:absolute para la pelota dentro del campo con position:relative.
La coordenada inferior del campo es field.clientHeight. La propiedad CSS top se refiere al borde superior de la bola. Por lo tanto, debe ir desde 0 hasta field.clientHeight - ball.clientHeight, que es la posición final más baja del borde superior de la pelota.
Para obtener el efecto de “rebote”, podemos usar la función de sincronización bounce en el modo easeOut.
Aquí está el código final de la animación:

      
        
        
          let to = field.clientHeight - ball.clientHeight;

animate({
  duration: 2000,
  timing: makeEaseOut(bounce),
  draw(progress) {
    ball.style.top = to * progress + 'px'
  }
});
        
      
      
      Abrir la solución en un entorno controlado.Animar la pelota rebotando hacia la derechaimportancia: 5Haz que la pelota rebote hacia la derecha. Así:

    
    
  Escribe el código de la animación. La distancia a la izquierda es 100px.
Toma la solución de la tarea anterior Animar la pelota que rebota como fuente.
soluciónEn la tarea Animar la pelota que rebota solo teníamos una propiedad para animar. Ahora necesitamos una más: elem.style.left.
La coordenada horizontal cambia por otra ley: no “rebota”, sino que aumenta gradualmente desplazando la pelota hacia la derecha.
Podemos escribir una animate más para ello.
Como función de tiempo podríamos usar linear, pero algo como makeEaseOut(quad) se ve mucho mejor.
El código:

      
        
        
          let height = field.clientHeight - ball.clientHeight;
let width = 100;

// animate top (rebotando)
animate({
  duration: 2000,
  timing: makeEaseOut(bounce),
  draw: function(progress) {
    ball.style.top = height * progress + 'px'
  }
});

// animate left (moviéndose a la derecha)
animate({
  duration: 2000,
  timing: makeEaseOut(quad),
  draw: function(progress) {
    ball.style.left = width * progress + "px"
  }
});
        
      
      
      Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/js-animation" 
},
{
	"docs_id": "155",
	"name": "Desde la altura orbital",
	"description": "En esta sección se describe un conjunto de normas modernas para los “web components”.",
	"content": "En esta sección se describe un conjunto de normas modernas para los “web components”.
En la actualidad, estos estándares están en desarrollo. Algunas características están bien apoyadas e integradas en el standard moderno HTML/DOM, mientras que otras están aún en fase de borrador. Puedes probar algunos ejemplos en cualquier navegador, Google Chrome es probablemente el que más actualizado esté con estas características. Suponemos que eso se debe a que los compañeros de Google están detrás de muchas de las especificaciones relacionadas.
Lo que es común entre…La idea del componente completo no es nada nuevo. Se usa en muchos frameworks y en otros lugares.
Antes de pasar a los detalles de implementación, echemos un vistazo a este gran logro de la humanidad:

      
      
      Esa es la Estación Espacial Internacional (EEI).
Y así es como se ha montado (aproximadamente):

      
      
      La Estación Espacial Internacional:

Está formada por muchos componentes.
Cada componente, a su vez, tiene muchos detalles más pequeños en su interior.
Los componentes son muy complejos, mucho más complicados que la mayoría de los sitios web.
Los componentes han sido desarrollados internacionalmente, por equipos de diferentes países, que hablan diferentes idiomas.

…Y esta cosa vuela, ¡mantiene a los humanos vivos en el espacio!
¿Cómo se crean dispositivos tan complejos?
¿Qué principios podríamos tomar prestados para que nuestro desarrollo sea fiable y escalable a ese nivel? ¿O, al menos, cerca de él?
Arquitectura de componentesLa regla más conocida para desarrollar software complejo es: no hacer software complejo.
Si algo se vuelve complejo – divídelo en partes más simples y conéctalas de la manera más obvia.
Un buen arquitecto es el que puede hacer lo complejo simple.
Podemos dividir la interfaz de usuario en componentes visuales: cada uno de ellos tiene su propio lugar en la página, puede “hacer” una tarea bien descrita, y está separado de los demás.
Echemos un vistazo a un sitio web, por ejemplo Twitter.
Naturalmente está divido en componentes:

      
      
        
      
      
Navegación superior.
Información usuario.
Sugerencias de seguimiento.
Envío de formulario.
(y también 6, 7) – mensajes.

Los componentes pueden tener subcomponentes, p.ej. los mensajes pueden ser parte de un componente “lista de mensajes” de nivel superior. Una imagen de usuario en sí puede ser un componente, y así sucesivamente.
¿Cómo decidimos qué es un componente? Eso viene de la intuición, la experiencia y el sentido común. Normalmente es una entidad visual separada que podemos describir en términos de lo que hace y cómo interactúa con la página. En el caso anterior, la página tiene bloques, cada uno de ellos juega su propio papel, es lógico crear esos componentes.
Un componente tiene:

Su propia clase de JavaScript.
La estructura DOM, gestionada únicamente por su clase, el código externo no accede a ella (principio de  “encapsulación”).
Estilos CSS, aplicados al componente.
API: eventos, métodos de clase etc, para interactuar con otros componentes.

Una vez más, todo el asunto del “componente” no es nada especial.
Existen muchos frameworks y metodologías de desarrollos para construirlos, cada uno con sus propias características y reglas. Normalmente, se utilizan clases y convenciones CSS para proporcionar la “sensación de componente” – alcance de CSS y encapsulación de DOM.
“Web components” proporcionan capacidades de navegación incorporadas para eso, así que ya no tenemos que emularlos.

Custom elements – para definir elementos HTML personalizados.
Shadow DOM – para crear un DOM interno para el componente, oculto a los demás componentes.
CSS Scoping – para declarar estilos que sólo se aplican dentro del Shadow DOM del componente.
Event retargeting y otras cosas menores para hacer que los componentes se ajusten mejor al desarrollo.

En el próximo capítulo entraremos en detalles en los “Custom Elements” – la característica fundamental y bien soportada de los componentes web, buena por sí misma.
",
	"url": "https://es.javascript.info/webcomponents-intro" 
},
{
	"docs_id": "156",
	"name": "Elementos personalizados",
	"description": "Podemos crear elementos HTML personalizados con nuestras propias clases; con sus propios métodos, propiedades, eventos y demás.",
	"content": "Podemos crear elementos HTML personalizados con nuestras propias clases; con sus propios métodos, propiedades, eventos y demás.
Una vez que definimos el elemento personalizado, podemos usarlo a la par de elementos HTML nativos.
Esto es grandioso, porque el el diccionario HTML es rico pero no infinito. No hay <aletas-faciles>, <gira-carrusel>, <bella-descarga>… Solo piensa en cualquier otra etiqueta que puedas necesitar.
Podemos definirlos con una clase especial, y luego usarlos como si siempre hubieran sido parte del HTML.
Hay dos clases de elementos personalizados:

Elementos personalizados autónomos – son elementos “todo-nuevo”, extensiones de la clase abstracta HTMLElement.
Elementos nativos personalizados – son extensiones de elementos nativos, por ejemplo un botón personalizado basado en HTMLButtonElement.

Primero cubriremos los elementos autónomos, luego pasaremos a la personalización de elementos nativos.
Para crear un elemento personalizado, necesitamos decirle al navegador varios detalles acerca de él: cómo mostrarlo, qué hacer cuando el elemento es agregado o quitado de la página, etc.
Eso se logra creando una clase con métodos especiales. Es fácil, son unos pocos métodos y todos ellos son opcionales.
Este es el esquema con la lista completa:

      
        
        
          class MyElement extends HTMLElement {
  constructor() {
    super();
    // elemento creado
  }

  connectedCallback() {
    // el navegador llama a este método cuando el elemento es agregado al documento
    // (puede ser llamado varias veces si un elemento es agregado y quitado repetidamente)
  }

  disconnectedCallback() {
    // el navegador llama a este método cuando el elemento es quitado del documento
    // (puede ser llamado varias veces si un elemento es agregado y quitado repetidamente)
  }

  static get observedAttributes() {
    return [/* array de nombres de atributos a los que queremos monitorear por cambios */];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // es llamado cuando uno de los atributos listados arriba es modificado
  }

  adoptedCallback() {
    // es llamado cuando el elemento es movido a un nuevo documento
    // (ocurre en document.adoptNode, muy raramente usado)
  }

  // puede haber otros métodos y propiedades de elemento
}
        
      
      
      Después de ello, necesitamos registrar el elemento:

      
        
        
          // hacer saber al navegador que <my-element> es servido por nuestra nueva clase
customElements.define("my-element", MyElement);
        
      
      
      A partir de ello, para cada elemento HTML con la etiqueta <my-element> se crea una instancia de MyElement y se llaman los métodos mencionados. También podemos insertarlo con JavaScript: document.createElement('my-element').

            Los nombres de los elementos personalizados deben incluir un guion -
            Los elemento personalizados deben incluir un guion corto - en su nombre. Por ejemplo, my-element y super-button son nombres válidos, pero myelement no lo es.
Esto se hace para asegurar que no haya conflicto de nombres entre los elementos nativos y los personalizados.

Ejemplo: “time-formatted”Ya existe un elemento <time> en HTML para presentar fecha y hora, pero este no hace ningún formateo por sí mismo.
Construyamos el elemento <time-formatted> que muestre la hora en un bonito formato y reconozca la configuración de lengua local:

      
        
        
          
            
          
          
            
          
        
        
          <script>
class TimeFormatted extends HTMLElement { // (1)

  connectedCallback() {
    let date = new Date(this.getAttribute('datetime') || Date.now());

    this.innerHTML = new Intl.DateTimeFormat("default", {
      year: this.getAttribute('year') || undefined,
      month: this.getAttribute('month') || undefined,
      day: this.getAttribute('day') || undefined,
      hour: this.getAttribute('hour') || undefined,
      minute: this.getAttribute('minute') || undefined,
      second: this.getAttribute('second') || undefined,
      timeZoneName: this.getAttribute('time-zone-name') || undefined,
    }).format(date);
  }

}

customElements.define("time-formatted", TimeFormatted); // (2)
</script>

<!-- (3) -->
<time-formatted datetime="2019-12-01"
  year="numeric" month="long" day="numeric"
  hour="numeric" minute="numeric" second="numeric"
  time-zone-name="short"
></time-formatted>
        
      
      
          
        
      
La clase tiene un solo método, connectedCallback(), que es llamado por el navegador cuando se agrega el elemento <time-formatted> a la página o cuando el analizador HTML lo detecta. Este método usa el formateador de datos nativo Intl.DateTimeFormat, bien soportado por los navegadores, para mostrar una agradable hora formateada.
Necesitamos registrar nuestro nuevo elemento con customElements.define(tag, class).
Y podremos usarlo por doquier.


            Actualización de elementos personalizados
            Si el navegador encuentra algún <time-formatted> antes de customElements.define, no es un error. Pero el elemento es todavía desconocido, como cualquier etiqueta no estándar.
Tal elemento “undefined” puede ser estilizado con el selector CSS :not(:defined).
Una vez que customElement.define es llamado, estos elementos son “actualizados”: para cada elemento, una nueva instancia de TimeFormatted
es creada y connectedCallback es llamado. Se vuelven :defined.
Para obtener información acerca de los elementos personalizados, tenemos los métodos:

customElements.get(name) – devuelve la clase del elemento personalizado con el name dado,
customElements.whenDefined(name) – devuelve una promesa que se resuelve (sin valor) cuando un elemento personalizado con el name dado se vuelve defined.



            Renderizado en connectedCallback, no en el constructor
            En el ejemplo de arriba, el contenido del elemento es renderizado (construido) en connectedCallback.
¿Por qué no en el constructor?
La razón es simple: cuando el constructor es llamado, es aún demasiado pronto. El elemento es creado, pero el navegador aún no procesó ni asignó atributos en este estado, entonces las llamadas a getAttribute devolverían null. Así que no podemos renderizar ahora.
Por otra parte, si lo piensas, es más adecuado en términos de performance: demorar el trabajo hasta que realmente se lo necesite.
El connectedCallback se dispara cuando el elemento es agregado al documento. No apenas agregado a otro elemento como hijo, sino cuando realmente se vuelve parte de la página. Así podemos construir un DOM separado, crear elementos y prepararlos para uso futuro. Ellos serán realmente renderizados una vez que estén dentro de la página.

Observando atributosEn la implementación actual de <time-formatted>, después de que el elemento fue renderizado, cambios posteriores en sus atributos no tendrán ningún efecto. Eso es extraño para un elemento HTML, porque cuando cambiamos un atributo (como en a.href) esperamos que dicho cambio sea visible de inmediato. Corrijamos esto.
Podemos observar atributos suministrando la lista de ellos al getter estático observedAttributes(). Cuando esos atributos son modificados, se dispara attributeChangedCallback. No se dispara para los atributos no incluidos en la lista, por razones de performance.
A continuación, el nuevo <time-formatted> que se actualiza cuando los atributos cambian:

      
        
        
          
            
          
          
            
          
        
        
          <script>
class TimeFormatted extends HTMLElement {

  render() { // (1)
    let date = new Date(this.getAttribute('datetime') || Date.now());

    this.innerHTML = new Intl.DateTimeFormat("default", {
      year: this.getAttribute('year') || undefined,
      month: this.getAttribute('month') || undefined,
      day: this.getAttribute('day') || undefined,
      hour: this.getAttribute('hour') || undefined,
      minute: this.getAttribute('minute') || undefined,
      second: this.getAttribute('second') || undefined,
      timeZoneName: this.getAttribute('time-zone-name') || undefined,
    }).format(date);
  }

  connectedCallback() { // (2)
    if (!this.rendered) {
      this.render();
      this.rendered = true;
    }
  }

  static get observedAttributes() { // (3)
    return ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'time-zone-name'];
  }

  attributeChangedCallback(name, oldValue, newValue) { // (4)
    this.render();
  }

}

customElements.define("time-formatted", TimeFormatted);
</script>

<time-formatted id="elem" hour="numeric" minute="numeric" second="numeric"></time-formatted>

<script>
setInterval(() => elem.setAttribute('datetime', new Date()), 1000); // (5)
</script>
        
      
      
          
        
      
La lógica de renderizado fue movida al método ayudante render().
Lo llamamos una vez cuando el elemento es insertado en la página.
Al cambiar un atributo listado en observedAttributes(), se dispara attributeChangedCallback.
…y se re-renderiza el elemento.
Como resultado, ahora podemos crear un reloj dinámico con facilidad.

Orden de renderizadoCuando el “parser” construye el DOM, los elementos son procesados uno tras otro, padres antes que hijos. Por ejemplo si tenemos <outer><inner></inner></outer>, el elemento <outer> es creado y conectado al DOM primero, y luego <inner>.
Esto lleva a consecuencias importantes para los elementos personalizados.
Por ejemplo, si un elemento personalizado trata de acceder a innerHTML en connectedCallback, no obtiene nada:

      
        
        
          
            
          
          
            
          
        
        
          <script>
customElements.define('user-info', class extends HTMLElement {

  connectedCallback() {
    alert(this.innerHTML); // vacío (*)
  }

});
</script>

<user-info>John</user-info>
        
      
      
      Si lo ejecutas, el alert estará vacío.
Esto es porque no hay hijos en aquel estadio, pues el DOM no está finalizado. Se conectó el elemento personalizado <user-info> y está por proceder con sus hijos, pero no lo hizo aún.
Si queremos pasar información al elemento personalizado, podemos usar atributos. Estos están disponibles inmediatamente.
O, si realmente necesitamos acceder a los hijos, podemos demorar el acceso a ellos con un setTimeout de tiempo cero.
Esto funciona:

      
        
        
          
            
          
          
            
          
        
        
          <script>
customElements.define('user-info', class extends HTMLElement {

  connectedCallback() {
    setTimeout(() => alert(this.innerHTML)); // John (*)
  }

});
</script>

<user-info>John</user-info>
        
      
      
      Ahora el alert en la línea (*) muestra “John” porque lo corremos asincrónicamente, después de que el armado HTML está completo. Podemos procesar los hijos si lo necesitamos y finalizar la inicialización.
Por otro lado, la solución tampoco es perfecta. Si los elementos anidados también usan setTimeout para inicializarse, entonces van a la cola: el setTimeout externo se dispara primero y luego el interno.
Como consecuencia, el elemento externo termina la inicialización antes que el interno.
Demostrémoslo con un ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <script>
customElements.define('user-info', class extends HTMLElement {
  connectedCallback() {
    alert(`${this.id} connected.`);
    setTimeout(() => alert(`${this.id} initialized.`));
  }
});
</script>

<user-info id="outer">
  <user-info id="inner"></user-info>
</user-info>
        
      
      
      Orden de salida:

outer conectado.
inner conectado.
outer inicializado.
inner inicializado.

Claramente vemos que el elemento finaliza su inicialización (3) antes que el interno (4).
No existe un callback nativo que se dispare después de que los elementos anidados estén listos. Si es necesario, podemos implementarlo nosotros mismos. Por ejemplo, los elementos internos pueden disparar eventos como initialized, y los externos pueden escucharlos para reaccionar a ellos.
Elementos nativos personalizadosLos elementos nuevos que creamos, tales como <time-formatted>, no tienen ninguna semántica asociada. Para los motores de búsqueda son desconocidos, y los dispositivos de accesibilidad tampoco pueden manejarlos.
Pero estas cosas son importantes. Por ejemplo, un motor de búsqueda podría estar interesado en saber que realmente mostramos la hora. y si hacemos una clase especial de botón, ¿por qué no reusar la funcionalidad ya existente de <button>?
Podemos extender y personalizar elementos HTML nativos, heredando desde sus clases.
Por ejemplo, los botones son instancias de HTMLButtonElement, construyamos sobre ello.


Extender HTMLButtonElement con nuestra clase:

      
        
        
          class HelloButton extends HTMLButtonElement { /* métodos de elemento personalizado */ }
        
      
      
      

Ponemos el tercer argumento de customElements.define, el cual especifica la etiqueta:

      
        
        
          customElements.define('hello-button', HelloButton, {extends: 'button'});
        
      
      
      Puede haber diferentes etiquetas que comparten la misma clase DOM, por eso se necesita especificar extends.


Por último, para usar nuestro elemento personalizado, insertamos una etiqueta común <button>, pero le agregamos is="hello-button":

      
        
        
          <button is="hello-button">...</button>
        
      
      
      

El ejemplo completo:

      
        
        
          
            
          
          
            
          
        
        
          <script>
// El botón que dice "hello" al hacer clic
class HelloButton extends HTMLButtonElement {
  constructor() {
    super();
    this.addEventListener('click', () => alert("Hello!"));
  }
}

customElements.define('hello-button', HelloButton, {extends: 'button'});
</script>

<button is="hello-button">Click me</button>

<button is="hello-button" disabled>Disabled</button>
        
      
      
          
        
      Nuestro nuevo botón extiende el ‘button’ nativo. Así mantenemos los mismos estilos y características estándar, como por ejemplo el atributo disabled.
Referencias
HTML estándar vivo: https://html.spec.whatwg.org/#custom-elements.
Compatibilidad: https://caniuse.com/#feat=custom-elementsv1.

ResumenLos elementos personalizados pueden ser de dos tipos:


“Autónomos” – son etiquetas nuevas, se crean extendiendo HTMLElement.
Esquema de definición:

      
        
        
          class MyElement extends HTMLElement {
  constructor() { super(); /* ... */ }
  connectedCallback() { /* ... */ }
  disconnectedCallback() { /* ... */  }
  static get observedAttributes() { return [/* ... */]; }
  attributeChangedCallback(name, oldValue, newValue) { /* ... */ }
  adoptedCallback() { /* ... */ }
 }
customElements.define('my-element', MyElement);
/* <my-element> */
        
      
      
      

“Elementos nativos personalizados” – se crean extendiendo elementos ya existentes.
Requiere un argumento más .define, y is="..." en HTML:

      
        
        
          class MyButton extends HTMLButtonElement { /*...*/ }
customElements.define('my-button', MyElement, {extends: 'button'});
/* <button is="my-button"> */
        
      
      
      

Los elementos personalizados tienen muy buen soporte entre los navegadores. Existe un polyfill https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs.
TareasElemento reloj dinámicoYa tenemos un elemento <time-formatted> para mostrar la hora agradablemente formateada.
Crea el elemento <live-timer> para mostrar la hora actual:

Internamente debe usar <time-formatted>, no duplicar su funcionalidad.
Aactualiza (¡tic!) cada segundo.
Por cada tic, se debe generar un evento personalizado llamado tick con la fecha actual en event.detail (ver artículo Envío de eventos personalizados).

Uso:

      
        
        
          <live-timer id="elem"></live-timer>

<script>
  elem.addEventListener('tick', event => console.log(event.detail));
</script>
        
      
      
      Demo:

    
    
  Abrir un entorno controlado para la tarea.soluciónPor favor ten en cuenta:

Borramos el temporizador setInterval cuando el elemento es quitado del documento. Esto es importante, de otro modo continuará ejecutando aunque no se lo necesite más, y el navegador no puede liberar la memoria asignada a este elemento.
Podemos acceder a la fecha actual con la propiedad elem.date. Todos los métodos y propiedades de clase son naturalmente métodos y propiedades del elemento.

Abrir la solución en un entorno controlado.",
	"url": "https://es.javascript.info/custom-elements" 
},
{
	"docs_id": "157",
	"name": "Shadow DOM",
	"description": "Shadow DOM sirve para el encapsulamiento. Le permite a un componente tener su propio árbol DOM oculto, que no puede ser accedido por accidente desde el documento principal, puede tener reglas de estilo locales, y más.",
	"content": "Shadow DOM sirve para el encapsulamiento. Le permite a un componente tener su propio árbol DOM oculto, que no puede ser accedido por accidente desde el documento principal, puede tener reglas de estilo locales, y más.
Shadow DOM incorporado¿Alguna vez pensó cómo los controles complejos del navegador se crean y se les aplica estilo?
Tales como <input type="range">:



El navegador usa DOM/CSS internamente para dibujarlos. Esa estructura DOM normalmente está oculta para nosotros, pero podemos verla con herramientas de desarrollo. Por ejemplo, en Chrome, necesitamos habilitar la opción “Show user agent shadow DOM” en las herramientas de desarrollo.
Entonces <input type="range"> se ve algo así:

      
      
      Lo que ves bajo #shadow-root se llama “shadow DOM”.
No podemos obtener los elementos de shadow DOM incorporados con llamadas normales a JavaScript o selectores. Estos no son hijos normales sino una poderosa técnica de encapsulamiento.
En el ejemplo de abajo podemos ver un útil atributo pseudo. No es estándar, existe por razones históricas. Podemos usarlo para aplicar estilo a subelementos con CSS como aquí:

      
        
        
          
            
          
          
            
          
        
        
          <style>
/* hace el control deslizable rojo */
input::-webkit-slider-runnable-track {
  background: red;
}
</style>

<input type="range">
        
      
      
          
        
      De nuevo: pseudo no es un atributo estándar. Cronológicamente, los navegadores primero comenzaron a experimentar con estructuras DOM internas para implementar controles, y luego, con el tiempo, fue estandarizado shadow DOM que nos permite, a nosotros desarrolladores, hacer algo similar.
Seguidamente usaremos el moderno estándar shadow DOM cubierto en la especificación DOM.
Shadow tree (árbol oculto)Un elemento DOM puede tener dos tipos de subárboles DOM:

Light tree – un subárbol normal, hecho de hijos HTML. Todos los subárboles vistos en capítulos previos eran “light”.
Shadow tree – un subárbol shadow DOM, no reflejado en HTML, oculto a la vista.

Si un elemento tiene ambos, el navegador solamente construye el árbol shadow. Pero también podemos establecer un tipo de composición entre árboles shadow y light. Veremos los detalles en el capítulo Shadow DOM slots, composición.
El árbol shadow puede ser usado en elementos personalizados para ocultar los componentes internos y aplicarles estilos locales.
Por ejemplo, este elemento <show-hello> oculta su DOM interno en un shadow tree:

      
        
        
          
            
          
          
            
          
        
        
          <script>
customElements.define('show-hello', class extends HTMLElement {
  connectedCallback() {
    const shadow = this.attachShadow({mode: 'open'});
    shadow.innerHTML = `<p>
      Hello, ${this.getAttribute('name')}
    </p>`;
  }
});
</script>

<show-hello name="John"></show-hello>
        
      
      
          
        
      Así es como el DOM resultante se ve en las herramientas de desarrollador de Chrome, todo el contenido está bajo “#shadow-root”:

      
      
      Primero, el llamado a elem.attachShadow({mode: …}) crea un árbol shadow.
Hay dos limitaciones:

Podemos crear solamente una raíz shadow por elemento.
elem debe ser: o bien un elemento personalizado, o uno de: “article”, “aside”, “blockquote”, “body”, “div”, “footer”, “h1…h6”, “header”, “main” “nav”, “p”, “section”, o “span”. Otros elementos, como <img>, no pueden contener un árbol shadow.

La opción mode establece el nivel de encapsulamiento. Debe tener uno de estos dos valores:


"open" – Abierto: la raíz shadow está disponible como elem.shadowRoot.
Todo código puede acceder el árbol shadow de elem.


"closed" – Cerrado: elem.shadowRoot siempre es null.
Solamente podemos acceder al shadow DOM por medio de la referencia devuelta por attachShadow (y probablemente oculta dentro de un class). Árboles shadow nativos del navegador, tales como <input type="range">, son “closed”. No hay forma de accederlos.


La raíz shadow root, devuelta por attachShadow, es como un elemento: podemos usar innerHTML o métodos DOM tales como append para llenarlo.
El elemento con una raíz shadow es llamado “shadow tree host” (anfitrión de árbol shadow), y está disponible como la propiedad host de shadow root:

      
        
        
          // asumimos {mode: "open"}, de otra forma elem.shadowRoot sería null
alert(elem.shadowRoot.host === elem); // true
        
      
      
      EncapsulamientoShadow DOM está fuertemente delimitado del documento principal “main document”:

Los elementos Shadow DOM no son visibles para querySelector desde el DOM visible (light DOM). En particular,  los elementos Shadow DOM pueden tener ids en conflicto con aquellos en el DOM visible. Estos deben ser únicos solamente dentro del árbol shadow.
El Shadow DOM tiene stylesheets propios. Las reglas de estilo del exterior DOM no se le aplican.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <style>
  /* document style no será aplicado al árbol shadow dentro de #elem (1) */
  p { color: red; }
</style>

<div id="elem"></div>

<script>
  elem.attachShadow({mode: 'open'});
    // el árbol shadow tiene su propio style (2)
  elem.shadowRoot.innerHTML = `
    <style> p { font-weight: bold; } </style>
    <p>Hello, John!</p>
  `;

  // <p> solo es visible en consultas "query" dentro del árbol shadow (3)
  alert(document.querySelectorAll('p').length); // 0
  alert(elem.shadowRoot.querySelectorAll('p').length); // 1
</script>
        
      
      
      
El estilo del documento no afecta al árbol shadow.
…Pero el estilo interno funciona.
Para obtener los elementos en el árbol shadow, debemos buscarlos (query) desde dentro del árbol.

Referencias
DOM: https://dom.spec.whatwg.org/#shadow-trees
Compatibilidad: https://caniuse.com/#feat=shadowdomv1
Shadow DOM es mencionado en muchas otras especificaciones, por ejemplo DOM Parsing especifica que el shadow root tiene innerHTML.

ResumenEl Shadow DOM es una manera de crear un DOM de componentes locales.

shadowRoot = elem.attachShadow({mode: open|closed}) – crea shadow DOM para elem. Si mode="open", será accesible con la propiedad elem.shadowRoot.
Podemos llenar shadowRoot usando innerHTML u otros métodos DOM.

Los elementos de Shadow DOM:

Tienen su propio espacio de ids,
Son invisibles a los selectores JavaScript desde el documento principal tales como querySelector,
Usan style solo desde dentro del árbol shadow, no desde el documento principal.

El Shadow DOM, si existe, es construido por el navegador en lugar del DOM visible llamado “light DOM” (hijo regular). En el capítulo Shadow DOM slots, composición veremos cómo se componen.
",
	"url": "https://es.javascript.info/shadow-dom" 
},
{
	"docs_id": "158",
	"name": "Elemento template",
	"description": "El elemento incorporado <template> sirve como almacenamiento para plantillas de markup de HTML. El navegador ignora su contenido, solo verifica la validez de la sintaxis, pero podemos acceder a él y usarlo en JavaScript para crear otros elementos.",
	"content": "El elemento incorporado <template> sirve como almacenamiento para plantillas de markup de HTML. El navegador ignora su contenido, solo verifica la validez de la sintaxis, pero podemos acceder a él y usarlo en JavaScript para crear otros elementos.
En teoría, podríamos crear cualquier elemento invisible en algún lugar de HTML par fines de almacenamiento de HTML markup. ¿Qué hay de especial en <template>?
En primer lugar, su contenido puede ser cualquier HTML válido, incluso si normalmente requiere una etiqueta adjunta adecuada.
Por ejemplo, podemos poner una fila de tabla <tr>:

      
        
        
          <template>
  <tr>
     <td>Contenidos</td>
  </tr>
</template>
        
      
      
      Normalmente, si intentamos poner <tr> dentro, digamos, de un <div>, el navegador detecta la estructura DOM como inválida y la “arregla”, y añade un <table> alrededor. Eso no es lo que queremos. Sin embargo, <template> mantiene exactamente lo que ponemos allí.
También podemos poner estilos y scripts dentro de <template>:

      
        
        
          <template>
  <style>
    p { font-weight: bold; }
  </style>
  <script>
    alert("Hola");
  </script>
</template>
        
      
      
      El navegador considera al contenido <template> “fuera del documento”: Los estilos no son aplicados, los scripts no son ejecutados, <video autoplay> no es ejecutado, etc.
El contenido cobra vida (estilos aplicados, scripts, etc) cuando los insertamos dentro del documento.
Insertando templateEl contenido template está disponible en su propiedad content como un DocumentFragment: un tipo especial de nodo DOM.
Podemos tratarlo como a cualquier otro nodo DOM, excepto por una propiedad especial: cuando lo insertamos en algún lugar, sus hijos son insertados en su lugar.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          <template id="tmpl">
  <script>
    alert("Hola");
  </script>
  <div class="message">¡Hola mundo!</div>
</template>

<script>
  let elem = document.createElement('div');

  // Clona el contenido de la plantilla para reutilizarlo múltiples veces
  elem.append(tmpl.content.cloneNode(true));

  document.body.append(elem);
  // Ahora el script de <template> se ejecuta
</script>
        
      
      
      Reescribamos un ejemplo de Shadow DOM del capítulo anterior usando <template>:

      
        
        
          
            
          
          
            
          
        
        
          <template id="tmpl">
  <style> p { font-weight: bold; } </style>
  <p id="message"></p>
</template>

<div id="elem">Haz clic sobre mi</div>

<script>
  elem.onclick = function() {
    elem.attachShadow({mode: 'open'});

    elem.shadowRoot.append(tmpl.content.cloneNode(true)); // (*)

    elem.shadowRoot.getElementById('message').innerHTML = "¡Saludos desde las sombras!";
  };
</script>
        
      
      
          
        
      En la línea (*), cuando clonamos e insertamos tmpl.content como su DocumentFragment, sus hijos (<style>, <p>) se insertan en su lugar.
Ellos forman el shadow DOM:

      
        
        
          <div id="elem">
  #shadow-root
    <style> p { font-weight: bold; } </style>
    <p id="message"></p>
</div>
        
      
      
      ResumenPara resumir:

El contenido <template> puede ser cualquier HTML sintácticamente correcto.
El contenido <template> es considerado “fuera del documento”, para que no afecte a nada.
Podemos acceder a template.content desde JavaScript, y clonarlo para reusarlo en un nuevo componente.

La etiqueta <template> es bastante única, ya que:

El navegador comprueba la sintaxis HTML dentro de él (lo opuesto a usar una plantilla string dentro de un script).
…Pero aún permite el uso de cualquier etiqueta HTML de alto nivel, incluso aquellas que no tienen sentido sin un envoltorio adecuado (por ej.<tr>).
El contenido se vuelve interactivo cuando es insertado en el documento: los scripts se ejecutan, <video autoplay> se reproduce, etc.

El elemento <template> no ofrece ningún mecanismo de iteración, enlazamiento de datos o sustitución de variables, pero podemos implementar los que están por encima.
",
	"url": "https://es.javascript.info/template-element" 
},
{
	"docs_id": "159",
	"name": "Shadow DOM slots, composición",
	"description": "Muchos tipos de componentes; como pestañas, menús, galerías de imágenes, etc., necesitan renderizar contenido.",
	"content": "Muchos tipos de componentes; como pestañas, menús, galerías de imágenes, etc., necesitan renderizar contenido.
Al igual que el <select> nativo del navegador espera elementos de <option>, nuestros <custom-tabs> pueden esperar que se pase el contenido real de la pestaña. Y un <custom-menu> puede esperar elementos de menú.
El código que hace uso de <custom-menu> puede verse así:

      
        
        
          <custom-menu>
  <title>Menú de dulces</title>
  <item>Paletas</item>
  <item>Tostada de frutas</item>
  <item>Magdalenas</item>
</custom-menu>
        
      
      
      …Entonces nuestro componente debería renderizar correctamente, como un agradable menú con un título y elementos dados, manejar eventos de menú, etc.
¿Cómo implementarlo?
Podríamos intentar analizar el contenido del elemento y copiar y reorganizar dinámicamente los nodos del DOM. Esto es posible, pero si estamos moviendo elementos al shadow DOM, entonces los estilos CSS del documento no se aplican allí, por lo que se puede perder el estilo visual. También eso requiere algo de programación.
Afortunadamente, no tenemos que hacerlo. Shadow DOM soporta elementos <slot>, que se llenan automáticamente con el contenido del light DOM.
Slots con nombresVeamos cómo funcionan los slots en un ejemplo simple.
Aquí, el shadow DOM <user-card> proporciona dos slots, que se llenan desde el light DOM:

      
        
        
          
            
          
          
            
          
        
        
          <script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <div>Nombre:
        <slot name="username"></slot>
      </div>
      <div>Cumpleaños:
        <slot name="birthday"></slot>
      </div>
    `;
  }
});
</script>

<user-card>
  <span slot="username">John Smith</span>
  <span slot="birthday">01.01.2001</span>
</user-card>
        
      
      
          
        
      En el shadow DOM, <slot name="X"> define un “punto de inserción”, un lugar donde se renderizan los elementos con slot="X".
Luego, el navegador realiza la “composición”: toma elementos del light DOM y los renderiza en los slots correspondientes del shadow DOM. Al final, tenemos exactamente lo que queremos: un componente que se puede llenar con datos.
Aquí está la estructura del DOM después del script, sin tener en cuenta la composición:

      
        
        
          <user-card>
  #shadow-root
    <div>Nombre:
      <slot name="username"></slot>
    </div>
    <div>Cumpleaños:
      <slot name="birthday"></slot>
    </div>
  <span slot="username">John Smith</span>
  <span slot="birthday">01.01.2001</span>
</user-card>
        
      
      
      Creamos el shadow DOM, así que aquí está, en #shadow-root. Ahora el elemento tiene ambos, light DOM y shadow DOM.
Para fines de renderizado, para cada <slot name="..."> en el shadow DOM, el navegador busca slot="..." con el mismo nombre en el light DOM.  Estos elementos se renderizan dentro de los slots:

      
      
        
      
      El resultado se llama “flattened DOM” (DOM aplanado):

      
        
        
          <user-card>
  #shadow-root
    <div>Nombre:
      <slot name="username">
        <!-- el elemento esloteado se inserta en el slot -->
        <span slot="username">John Smith</span>
      </slot>
    </div>
    <div>Cumpleaños:
      <slot name="birthday">
        <span slot="birthday">01.01.2001</span>
      </slot>
    </div>
</user-card>
        
      
      
      …Pero el flattened DOM existe solo para fines de procesamiento y manejo de eventos. Es una especie de “virtual DOM”. Así se muestran las cosas. Pero los nodos del documento en realidad no se mueven!
Eso se puede comprobar fácilmente si ejecutamos querySelectorAll: los nodos todavía están en sus lugares.

      
        
        
          // light DOM <span> los nodos siguen en el mismo lugar, en `<user-card>`
alert( document.querySelectorAll('user-card span').length ); // 2
        
      
      
      Entonces, el flattened DOM se deriva del shadow DOM insertando slots. El navegador lo renderiza y lo usa para la herencia de estilo, la propagación de eventos (más sobre esto más adelante). Pero JavaScript todavía ve el documento “tal cual”, antes de acoplarlo.

            Solo los nodos hijos de alto nivel pueden tener el atributo slot="…" 
            El atributo slot =" ... " solo es válido para los hijos directos del shadow host (en nuestro ejemplo, el elemento <user-card>). Para los elementos anidados, se ignora.
Por ejemplo, el segundo <span> aquí se ignora (ya que no es un elemento hijo de nivel superior de <user-card>):

      
        
        
          <user-card>
  <span slot="username">John Smith</span>
  <div>
    <!-- slot no válido, debe ser hijo directo de user-card -->
    <span slot="birthday">01.01.2001</span>
  </div>
</user-card>
        
      
      
      
Si hay varios elementos en el light DOM con el mismo nombre de slot, se añaden al slot, uno tras otro.
Por ejemplo, este:

      
        
        
          <user-card>
  <span slot="username">John</span>
  <span slot="username">Smith</span>
</user-card>
        
      
      
      Este flattened DOM con dos elementos en <slot name="username">:

      
        
        
          <user-card>
  #shadow-root
    <div>Nombre:
      <slot name="username">
        <span slot="username">John</span>
        <span slot="username">Smith</span>
      </slot>
    </div>
    <div>Cumpleaños:
      <slot name="birthday"></slot>
    </div>
</user-card>
        
      
      
      Slot con contenido alternativoSi ponemos algo dentro de un <slot>, se convierte en el contenido alternativo, “predeterminado”. El navegador lo muestra si no tiene un equivalente en el Light DOM desde donde llenarlo.
Por ejemplo, en esta parte del shadow DOM, se representa Anónimo si no hay slot="username" en el light DOM.

      
        
        
          <div>Name:
  <slot name="username">anónimo</slot>
</div>
        
      
      
      Slot predeterminado: el primero sin nombreEl primer <slot> en el shadow DOM que no tiene un nombre es un slot “predeterminado”. Obtiene todos los nodos del light DOM que no están ubicados en otro lugar.
Por ejemplo, agreguemos el slot predeterminado a nuestro <user-card> que muestra toda la información sin slotear sobre el usuario:

      
        
        
          
            
          
          
            
          
        
        
          <script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
    <div>Nombre:
      <slot name="username"></slot>
    </div>
    <div>Cumpleaños:
      <slot name="birthday"></slot>
    </div>
    <fieldset>
      <legend>Otra información</legend>
      <slot></slot>
    </fieldset>
    `;
  }
});
</script>

<user-card>
  <div>Me gusta nadar.</div>
  <span slot="username">John Smith</span>
  <span slot="birthday">01.01.2001</span>
  <div>...Y jugar volleyball también!</div>
</user-card>
        
      
      
          
        
      Todo el contenido del light DOM sin slotear entra en el conjunto de campos “Otra información”.
Los elementos se agregan a un slot uno tras otro, por lo que ambas piezas de información sin slotear se encuentran juntas en el slot predeterminado.
El flattened DOM se ve así:

      
        
        
          <user-card>
  #shadow-root
    <div>Nombre:
      <slot name="username">
        <span slot="username">John Smith</span>
      </slot>
    </div>
    <div>Cumpleaños:
      <slot name="birthday">
        <span slot="birthday">01.01.2001</span>
      </slot>
    </div>
    <fieldset>
      <legend>Otra información</legend>
      <slot>
        <div>Me gusta nadar.</div>
        <div>...Y jugar volleyball también!</div>
      </slot>
    </fieldset>
</user-card>
        
      
      
      Ejemplo de menúAhora volvamos al <custom-menu>, mencionado al principio del capítulo.
Podemos usar slots para distribuir elementos.
Aquí está el marcado para <custom-menu>:

      
        
        
          <custom-menu>
  <span slot="title">Menú de dulces</span>
  <li slot="item">Paletas</li>
  <li slot="item">Tostada de frutas</li>
  <li slot="item">Magdalenas</li>
</custom-menu>
        
      
      
      La plantilla del shadow DOM con los slots adecuados:

      
        
        
          <template id="tmpl">
  <style> /* estilos del menu */ </style>
  <div class="menu">
    <slot name="title"></slot>
    <ul><slot name="item"></slot></ul>
  </div>
</template>
        
      
      
      
<span slot="title"> entra en <slot name="title">.
Hay muchos <li slot="item"> en la plantilla, pero solo un <slot name="item"> en la plantilla. Así que todos esos <li slot="item"> se añaden a  <slot name="item"> uno tras otro, formando así la lista.

El flattened DOM se convierte en:

      
        
        
          <custom-menu>
  #shadow-root
    <style> /* estilos del menu */ </style>
    <div class="menu">
      <slot name="title">
        <span slot="title">Menú de dulces</span>
      </slot>
      <ul>
        <slot name="item">
          <li slot="item">Paletas</li>
          <li slot="item">Tostada de frutas</li>
          <li slot="item">Magdalenas</li>
        </slot>
      </ul>
    </div>
</custom-menu>
        
      
      
      Uno podría notar que, en un DOM válido, <li> debe ser un hijo directo de <ul>. Pero esto es flattened DOM, describe cómo se representa el componente, tal cosa sucede naturalmente aquí.
Solo necesitamos agregar un manejador de click para abrir/cerrar la lista, y el <custom-menu> está listo:

      
        
        
          customElements.define('custom-menu', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});

    // tmpl es la plantilla del shadow DOM (arriba)
    this.shadowRoot.append( tmpl.content.cloneNode(true) );

    // no podemos seleccionar nodos del light DOM, así que manejemos los clics en el slot
    this.shadowRoot.querySelector('slot[name="title"]').onclick = () => {
      // abrir/cerrar el menú
      this.shadowRoot.querySelector('.menu').classList.toggle('closed');
    };
  }
});
        
      
      
      Aquí está la demostración completa:

    
        
      
      
    
  Por supuesto, podemos agregarle más funcionalidad: eventos, métodos, etc.
Actualizar slots¿Qué pasa si el código externo quiere agregar/eliminar elementos de menú dinámicamente?
El navegador monitorea los slots y actualiza la representación si se agregan/eliminan elementos sloteados.
Además, como los nodos del light DOM no se copian, sino que simplemente se renderizan en los slots, los cambios dentro de ellos se hacen visibles de inmediato.
Así que no tenemos que hacer nada para actualizar el renderizado. Pero si el código del componente quiere saber acerca de los cambios del slot, entonces el evento slotchange está disponible.
Por ejemplo, aquí el elemento del menú se inserta dinámicamente después de 1 segundo y el título cambia después de 2 segundos.:

      
        
        
          
            
          
          
            
          
        
        
          <custom-menu id="menu">
  <span slot="title">Menú de dulces</span>
</custom-menu>

<script>
customElements.define('custom-menu', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `<div class="menu">
      <slot name="title"></slot>
      <ul><slot name="item"></slot></ul>
    </div>`;

    // shadowRoot no puede tener controladores de eventos, por lo que se usa el primer hijo
    this.shadowRoot.firstElementChild.addEventListener('slotchange',
      e => alert("slotchange: " + e.target.name)
    );
  }
});

setTimeout(() => {
  menu.insertAdjacentHTML('beforeEnd', '<li slot="item">Paletas</li>')
}, 1000);

setTimeout(() => {
  menu.querySelector('[slot="title"]').innerHTML = "Nuevo menú";
}, 2000);
</script>
        
      
      
      La representación del menú se actualiza cada vez sin nuestra intervención…
Hay dos eventos slotchange aquí:


En la inicialización:
slotchange: title se dispara inmediatamente, cuando el slot="title" desde el light DOM entra en el slot correspondiente.


Después de 1 segundo:
slotchange: item se activa, cuando se agrega un nuevo <li slot="item">.


Observa que no hay ningún evento slotchange después de 2 segundos, cuando se modifica el contenido de slot = "title". Eso es porque no hay cambio en el slot. Modificamos el contenido dentro del elemento esloteado, eso es otra cosa.
Si quisiéramos rastrear las modificaciones internas del Light DOM desde JavaScript, eso también es posible usando un mecanismo más genérico: MutationObserver.
Slot APIFinalmente, mencionemos los métodos JavaScript relacionados con los slots.
Como hemos visto antes, JavaScript busca en el DOM “real”, sin aplanar. Pero, si el shadow tree tiene {mode: 'open'}, averiguar qué elementos hay asignados a un slot y, viceversa, averiguar el slot por el elemento dentro de el:

node.assignedSlot – retorna el elemento <slot> al que está asignado el nodo.
slot.assignedNodes({flatten: true/false}) – Nodos DOM, asignados al slot. La opción flatten es false por defecto. Si se establece explícitamente a true, entonces mira más profundamente en el flattened DOM, retornando slots anidadas en caso de componentes anidados y el contenido de respaldo si ningún node está asignado.
slot.assignedElements({flatten: true/false}) – Elementos DOM, asignados al slot (igual que arriba, pero solo nodos de elementos).

Estos métodos son útiles cuando no solo necesitamos mostrar el contenido esloteado, sino también rastrearlo en JavaScript.
Por ejemplo, si el componente <custom-menu> quiere saber qué muestra, entonces podría rastrear slotchange y obtener los elementos de slot.assignedElements:

      
        
        
          
            
          
          
            
          
        
        
          <custom-menu id="menu">
  <span slot="title">Menú de dulces</span>
  <li slot="item">Paletas</li>
  <li slot="item">Tostada de frutas</li>
</custom-menu>

<script>
customElements.define('custom-menu', class extends HTMLElement {
  items = []

  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `<div class="menu">
      <slot name="title"></slot>
      <ul><slot name="item"></slot></ul>
    </div>`;

    // se activa cuando cambia el contenido del slot
    this.shadowRoot.firstElementChild.addEventListener('slotchange', e => {
      let slot = e.target;
      if (slot.name == 'item') {
        this.items = slot.assignedElements().map(elem => elem.textContent);
        alert("Items: " + this.items);
      }
    });
  }
});

// se actualizan después de 1 segundo
setTimeout(() => {
  menu.insertAdjacentHTML('beforeEnd', '<li slot="item">Magdalenas</li>')
}, 1000);
</script>
        
      
      
      ResumenPor lo general, si un elemento tiene shadow DOM, no se muestra su light DOM. Los slots permiten mostrar elementos del light DOM en lugares específicos del shadow DOM.
Hay dos tipos de slots:

Named slots: <slot name="X">...</slot> – consigue los light children con slot="X".
Default slot: el primer <slot> sin un nombre (los slots subsiguientes sin nombre se ignoran) – obtiene light children sin slotear.
Si hay muchos elementos para el mismo slot, se añaden uno tras otro.
El contenido del elemento <slot> se utiliza como respaldo. Se muestra si no hay light children para el slot.

El proceso de renderizar elementos sloteados dentro de sus slots se llama “composición”. El resultado se denomina “flattened DOM”.
La composición no mueve realmente los nodos, desde el punto de vista de JavaScript, el DOM sigue siendo el mismo.
JavaScript puede acceder a los slots mediante estos métodos:

slot.assignedNodes/Elements() – retorna nodos/elementos dentro del slot.
node.assignedSlot – la propiedad inversa, retorna el slot por un nodo.

Si queremos saber, podemos rastrear el contenido de los slots usando:

slotchange event – se activa la primera vez que se llena un slot, y en cualquier operación de agregar/quitar/reemplazar del elemento esloteado, pero no sus hijos. El slot es event.target.
MutationObserver para profundizar en el contenido del slot, observar los cambios en su interior.

Ahora que, como sabemos cómo mostrar elementos del light DOM en el shadow DOM, veamos cómo diseñarlos correctamente. La regla básica es que los elementos shadow se diseñan en el interior y los elementos light se diseñan afuera, pero hay notables excepciones.
Veremos los detalles en el próximo capítulo.
",
	"url": "https://es.javascript.info/slots-composition" 
},
{
	"docs_id": "160",
	"name": "Estilo Shadow DOM",
	"description": "Shadow DOM puede incluir las etiquetas <style> y <link rel="stylesheet" href="…">. En este último caso, las hojas de estilo se almacenan en la caché HTTP, por lo que no se vuelven a descargar para varios de los componentes que usan la misma plantilla.",
	"content": "Shadow DOM puede incluir las etiquetas <style> y <link rel="stylesheet" href="…">. En este último caso, las hojas de estilo se almacenan en la caché HTTP, por lo que no se vuelven a descargar para varios de los componentes que usan la misma plantilla.
Como regla general, los estilos locales solo funcionan dentro del shadow tree, y los estilos de documentos funcionan fuera de él. Pero hay pocas excepciones.
:hostEl selector :host permite seleccionar el shadow host (el elemento que contiene el shadow tree).
Por ejemplo, estamos creando un elemento <custom-dialog> que debería estar centrado. Para eso necesitamos diseñar el elemento <custom-dialog>.
Eso es exactamente lo que :host hace:

      
        
        
          
            
          
          
            
          
        
        
          <template id="tmpl">
  <style>
    /* el estilo se aplicará desde el interior al elemento de diálogo personalizado */
    :host {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      display: inline-block;
      border: 1px solid red;
      padding: 10px;
    }
  </style>
  <slot></slot>
</template>

<script>
customElements.define('custom-dialog', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));
  }
});
</script>

<custom-dialog>
  Hello!
</custom-dialog>
        
      
      
          
        
      CascadaEl shadow host (<custom-dialog> en sí) reside en el light DOM, por lo que se ve afectado por las reglas de CSS del documento.
Si hay una propiedad con estilo tanto en el :host localmente, y en el documento, entonces el estilo del documento tiene prioridad.
Por ejemplo, si en el documento tenemos:

      
        
        
          <style>
custom-dialog {
  padding: 0;
}
</style>
        
      
      
      …Entonces el <custom-dialog> estaría sin padding.
Es muy conveniente, ya que podemos configurar estilos de componentes “predeterminados” en su regla :host, y luego sobreescribirlos fácilmente en el documento.
La excepción es cuando una propiedad local está etiquetada como !important. Para tales propiedades, los estilos locales tienen prioridad.
:host(selector)Igual que :host, pero se aplica solo si el shadow host coincide con el selector.
Por ejemplo, nos gustaría centrar el <custom-dialog> solo si tiene el atributo centered:

      
        
        
          
            
          
          
            
          
        
        
          <template id="tmpl">
  <style>
    :host([centered]) {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border-color: blue;
    }

    :host {
      display: inline-block;
      border: 1px solid red;
      padding: 10px;
    }
  </style>
  <slot></slot>
</template>

<script>
customElements.define('custom-dialog', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));
  }
});
</script>


<custom-dialog centered>
  ¡Centrado!
</custom-dialog>

<custom-dialog>
  No centrado.
</custom-dialog>
        
      
      
          
        
      Ahora los estilos de centrado adicionales solo se aplican al primer diálogo: <custom-dialog centered>.
Para resumir, podemos usar la familia de selectores :host para aplicar estilos al elemento principal del componente. Estos estilos (a menos que sea !important) pueden ser sobreescritos por el documento.
Estilo de contenido eslotado(cuando un elemento ha sido insertado en un slot, se dice que fue eslotado por su término en inglés slotted)Ahora consideremos la situación con los slots.
Los elementos eslotados vienen del light DOM, por lo que usan estilos del documento. Los estilos locales no afectan al contenido de los elementos eslotados.
En el siguiente ejemplo, el elemento eslotado <span> está en bold, según el estilo del documento, pero no toma el background del estilo local:

      
        
        
          
            
          
          
            
          
        
        
          <style>
  span { font-weight: bold }
</style>

<user-card>
  <div slot="username"><span>John Smith</span></div>
</user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <style>
      span { background: red; }
      </style>
      Name: <slot name="username"></slot>
    `;
  }
});
</script>
        
      
      
          
        
      El resultado es bold, pero no red.
Si queremos aplicar estilos a elementos eslotados en nuestro componente, hay dos opciones.
Primero, podemos aplicarle el estilo al elemento <slot> en sí mismo y confiar en la herencia CSS:

      
        
        
          
            
          
          
            
          
        
        
          <user-card>
  <div slot="username"><span>John Smith</span></div>
</user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <style>
      slot[name="username"] { font-weight: bold; }
      </style>
      Name: <slot name="username"></slot>
    `;
  }
});
</script>
        
      
      
          
        
      Aquí <p>John Smith</p> se vuelve bold, porque la herencia CSS está en efecto entre el <slot> y su contenido. Pero en el propio CSS no todas las propiedades se heredan.
Otra opción es usar la pseudoclase ::slotted(selector). Coincide con elementos en función de 2 condiciones.

Eso es un elemento eslotado, que viene del light DOM. El nombre del slot no importa. Cualquier elemento eslotado, pero solo el elemento en si, no sus hijos.
El elemento coincide con el selector.

En nuestro ejemplo, ::slotted(div) selecciona exactamente <div slot="username">, pero no sus hijos:

      
        
        
          
            
          
          
            
          
        
        
          <user-card>
  <div slot="username">
    <div>John Smith</div>
  </div>
</user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <style>
      ::slotted(div) { border: 1px solid red; }
      </style>
      Name: <slot name="username"></slot>
    `;
  }
});
</script>
        
      
      
          
        
      Tenga en cuenta, que el selector ::slotted no puede descender más en el slot. Estos selectores no son válidos:

      
        
        
          ::slotted(div span) {
  /* nuestro slotted <div> no coincide con esto */
}

::slotted(div) p {
  /* No puede entrar en light DOM */
}
        
      
      
      También, ::slotted solo se puede utilizar en CSS. No podemos usarlo en querySelector.
CSS hooks con propiedades personalizadas¿Cómo diseñamos los elementos internos de un componente del documento principal?
Selectores como :host aplican reglas al elemento <custom-dialog> o <user-card>, ¿pero cómo aplicar estilos a elementos del shadow DOM dentro de ellos?
No hay ningún selector que pueda afectar directamente a los estilos del shadow DOM del documento. Pero así como exponemos métodos para interactuar con nuestro componente, podemos exponer variables CSS (propiedades CSS personalizadas) para darle estilo.
Existen propiedades CSS personalizadas en todos los niveles, tanto en light como shadow.
Por ejemplo, en el shadow DOM podemos usar la variable CSS --user-card-field-color para dar estilo a los campos, y en el documento exterior establecer su valor:

      
        
        
          <style>
  .field {
    color: var(--user-card-field-color, black);
    /* si --user-card-field-color no esta definido, usar color negro */
  }
</style>
<div class="field">Name: <slot name="username"></slot></div>
<div class="field">Birthday: <slot name="birthday"></slot></div>
        
      
      
      Entonces, podemos declarar esta propiedad en el documento exterior para <user-card>:

      
        
        
          user-card {
  --user-card-field-color: green;
}
        
      
      
      Las propiedades personalizadas CSS atraviesan el shadow DOM, son visibles en todas partes, por lo que la regla interna .field hará uso de ella.
Aquí está el ejemplo completo:

      
        
        
          
            
          
          
            
          
        
        
          <style>
  user-card {
    --user-card-field-color: green;
  }
</style>

<template id="tmpl">
  <style>
    .field {
      color: var(--user-card-field-color, black);
    }
  </style>
  <div class="field">Name: <slot name="username"></slot></div>
  <div class="field">Birthday: <slot name="birthday"></slot></div>
</template>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.append(document.getElementById('tmpl').content.cloneNode(true));
  }
});
</script>

<user-card>
  <span slot="username">John Smith</span>
  <span slot="birthday">01.01.2001</span>
</user-card>
        
      
      
          
        
      ResumenShadow DOM puede incluir estilos, como <style> o <link rel="stylesheet">.
Los estilos locales pueden afectar:

shadow tree,
shadow host con pseudoclases :host y :host(),
elementos eslotados (provenientes de light DOM), ::slotted(selector) permite seleccionar elementos eslotados, pero no a sus hijos.

Los estilos de documentos pueden afectar:

shadow host (ya que vive en el documento exterior)
elementos eslotados y su contenido (ya que eso también está en el documento exterior)

Cuando las propiedades CSS entran en conflicto, normalmente los estilos del documento tienen prioridad, a menos que la propiedad esté etiquetada como !important. Entonces, los estilos locales tienen prioridad.
Las propiedades CSS personalizadas atraviesan el shadow DOM. Se utilizan como “hooks” para aplicar estilos al componente:

El componente utiliza una propiedad CSS personalizada para aplicar estilos a elementos clave, como var(--component-name-title, <default value>).
El autor del componente publica estas propiedades para los desarrolladores, son tan importantes como otros métodos de componentes públicos.
Cuando un desarrollador desea aplicar un estilo a un título, asigna la propiedad CSS --component-name-title para el shadow host o superior.
¡Beneficio!

",
	"url": "https://es.javascript.info/shadow-dom-style" 
},
{
	"docs_id": "161",
	"name": "Shadow DOM y eventos",
	"description": "La idea detrás del shadow tree es encapsular los detalles internos de implementación de un componente.",
	"content": "La idea detrás del shadow tree es encapsular los detalles internos de implementación de un componente.
Digamos que ocurre un evento click dentro de un shadow DOM del componente <user-card>. Pero los scripts en el documento principal no tienen idea acerca del interior del shadow DOM, especialmente si el componente es de una librería de terceros.
Entonces, para mantener los detalles encapsulados, el navegador redirige el evento.
Los eventos que ocurren en el shadow DOM tienen el elemento host como objetivo cuando son atrapados fuera del componente.
Un ejemplo simple:

      
        
        
          
            
          
          
            
          
        
        
          <user-card></user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `<p>
      <button>Click me</button>
    </p>`;
    this.shadowRoot.firstElementChild.onclick =
      e => alert("Inner target: " + e.target.tagName);
  }
});

document.onclick =
  e => alert("Outer target: " + e.target.tagName);
</script>
        
      
      
          
        
      Si haces clic en el botón, los mensajes son:

Inner target: BUTTON – el manejador de evento interno obtiene el objetivo correcto, el elemento dentro del shadow DOM.
Outer target: USER-CARD – el manejador de evento del documento obtiene el shadow host como objetivo.

Tener la “redirección de eventos” es muy bueno, porque el documento externo no necesita tener conocimiento acerca del interior del componente. Desde su punto de vista, el evento ocurrió sobre <user-card>.
No hay redirección si el evento ocurre en un elemento eslotado (slot element), que físicamente se aloja en el “light DOM”, el DOM visible.
Por ejemplo, si un usuario hace clic en <span slot="username"> en el ejemplo siguiente, el objetivo del evento es precisamente ese elemento span para ambos manejadores, shadow y light.

      
        
        
          
            
          
          
            
          
        
        
          <user-card id="userCard">
  <span slot="username">John Smith</span>
</user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `<div>
      <b>Name:</b> <slot name="username"></slot>
    </div>`;

    this.shadowRoot.firstElementChild.onclick =
      e => alert("Inner target: " + e.target.tagName);
  }
});

userCard.onclick = e => alert(`Outer target: ${e.target.tagName}`);
</script>
        
      
      
          
        
      Si un clic ocurre en "John Smith", el target es <span slot="username"> para ambos manejadores: el interno y el externo. Es un elemento del light DOM, entonces no hay redirección.
Por otro lado, si el clic ocurre en un elemento originalmente del shadow DOM, ej. en <b>Name</b>, entonces, como se propaga hacia fuera del shadow DOM, su event.target se reestablece a <user-card>.
Propagación, event.composedPath()Para el propósito de propagación de eventos, es usado un “flattened DOM” (DOM aplanado, fusión de light y shadow).
Así, si tenemos un elemento eslotado y un evento ocurre dentro, entonces se propaga hacia arriba a <slot> y más allá.
La ruta completa del destino original “event target”, con todos sus elementos shadow, puede ser obtenida usando event.composedPath(). Como podemos ver del nombre del método, la ruta se toma despúes de la composición.
En el ejemplo de arriba, el “flattened DOM” es:

      
        
        
          <user-card id="userCard">
  #shadow-root
    <div>
      <b>Name:</b>
      <slot name="username">
        <span slot="username">John Smith</span>
      </slot>
    </div>
</user-card>
        
      
      
      Entonces, para un clic sobre <span slot="username">, una llamada a event.composedPath() devuelve un array: [span, slot, div, shadow-root, user-card, body, html, document, window]. Que es precisamente la cadena de padres desde el elemento target en el flattened DOM, después de la composición.

            Los detalles del árbol Shadow solo son provistos en árboles con {mode:'open'}
            Si el árbol shadow fue creado con {mode: 'closed'}, la ruta compuesta comienza desde el host: user-card en adelante.
Este principio es similar a otros métodos que trabajan con el shadow DOM. El interior de árboles cerrados está completamente oculto.

event.composedLa mayoría de los eventos se propagan exitosamente a través de los límites de un shadow DOM. Hay unos pocos eventos que no.
Esto está gobernado por la propiedad composed del objeto de evento. Si es true, el evento cruza los límites. Si no, solamente puede ser capturado dentro del shadow DOM.
Vemos en la especificación UI Events que la mayoría de los eventos tienen composed: true:

blur, focus, focusin, focusout,
click, dblclick,
mousedown, mouseup mousemove, mouseout, mouseover,
wheel,
beforeinput, input, keydown, keyup.

Todos los eventos de toque y puntero también tienen composed: true.
Algunos eventos tienen composed: false:

mouseenter, mouseleave (que no se propagan en absoluto),
load, unload, abort, error,
select,
slotchange.

Estos eventos solo pueden ser capturados dentro del mismo DOM, donde reside el evento target.
Eventos personalizadosCuando enviamos eventos personalizados, necesitamos establecer ambas propiedades bubbles y composed a true para que se propague hacia arriba y afuera del componente.
Por ejemplo, aquí creamos div#inner en el shadow DOM de div#outer y disparamos dos eventos en él. Solo el que tiene composed: true logra salir hacia el documento:

      
        
        
          
            
          
          
            
          
        
        
          <div id="outer"></div>

<script>
outer.attachShadow({mode: 'open'});

let inner = document.createElement('div');
outer.shadowRoot.append(inner);

/*
div(id=outer)
  #shadow-dom
    div(id=inner)
*/

document.addEventListener('test', event => alert(event.detail));

inner.dispatchEvent(new CustomEvent('test', {
  bubbles: true,
  composed: true,
  detail: "composed"
}));

inner.dispatchEvent(new CustomEvent('test', {
  bubbles: true,
  composed: false,
  detail: "not composed"
}));
</script>
        
      
      
      ResumenLos eventos solo cruzan los límites de shadow DOM si su bandera composed se establece como true.
La mayoría de los eventos nativos tienen composed: true, tal como se describe en las especificaciones relevantes:

Eventos UI https://www.w3.org/TR/uievents.
Eventos Touch  https://w3c.github.io/touch-events.
Eventos Pointer https://www.w3.org/TR/pointerevents.
…y así.

Algunos eventos nativos que tienen composed: false:

mouseenter, mouseleave (que tampoco se propagan),
load, unload, abort, error,
select,
slotchange.

Estos eventos solo pueden ser capturados en elementos dentro del mismo DOM.
Si enviamos un evento personalizado CustomEvent, debemos establecer explícitamente composed: true.
Tenga en cuenta que en caso de componentes anidados, un shadow DOM puede estar anidado dentro de otro. En ese caso los eventos se propagan a través de los límites de todos los shadow DOM. Entonces, si se pretende que un evento sea solo para el componente inmediato que lo encierra, podemos enviarlo también en el shadow host y establecer composed: false. Entonces saldrá al shadow DOM del componente, pero no se propagará hacia un DOM de mayor nivel.
",
	"url": "https://es.javascript.info/shadow-dom-events" 
},
{
	"docs_id": "162",
	"name": "Patrones y banderas (flags)",
	"description": "Las expresiones regulares son patrones que proporcionan una forma poderosa de buscar y reemplazar texto.",
	"content": "Las expresiones regulares son patrones que proporcionan una forma poderosa de buscar y reemplazar texto.
En JavaScript, están disponibles a través del objeto RegExp, además de integrarse en métodos de cadenas.
Expresiones RegularesUna expresión regular (también “regexp”, o simplemente “reg”) consiste en un patrón y banderas opcionales.
Hay dos sintaxis que se pueden usar para crear un objeto de expresión regular.
La sintaxis “larga”:

      
        
        
          regexp = new RegExp("patrón", "banderas");
        
      
      
      Y el “corto”, usando barras "/":

      
        
        
          regexp = /pattern/; // sin banderas
regexp = /pattern/gmi; // con banderas g,m e i (para ser cubierto pronto)
        
      
      
      Las barras /.../ le dicen a JavaScript que estamos creando una expresión regular. Juegan el mismo papel que las comillas para las cadenas.
En ambos casos, regexp se convierte en una instancia de la clase incorporada RegExp.
La principal diferencia entre estas dos sintaxis es que el patrón que utiliza barras /.../ no permite que se inserten expresiones (como los literales de plantilla de cadena con ${...}). Son completamente estáticos.
Las barras se utilizan cuando conocemos la expresión regular en el momento de escribir el código, y esa es la situación más común. Mientras que  new RegExp, se usa con mayor frecuencia cuando necesitamos crear una expresión regular “sobre la marcha” a partir de una cadena generada dinámicamente. Por ejemplo:

      
        
        
          let tag = prompt("¿Qué etiqueta quieres encontrar?", "h2");

igual que /<h2>/ si respondió "h2" en el mensaje anterior
        
      
      
      BanderasLas expresiones regulares pueden usar banderas que afectan la búsqueda.
Solo hay 6 de ellas en JavaScript:

i
Con esta bandera, la búsqueda no distingue entre mayúsculas y minúsculas: no hay diferencia entre A y a (consulte el ejemplo a continuación).
g
Con esta bandera, la búsqueda encuentra todas las coincidencias, sin ella, solo se devuelve la primera coincidencia.
m
Modo multilínea (cubierto en el capítulo Modo multilínea de anclas ^ $, bandera "m").
s
Habilita el modo “dotall”, que permite que un punto . coincida con el carácter de línea nueva \n (cubierto en el capítulo Clases de caracteres).
u
Permite el soporte completo de Unicode. La bandera permite el procesamiento correcto de pares sustitutos. Más del tema en el capítulo Unicode: bandera "u" y clase \p{...}.
y
Modo “adhesivo”: búsqueda en la posición exacta del texto (cubierto en el capítulo Indicador adhesivo “y”, buscando en una posición.)


            Colores
            A partir de aquí, el esquema de color es:

regexp – red
cadena (donde buscamos) – blue
resulta – green


Buscando: str.matchComo se mencionó anteriormente, las expresiones regulares se integran con los métodos de cadena.
El método str.match(regex) busca todas las coincidencias de regex en la cadena str.
Tiene 3 modos de trabajo:


Si la expresión regular tiene la bandera g, devuelve un arreglo de todas las coincidencias:

      
        
        
          
            
          
          
            
          
        
        
          let str = "We will, we will rock you";

alert( str.match(/we/gi) ); // We,we (un arreglo de 2 subcadenas que coinciden)
        
      
      
      Tenga en cuenta que tanto We como  we se encuentran, porque la bandera i hace que la expresión regular no distinga entre mayúsculas y minúsculas.


Si no existe dicha bandera, solo devuelve la primera coincidencia en forma de arreglo, con la coincidencia completa en el índice 0 y algunos detalles adicionales en las propiedades:

      
        
        
          
            
          
          
            
          
        
        
          let str = "We will, we will rock you";

let result = str.match(/we/i); // sin la bandera g

alert( result[0] );     // We (1ra coincidencia)
alert( result.length ); // 1

// Detalles:
alert( result.index );  // 0 (posición de la coincidencia)
alert( result.input );  // We will, we will rock you (cadena fuente)
        
      
      
      El arreglo puede tener otros índices, además de 0 si una parte de la expresión regular está encerrada entre paréntesis. Cubriremos eso en el capítulo Grupos de captura.


Y, finalmente, si no hay coincidencias, se devuelve null (no importa si hay una bandera g o no).
Este es un matiz muy importante. Si no hay coincidencias, no recibimos un arreglo vacío, sino que recibimos null. Olvidar eso puede conducir a errores, por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let matches = "JavaScript".match(/HTML/); // = null

if (!matches.length) { // Error: No se puede leer la propiedad 'length' de null
  alert("Error en la línea anterior");
}
        
      
      
      Si queremos que el resultado sea siempre un arreglo, podemos escribirlo de esta manera:

      
        
        
          
            
          
          
            
          
        
        
          let matches = "JavaScript".match(/HTML/) || [];

if (!matches.length) {
  alert("Sin coincidencias"); // ahora si trabaja
}
        
      
      
      

Reemplazando: str.replaceEl método str.replace(regexp, replacement) reemplaza las coincidencias encontradas usando regexp en la cadena str con replacement (todas las coincidencias si está la bandera g, de lo contrario, solo la primera).
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          // sin la bandera g
alert( "We will, we will".replace(/we/i, "I") ); // I will, we will

// con la bandera g
alert( "We will, we will".replace(/we/ig, "I") ); // I will, I will
        
      
      
      El segundo argumento es la cadena de replacement. Podemos usar combinaciones de caracteres especiales para insertar fragmentos de la coincidencia:



Símbolos
Acción en la cadena de reemplazo




$&
inserta toda la coincidencia


$`
inserta una parte de la cadena antes de la coincidencia


$'
inserta una parte de la cadena después de la coincidencia


$n
si n es un número de 1-2 dígitos, entonces inserta el contenido de los paréntesis n-ésimo, más del tema en el capítulo Grupos de captura


$<name>
inserta el contenido de los paréntesis con el nombre dado, más del tema en el capítulo Grupos de captura


$$
inserta el carácter $



Un ejemplo con $&:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Me gusta HTML".replace(/HTML/, "$& y JavaScript") ); // Me gusta HTML y JavaScript
        
      
      
      Pruebas: regexp.testEl método regexp.test(str) busca al menos una coincidencia, si se encuentra, devuelve true, de lo contrario false.

      
        
        
          
            
          
          
            
          
        
        
          let str = "Me gusta JavaScript";
let regexp = /GUSTA/i;


alert( regexp.test(str) ); // true
        
      
      
      Más adelante en este capítulo estudiaremos más expresiones regulares, exploraremos más ejemplos y también conoceremos otros métodos.
La información completa sobre métodos se proporciona en el artículo No se encontró el artículo "regexp-method".
Resumen
Una expresión regular consiste en un patrón y banderas opcionales: g, i, m, u, s, y.
Sin banderas y símbolos especiales (que estudiaremos más adelante), la búsqueda por expresión regular es lo mismo que una búsqueda de subcadena.
El método str.match(regexp) busca coincidencias: devuelve todas si hay una bandera g, de lo contrario, solo la primera.
El método str.replace(regexp, replacement) reemplaza las coincidencias encontradas usando regexp con replacement: devuelve todas si hay una bandera g, de lo contrario solo la primera.
El método regexp.test(str) devuelve true si hay al menos una coincidencia, de lo contrario, devuelve false.

",
	"url": "https://es.javascript.info/regexp-introduction" 
},
{
	"docs_id": "163",
	"name": "Clases de caracteres",
	"description": "Considera una tarea práctica: tenemos un número de teléfono como "+7(903)-123-45-67", y debemos convertirlo en número puro: 79031234567.",
	"content": "Considera una tarea práctica: tenemos un número de teléfono como "+7(903)-123-45-67", y debemos convertirlo en número puro: 79031234567.
Para hacerlo, podemos encontrar y eliminar cualquier cosa que no sea un número. La clase de caracteres pueden ayudar con eso.
Una clase de caracteres es una notación especial que coincide con cualquier símbolo de un determinado conjunto.
Para empezar, exploremos la clase “dígito”. Está escrito como \d y corresponde a “cualquier dígito”.
Por ejemplo, busquemos el primer dígito en el número de teléfono:

      
        
        
          
            
          
          
            
          
        
        
          let str = "+7(903)-123-45-67";

let regexp = /\d/;

alert( str.match(regexp) ); // 7
        
      
      
      Sin la bandera (flag) g, la expresión regular solo busca la primera coincidencia, es decir, el primer dígito \d.
Agreguemos la bandera g para encontrar todos los dígitos:

      
        
        
          
            
          
          
            
          
        
        
          let str = "+7(903)-123-45-67";

let regexp = /\d/g;

alert( str.match(regexp) ); // array de coincidencias: 7,9,0,3,1,2,3,4,5,6,7

// hagamos el número de teléfono de solo dígitos:
alert( str.match(regexp).join('') ); // 79031234567
        
      
      
      Esa fue una clase de caracteres para los dígitos. También hay otras.
Las más usadas son:

\d (“d” es de dígito")
Un dígito: es un caracter de 0 a 9.
\s (“s” es un espacio)
Un símbolo de espacio: incluye espacios, tabulaciones \t, líneas nuevas \n y algunos otros caracteres raros, como \v, \f y \r.
\w (“w” es carácter de palabra)
Un carácter de palabra es: una letra del alfabeto latino o un dígito o un guión bajo _. Las letras no latinas (como el cirílico o el hindi) no pertenecen al \w.

Por ejemplo, \d\s\w significa un “dígito” seguido de un “carácter de espacio” seguido de un “carácter de palabra”, como 1 a.
Una expresión regular puede contener símbolos regulares y clases de caracteres.
Por ejemplo, CSS\d coincide con una cadena CSS con un dígito después:

      
        
        
          
            
          
          
            
          
        
        
          let str = "¿Hay CSS4?";
let regexp = /CSS\d/

alert( str.match(regexp) ); // CSS4
        
      
      
      También podemos usar varias clases de caracteres:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Me gusta HTML5!".match(/\s\w\w\w\w\d/) ); // ' HTML5'
        
      
      
      La coincidencia (cada clase de carácter de la expresión regular tiene el carácter resultante correspondiente):

      
      
        
      
      Clases inversasPara cada clase de caracteres existe una “clase inversa”, denotada con la misma letra, pero en mayúscula.
El “inverso” significa que coincide con todos los demás caracteres, por ejemplo:

\D
Sin dígitos: cualquier carácter excepto \d, por ejemplo, una letra.
\S
Sin espacio: cualquier carácter excepto \s, por ejemplo, una letra.
\W
Sin carácter de palabra: cualquier cosa menos \w, por ejemplo, una letra no latina o un espacio.

Al comienzo del capítulo vimos cómo hacer un número de teléfono solo de números a partir de una cadena como +7(903)-123-45-67: encontrar todos los dígitos y unirlos.

      
        
        
          
            
          
          
            
          
        
        
          let str = "+7(903)-123-45-67";

alert( str.match(/\d/g).join('') ); // 79031234567
        
      
      
      Una forma alternativa y más corta es usar el patrón sin dígito \D para encontrarlos y eliminarlos de la cadena:

      
        
        
          
            
          
          
            
          
        
        
          let str = "+7(903)-123-45-67";

alert( str.replace(/\D/g, "") ); // 79031234567
        
      
      
      Un punto es “cualquier carácter”El patrón punto (.) es una clase de caracteres especial que coincide con “cualquier carácter excepto una nueva línea”.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Z".match(/./) ); // Z
        
      
      
      O en medio de una expresión regular:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /CS.4/;

alert( "CSS4".match(regexp) ); // CSS4
alert( "CS-4".match(regexp) ); // CS-4
alert( "CS 4".match(regexp) ); // CS 4 (el espacio también es un carácter)
        
      
      
      Tenga en cuenta que un punto significa “cualquier carácter”, pero no la “ausencia de un carácter”. Debe haber un carácter para que coincida:

      
        
        
          
            
          
          
            
          
        
        
          alert( "CS4".match(/CS.4/) ); // null, no coincide porque no hay caracteres entre S y 4
        
      
      
      Punto es igual a la bandera “s” que literalmente retorna cualquier carácterPor defecto, punto no coincide con el carácter de  línea nueva \n.
Por ejemplo, la expresión regular A.B coincide con A, y luego B con cualquier carácter entre ellos, excepto una línea nueva \n:

      
        
        
          
            
          
          
            
          
        
        
          alert( "A\nB".match(/A.B/) ); // null (sin coincidencia)
        
      
      
      Hay muchas situaciones en las que nos gustaría que punto signifique literalmente “cualquier carácter”, incluida la línea nueva.
Eso es lo que hace la bandera s. Si una expresión regular la tiene, entonces . coincide literalmente con cualquier carácter:

      
        
        
          
            
          
          
            
          
        
        
          alert( "A\nB".match(/A.B/s) ); // A\nB (coincide!)
        
      
      
      
            No soportado en IE
            La bandera s no está soportada en IE.
Afortunadamente, hay una alternativa, que funciona en todas partes. Podemos usar una expresión regular como [\s\S] para que coincida con “cualquier carácter”. (Este patrón será cubierto en el artículo Conjuntos y rangos [...]).

      
        
        
          
            
          
          
            
          
        
        
          alert( "A\nB".match(/A[\s\S]B/) ); // A\nB (coincide!)
        
      
      
      El patrón [\s\S] literalmente dice: “con carácter de espacio O sin carácter de espacio”. En otras palabras, “cualquier cosa”. Podríamos usar otro par de clases complementarias, como [\d\D], eso no importa. O incluso [^], que significa que coincide con cualquier carácter excepto nada.
También podemos usar este truco si queremos ambos tipos de “puntos” en el mismo patrón: el patrón actual . comportándose de la manera regular (“sin incluir una línea nueva”), y la forma de hacer coincidir “cualquier carácter” con el patrón [\s\S] o similar.


            Presta atención a los espacios
            Por lo general, prestamos poca atención a los espacios. Para nosotros, las cadenas 1-5 y 1 - 5 son casi idénticas.
Pero si una expresión regular no tiene en cuenta los espacios, puede que no funcione.
Intentemos encontrar dígitos separados por un guión:

      
        
        
          
            
          
          
            
          
        
        
          alert( "1 - 5".match(/\d-\d/) ); // null, sin coincidencia!
        
      
      
      Vamos a arreglarlo agregando espacios en la expresión regular \d - \d:

      
        
        
          
            
          
          
            
          
        
        
          alert( "1 - 5".match(/\d - \d/) ); // 1 - 5, funciona ahora
// o podemos usar la clase \s:
alert( "1 - 5".match(/\d\s-\s\d/) ); // 1 - 5, tambien funciona
        
      
      
      Un espacio es un carácter. Igual de importante que cualquier otro carácter.
No podemos agregar o eliminar espacios de una expresión regular y esperar que funcione igual.
En otras palabras, en una expresión regular todos los caracteres importan, los espacios también.

ResumenExisten las siguientes clases de caracteres:

\d – dígitos.
\D – sin dígitos.
\s – símbolos de espacio, tabulaciones, líneas nuevas.
\S – todo menos \s.
\w – letras latinas, dígitos, guión bajo '_'.
\W – todo menos \w.
. – cualquier carácter, si la expresión regular usa la bandera 's', de otra forma cualquiera excepto línea nueva \n.

…¡Pero eso no es todo!
La codificación Unicode, utilizada por JavaScript para las cadenas, proporciona muchas propiedades para los caracteres, como: a qué idioma pertenece la letra (si es una letra), es un signo de puntuación, etc.
Se pueden hacer búsquedas usando esas propiedades. Y se requiere la bandera u, analizada en el siguiente artículo.
",
	"url": "https://es.javascript.info/regexp-character-classes" 
},
{
	"docs_id": "164",
	"name": "Unicode: bandera "u" y clase \p{...}",
	"description": "JavaScript utiliza codificación Unicode para las cadenas. La mayoría de los caracteres están codificados con 2 bytes, esto permite representar un máximo de 65536 caracteres.",
	"content": "JavaScript utiliza codificación Unicode para las cadenas. La mayoría de los caracteres están codificados con 2 bytes, esto permite representar un máximo de 65536 caracteres.
Ese rango no es lo suficientemente grande como para codificar todos los caracteres posibles, es por eso que algunos caracteres raros se codifican con 4 bytes, por ejemplo como 𝒳 (X matemática) o 😄 (una sonrisa), algunos sinogramas, etc.
Aquí los valores unicode de algunos caracteres:



Carácter
Unicode
conteo de Bytes en unicode




a
0x0061
2


≈
0x2248
2


𝒳
0x1d4b3
4


𝒴
0x1d4b4
4


😄
0x1f604
4



Entonces los caracteres como a e ≈ ocupan 2 bytes, mientras que los códigos para 𝒳, 𝒴 y 😄 son más largos, tienen 4 bytes.
Hace mucho tiempo, cuando se creó el lenguaje JavaScript, la codificación Unicode era más simple: no había caracteres de 4 bytes. Por lo tanto, algunas características del lenguaje aún los manejan incorrectamente.
Por ejemplo, aquí length interpreta que hay dos caracteres:

      
        
        
          
            
          
          
            
          
        
        
          alert('😄'.length); // 2
alert('𝒳'.length); // 2
        
      
      
      …Pero podemos ver que solo hay uno, ¿verdad? El punto es que length maneja 4 bytes como dos caracteres de 2 bytes. Eso es incorrecto, porque debe considerarse como uno solo (el llamado “par sustituto”, puede leer sobre ellos en el artículo Strings).
Por defecto, las expresiones regulares manejan los “caracteres largos” de 4 bytes como un par de caracteres de 2 bytes cada uno. Y, como sucede con las cadenas, eso puede conducir a resultados extraños. Lo veremos un poco más tarde, en el artículo No se encontró el artículo "regexp-character-sets-and-range".
A diferencia de las cadenas, las expresiones regulares tienen la bandera u que soluciona tales problemas. Con dicha bandera, una expresión regular maneja correctamente los caracteres de 4 bytes. Y podemos usar la búsqueda de propiedades Unicode, que veremos a continuación.
Propiedades Unicode \p{…}Cada carácter en Unicode tiene varias propiedades. Describen a qué “categoría” pertenece el carácter, contienen información diversa al respecto.
Por ejemplo, si un carácter tiene la propiedad Letter, significa que pertenece a un alfabeto (de cualquier idioma). Y la propiedad Number significa que es un dígito: tal vez árabe o chino, y así sucesivamente.
Podemos buscar caracteres por su propiedad, usando \p{...}. Para usar \p{...}, una expresión regular debe usar también u.
Por ejemplo, \p{Letter} denota una letra en cualquiera de los idiomas. También podemos usar \p{L}, ya que L es un alias de Letter. Casi todas las propiedades tienen alias cortos.
En el ejemplo a continuación se encontrarán tres tipos de letras: inglés, georgiano y coreano.

      
        
        
          
            
          
          
            
          
        
        
          let str = "A ბ ㄱ";

alert( str.match(/\p{L}/gu) ); // A,ბ,ㄱ
alert( str.match(/\p{L}/g) ); // null (sin coincidencia, como no hay bandera "u")
        
      
      
      Estas son las principales categorías y subcategorías de caracteres:

Letter (Letra) L:

lowercase (minúscula) Ll
modifier (modificador) Lm,
titlecase (capitales) Lt,
uppercase (mayúscula) Lu,
other (otro) Lo.


Number (número) N:

decimal digit (dígito decimal) Nd,
letter number (número de letras) Nl,
other (otro) No.


Punctuation (puntuación) P:

connector (conector) Pc,
dash (guión) Pd,
initial quote (comilla inicial) Pi,
final quote (comilla final) Pf,
open (abre) Ps,
close (cierra) Pe,
other (otro) Po.


Mark (marca) M (acentos etc):

spacing combining (combinación de espacios) Mc,
enclosing (encerrado) Me,
non-spacing (sin espaciado) Mn.


Symbol (símbolo) S:

currency (moneda) Sc,
modifier (modificador) Sk,
math (matemática) Sm,
other (otro) So.


Separator (separador) Z:

line (línea) Zl,
paragraph (párrafo)Zp,
space (espacio) Zs.


Other (otros) C:

control Cc,
format (formato) Cf,
not assigned (sin asignación) Cn,
private use (uso privado) Co,
surrogate (sustituto) Cs.



Entonces, por ejemplo si necesitamos letras en minúsculas, podemos escribir \p{Ll}, signos de puntuación: \p{P} y así sucesivamente.
También hay otras categorías derivadas, como:

Alphabetic (alfabético) (Alfa), incluye letras L, más números de letras Nl (por ejemplo, Ⅻ – un carácter para el número romano 12), y otros símbolos Other_Alphabetic (OAlpha).
Hex_Digit incluye dígitos hexadecimales: 0-9, a-f.
…Y así.

Unicode admite muchas propiedades diferentes, la lista completa es muy grande, estas son las referencias:

Lista de todas las propiedades por carácter: https://unicode.org/cldr/utility/character.jsp (enlace no disponible).
Lista de caracteres por propiedad: https://unicode.org/cldr/utility/list-unicodeset.jsp. (enlace no disponible)
Alias cortos para propiedades: https://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt.
Aquí una base completa de caracteres Unicode en formato de texto, con todas las propiedades: https://www.unicode.org/Public/UCD/latest/ucd/.

Ejemplo: números hexadecimalesPor ejemplo, busquemos números hexadecimales, escritos como xFF dondeF es un dígito hexadecimal (0…9 o A…F).
Un dígito hexadecimal se denota como \p{Hex_Digit}:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /x\p{Hex_Digit}\p{Hex_Digit}/u;

alert("número: xAF".match(regexp)); // xAF
        
      
      
      Ejemplo: sinogramas chinosBusquemos sinogramas chinos.
Hay una propiedad Unicode Script (un sistema de escritura), que puede tener un valor: Cyrillic, Greek, Arabic, Han (chino), etc. lista completa.
Para buscar caracteres de un sistema de escritura dado, debemos usar Script=<value>, por ejemplo para letras cirílicas: \p{sc=Cyrillic}, para sinogramas chinos: \p{sc=Han}, y así sucesivamente:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /\p{sc=Han}/gu; // devuelve sinogramas chinos

let str = `Hello Привет 你好 123_456`;

alert( str.match(regexp) ); // 你,好
        
      
      
      Ejemplo: monedaLos caracteres que denotan una moneda, como $, €, ¥, tienen la propiedad unicode \p{Currency_Symbol}, el alias corto: \p{Sc}.
Usémoslo para buscar precios en el formato “moneda, seguido de un dígito”:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /\p{Sc}\d/gu;

let  str = `Precios: $2, €1, ¥9`;

alert( str.match(regexp) ); // $2,€1,¥9
        
      
      
      Más adelante, en el artículo Cuantificadores +, *, ? y {n} veremos cómo buscar números que contengan muchos dígitos.
ResumenLa bandera u habilita el soporte de Unicode en expresiones regulares.
Eso significa dos cosas:

Los caracteres de 4 bytes se manejan correctamente: como un solo carácter, no dos caracteres de 2 bytes.
Las propiedades Unicode se pueden usar en las búsquedas: \p{…}.

Con las propiedades Unicode podemos buscar palabras en determinados idiomas, caracteres especiales (comillas, monedas), etc.
",
	"url": "https://es.javascript.info/regexp-unicode" 
},
{
	"docs_id": "165",
	"name": "Anclas: inicio ^ y final $ de cadena",
	"description": "Los patrones caret (del latín carece) ^ y dólar $ tienen un significado especial en una expresión regular. Se llaman “anclas”.",
	"content": "Los patrones caret (del latín carece) ^ y dólar $ tienen un significado especial en una expresión regular. Se llaman “anclas”.
El patrón caret ^ coincide con el principio del texto y dólar $ con el final.
Por ejemplo, probemos si el texto comienza con Mary:

      
        
        
          
            
          
          
            
          
        
        
          let str1 = "Mary tenía un corderito";
alert( /^Mary/.test(str1) ); // true
        
      
      
      El patrón ^Mary significa: “inicio de cadena y luego Mary”.
Similar a esto, podemos probar si la cadena termina con nieve usando nieve$:

      
        
        
          
            
          
          
            
          
        
        
          let str1 = "su vellón era blanco como la nieve";
alert( /nieve$/.test(str1) ); // true
        
      
      
      En estos casos particulares, en su lugar podríamos usar métodos de cadena beginWith/endsWith. Las expresiones regulares deben usarse para pruebas más complejas.
Prueba para una coincidencia completaAmbos anclajes ^...$ se usan juntos a menudo para probar si una cadena coincide completamente con el patrón. Por ejemplo, para verificar si la entrada del usuario está en el formato correcto.
Verifiquemos si una cadena esta o no en formato de hora 12:34. Es decir: dos dígitos, luego dos puntos y luego otros dos dígitos.
En el idioma de las expresiones regulares eso es \d\d:\d\d:

      
        
        
          
            
          
          
            
          
        
        
          let goodInput = "12:34";
let badInput = "12:345";

let regexp = /^\d\d:\d\d$/;
alert( regexp.test(goodInput) ); // true
alert( regexp.test(badInput) ); // false
        
      
      
      La coincidencia para \d\d:\d\d debe comenzar exactamente después del inicio de texto^, y seguido inmediatamente, el final $.
Toda la cadena debe estar exactamente en este formato. Si hay alguna desviación o un carácter adicional, el resultado es falso.
Las anclas se comportan de manera diferente si la bandera m está presente. Lo veremos en el próximo artículo.

            Las anclas tienen “ancho cero”
            Las anclas ^ y $ son pruebas. Ellas tienen ancho cero.
En otras palabras, no coinciden con un carácter, sino que obligan al motor regexp a verificar la condición (inicio/fin de texto).

TareasRegexp ^$¿Qué cadena coincide con el patrón ^$?
soluciónUna cadena vacía es la única coincidencia: comienza y termina inmediatamente.
Esta tarea demuestra una vez más que los anclajes no son caracteres, sino pruebas.
La cadena está vacía "". El motor primero coincide con ^ (inicio de entrada), sí, está allí, y luego inmediatamente el final $, también está. Entonces hay una coincidencia.
",
	"url": "https://es.javascript.info/regexp-anchors" 
},
{
	"docs_id": "166",
	"name": "Modo multilínea de anclas ^ $, bandera "m"",
	"description": "El modo multilínea está habilitado por el indicador m.",
	"content": "El modo multilínea está habilitado por el indicador m.
Solo afecta el comportamiento de ^ y $.
En el modo multilínea, coinciden no solo al principio y al final de la cadena, sino también al inicio/final de la línea.
Buscando al inicio de línea ^En el siguiente ejemplo, el texto tiene varias líneas. El patrón /^\d/gm toma un dígito desde el principio de cada línea:

      
        
        
          
            
          
          
            
          
        
        
          let str = `1er lugar: Winnie
2do lugar: Piglet
3er lugar: Eeyore`;

console.log( str.match(/^\d/gm) ); // 1, 2, 3
        
      
      
      Sin la bandera m solo coincide el primer dígito:

      
        
        
          
            
          
          
            
          
        
        
          let str = `1er lugar: Winnie
2do lugar: Piglet
3er lugar: Eeyore`;

console.log( str.match(/^\d/g) ); // 1
        
      
      
      Esto se debe a que, de forma predeterminada, un caret ^ solo coincide al inicio del texto y en el modo multilínea, al inicio de cualquier línea.

            Por favor tome nota:
            “Inicio de una línea” significa formalmente “inmediatamente después de un salto de línea”: la prueba ^ en modo multilínea coincide en todas las posiciones precedidas por un carácter de línea nueva \n.
Y al comienzo del texto.

Buscando al final de la línea $El signo de dólar $ se comporta de manera similar.
La expresión regular \d$ encuentra el último dígito en cada línea

      
        
        
          
            
          
          
            
          
        
        
          let str = `Winnie: 1
Piglet: 2
Eeyore: 3`;

console.log( str.match(/\d$/gm) ); // 1,2,3
        
      
      
      Sin la bandera m, dólar $ solo coincidiría con el final del texto completo, por lo que solo se encontraría el último dígito.

            Por favor tome nota:
            “Fin de una línea” significa formalmente “inmediatamente antes de un salto de línea”: la prueba $ en el modo multilínea coincide en todas las posiciones seguidas por un carácter de línea nueva \n.
Y al final del texto.

Buscando \n en lugar de ^ $Para encontrar una línea nueva, podemos usar no solo las anclas ^ y $, sino también el carácter de línea nueva \n.
¿Cual es la diferencia? Veamos un ejemplo.
Buscamos \d\n en lugar de \d$:

      
        
        
          
            
          
          
            
          
        
        
          let str = `Winnie: 1
Piglet: 2
Eeyore: 3`;

console.log( str.match(/\d\n/g) ); // 1\n,2\n
        
      
      
      Como podemos ver, hay 2 coincidencias en lugar de 3.
Esto se debe a que no hay una línea nueva después de 3 (sin embargo, hay un final de texto, por lo que coincide con $).
Otra diferencia: ahora cada coincidencia incluye un carácter de línea nueva \n. A diferencia de las anclas ^ $, que solo prueban la condición (inicio/final de una línea), \n es un carácter, por lo que se hace parte del resultado.
Entonces, un \n en el patrón se usa cuando necesitamos encontrar caracteres de línea nueva, mientras que las anclas se usan para encontrar algo “al principio/al final” de una línea.
",
	"url": "https://es.javascript.info/regexp-multiline-mode" 
},
{
	"docs_id": "167",
	"name": "Límite de palabra: \b",
	"description": "Un límite de palabra \b es una prueba, al igual que ^ y $.",
	"content": "Un límite de palabra \b es una prueba, al igual que ^ y $.
Cuando el motor regex (módulo de programa que implementa la búsqueda de expresiones regulares) se encuentra con \b, comprueba que la posición en la cadena es un límite de palabra.
Hay tres posiciones diferentes que califican como límites de palabras:

Al comienzo de la cadena, si el primer carácter de cadena es un carácter de palabra \w.
Entre dos caracteres en la cadena, donde uno es un carácter de palabra \w y el otro no.
Al final de la cadena, si el último carácter de la cadena es un carácter de palabra \w.

Por ejemplo, la expresión regular \bJava\b se encontrará en Hello, Java!, donde Java es una palabra independiente, pero no en Hello, JavaScript!.

      
        
        
          
            
          
          
            
          
        
        
          alert( "Hello, Java!".match(/\bJava\b/) ); // Java
alert( "Hello, JavaScript!".match(/\bJava\b/) ); // null
        
      
      
      En la cadena Hello, Java! las flechas que se muestran corresponden a \b, ver imagen:

      
      
        
      
      Entonces, coincide con el patrón \bHello\b, porque:

Al comienzo de la cadena coincide con la primera prueba: \b.
Luego coincide con la palabra Hello.
Luego, la prueba \b vuelve a coincidir, ya que estamos entre o y una coma.

El patrón \bHello\b también coincidiría. Pero no \bHel\b (porque no hay límite de palabras después de l) y tampoco Java!\b (porque el signo de exclamación no es un carácter común \w, entonces no hay límite de palabras después de eso).

      
        
        
          
            
          
          
            
          
        
        
          alert( "Hello, Java!".match(/\bHello\b/) ); // Hello
alert( "Hello, Java!".match(/\bJava\b/) );  // Java
alert( "Hello, Java!".match(/\bHell\b/) );  // null (sin coincidencia)
alert( "Hello, Java!".match(/\bJava!\b/) ); // null (sin coincidencia)
        
      
      
      Podemos usar \b no solo con palabras, sino también con dígitos.
Por ejemplo, el patrón \b\d\d\b busca números independientes de 2 dígitos. En otras palabras, busca números de 2 dígitos que están rodeados por caracteres diferentes de \w, como espacios o signos de puntuación (o texto de inicio/fin).

      
        
        
          
            
          
          
            
          
        
        
          alert( "1 23 456 78".match(/\b\d\d\b/g) ); // 23,78
alert( "12,34,56".match(/\b\d\d\b/g) ); // 12,34,56
        
      
      
      
            El límite de palabra \b no funciona para alfabetos no latinos
            La prueba de límite de palabra \b verifica que debe haber un \w en un lado de la posición y "no \w"- en el otro lado.
Pero \w significa una letra latina a-z (o un dígito o un guión bajo), por lo que la prueba no funciona para otros caracteres, p.ej.: letras cirílicas o jeroglíficos.

TareasEncuentra la horaLa hora tiene un formato: horas:minutos. Tanto las horas como los minutos tienen dos dígitos, como 09:00.
Haz una expresión regular para encontrar el tiempo en la cadena: Desayuno a las 09:00 en la habitación 123:456.
P.D.: En esta tarea todavía no hay necesidad de verificar la corrección del tiempo, por lo que 25:99 también puede ser un resultado válido.
P.P.D.: La expresión regular no debe coincidir con 123:456.
soluciónLa respuesta: \b\d\d:\d\d\b.

      
        
        
          
            
          
          
            
          
        
        
          alert( "Desayuno a las 09:00 en la habitación 123:456.".match( /\b\d\d:\d\d\b/ ) ); // 09:00
        
      
      
      ",
	"url": "https://es.javascript.info/regexp-boundary" 
},
{
	"docs_id": "168",
	"name": "Escapando, caracteres especiales",
	"description": "Como hemos visto, una barra invertida \ se usa para denotar clases de caracteres, p.ej. \d. Por lo tanto, es un carácter especial en expresiones regulares (al igual que en las cadenas regulares).",
	"content": "Como hemos visto, una barra invertida \ se usa para denotar clases de caracteres, p.ej. \d. Por lo tanto, es un carácter especial en expresiones regulares (al igual que en las cadenas regulares).
También hay otros caracteres especiales que tienen un significado especial en una expresión regular, tales como [ ] { } ( ) \ ^ $ . | ? * +. Se utilizan para hacer búsquedas más potentes.
No intentes recordar la lista: pronto nos ocuparemos de cada uno de ellos por separado y los recordarás fácilmente.
EscapandoDigamos que queremos encontrar literalmente un punto. No “cualquier carácter”, sino solo un punto.
Para usar un carácter especial como uno normal, agrégalo con una barra invertida: \..
A esto se le llama “escape de carácter”.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Capítulo 5.1".match(/\d\.\d/) ); // 5.1 (¡Coincide!)
alert( "Capítulo 511".match(/\d\.\d/) ); // null (buscando un punto real \.)
        
      
      
      Los paréntesis también son caracteres especiales, por lo que si los buscamos, deberíamos usar \(. El siguiente ejemplo busca una cadena "g()":

      
        
        
          
            
          
          
            
          
        
        
          alert( "función g()".match(/g\(\)/) ); // "g()"
        
      
      
      Si estamos buscando una barra invertida \, como es un carácter especial tanto en cadenas regulares como en expresiones regulares, debemos duplicarlo.

      
        
        
          
            
          
          
            
          
        
        
          alert( "1\\2".match(/\\/) ); // '\'
        
      
      
      Una barraUn símbolo de barra '/' no es un carácter especial, pero en JavaScript se usa para abrir y cerrar expresiones regulares: /...pattern.../, por lo que también debemos escaparlo.
Así es como se ve la búsqueda de una barra '/':

      
        
        
          
            
          
          
            
          
        
        
          alert( "/".match(/\//) ); // '/'
        
      
      
      Por otro lado, si no estamos usando /.../, pero creamos una expresión regular usando new RegExp, entonces no necesitamos escaparla:

      
        
        
          
            
          
          
            
          
        
        
          alert( "/".match(new RegExp("/")) ); // encuentra /
        
      
      
      new RegExpSi estamos creando una expresión regular con new RegExp, entonces no tenemos que escapar la barra /, pero sí otros caracteres especiales.
Por ejemplo, considere esto:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = new RegExp("\d\.\d");

alert( "Capítulo 5.1".match(regexp) ); // null
        
      
      
      En uno de los ejemplos anteriores funcionó la búsqueda con /\d\.\d/, pero new RegExp ("\d\.\d") no funciona, ¿por qué?
La razón es que las barras invertidas son “consumidas” por una cadena. Como podemos recordar, las cadenas regulares tienen sus propios caracteres especiales, como \n, y se usa una barra invertida para escapar esos caracteres especiales de cadena.
Así es como se percibe “\d.\d”:

      
        
        
          
            
          
          
            
          
        
        
          alert("\d\.\d"); // d.d
        
      
      
      Las comillas de cadenas “consumen” barras invertidas y las interpretan como propias, por ejemplo:

\n – se convierte en un carácter de línea nueva,
\u1234 – se convierte en el carácter Unicode con dicho código,
…Y cuando no hay un significado especial: como \d o \z, entonces la barra invertida simplemente se elimina.

Así que new RegExp toma una cadena sin barras invertidas. ¡Por eso la búsqueda no funciona!
Para solucionarlo, debemos duplicar las barras invertidas, porque las comillas de cadena convierten \\ en \:

      
        
        
          
            
          
          
            
          
        
        
          let regStr = "\\d\\.\\d";
alert(regStr); // \d\.\d (ahora está correcto)

let regexp = new RegExp(regStr);

alert( "Capítulo 5.1".match(regexp) ); // 5.1
        
      
      
      Resumen
Para buscar literalmente caracteres especiales [ \ ^ $ . | ? * + ( ), se les antepone una barra invertida \ (“escaparlos”).
Se debe escapar / si estamos dentro de /.../ (pero no dentro de new RegExp).
Al pasar una cadena a new RegExp, se deben duplicar las barras invertidas \\, porque las comillas de cadena consumen una.

",
	"url": "https://es.javascript.info/regexp-escaping" 
},
{
	"docs_id": "169",
	"name": "Conjuntos y rangos [...]",
	"description": "Varios caracteres o clases de caracteres entre corchetes […] significa “buscar cualquier carácter entre los dados”.",
	"content": "Varios caracteres o clases de caracteres entre corchetes […] significa “buscar cualquier carácter entre los dados”.
ConjuntosPor ejemplo, [eao] significa cualquiera de los 3 caracteres: 'a', 'e', o 'o'.
A esto se le llama conjunto. Los conjuntos se pueden usar en una expresión regular junto con los caracteres normales:

      
        
        
          
            
          
          
            
          
        
        
          // encontrar [t ó m], y luego "op"
alert( "Mop top".match(/[tm]op/gi) ); // "Mop", "top"
        
      
      
      Tenga en cuenta que aunque hay varios caracteres en el conjunto, corresponden exactamente a un carácter en la coincidencia.
Entonces, en el siguiente ejemplo no hay coincidencias:

      
        
        
          
            
          
          
            
          
        
        
          // encuentra "V", luego [o ó i], luego "la"
alert( "Voila".match(/V[oi]la/) ); // null, sin coincidencias
        
      
      
      El patrón busca:

V,
después una de las letras [oi],
después la.

Entonces habría una coincidencia para Vola o Vila.
RangosLos corchetes también pueden contener rangos de caracteres.
Por ejemplo, [a-z] es un carácter en el rango de a a z, y [0-5] es un dígito de 0 a 5.
En el ejemplo a continuación, estamos buscando "x" seguido de dos dígitos o letras de A a F:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Excepción 0xAF".match(/x[0-9A-F][0-9A-F]/g) ); // xAF
        
      
      
      Aquí [0-9A-F] tiene dos rangos: busca un carácter que sea un dígito de 0 a 9 o una letra de A a F.
Si también queremos buscar letras minúsculas, podemos agregar el rango a-f: [0-9A-Fa-f]. O se puede agregar la bandera i.
También podemos usar clases de caracteres dentro de los […].
Por ejemplo, si quisiéramos buscar un carácter de palabra \w o un guión -, entonces el conjunto es [\w-].
También es posible combinar varias clases, p.ej.: [\s\d] significa “un carácter de espacio o un dígito”.

            Las clases de caracteres son abreviaturas (o atajos) para ciertos conjuntos de caracteres.
            Por ejemplo:

\d – es lo mismo que [0-9],
\w – es lo mismo que [a-zA-Z0-9_],
\s – es lo mismo que [\t\n\v\f\r ], además de otros caracteres de espacio raros de unicode.


Ejemplo: multi-idioma \wComo la clase de caracteres \w es una abreviatura de [a-zA-Z0-9_], no puede coincidir con sinogramas chinos, letras cirílicas, etc.
Podemos escribir un patrón más universal, que busque caracteres de palabra en cualquier idioma. Eso es fácil con las propiedades unicode: [\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}].
Decifrémoslo. Similar a \w, estamos creando un conjunto propio que incluye caracteres con las siguientes propiedades unicode:

Alfabético (Alpha) – para letras,
Marca (M) – para acentos,
Numero_Decimal (Nd) – para dígitos,
Conector_Puntuación (Pc) – para guión bajo '_' y caracteres similares,
Control_Unión (Join_C) – dos códigos especiales 200c and 200d, utilizado en ligaduras, p.ej. en árabe.

Un ejemplo de uso:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /[\p{Alpha}\p{M}\p{Nd}\p{Pc}\p{Join_C}]/gu;

let str = `Hola 你好 12`;

// encuentra todas las letras y dígitos:
alert( str.match(regexp) ); // H,o,l,a,你,好,1,2
        
      
      
      Por supuesto, podemos editar este patrón: agregar propiedades unicode o eliminarlas. Las propiedades Unicode se cubren con más detalle en el artículo Unicode: bandera "u" y clase \p{...}.

            Las propiedades Unicode no son compatibles con IE
            Las propiedades Unicode p{…} no se implementaron en IE. Si realmente las necesitamos, podemos usar la biblioteca XRegExp.
O simplemente usa rangos de caracteres en el idioma de tu interés, p.ej. [а-я] para letras cirílicas.

Excluyendo rangosAdemás de los rangos normales, hay rangos “excluyentes” que se parecen a [^…].
Están denotados por un carácter caret ^ al inicio y coinciden con cualquier carácter excepto los dados.
Por ejemplo:

[^aeyo] – cualquier carácter excepto  'a', 'e', 'y' u 'o'.
[^0-9] – cualquier carácter excepto un dígito, igual que \D.
[^\s] – cualquiere carácter sin espacio, igual que \S.

El siguiente ejemplo busca cualquier carácter, excepto letras, dígitos y espacios:

      
        
        
          
            
          
          
            
          
        
        
          alert( "alice15@gmail.com".match(/[^\d\sA-Z]/gi) ); // @ y .
        
      
      
      Escapando dentro de corchetes […]Por lo general, cuando queremos encontrar exactamente un carácter especial, necesitamos escaparlo con \.. Y si necesitamos una barra invertida, entonces usamos \\, y así sucesivamente.
Entre corchetes podemos usar la gran mayoría de caracteres especiales sin escaparlos:

Los símbolos . + ( ) nunca necesitan escape.
Un guión - no se escapa al principio ni al final (donde no define un rango).
Un carácter caret ^ solo se escapa al principio (donde significa exclusión).
El corchete de cierre ] siempre se escapa (si se necesita buscarlo).

En otras palabras, todos los caracteres especiales están permitidos sin escapar, excepto cuando significan algo entre corchetes.
Un punto . dentro de corchetes significa solo un punto. El patrón [.,] Buscaría uno de los caracteres: un punto o una coma.
En el siguiente ejemplo, la expresión regular  [-().^+] busca uno de los caracteres -().^+:

      
        
        
          
            
          
          
            
          
        
        
          // no es necesario escaparlos
let regexp = /[-().^+]/g;

alert( "1 + 2 - 3".match(regexp) ); // Coincide +, -
        
      
      
      …Pero si decides escaparlos “por si acaso”, no habría daño:

      
        
        
          
            
          
          
            
          
        
        
          // Todo escapado
let regexp = /[\-\(\)\.\^\+]/g;

alert( "1 + 2 - 3".match(regexp) ); // funciona también: +, -
        
      
      
      Rangos y la bandera (flag) “u”Si hay pares sustitutos en el conjunto, se requiere la flag u para que funcionen correctamente.
Por ejemplo, busquemos [𝒳𝒴] en la cadena 𝒳:

      
        
        
          
            
          
          
            
          
        
        
          alert( '𝒳'.match(/[𝒳𝒴]/) ); // muestra un carácter extraño, como [?]
// (la búsqueda se realizó incorrectamente, se devolvió medio carácter)
        
      
      
      El resultado es incorrecto porque, por defecto, las expresiones regulares “no saben” sobre pares sustitutos.
El motor de expresión regular piensa que la cadena [𝒳𝒴] no son dos, sino cuatro caracteres:

mitad izquierda de 𝒳 (1),
mitad derecha de 𝒳 (2),
mitad izquierda de 𝒴 (3),
mitad derecha de 𝒴 (4).

Sus códigos se pueden mostrar ejecutando:

      
        
        
          
            
          
          
            
          
        
        
          for(let i = 0; i < '𝒳𝒴'.length; i++) {
  alert('𝒳𝒴'.charCodeAt(i)); // 55349, 56499, 55349, 56500
};
        
      
      
      Entonces, el ejemplo anterior encuentra y muestra la mitad izquierda de 𝒳.
Si agregamos la flag u, entonces el comportamiento será correcto:

      
        
        
          
            
          
          
            
          
        
        
          alert( '𝒳'.match(/[𝒳𝒴]/u) ); // 𝒳
        
      
      
      Ocurre una situación similar cuando se busca un rango, como[𝒳-𝒴].
Si olvidamos agregar la flag u, habrá un error:

      
        
        
          
            
          
          
            
          
        
        
          '𝒳'.match(/[𝒳-𝒴]/); // Error: Expresión regular inválida
        
      
      
      La razón es que sin la bandera u los pares sustitutos se perciben como dos caracteres, por lo que [𝒳-𝒴] se interpreta como [<55349><56499>-<55349><56500>] (cada par sustituto se reemplaza con sus códigos). Ahora es fácil ver que el rango 56499-55349 es inválido: su código de inicio 56499 es mayor que el último 55349. Esa es la razón formal del error.
Con la bandera u el patrón funciona correctamente:

      
        
        
          
            
          
          
            
          
        
        
          // buscar caracteres desde  𝒳  a 𝒵
alert( '𝒴'.match(/[𝒳-𝒵]/u) ); // 𝒴
        
      
      
      TareasJava[^script]Tenemos una regexp /Java[^script]/.
¿Coincide con algo en la cadena Java? ¿Y en la cadena JavaScript?
soluciónRespuestas: no, si.


En el script Java no coincide con nada, porque [^script] significa “cualquier carácter excepto los dados”. Entonces, la expresión regular busca "Java" seguido de uno de esos símbolos, pero hay un final de cadena, sin símbolos posteriores.

      
        
        
          
            
          
          
            
          
        
        
          alert( "Java".match(/Java[^script]/) ); // null
        
      
      
      

Sí, porque la sección [^script] en parte coincide con el carácter "S". No está en script. Como el regexp distingue entre mayúsculas y minúsculas (sin flag i), procesa a "S" como un carácter diferente de "s".

      
        
        
          
            
          
          
            
          
        
        
          alert( "JavaScript".match(/Java[^script]/) ); // "JavaS"
        
      
      
      

Encuentra la hora como hh:mm o hh-mmLa hora puede estar en el formato horas:minutos u horas-minutos. Tanto las horas como los minutos tienen 2 dígitos: 09:00 ó 21-30.
Escribe una regexp que encuentre la hora:

      
        
        
          let regexp = /tu regexp/g;
alert( "El desayuno es a las 09:00. La cena es a las 21-30".match(regexp) ); // 09:00, 21-30
        
      
      
      En esta tarea asumimos que el tiempo siempre es correcto, no hay necesidad de filtrar cadenas malas como “45:67”. Más tarde nos ocuparemos de eso también.
soluciónRespuesta: \d\d[-:]\d\d.

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /\d\d[-:]\d\d/g;
alert( "El desayuno es a las 09:00. La cena es a las 21-30".match(regexp) ); // 09:00, 21-30
        
      
      
      Tenga en cuenta que el guión '-' tiene un significado especial entre corchetes, pero solo entre otros caracteres, no al principio o al final, por lo que no necesitamos escaparlo.
",
	"url": "https://es.javascript.info/regexp-character-sets-and-ranges" 
},
{
	"docs_id": "170",
	"name": "Cuantificadores +, *, ? y {n}",
	"description": "Digamos que tenemos una cadena como +7 (903) -123-45-67 y queremos encontrar todos los números en ella. Pero contrastando el ejemplo anterior, no estamos interesados en un solo dígito, sino en números completos: 7, 903, 123, 45, 67.",
	"content": "Digamos que tenemos una cadena como +7 (903) -123-45-67 y queremos encontrar todos los números en ella. Pero contrastando el ejemplo anterior, no estamos interesados en un solo dígito, sino en números completos: 7, 903, 123, 45, 67.
Un número es una secuencia de 1 o más dígitos \d. Para marcar cuántos necesitamos, podemos agregar un cuantificador.
Cantidad {n}El cuantificador más simple es un número entre llaves: {n}.
Se agrega un cuantificador a un carácter (o a una clase de caracteres, o a un conjunto [...], etc) y especifica cuántos necesitamos.
Tiene algunas formas avanzadas, veamos los ejemplos:

El recuento exacto: {5}

\d{5} Denota exactamente 5 dígitos, igual que \d\d\d\d\d.
El siguiente ejemplo busca un número de 5 dígitos:

      
        
        
          
            
          
          
            
          
        
        
          alert( "Tengo 12345 años de edad".match(/\d{5}/) ); //  "12345"
        
      
      
      Podemos agregar \b para excluir números largos: \b\d{5}\b.

El rango: {3,5}, coincide 3-5 veces

Para encontrar números de 3 a 5 dígitos, podemos poner los límites en llaves: \d{3,5}

      
        
        
          
            
          
          
            
          
        
        
          alert( "No tengo 12, sino 1234 años de edad".match(/\d{3,5}/) ); // "1234"
        
      
      
      Podemos omitir el límite superior
Luego, una regexp \d{3,} busca secuencias de dígitos de longitud 3 o más:

      
        
        
          
            
          
          
            
          
        
        
          alert( "No tengo 12, sino, 345678 años de edad".match(/\d{3,}/) ); // "345678"
        
      
      
      

Volvamos a la cadena +7(903)-123-45-67.
Un número es una secuencia de uno o más dígitos continuos. Entonces la expresión regular es \d{1,}:

      
        
        
          
            
          
          
            
          
        
        
          let str = "+7(903)-123-45-67";

let numbers = str.match(/\d{1,}/g);

alert(numbers); // 7,903,123,45,67
        
      
      
      AbreviacionesHay abreviaciones para los cuantificadores más usados:

+

Significa “uno o más”, igual que {1,}.
Por ejemplo, \d+ busca números:

      
        
        
          
            
          
          
            
          
        
        
          let str = "+7(903)-123-45-67";

alert( str.match(/\d+/g) ); // 7,903,123,45,67
        
      
      
      
?

Significa “cero o uno”, igual que {0,1}. En otras palabras, hace que el símbolo sea opcional.
Por ejemplo, el patrón ou?r busca o seguido de cero o uno u, y luego r.
Entonces, colou?r encuentra ambos color y colour:

      
        
        
          
            
          
          
            
          
        
        
          let str = "¿Debo escribir color o colour?";

alert( str.match(/colou?r/g) ); // color, colour
        
      
      
      
*

Significa “cero o más”, igual que {0,}. Es decir, el carácter puede repetirse muchas veces o estar ausente.
Por ejemplo, \d0* busca un dígito seguido de cualquier número de ceros (puede ser muchos o ninguno):

      
        
        
          
            
          
          
            
          
        
        
          alert( "100 10 1".match(/\d0*/g) ); // 100, 10, 1
        
      
      
      Compáralo con + (uno o más):

      
        
        
          
            
          
          
            
          
        
        
          alert( "100 10 1".match(/\d0+/g) ); // 100, 10
// 1 no coincide, ya que 0+ requiere al menos un cero
        
      
      
      

Más ejemplosLos cuantificadores se usan con mucha frecuencia. Sirven como el “bloque de construcción” principal de expresiones regulares complejas, así que veamos más ejemplos.
Regexp para fracciones decimales (un número con coma flotante): \d+\.\d+
En acción:

      
        
        
          
            
          
          
            
          
        
        
          alert( "0 1 12.345 7890".match(/\d+\.\d+/g) ); // 12.345
        
      
      
      Regexp para una “etiqueta HTML de apertura sin atributos”, tales como <span> o <p>.


La más simple: /<[a-z]+>/i

      
        
        
          
            
          
          
            
          
        
        
          alert( "<body> ... </body>".match(/<[a-z]+>/gi) ); // <body>
        
      
      
      La regexp busca el carácter '<' seguido de una o más letras latinas, y el carácter '>'.


Mejorada: /<[a-z][a-z0-9]*>/i
De acuerdo al estándar, el nombre de una etiqueta HTML puede tener un dígito en cualquier posición excepto al inicio, tal como <h1>.

      
        
        
          
            
          
          
            
          
        
        
          alert( "<h1>Hola!</h1>".match(/<[a-z][a-z0-9]*>/gi) ); // <h1>
        
      
      
      

Regexp para “etiquetas HTML de apertura o cierre sin atributos”: /<\/?[a-z][a-z0-9]*>/i
Agregamos una barra opcional /? cerca del comienzo del patrón. Se tiene que escapar con una barra diagonal inversa, de lo contrario, JavaScript pensaría que es el final del patrón.

      
        
        
          
            
          
          
            
          
        
        
          alert( "<h1>Hola!</h1>".match(/<\/?[a-z][a-z0-9]*>/gi) ); // <h1>, </h1>
        
      
      
      
            Para hacer más precisa una regexp, a menudo necesitamos hacerla más compleja
            Podemos ver una regla común en estos ejemplos: cuanto más precisa es la expresión regular, es más larga y compleja.
Por ejemplo, para las etiquetas HTML debemos usar una regexp más simple: <\w+>. Pero como HTML tiene normas estrictas para los nombres de etiqueta, <[a-z][a-z0-9]*> es más confiable.
¿Podemos usar <\w+> o necesitamos <[a-z][a-z0-9]*>?
En la vida real, ambas variantes son aceptables. Depende de cuán tolerantes podamos ser a las coincidencias “adicionales” y si es difícil o no eliminarlas del resultado por otros medios.

Tareas¿Cómo encontrar puntos suspensivos "..."?importancia: 5Escriba una regexp para encontrar puntos suspensivos: 3 (¿o más?) puntos en una fila.
Revísalo:

      
        
        
          let regexp = /tu regexp/g;
alert( "Hola!... ¿Cómo vas?.....".match(regexp) ); // ..., .....
        
      
      
      soluciónSolución:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /\.{3,}/g;
alert( "Hola!... ¿Cómo vas?.....".match(regexp) ); // ..., .....
        
      
      
      Tenga en cuenta que el punto es un carácter especial, por lo que debemos escaparlo e insertarlo como \..
Regexp para colores HTMLEscribe una regexp para encontrar colores HTML escritos como #ABCDEF: primero #  y luego 6 caracteres hexadecimales.
Un ejemplo de uso:

      
        
        
          let regexp = /...tu regexp.../

let str = "color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2 #12345678";

alert( str.match(regexp) )  // #121212,#AA00ef
        
      
      
      P.D. En esta tarea no necesitamos otro formato de color como #123 o rgb(1,2,3), etc.
soluciónNecesitamos buscar # seguido de 6 caracteres hexadecimales.
Un carácter hexadecimal se puede describir como [0-9a-fA-F]. O si usamos la bandera i, entonces simplemente [0-9a-f].
Entonces podemos buscar 6 de ellos usando el cuantificador {6}.
Como resultado, tenemos la regexp: /#[a-f0-9]{6}/gi.

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /#[a-f0-9]{6}/gi;

let str = "color:#121212; background-color:#AA00ef bad-colors:f#fddee #fd2"

alert( str.match(regexp) );  // #121212,#AA00ef
        
      
      
      El problema es que también encuentra el color en secuencias más largas:

      
        
        
          
            
          
          
            
          
        
        
          alert( "#12345678".match( /#[a-f0-9]{6}/gi ) ) // #123456
        
      
      
      Para corregir eso, agregamos \b al final:

      
        
        
          
            
          
          
            
          
        
        
          // color
alert( "#123456".match( /#[a-f0-9]{6}\b/gi ) ); // #123456

// sin color
alert( "#12345678".match( /#[a-f0-9]{6}\b/gi ) ); // null
        
      
      
      ",
	"url": "https://es.javascript.info/regexp-quantifiers" 
},
{
	"docs_id": "171",
	"name": "Cuantificadores codiciosos y perezosos",
	"description": "Los cuantificadores son muy simples a primera vista, pero de hecho pueden ser complicados.",
	"content": "Los cuantificadores son muy simples a primera vista, pero de hecho pueden ser complicados.
Debemos entender muy bien cómo funciona la búsqueda si planeamos buscar algo más complejo que /\d+/.
Tomemos la siguiente tarea como ejemplo.
Tenemos un texto y necesitamos reemplazar todas las comillas "..." con comillas latinas: «...». En muchos paises los tipógrafos las prefieren.
Por ejemplo: "Hola, mundo" debe ser «Hola, mundo». Existen otras comillas, como „Witam, świat!” (Polaco) o 「你好，世界」 (Chino), pero para nuestra tarea elegimos «...».
Lo primero que debe hacer es ubicar las cadenas entre comillas, y luego podemos reemplazarlas.
Una expresión regular como /".+"/g (una comilla, después algo, luego otra comilla) Puede parecer una buena opción, ¡pero no lo es!
Vamos a intentarlo:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /".+"/g;

let str = 'una "bruja" y su "escoba" son una';

alert( str.match(regexp) ); // "bruja" y su "escoba"
        
      
      
      …¡Podemos ver que no funciona según lo previsto!
En lugar de encontrar dos coincidencias "bruja" y "escoba", encuentra una: "bruja" y su "escoba".
Esto se puede describir como “la codicia es la causa de todo mal”.
Búsqueda codiciosaPara encontrar una coincidencia, el motor de expresión regular utiliza el siguiente algoritmo:

Para cada posición en la cadena

Prueba si el patrón coincide en esta posición.
Si no hay coincidencia, ir a la siguiente posición.



Estas palabras comunes no son tan obvias para determinar por qué la regexp falla, así que elaboremos el funcionamiento de la búsqueda del patrón ".+".


El primer carácter del patrón es una comilla doble ".
El motor de expresión regular intenta encontrarla en la posición cero de la cadena fuente una "bruja" y su "escoba" son una, pero hay una u allí, por lo que inmediatamente no hay coincidencia.
Entonces avanza: va a la siguiente posición en la cadena fuente y prueba encontrar el primer carácter del patrón allí, falla de nuevo, y finalmente encuentra la comilla doble en la 3ra posición:

      
      
        
      
      

La comilla doble es detectada, y después el motor prueba encontrar una coincidencia para el resto del patrón. Prueba ver si el resto de la cadena objetivo satisface a .+".
En nuestro caso el próximo carácter de patrón es . (un punto). Que denota “cualquiere carácter excepto línea nueva”, entonces la próxima letra de la cadena encaja 'w':

      
      
        
      
      

Entonces el punto (.) se repite por el cuantificador .+. El motor de expresión regular agrega a la coincidencia un carácter uno después de otro.
…¿Hasta cuando? Todos los caracteres coinciden con el punto, entonces se detiene hasta que alcanza el final de la cadena:

      
      
        
      
      

Ahora el motor finalizó el ciclo de .+ y prueba encontrar el próximo carácter del patrón. El cual es la comilla doble ". Pero hay un problema: la cadena ha finalizado, ¡no hay más caracteres!
El motor de expresión regular comprende que procesó demasiados .+ y reinicia la cadena.
En otras palabras, acorta la coincidencia para el cuantificador en un carácter:

      
      
        
      
      Ahora se supone que .+ finaliza un carácter antes del final de la cadena e intenta hacer coincidir el resto del patrón desde esa posición.
Si hubiera comillas doble allí, entonces la búsqueda terminaría, pero el último carácter es 'a', por lo que no hay coincidencia.


…Entonces el motor disminuye el número de repeticiones de .+ en uno:

      
      
        
      
      Las comillas dobles '"' no coinciden con 'n'.


El motor continua reiniciando la lectura de la cadena: decrementa el contador de repeticiones para '.' hasta que el resto del patrón (en nuestro caso '"') coincida:

      
      
        
      
      

La coincidencia está completa.


Entonces la primera coincidencia es "bruja" y su "escoba". Si la expresión regular tiene la bandera g, entonces la búsqueda continuará desde donde termina la primera coincidencia. No hay más comillas dobles en el resto de la cadena son una, entonces no hay más resultados.


Probablemente no es lo que esperabamos, pero así es como funciona.
En el modo codicioso (por defecto) un carácter cuantificado se repite tantas veces como sea posible.
El motor de regexp agrega a la coincidencia tantos caracteres como pueda abarcar el patrón .+, y luego los abrevia uno por uno si el resto del patrón no coincide.
En nuestro caso queremos otra cosa. Es entonces donde el modo perezoso puede ayudar.
Modo perezosoEl modo perezoso de los cuantificadores es lo opuesto del modo codicioso. Eso significa: “repite el mínimo número de veces”.
Podemos habilitarlo poniendo un signo de interrogación '?' después del cuantificador, entonces tendríamos *? o +? o incluso ?? para '?'.
Aclarando las cosas: generalmente un signo de interrogación ? es un cuantificador por si mismo (cero o uno), pero si se agrega despues de otro cuantificador (o incluso el mismo) toma otro significado, alterna el modo de coincidencia de codicioso a perezoso.
La regexp /".+?"/g funciona como se esperaba: encuentra "bruja" y "escoba":

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /".+?"/g;

let str = 'una "bruja" y su "escoba" son una';

alert( str.match(regexp) ); // "bruja", "escoba"
        
      
      
      Para comprender claramente el cambio, rastreemos la búsqueda paso a paso.


El primer paso es el mismo: encuentra el inicio del patrón '"' en la 5ta posición:

      
      
        
      
      

El siguiente paso también es similar: el motor encuentra una coincidencia para el punto '.':

      
      
        
      
      

Y ahora la búsqueda es diferente. Porque tenemos el modo perezoso activado en +?, el motor no prueba coincidir un punto una vez más, se detiene y prueba coincidir el resto del patrón ('"') ahora mismo :

      
      
        
      
      Si hubiera comillas dobles allí, entonces la búsqueda terminaría, pero hay una 'r', entonces no hay coincidencia.


Después el motor de expresión regular incrementa el número de repeticiones para el punto y prueba una vez más:

      
      
        
      
      Falla de nuevo. Después el número de repeticiones es incrementado una y otra vez…


…Hasta que se encuentre una coincidencia para el resto del patrón:

      
      
        
      
      

La próxima busqueda inicia desde el final de la coincidencia actual y produce un resultado más:

      
      
        
      
      

En este ejemplo vimos cómo funciona el modo perezoso para +?. Los cuantificadores *? y ?? funcionan de manera similar, el motor regexp incrementa el número de repticiones solo si el resto del patrón no coincide en la posición dada.
La pereza solo está habilitada para el cuantificador con ?.
Otros cuantificadores siguen siendo codiciosos.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          alert( "123 456".match(/\d+ \d+?/) ); // 123 4
        
      
      
      

El patrón \d+ intenta hacer coincidir tantos dígitos como sea posible (modo codicioso), por lo que encuentra  123 y se detiene, porque el siguiente carácter es un espacio ' '.


Luego hay un espacio en el patrón, coincide.


Después hay un \d+?. El cuantificador está en modo perezoso, entonces busca un dígito 4 y trata de verificar si el resto del patrón coincide desde allí.
…Pero no hay nada en el patrón después de \d+?.
El modo perezoso no repite nada sin necesidad. El patrón terminó, así que terminamos. Tenemos una coincidencia 123 4.



            Optimizaciones
            Los motores modernos de expresiones regulares pueden optimizar algoritmos internos para trabajar más rápido. Estos trabajan un poco diferente del algoritmo descrito.
Pero para comprender como funcionan las expresiones regulares y construirlas, no necesitamos saber nada al respecto. Solo se usan internamente para optimizar cosas.
Las expresiones regulares complejas son difíciles de optimizar, por lo que la búsqueda también puede funcionar exactamente como se describe.

Enfoque alternativoCon las regexps, por lo general hay muchas formas de hacer la misma cosa.
En nuestro caso podemos encontrar cadenas entre comillas sin el modo perezoso usando la regexp "[^"]+":

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /"[^"]+"/g;

let str = 'una "bruja" y su "escoba" son una';

alert( str.match(regexp) ); // "bruja", "escoba"
        
      
      
      La regexp "[^"]+" devuelve el resultado correcto, porque busca una comilla doble '"' seguida por uno o más caracteres no comilla doble [^"], y luego la comilla doble de cierre.
Cuando la máquina de regexp busca el carácter no comilla [^"]+ se detiene la repetición cuando encuentra la comilla doble de cierre,y terminamos.
Nótese, ¡esta lógica no reemplaza al cuantificador perezoso!
Es solo diferente. Hay momentos en que necesitamos uno u otro.
Veamos un ejemplo donde los cuantificadores perezosos fallan y la variante funciona correctamente.
Por ejemplo, queremos encontrar enlaces en la forma <a href="..." class="doc">, con cualquier href.
¿Cual expresión regular usamos?
La primera idea podría ser: /<a href=".*" class="doc">/g.
Veámoslo:

      
        
        
          
            
          
          
            
          
        
        
          let str = '...<a href="link" class="doc">...';
let regexp = /<a href=".*" class="doc">/g;

// ¡Funciona!
alert( str.match(regexp) ); // <a href="link" class="doc">
        
      
      
      Funcionó. Pero veamos ¿que pasa si hay varios enlaces en el texto?

      
        
        
          
            
          
          
            
          
        
        
          let str = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';
let regexp = /<a href=".*" class="doc">/g;

// ¡Vaya! ¡Dos enlaces en una coincidencia!
alert( str.match(regexp) ); // <a href="link1" class="doc">... <a href="link2" class="doc">
        
      
      
      Ahora el resultado es incorrecto por la misma razón del ejemplo de la bruja. El cuantificador .* toma demasiados caracteres.
La coincidencia se ve así:

      
        
        
          <a href="....................................." class="doc">
<a href="link1" class="doc">... <a href="link2" class="doc">
        
      
      
      Modifiquemos el patrón haciendo el cuantificador perezoso: .*?:

      
        
        
          
            
          
          
            
          
        
        
          let str = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';
let regexp = /<a href=".*?" class="doc">/g;

// ¡Funciona!
alert( str.match(regexp) ); // <a href="link1" class="doc">, <a href="link2" class="doc">
        
      
      
      Ahora parece funcionar, hay dos coincidencias:

      
        
        
          <a href="....." class="doc">    <a href="....." class="doc">
<a href="link1" class="doc">... <a href="link2" class="doc">
        
      
      
      …Pero probemos ahora con una entrada de texto adicional:

      
        
        
          
            
          
          
            
          
        
        
          let str = '...<a href="link1" class="wrong">... <p style="" class="doc">...';
let regexp = /<a href=".*?" class="doc">/g;

// ¡Coincidencia incorrecta!
alert( str.match(regexp) ); // <a href="link1" class="wrong">... <p style="" class="doc">
        
      
      
      Ahora falla. La coincidencia no solo incluye el enlace, sino también mucho texto después, incluyendo <p...>.
¿Por qué?
Eso es lo que está pasando:

Primero la regexp encuentra un enlace inicial <a href=".
Después busca para el patrón .*?: toma un carácter (¡perezosamente!), verifica si hay una coincidencia para " class="doc"> (ninguna).
Después toma otro carácter dentro de .*?, y así… hasta que finalmente alcanza a  " class="doc">.

Pero el problema es que: eso ya está más allá del enlace <a...>, en otra etiqueta <p>. No es lo que queremos.
Esta es la muestra de la coincidencia alineada con el texto:

      
        
        
          <a href="..................................." class="doc">
<a href="link1" class="wrong">... <p style="" class="doc">
        
      
      
      Entonces, necesitamos un patrón que busque <a href="...algo..." class="doc">, pero ambas variantes, codiciosa y perezosa, tienen problemas.
La variante correcta puede ser: href="[^"]*". Esta tomará todos los caracteres dentro del atributo href hasta la comilla doble más cercana, justo lo que necesitamos.
Un ejemplo funcional:

      
        
        
          
            
          
          
            
          
        
        
          let str1 = '...<a href="link1" class="wrong">... <p style="" class="doc">...';
let str2 = '...<a href="link1" class="doc">... <a href="link2" class="doc">...';
let regexp = /<a href="[^"]*" class="doc">/g;

// ¡Funciona!
alert( str1.match(regexp) ); // null, sin coincidencia, eso es correcto
alert( str2.match(regexp) ); // <a href="link1" class="doc">, <a href="link2" class="doc">
        
      
      
      ResumenLos cuantificadores tienen dos modos de funcionamiento:

Codiciosa
Por defecto el motor de expresión regular prueba repetir el carácter cuantificado tantas veces como sea posible. Por ejemplo, \d+ consume todos los posibles dígitos. Cuando es imposible consumir más (no hay más dígitos o es el fin de la cadena), entonces continúa hasta coincidir con el resto del patrón. Si no hay coincidencia entonces se decrementa el número de repeticiones (reinicios) y prueba de nuevo.
Perezoso
Habilitado por el signo de interrogación ? después de un cuantificador. El motor de regexp prueba la coincidencia para el resto del patrón antes de cada repetición del carácter cuantificado.

Como vimos, el modo perezoso no es una “panacea” de la búsqueda codiciosa. Una alternativa es una búsqueda codiciosa refinada, con exclusiones, como en el patrón "[^"]+".
TareasUna coincidencia para /d+? d+?/¿Cual es la coincidencia aquí?

      
        
        
          alert( "123 456".match(/\d+? \d+?/g) ); // ?
        
      
      
      soluciónEl resultado es: 123 4.
Primero el perezoso \d+? trata de tomar la menor cantidad de dígitos posible, pero tiene que llegar al espacio, por lo que toma 123.
Después el segundo \d+? toma solo un dígito, porque es sufuciente.
Encuentra el comentario HTMLEncuentra todos los comentarios HTML en el texto:

      
        
        
          let regexp = /your regexp/g;

let str = `... <!-- Mi -- comentario
 prueba --> ..  <!----> ..
`;

alert( str.match(regexp) ); // '<!-- Mi -- comentario \n prueba -->', '<!---->'
        
      
      
      soluciónNecesitamos encontrar el inicio del comentario <!--, después todo hasta el fin de -->.
Una variante aceptable es <!--.*?--> – el cuantificador perezoso detiene el punto justo antes de -->. También necesitamos agregar la bandera s al punto para incluir líneas nuevas.
De lo contrario, no se encontrarán comentarios multilínea:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /<!--.*?-->/gs;

let str = `... <!-- Mi -- comentario
 prueba --> ..  <!----> ..
`;

alert( str.match(regexp) ); // '<!-- Mi -- comentario \n prueba -->', '<!---->'
        
      
      
      Encontrar las etiquetas HTMLCrear una expresión regular para encontrar todas las etiquetas HTML (de apertura y cierre) con sus atributos.
Un ejemplo de uso:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /tu regexp/g;

let str = '<> <a href="/"> <input type="radio" checked > <b>';

alert( str.match(regexp) ); // '<a href="/">', '<input type="radio" checked >', '<b>'
        
      
      
      Asumimos que los atributos de etiqueta no deben contener < ni > (dentro de comillas dobles también), esto simplifica un poco las cosas.
soluciónLa solución es <[^<>]+>.

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /<[^<>]+>/g;

let str = '<> <a href="/"> <input type="radio" checked > <b>';

alert( str.match(regexp) ); // '<a href="/">', '<input type="radio" checked >', '<b>'
        
      
      
      ",
	"url": "https://es.javascript.info/regexp-greedy-and-lazy" 
},
{
	"docs_id": "172",
	"name": "Grupos de captura",
	"description": "Una parte de un patrón se puede incluir entre paréntesis (...). Esto se llama “grupo de captura”.",
	"content": "Una parte de un patrón se puede incluir entre paréntesis (...). Esto se llama “grupo de captura”.
Esto tiene dos resultados:

Permite obtener una parte de la coincidencia como un elemento separado en la matriz de resultados.
Si colocamos un cuantificador después del paréntesis, se aplica a los paréntesis en su conjunto.

EjemplosVeamos cómo funcionan los paréntesis en los ejemplos.
Ejemplo: gogogoSin paréntesis, el patrón go+ significa el carácter g, seguido por o repetido una o más veces. Por ejemplo, goooo o gooooooooo.
Los paréntesis agrupan los carácteres juntos, por lo tanto (go)+ significa go, gogo, gogogo etcétera.

      
        
        
          
            
          
          
            
          
        
        
          alert( 'Gogogo now!'.match(/(go)+/ig) ); // "Gogogo"
        
      
      
      Ejemplo: dominioHagamos algo más complejo: una expresión regular para buscar un dominio de sitio web.
Por ejemplo:

      
        
        
          mail.com
users.mail.com
smith.users.mail.com
        
      
      
      Como podemos ver, un dominio consta de palabras repetidas, un punto después de cada una excepto la última.
En expresiones regulares eso es (\w+\.)+\w+:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /(\w+\.)+\w+/g;

alert( "site.com my.site.com".match(regexp) ); // site.com,my.site.com
        
      
      
      La búsqueda funciona, pero el patrón no puede coincidir con un dominio con un guión, por ejemplo, my-site.com, porque el guión no pertenece a la clase \w.
Podemos arreglarlo al reemplazar \w con [\w-] en cada palabra excepto el último: ([\w-]+\.)+\w+.
Ejemplo: emailEl ejemplo anterior puede ser extendido. Podemos crear una expresión regular para emails en base a esto.
El formato de email es: name@domain. Cualquier palabra puede ser el nombre, guiones y puntos están permitidos. En expresiones regulares esto es [-.\w]+.
El patrón:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /[-.\w]+@([\w-]+\.)+[\w-]+/g;

alert("my@mail.com @ his@site.com.uk".match(regexp)); // my@mail.com, his@site.com.uk
        
      
      
      Esa expresión regular no es perfecta, pero sobre todo funciona y ayuda a corregir errores de escritura accidentales. La única verificación verdaderamente confiable para un correo electrónico solo se puede realizar enviando una carta.
Contenido del paréntesis en la coincidencia (match)Los paréntesis están numerados de izquierda a derecha. El buscador memoriza el contenido que coincide con cada uno de ellos y permite obtenerlo en el resultado.
El método str.match(regexp), si regexp no tiene indicador (flag) g, busca la primera coincidencia y lo devuelve como un array:

En el índice 0: la coincidencia completa.
En el índice 1: el contenido del primer paréntesis.
En el índice 2: el contenido del segundo paréntesis.
…etcétera…

Por ejemplo, nos gustaría encontrar etiquetas HTML <.*?>, y procesarlas. Sería conveniente tener el contenido de la etiqueta (lo que está dentro de los ángulos), en una variable por separado.
Envolvamos el contenido interior en paréntesis, de esta forma: <(.*?)>.
Ahora obtendremos ambos, la etiqueta entera <h1>  y su contenido h1 en el array resultante:

      
        
        
          
            
          
          
            
          
        
        
          let str = '<h1>Hello, world!</h1>';

let tag = str.match(/<(.*?)>/);

alert( tag[0] ); // <h1>
alert( tag[1] ); // h1
        
      
      
      Grupos anidadosLos paréntesis pueden ser anidados. En este caso la numeración también va de izquierda a derecha.
Por ejemplo, al buscar una etiqueta en <span class="my"> tal vez nos pueda interesar:

El contenido de la etiqueta como un todo: span class="my".
El nombre de la etiqueta: span.
Los atributos de la etiqueta: class="my".

Agreguemos paréntesis: <(([a-z]+)\s*([^>]*))>.
Así es cómo se enumeran (izquierda a derecha, por el paréntesis de apertura):

      
      
        
      
      En acción:

      
        
        
          
            
          
          
            
          
        
        
          let str = '<span class="my">';

let regexp = /<(([a-z]+)\s*([^>]*))>/;

let result = str.match(regexp);
alert(result[0]); // <span class="my">
alert(result[1]); // span class="my"
alert(result[2]); // span
alert(result[3]); // class="my"
        
      
      
      El índice cero de result siempre contiene la coincidencia completa.
Luego los grupos, numerados de izquierda a derecha por un paréntesis de apertura. El primer grupo se devuelve como result[1]. Aquí se encierra todo el contenido de la etiqueta.
Luego en result[2] va el grupo desde el segundo paréntesis de apertura ([a-z]+) – nombre de etiqueta, luego en result[3] la etiqueta: ([^>]*).
El contenido de cada grupo en el string:

      
      
        
      
      Grupos opcionalesIncluso si un grupo es opcional y no existe en la coincidencia (p.ej. tiene el cuantificador (...)?), el elemento array result correspondiente está presente y es igual a undefined.
Por ejemplo, consideremos la expresión regular a(z)?(c)?. Busca "a" seguida por opcionalmente "z", seguido por "c" opcionalmente.
Si lo ejecutamos en el string con una sola letra a, entonces el resultado es:

      
        
        
          
            
          
          
            
          
        
        
          let match = 'a'.match(/a(z)?(c)?/);

alert( match.length ); // 3
alert( match[0] ); // a (coincidencia completa)
alert( match[1] ); // undefined
alert( match[2] ); // undefined
        
      
      
      El array tiene longitud de 3, pero todos los grupos están vacíos.
Y aquí hay una coincidencia más compleja para el string ac:

      
        
        
          
            
          
          
            
          
        
        
          let match = 'ac'.match(/a(z)?(c)?/)

alert( match.length ); // 3
alert( match[0] ); // ac (coincidencia completa)
alert( match[1] ); // undefined, ¿porque no hay nada para (z)?
alert( match[2] ); // c
        
      
      
      La longitud del array es permanente: 3. Pero no hay nada para el grupo (z)?, por lo tanto el resultado es ["ac", undefined, "c"].
Buscar todas las coincidencias con grupos: matchAll
            matchAll es un nuevo método, polyfill puede ser necesario
            El método matchAll no es compatible con antiguos navegadores.
Un polyfill puede ser requerido, tal como https://github.com/ljharb/String.prototype.matchAll.

Cuando buscamos todas las coincidencias (flag g), el método match no devuelve contenido para los grupos.
Por ejemplo, encontremos todas las etiquetas en un string:

      
        
        
          
            
          
          
            
          
        
        
          let str = '<h1> <h2>';

let tags = str.match(/<(.*?)>/g);

alert( tags ); // <h1>,<h2>
        
      
      
      El resultado es un array de coincidencias, pero sin detalles sobre cada uno de ellos. Pero en la práctica normalmente necesitamos contenidos de los grupos de captura en el resultado.
Para obtenerlos tenemos que buscar utilizando el método str.matchAll(regexp).
Fue incluido a JavaScript mucho después de match, como su versión “nueva y mejorada”.
Al igual que match, busca coincidencias, pero hay 3 diferencias:

No devuelve un array sino un objeto iterable.
Cuando está presente el indicador g, devuelve todas las coincidencias como un array con grupos.
Si no hay coincidencias, no devuelve null sino un objeto iterable vacío.

Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

// results - no es un array, sino un objeto iterable
alert(results); // [object RegExp String Iterator]

alert(results[0]); // undefined (*)

results = Array.from(results); // lo convirtamos en array

alert(results[0]); // <h1>,h1 (1er etiqueta)
alert(results[1]); // <h2>,h2 (2da etiqueta)
        
      
      
      Como podemos ver, la primera diferencia es muy importante, como se demuestra en la línea (*). No podemos obtener la coincidencia como results[0], porque ese objeto no es pseudo array. Lo podemos convertir en un Array real utilizando Array.from. Hay más detalles sobre pseudo arrays e iterables en el artículo. Iterables.
No se necesita Array.from si estamos iterando sobre los resultados:

      
        
        
          
            
          
          
            
          
        
        
          let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

for(let result of results) {
  alert(result);
  // primer alert: <h1>,h1
  // segundo: <h2>,h2
}
        
      
      
      …O utilizando desestructurización:

      
        
        
          let [tag1, tag2] = '<h1> <h2>'.matchAll(/<(.*?)>/gi);
        
      
      
      Cada coincidencia devuelta por matchAll tiene el mismo formato que el devuelto por match sin el flag g: es un array con propiedades adicionales index (coincide índice en el string) e input (fuente string):

      
        
        
          
            
          
          
            
          
        
        
          let results = '<h1> <h2>'.matchAll(/<(.*?)>/gi);

let [tag1, tag2] = results;

alert( tag1[0] ); // <h1>
alert( tag1[1] ); // h1
alert( tag1.index ); // 0
alert( tag1.input ); // <h1> <h2>
        
      
      
      
            ¿Por qué el resultado de matchAll es un objeto iterable y no un array?
            ¿Por qué el método está diseñado de esa manera? La razón es simple – por la optimización.
El llamado a matchAll no realiza la búsqueda. En cambio devuelve un objeto iterable, en un principio sin los resultados. La búsqueda es realizada cada vez que iteramos sobre ella, es decir, en el bucle.
Por lo tanto, se encontrará tantos resultados como sea necesario, no más.
Por ejemplo, posiblemente hay 100 coincidencias en el texto, pero en un bucle for..of encontramos 5 de ellas: entonces decidimos que es suficiente y realizamos un break.  Así el buscador no gastará tiempo buscando otras 95 coincidencias.

Grupos con nombreEs difícil recordar a los grupos por su número. Para patrones simples, es factible, pero para los más complejos, contar los paréntesis es inconveniente. Tenemos una opción mucho mejor: poner nombres entre paréntesis.
Eso se hace poniendo ?<name> inmediatamente después del paréntesis de apertura.
Por ejemplo, busquemos una fecha en el formato “año-mes-día”:

      
        
        
          
            
          
          
            
          
        
        
          let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/;
let str = "2019-04-30";

let groups = str.match(dateRegexp).groups;

alert(groups.year); // 2019
alert(groups.month); // 04
alert(groups.day); // 30
        
      
      
      Como puedes ver, los grupos residen en la propiedad .groups de la coincidencia.
Para buscar todas las fechas, podemos agregar el flag g.
También vamos a necesitar matchAll para obtener coincidencias completas, junto con los grupos:

      
        
        
          
            
          
          
            
          
        
        
          let dateRegexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;

let str = "2019-10-30 2020-01-01";

let results = str.matchAll(dateRegexp);

for(let result of results) {
  let {year, month, day} = result.groups;

  alert(`${day}.${month}.${year}`);
  // primer alert: 30.10.2019
  // segundo: 01.01.2020
}
        
      
      
      Grupos de captura en reemplazoEl método str.replace(regexp, replacement) que reemplaza todas las coincidencias con regexp en str nos permite utilizar el contenido de los paréntesis en el string replacement. Esto se hace utilizando $n, donde n es el número de grupo.
Por ejemplo,

      
        
        
          
            
          
          
            
          
        
        
          let str = "John Bull";
let regexp = /(\w+) (\w+)/;

alert( str.replace(regexp, '$2, $1') ); // Bull, John
        
      
      
      Para los paréntesis con nombre la referencia será $<name>.
Por ejemplo, volvamos a darle formato a las fechas desde “year-month-day” a “day.month.year”:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/g;

let str = "2019-10-30, 2020-01-01";

alert( str.replace(regexp, '$<day>.$<month>.$<year>') );
// 30.10.2019, 01.01.2020
        
      
      
      Grupos que no capturan con ?:A veces necesitamos paréntesis para aplicar correctamente un cuantificador, pero no queremos su contenido en los resultados.
Se puede excluir un grupo agregando ?: al inicio.
Por ejemplo, si queremos encontrar (go)+, pero no queremos el contenido del paréntesis (go) como un ítem separado del array, podemos escribir: (?:go)+.
En el ejemplo de arriba solamente obtenemos el nombre John como un miembro separado de la coincidencia:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Gogogo John!";

// ?: excluye 'go' de la captura
let regexp = /(?:go)+ (\w+)/i;

let result = str.match(regexp);

alert( result[0] ); // Gogogo John (coincidencia completa)
alert( result[1] ); // John
alert( result.length ); // 2 (no hay más ítems en el array)
        
      
      
      ResumenLos paréntesis agrupan una parte de la expresión regular, de modo que el cuantificador se aplique a ella como un todo.
Los grupos de paréntesis se numeran de izquierda a derecha y, opcionalmente, se pueden nombrar con (?<name>...).
El contenido, emparejado por un grupo, se puede obtener en los resultados:

El método str.match devuelve grupos de captura únicamente sin el indicador (flag) g.
El método str.matchAll siempre devuelve grupos de captura.

Si el paréntesis no tiene nombre, entonces su contenido está disponible en el array de coincidencias por su número. Los paréntesis con nombre también están disponible en la propiedad groups.
También podemos utilizar el contenido del paréntesis en el string de reemplazo de str.replace: por el número $n o el nombre $<name>.
Un grupo puede ser excluido de la enumeración al agregar ?: en el inicio. Eso se usa cuando necesitamos aplicar un cuantificador a todo el grupo, pero no lo queremos como un elemento separado en el array de resultados. Tampoco podemos hacer referencia a tales paréntesis en el string de reemplazo.
TareasVerificar dirección MACLa Dirección MAC de una interfaz de red consiste en 6  números hexadecimales de dos dígitos separados por dos puntos.
Por ejemplo: '01:32:54:67:89:AB'.
Escriba una expresión regular que verifique si una cadena es una Dirección MAC.
Uso:

      
        
        
          let regexp = /your regexp/;

alert( regexp.test('01:32:54:67:89:AB') ); // true

alert( regexp.test('0132546789AB') ); // false (sin dos puntos)

alert( regexp.test('01:32:54:67:89') ); // false (5 números, necesita 6)

alert( regexp.test('01:32:54:67:89:ZZ') ) // false (ZZ al final)
        
      
      
      soluciónUn número hexadecimal de dos dígitos es [0-9a-f]{2} (suponiendo que se ha establecido el indicador i).
Necesitamos ese número NN, y luego :NN repetido 5 veces (más números);
La expresión regular es: [0-9a-f]{2}(:[0-9a-f]{2}){5}
Ahora demostremos que la coincidencia debe capturar todo el texto: comience por el principio y termine por el final. Eso se hace envolviendo el patrón en ^...$.
Finalmente:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /^[0-9a-f]{2}(:[0-9a-f]{2}){5}$/i;

alert( regexp.test('01:32:54:67:89:AB') ); // true

alert( regexp.test('0132546789AB') ); // false (sin dos puntos)

alert( regexp.test('01:32:54:67:89') ); // false (5 números, necesita 6)

alert( regexp.test('01:32:54:67:89:ZZ') ) // false (ZZ al final)
        
      
      
      Encuentra el color en el formato #abc o #abcdefEscriba una expresión regular que haga coincidir los colores en el formato #abc o #abcdef. Esto es: # seguido por 3 o 6 dígitos hexadecimales.
Ejemplo del uso:

      
        
        
          let regexp = /your regexp/g;

let str = "color: #3f3; background-color: #AA00ef; and: #abcd";

alert( str.match(regexp) ); // #3f3 #AA00ef
        
      
      
      P.D. Esto debe ser exactamente 3 o 6 dígitos hexadecimales. Valores con 4 dígitos, tales como #abcd, no deben coincidir.
soluciónUna expresión regular para buscar colores de 3 dígitos #abc: /#[a-f0-9]{3}/i.
Podemos agregar exactamente 3 dígitos hexadecimales opcionales más. No necesitamos más ni menos. El color tiene 3 o 6 dígitos.
Utilicemos el cuantificador {1,2} para esto: llegaremos a /#([a-f0-9]{3}){1,2}/i.
Aquí el patrón [a-f0-9]{3} está rodeado en paréntesis para aplicar el cuantificador {1,2}.
En acción:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /#([a-f0-9]{3}){1,2}/gi;

let str = "color: #3f3; background-color: #AA00ef; and: #abcd";

alert( str.match(regexp) ); // #3f3 #AA00ef #abc
        
      
      
      Hay un pequeño problema aquí: el patrón encontrado #abc en #abcd. Para prevenir esto podemos agregar \b al final:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /#([a-f0-9]{3}){1,2}\b/gi;

let str = "color: #3f3; background-color: #AA00ef; and: #abcd";

alert( str.match(regexp) ); // #3f3 #AA00ef
        
      
      
      Encuentre todos los númerosEscribe una expresión regular que busque todos los números decimales, incluidos los enteros, con el punto flotante y los negativos.
Un ejemplo de uso:

      
        
        
          let regexp = /your regexp/g;

let str = "-1.5 0 2 -123.4.";

alert( str.match(regexp) ); // -1.5, 0, 2, -123.4
        
      
      
      soluciónUn número positivo con una parte decimal opcional es: \d+(\.\d+)?.
Agreguemos el opcional al comienzo -:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /-?\d+(\.\d+)?/g;

let str = "-1.5 0 2 -123.4.";

alert( str.match(regexp) );   // -1.5, 0, 2, -123.4
        
      
      
      Analizar una expresión:Una expresión aritmética consta de 2 números y un operador entre ellos, por ejemplo:

1 + 2
1.2 * 3.4
-3 / -6
-2 - 2

El operador es uno de estos: "+", "-", "*" o "/".
Puede haber espacios adicionales al principio, al final o entre las partes.
Crea una función parse(expr) que tome una expresión y devuelva un array de 3 ítems:

El primer número.
El operador.
El segundo número.

Por ejemplo:

      
        
        
          let [a, op, b] = parse("1.2 * 3.4");

alert(a); // 1.2
alert(op); // *
alert(b); // 3.4
        
      
      
      soluciónUna expresión regular para un número es: -?\d+(\.\d+)?. La creamos en tareas anteriores.
Un operador es [-+*/]. El guión - va primero dentro de los corchetes porque colocado en el medio significaría un rango de caracteres, cuando nosotros queremos solamente un carácter -.
La barra inclinada / debe ser escapada dentro de una expresión regular de JavaScript /.../, eso lo haremos más tarde.
Necesitamos un número, un operador y luego otro número. Y espacios opcionales entre ellos.
La expresión regular completa: -?\d+(\.\d+)?\s*[-+*/]\s*-?\d+(\.\d+)?.
Tiene 3 partes, con \s* en medio de ellas:

-?\d+(\.\d+)? – el primer número,
[-+*/] – el operador,
-?\d+(\.\d+)? – el segundo número.

Para hacer que cada una de estas partes sea un elemento separado del array de resultados, encerrémoslas entre paréntesis: (-?\d+(\.\d+)?)\s*([-+*/])\s*(-?\d+(\.\d+)?).
En acción:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /(-?\d+(\.\d+)?)\s*([-+*\/])\s*(-?\d+(\.\d+)?)/;

alert( "1.2 + 12".match(regexp) );
        
      
      
      El resultado incluye:

result[0] == "1.2 + 12" (coincidencia completa)
result[1] == "1.2" (primer grupo (-?\d+(\.\d+)?) – el primer número, incluyendo la parte decimal)
result[2] == ".2" (segundo grupo (\.\d+)? – la primera parte decimal)
result[3] == "+" (tercer grupo ([-+*\/]) – el operador)
result[4] == "12" (cuarto grupo (-?\d+(\.\d+)?) – el segundo número)
result[5] == undefined (quinto grupo (\.\d+)? – la última parte decimal no está presente, por lo tanto es indefinida)

Solo queremos los números y el operador, sin la coincidencia completa o las partes decimales, así que “limpiemos” un poco el resultado.
La coincidencia completa (el primer elemento del array) se puede eliminar cambiando el array result.shift().
Los grupos que contengan partes decimales (número 2 y 4) (.\d+) pueden ser excluídos al agregar  ?: al comienzo: (?:\.\d+)?.
La solución final:

      
        
        
          
            
          
          
            
          
        
        
          function parse(expr) {
  let regexp = /(-?\d+(?:\.\d+)?)\s*([-+*\/])\s*(-?\d+(?:\.\d+)?)/;

  let result = expr.match(regexp);

  if (!result) return [];
  result.shift();

  return result;
}

alert( parse("-1.23 * 3.45") );  // -1.23, *, 3.45
        
      
      
      ",
	"url": "https://es.javascript.info/regexp-groups" 
},
{
	"docs_id": "173",
	"name": "Referencias inversas en patrones: \N y \k<nombre>",
	"description": "Podemos utilizar el contenido de los grupos de captura (...) no solo en el resultado o en la cadena de reemplazo, sino también en el patrón en sí.",
	"content": "Podemos utilizar el contenido de los grupos de captura (...) no solo en el resultado o en la cadena de reemplazo, sino también en el patrón en sí.
Referencia inversa por número: \NSe puede hacer referencia a un grupo en el patrón usando \N, donde N es el número de grupo.
Para aclarar por qué es útil, consideremos una tarea.
Necesitamos encontrar una cadena entre comillas: con cualquiera de los dos tipos, comillas simples '...' o comillas dobles "..." – ambas variantes deben coincidir.
¿Cómo encontrarlas?
Ambos tipos de comillas se pueden poner entre corchetes: ['"](.*?)['"], pero encontrará cadenas con comillas mixtas, como "...' y '...". Eso conduciría a coincidencias incorrectas cuando una cita aparece dentro de otra., como en la cadena "She's the one!" (en este ejemplo los strings no se traducen por el uso de la comilla simple):

      
        
        
          
            
          
          
            
          
        
        
          let str = `He said: "She's the one!".`;

let regexp = /['"](.*?)['"]/g;

// El resultado no es el que nos gustaría tener
alert( str.match(regexp) ); // "She'
        
      
      
      Como podemos ver, el patrón encontró una cita abierta ", luego se consume el texto hasta encontrar la siguiente comilla ', esta cierra la coincidencia.
Para asegurar que el patrón busque la comilla de cierre exactamente igual que la de apertura, se pone dentro de un grupo de captura y se hace referencia inversa al 1ero: (['"])(.*?)\1.
Aquí está el código correcto:

      
        
        
          
            
          
          
            
          
        
        
          let str = `He said: "She's the one!".`;

let regexp = /(['"])(.*?)\1/g;

alert( str.match(regexp) ); // "She's the one!"
        
      
      
      ¡Ahora funciona! El motor de expresiones regulares encuentra la primera comilla (['"]) y memoriza su contenido. Este es el primer grupo de captura.
Continuando en el patrón, \1 significa “encuentra el mismo texto que en el primer grupo”, en nuestro caso exactamente la misma comilla.
Similar a esto, \2 debería significar: el contenido del segundo grupo, \3 – del tercer grupo, y así sucesivamente.

            Por favor tome nota:
            Si usamos ?: en el grupo, entonces no lo podremos referenciar. Los grupos que se excluyen de las capturas (?:...) no son memorizados por el motor.


            No confundas: el patrón \1, con el reemplazo: $1
            En el reemplazo de cadenas usamos el signo dólar: $1, mientras que en el patrón – una barra invertida \1.

Referencia inversa por nombre: \k<nombre>Si una regexp tiene muchos paréntesis, es conveniente asignarle nombres.
Para referenciar un grupo con nombre usamos \k<nombre>.
En el siguiente ejemplo, el grupo con comillas se llama ?<quote>, entonces la referencia inversa es \k<quote>:

      
        
        
          
            
          
          
            
          
        
        
          let str = `He said: "She's the one!".`;

let regexp = /(?<quote>['"])(.*?)\k<quote>/g;

alert( str.match(regexp) ); // "She's the one!"
        
      
      
      ",
	"url": "https://es.javascript.info/regexp-backreferences" 
},
{
	"docs_id": "174",
	"name": "Alternancia (O) |",
	"description": "Alternancia es un término en expresión regular que simplemente significa “O”.",
	"content": "Alternancia es un término en expresión regular que simplemente significa “O”.
En una expresión regular se denota con un carácter de línea vertical |.
Por ejemplo, necesitamos encontrar lenguajes de programación: HTML, PHP, Java o JavaScript.
La expresión regular correspondiente es: html|php|java(script)?.
Un ejemplo de uso:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /html|php|css|java(script)?/gi;

let str = "Primera aparición de HTML, luego CSS, luego JavaScript";

alert( str.match(regexp) ); // 'HTML', 'CSS', 'JavaScript'
        
      
      
      Ya vimos algo similar: corchetes. Permiten elegir entre varios caracteres, por ejemplo gr[ae]y coincide con gray o grey.
Los corchetes solo permiten caracteres o conjuntos de caracteres. La alternancia permite cualquier expresión. Una expresión regular A|B|C significa una de las expresiones A, B o C.
Por ejemplo:

gr(a|e)y significa exactamente lo mismo que gr[ae]y.
gra|ey significa gra o ey.

Para aplicar la alternancia a una parte elegida del patrón, podemos encerrarla entre paréntesis:

I love HTML|CSS coincide con I love HTML o CSS.
I love (HTML|CSS) coincide con I love HTML o I love CSS.

Ejemplo: Expresión regular para el tiempoEn artículos anteriores había una tarea para construir una expresión regular para buscar un horario en la forma hh:mm, por ejemplo 12:00. Pero esta simple expresión \d\d:\d\d es muy vaga. Acepta 25:99 como tiempo (ya que 99 segundos coinciden con el patrón, pero ese tiempo no es válido).
¿Cómo podemos hacer un mejor patrón?
Podemos utilizar una combinación más cuidadosa. Primero, las horas:

Si el primer dígito es 0 o 1, entonces el siguiente dígito puede ser cualquiera: [01]\d.
De otra manera, si el primer dígito es 2, entonces el siguiente debe ser [0-3].
(no se permite ningún otro dígito)

Podemos escribir ambas variantes en una expresión regular usando alternancia: [01]\d|2[0-3].
A continuación, los minutos deben estar comprendidos entre 00 y 59. En el lenguaje de expresiones regulares se puede escribir como [0-5]\d: el primer dígito 0-5, y luego cualquier otro.
Si pegamos minutos y segundos juntos, obtenemos el patrón: [01]\d|2[0-3]:[0-5]\d.
Ya casi terminamos, pero hay un problema. La alternancia | ahora pasa a estar entre [01]\d y 2[0-3]:[0-5]\d.
Es decir: se agregan minutos a la segunda variante de alternancia, aquí hay una imagen clara:

      
        
        
          [01]\d  |  2[0-3]:[0-5]\d
        
      
      
      Este patrón busca [01]\d o 2[0-3]:[0-5]\d.
Pero eso es incorrecto, la alternancia solo debe usarse en la parte “horas” de la expresión regular, para permitir [01]\d O 2[0-3]. Corregiremos eso encerrando las “horas” entre paréntesis: ([01]\d|2[0-3]):[0-5]\d.
La solución final sería:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /([01]\d|2[0-3]):[0-5]\d/g;

alert("00:00 10:10 23:59 25:99 1:2".match(regexp)); // 00:00,10:10,23:59
        
      
      
      TareasEncuentra lenguajes de programaciónHay muchos lenguajes de programación, por ejemplo, Java, JavaScript, PHP, C, C ++.
Crea una expresión regular que los encuentre en la cadena Java JavaScript PHP C++ C:

      
        
        
          let regexp = /your regexp/g;

alert("Java JavaScript PHP C++ C".match(regexp)); // Java JavaScript PHP C++ C
        
      
      
      soluciónLa primera idea puede ser listar los idiomas con | en el medio.
Pero eso no funciona bien:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /Java|JavaScript|PHP|C|C\+\+/g;

let str = "Java, JavaScript, PHP, C, C++";

alert( str.match(regexp) ); // Java,Java,PHP,C,C
        
      
      
      El motor de expresiones regulares busca las alternancias una por una. Es decir: primero verifica si tenemos  Java, de lo contrario – busca  JavaScript y así sucesivamente.
Como resultado, nunca se puede encontrar  JavaScript, simplemente porque encuentra primero  Java.
Lo mismo con  C y  C++.
Hay dos soluciones para ese problema:

Cambiar el orden para comprobar primero la coincidencia más larga: JavaScript|Java|C\+\+|C|PHP.
Fusionar variantes con el mismo inicio: Java(Script)?|C(\+\+)?|PHP.

En acción:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /Java(Script)?|C(\+\+)?|PHP/g;

let str = "Java, JavaScript, PHP, C, C++";

alert( str.match(regexp) ); // Java,JavaScript,PHP,C,C++
        
      
      
      Encuentra la pareja bbtagUn “bb-tag” se ve como [tag]...[/tag], donde tag es uno de: b, url o quote.
Por ejemplo:

      
        
        
          [b]text[/b]
[url]http://google.com[/url]
        
      
      
      BB-tags se puede anidar. Pero una etiqueta no se puede anidar en sí misma, por ejemplo:

      
        
        
          Normal:
[url] [b]http://google.com[/b] [/url]
[quote] [b]text[/b] [/quote]

No puede suceder:
[b][b]text[/b][/b]
        
      
      
      Las etiquetas pueden contener saltos de línea, eso es normal:

      
        
        
          [quote]
  [b]text[/b]
[/quote]
        
      
      
      Cree una expresión regular para encontrar todas las BB-tags con su contenido.
Por ejemplo:

      
        
        
          let regexp = /your regexp/flags;

let str = "..[url]http://google.com[/url]..";
alert( str.match(regexp) ); // [url]http://google.com[/url]
        
      
      
      Si las etiquetas están anidadas, entonces necesitamos la etiqueta externa (si queremos podemos continuar la búsqueda en su contenido):

      
        
        
          let regexp = /your regexp/flags;

let str = "..[url][b]http://google.com[/b][/url]..";
alert( str.match(regexp) ); // [url][b]http://google.com[/b][/url]
        
      
      
      soluciónLa etiqueta de apertura es \[(b|url|quote)].
Luego, para encontrar todo hasta la etiqueta de cierre, usemos el patrón.*? con la bandera s para que coincida con cualquier carácter, incluida la nueva línea, y luego agreguemos una referencia inversa a la etiqueta de cierre.
El patrón completo: \[(b|url|quote)\].*?\[/\1].
En acción:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /\[(b|url|quote)].*?\[\/\1]/gs;

let str = `
  [b]hello![/b]
  [quote]
    [url]http://google.com[/url]
  [/quote]
`;

alert( str.match(regexp) ); // [b]hello![/b],[quote][url]http://google.com[/url][/quote]
        
      
      
      Tenga en cuenta que además de escapar [ tuvimos que escapar de una barra para la etiqueta de cierre [\/\1], porque normalmente la barra cierra el patrón.
Encuentra cadenas entre comillasCrea una expresión regular para encontrar cadenas entre comillas dobles "...".
Las cadenas deben admitir el escape, de la misma manera que lo hacen las cadenas de JavaScript. Por ejemplo, las comillas se pueden insertar como \" ,una nueva línea como \n, y la doble barra invertida como \\.

      
        
        
          let str = "Just like \"here\".";
        
      
      
      Tenga en cuenta, en particular, que una comilla escapada \" no termina una cadena.
Por lo tanto, deberíamos buscar de una comilla a otra (la de cierre), ignorando las comillas escapadas en el camino.
Esa es la parte esencial de la tarea, de lo contrario sería trivial.
Ejemplos de cadenas para hacer coincidir:

      
        
        
          .. "test me" ..
.. "Say \"Hello\"!" ... (comillas escapadas dentro)
.. "\\" ..  (doble barra invertida dentro)
.. "\\ \"" ..  (doble barra y comilla escapada dentro.)
        
      
      
      En JavaScript, necesitamos duplicar las barras para pasarlas directamente a la cadena, así:

      
        
        
          
            
          
          
            
          
        
        
          let str = ' .. "test me" .. "Say \\"Hello\\"!" .. "\\\\ \\"" .. ';

// the in-memory string
alert(str); //  .. "test me" .. "Say \"Hello\"!" .. "\\ \"" ..
        
      
      
      soluciónLa solución: /"(\\.|[^"\\])*"/g.
El paso a paso:

Primero buscamos una comilla de apertura "
Luego, si tenemos una barra invertida \\ (tenemos que duplicarla en el patrón porque es un carácter especial). Luego, cualquier carácter está bien después de él (un punto).
De lo contrario, tomamos cualquier carácter excepto una comilla (que significaría el final de la cadena) y una barra invertida (para evitar barras invertidas solitarias, la barra invertida solo se usa con algún otro símbolo después): [^"\\]
…Y así sucesivamente hasta la comilla de cierre.

En acción:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /"(\\.|[^"\\])*"/g;
let str = ' .. "test me" .. "Say \\"Hello\\"!" .. "\\\\ \\"" .. ';

alert( str.match(regexp) ); // "test me","Say \"Hello\"!","\\ \""
        
      
      
      Encuentra la etiqueta completaEscriba una expresión regular para encontrar la etiqueta <style...>. Debe coincidir con la etiqueta completa: puede no tener atributos <style> o tener varios de ellos <style type="..." id="...">.
…¡Pero la expresión regular no debería coincidir con <styler>!
Por ejemplo:

      
        
        
          let regexp = /your regexp/g;

alert( '<style> <styler> <style test="...">'.match(regexp) ); // <style>, <style test="...">
        
      
      
      soluciónEl inicio del patrón es obvio: <style.
…Pero entonces no podemos simplemente escribir <style.*?>, porque <styler> coincidiría.
Necesitamos un espacio después <style y luego, opcionalmente, algo más o el final >.
En el lenguaje de expresión regular: <style(>|\s.*?>).
En acción:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /<style(>|\s.*?>)/g;

alert( '<style> <styler> <style test="...">'.match(regexp) ); // <style>, <style test="...">
        
      
      
      ",
	"url": "https://es.javascript.info/regexp-alternation" 
},
{
	"docs_id": "175",
	"name": "Lookahead y lookbehind (revisar delante/detrás)",
	"description": "A veces necesitamos buscar únicamente aquellas coincidencias donde un patrón es precedido o seguido por otro patrón.",
	"content": "A veces necesitamos buscar únicamente aquellas coincidencias donde un patrón es precedido o seguido por otro patrón.
Existe una sintaxis especial para eso llamadas “lookahead” y “lookbehind” (“ver delante” y “ver detrás”), juntas son conocidas como “lookaround” (“ver alrededor”).
Para empezar, busquemos el precio de la cadena siguiente 1 pavo cuesta 30€. Eso es: un número, seguido por el signo €.
LookaheadLa sintaxis es: X(?=Y). Esto significa "buscar X, pero considerarlo una coincidencia solo si es seguido por Y". Puede haber cualquier patrón en X y Y.
Para un número entero seguido de €, la expresión regular será \d+(?=€):

      
        
        
          
            
          
          
            
          
        
        
          let str = "1 pavo cuesta 30€";

alert( str.match(/\d+(?=€)/) ); // 30, el número 1 es ignorado porque no está seguido de €
        
      
      
      Tenga en cuenta que “lookahead” es solamente una prueba, lo contenido en los paréntesis (?=...) no es incluido en el resultado 30.
Cuando buscamos X(?=Y), el motor de expresión regular encuentra X y luego verifica si existe Y inmediatamente después de él. Si no existe, entonces la coincidencia potencial es omitida y la búsqueda continúa.
Es posible realizar pruebas más complejas, por ejemplo X(?=Y)(?=Z) significa:

Encuentra X.
Verifica si Y está inmediatamente después de X (omite si no es así).
Verifica si Z está también inmediatamente después de X (omite si no es así).
Si ambas verificaciones se cumplen, el X es una coincidencia. De lo contrario continúa buscando.

En otras palabras, dicho patrón significa que estamos buscando por X seguido de Y y Z al mismo tiempo.
Eso es posible solamente si los patrones Y y Z no se excluyen mutuamente.
Por ejemplo, \d+(?=\s)(?=.*30) busca un \d+ que sea seguido por un espacio (?=\s) y que también tenga un 30 en algún lugar después de él (?=.*30):

      
        
        
          
            
          
          
            
          
        
        
          let str = "1 pavo cuesta 30€";

alert( str.match(/\d+(?=\s)(?=.*30)/) ); // 1
        
      
      
      En nuestra cadena eso coincide exactamente con el número 1.
Lookahead negativoDigamos que queremos una cantidad, no un precio de la misma cadena. Eso es el número \d+ NO seguido por €.
Para eso se puede aplicar un “lookahead negativo”.
La sintaxis es: X(?!Y), que significa "busca X, pero solo si no es seguido por Y".

      
        
        
          
            
          
          
            
          
        
        
          let str = "2 pavos cuestan 60€";

alert( str.match(/\d+\b(?!€)/g) ); // 2 (el precio es omitido)
        
      
      
      Lookbehind
            Compatibilidad de navegadores en lookbehind
            Ten en cuenta: Lookbehind no está soportado en navegadores que no utilizan V8, como Safari, Internet Explorer.

“lookahead” permite agregar una condición para “lo que sigue”.
“Lookbehind” es similar. Permite coincidir un patrón solo si hay algo anterior a él.
La sintaxis es:

Lookbehind positivo: (?<=Y)X, coincide X, pero solo si hay Y antes de él.
Lookbehind negativo: (?<!Y)X, coincide X, pero solo si no hay Y antes de él.

Por ejemplo, cambiemos el precio a dólares estadounidenses. El signo de dólar usualmente va antes del número, entonces para buscar $30 usaremos (?<=\$)\d+: una cantidad precedida por $:

      
        
        
          
            
          
          
            
          
        
        
          let str = "1 pavo cuesta $30";

// el signo de dólar se ha escapado \$
alert( str.match(/(?<=\$)\d+/) ); // 30 (omite los números aislados)
        
      
      
      Y si necesitamos la cantidad (un número no precedida por $), podemos usar “lookbehind negativo” (?<!\$)\d+:

      
        
        
          
            
          
          
            
          
        
        
          let str = "2 pavos cuestan $60";

alert( str.match(/(?<!\$)\b\d+/g) ); // 2 (el precio es omitido)
        
      
      
      Atrapando gruposGeneralmente, los contenidos dentro de los paréntesis de “lookaround” (ver alrededor) no se convierten en parte del resultado.
Ejemplo en el patrón \d+(?=€), el signo €  no es capturado como parte de la coincidencia. Eso es esperado: buscamos un número \d+, mientras (?=€) es solo una prueba que indica que debe ser seguida por €.
Pero en algunas situaciones nosotros podríamos querer capturar también la expresión en “lookaround”, o parte de ella. Eso es posible: solo hay que rodear esa parte con paréntesis adicionales.
En los ejemplos de abajo el signo de divisa (€|kr) es capturado junto con la cantidad:

      
        
        
          
            
          
          
            
          
        
        
          let str = "1 pavo cuesta 30€";
let regexp = /\d+(?=(€|kr))/; // paréntesis extra alrededor de €|kr

alert( str.match(regexp) ); // 30, €
        
      
      
      Lo mismo para “lookbehind”:

      
        
        
          
            
          
          
            
          
        
        
          let str = "1 pavo cuesta $30";
let regexp = /(?<=(\$|£))\d+/;

alert( str.match(regexp) ); // 30, $
        
      
      
      ResumenLookahead y lookbehind (en conjunto conocidos como “lookaround”) son útiles cuando queremos hacer coincidir algo dependiendo del contexto antes/después.
Para expresiones regulares simples podemos hacer lo mismo manualmente. Esto es: coincidir todo, en cualquier contexto, y luego filtrar por contexto en el bucle.
Recuerda, str.match (sin el indicador g) y str.matchAll (siempre) devuelven las coincidencias como un array con la propiedad index, así que sabemos exactamente dónde están dentro del texto y podemos comprobar su contexto.
Pero generalmente “lookaround” es más conveniente.
Tipos de “lookaround”:



Patrón
Tipo
Coincidencias




X(?=Y)
lookahead positivo
X si está seguido por Y


X(?!Y)
lookahead negativo
X si no está seguido por Y


(?<=Y)X
lookbehind positivo
X si está después de Y


(?<!Y)X
lookbehind negativo
X si no está después de Y



TareasEncontrar enteros no negativosTenemos un string de números enteros.
Crea una expresión regular que encuentre solamente los no negativos (el cero está permitido).
Un ejemplo de uso:

      
        
        
          let regexp = /tu regexp/g;

let str = "0 12 -5 123 -18";

alert( str.match(regexp) ); // 0, 12, 123
        
      
      
      soluciónLa expresión regular para un número entero es \d+.
Podemos excluir los negativos anteponiendo un “lookbehind negativo”: (?<!-)\d+.
Pero al probarlo, notamos un resultado de más:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /(?<!-)\d+/g;

let str = "0 12 -5 123 -18";

console.log( str.match(regexp) ); // 0, 12, 123, 8
        
      
      
      Como puedes ver, hay coincidencia de 8, con -18. Para excluirla necesitamos asegurarnos de que regexp no comience la búsqueda desde el medio de otro número (no coincidente).
Podemos hacerlo especificando otra precedencia “lookbehind negativo”: (?<!-)(?<!\d)\d+. Ahora (?<!\d) asegura que la coicidencia no comienza después de otro dígito, justo lo que necesitamos.
También podemos unirlos en un único “lookbehind”:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /(?<![-\d])\d+/g;

let str = "0 12 -5 123 -18";

alert( str.match(regexp) ); // 0, 12, 123
        
      
      
      Insertar después de la cabeceraTenemos un string con un documento HTML.
Escribe una expresión regular que inserte <h1>Hello</h1> inmediatamente después de la etiqueta <body>. La etiqueta puede tener atributos.
Por ejemplo:

      
        
        
          let regexp = /tu expresión regular/;

let str = `
<html>
  <body style="height: 200px">
  ...
  </body>
</html>
`;

str = str.replace(regexp, `<h1>Hello</h1>`);
        
      
      
      Después de esto el valor de str debe ser:

      
        
        
          <html>
  <body style="height: 200px"><h1>Hello</h1>
  ...
  </body>
</html>
        
      
      
      soluciónPara insertar algo después de la etiqueta <body>, primero debemos encontrarla. Para ello  podemos usar la expresión regular <body.*?>.
En esta tarea no necesitamos modificar la etiqueta <body>. Solamente agregar texto después de ella.
Veamos cómo podemos hacerlo:

      
        
        
          
            
          
          
            
          
        
        
          let str = '...<body style="...">...';
str = str.replace(/<body.*?>/, '$&<h1>Hello</h1>');

alert(str); // ...<body style="..."><h1>Hello</h1>...
        
      
      
      En el string de reemplazo, $& significa la coincidencia misma, la parte del texto original que corresponde a <body.*?>. Es reemplazada por sí misma más <h1>Hello</h1>.
Una alternativa es el uso de “lookbehind”:

      
        
        
          
            
          
          
            
          
        
        
          let str = '...<body style="...">...';
str = str.replace(/(?<=<body.*?>)/, `<h1>Hello</h1>`);

alert(str); // ...<body style="..."><h1>Hello</h1>...
        
      
      
      Como puedes ver, solo está presente la parte “lookbehind” en esta expresión regular.
Esto funciona así:

En cada posición en el texto:
Verifica si está precedida por <body.*?>.
Si es así, tenemos una coincidencia.

La etiqueta <body.*?> no será devuelta. El resultado de esta expresión regular es un string vacío, pero coincide solo en las posiciones precedidas por <body.*?>.
Entonces reemplaza la “linea vacía”, precedida por <body.*?>, con <h1>Hello</h1>. Esto es, la inserción después de <body>.
P.S. Los indicadores de Regexp tales como s y i también nos pueden ser útiles: /<body.*?>/si. El indicador s hace que que el punto . coincida también con el carácter de salto de línea, y el indicador i hace que <body> también acepte coincidencias <BODY> en mayúsculas y minúsculas.
",
	"url": "https://es.javascript.info/regexp-lookahead-lookbehind" 
},
{
	"docs_id": "176",
	"name": "Backtracking catastrófico",
	"description": "Algunas expresiones regulares parecen simples pero pueden ejecutarse durante demasiado tiempo e incluso “colgar” el motor de JavaScript.",
	"content": "Algunas expresiones regulares parecen simples pero pueden ejecutarse durante demasiado tiempo e incluso “colgar” el motor de JavaScript.
Tarde o temprano la mayoría de los desarrolladores se enfrentan ocasionalmente a este comportamiento. El síntoma típico: una expresión regular funciona bien a veces, pero para ciertas cadenas se “cuelga” consumiendo el 100% de la CPU.
En este caso el navegador sugiere matar el script y recargar la página. No es algo bueno, sin duda.
Para el lado del servidor de JavaScript tal regexp puede colgar el proceso del servidor, que es aún peor. Así que definitivamente deberíamos echarle un vistazo.
EjemploSupongamos que tenemos una cadena y queremos comprobar si está formada por palabras \w+ con un espacio opcional \s? después de cada una.
Una forma obvia de construir una regexp sería tomar una palabra seguida de un espacio opcional \w+\s? y luego repetirla con *.
Esto nos lleva a la regexp ^(\w+\s?)*$ que especifica cero o más palabras de este tipo, que comienzan al principio ^ y terminan al final $ de la línea.
En la práctica:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /^(\w+\s?)*$/;

alert( regexp.test("A good string") ); // true
alert( regexp.test("Bad characters: $@#") ); // false
        
      
      
      La regexp parece funcionar. El resultado es correcto. Aunque en ciertas cadenas tarda mucho tiempo. Tanto tiempo que el motor de JavaScript se “cuelga” con un consumo del 100% de la CPU.
Si ejecuta el ejemplo de abajo probablemente no se verá nada ya que JavaScript simplemente se “colgará”. El navegador dejará de reaccionar a los eventos, la interfaz de usuario dejará de funcionar (la mayoría de los navegadores sólo permiten el desplazamiento). Después de algún tiempo se sugerirá recargar la página. Así que ten cuidado con esto:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /^(\w+\s?)*$/;
let str = "An input string that takes a long time or even makes this regexp hang!";

// tardará mucho tiempo
alert( regexp.test(str) );
        
      
      
      Para ser justos observemos que algunos motores de expresión regular pueden manejar este tipo de búsqueda con eficacia, por ejemplo, la versión del motor V8 a partir de la 8.8 puede hacerlo (por lo que Google Chrome 88 no se cuelga aquí) mientras que el navegador Firefox sí se cuelga.
Ejemplo simplificado¿Qué ocurre? ¿Por qué se cuelga la expresión regular?
Para entenderlo simplifiquemos el ejemplo: elimine los espacios \s?. Entonces se convierte en ^(\w+)*$.
Y, para hacer las cosas más obvias sustituyamos \w por \d. La expresión regular resultante sigue colgando, por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /^(\d+)*$/;

let str = "012345678901234567890123456789z";

// tardará mucho tiempo (¡cuidado!)
alert( regexp.test(str) );
        
      
      
      ¿Qué ocurre con la regexp?
En primer lugar uno puede notar que la regexp (\d+)* es un poco extraña. El cuantificador * parece extraño. Si queremos un número podemos utilizar \d+.
Efectivamente la regexp es artificial; la hemos obtenido simplificando el ejemplo anterior. Pero la razón por la que es lenta es la misma. Así que vamos a entenderlo y entonces el ejemplo anterior se hará evidente.
¿Qué sucede durante la búsqueda de ^(\d+)*$ en la línea 123456789z (acortada un poco para mayor claridad, por favor tenga en cuenta un carácter no numérico z al final, es importante) que tarda tanto?
Esto es lo que hace el motor regexp:


En primer lugar el motor regexp intenta encontrar el contenido de los paréntesis: el número d+. El + es codicioso por defecto, por lo que consume todos los dígitos:

      
        
        
          \d+.......
(123456789)z
        
      
      
      Una vez consumidos todos los dígitos se considera que se ha encontrado el d+ (como 123456789).
Entonces se aplica el cuantificador de asterisco (\d+)*. Pero no hay más dígitos en el texto, así que el asterisco no da nada.
El siguiente carácter del patrón es el final de la cadena $. Pero en el texto tenemos z en su lugar, por lo que no hay coincidencia:

      
        
        
                     X
\d+........$
(123456789)z
        
      
      
      

Como no hay ninguna coincidencia, el cuantificador codicioso + disminuye el recuento de repeticiones, retrocede un carácter.
Ahora \d+ toma todos los dígitos excepto el último (12345678):

      
        
        
          \d+.......
(12345678)9z
        
      
      
      

Entonces el motor intenta continuar la búsqueda desde la siguiente posición (justo después de 12345678).
Se puede aplicar el asterisco patrón:(\d+)* : da una coincidencia más de patrón:\d+, el número 9:

      
        
        
          \d+.......\d+
(12345678)(9)z
        
      
      
      El motor intenta coincidir con $ de nuevo, pero falla, porque encuentra z en su lugar:

      
        
        
                       X
\d+.......\d+
(12345678)(9)z
        
      
      
      

No hay coincidencia así que el motor continuará con el retroceso disminuyendo el número de repeticiones. El retroceso generalmente funciona así: el último cuantificador codicioso disminuye el número de repeticiones hasta llegar al mínimo. Entonces el cuantificador codicioso anterior disminuye, y así sucesivamente.
Se intentan todas las combinaciones posibles. Estos son sus ejemplos.
El primer número \d+ tiene 7 dígitos y luego un número de 2 dígitos:

      
        
        
                       X
\d+......\d+
(1234567)(89)z
        
      
      
      El primer número tiene 7 dígitos y luego dos números de 1 dígito cada uno:

      
        
        
                         X
\d+......\d+\d+
(1234567)(8)(9)z
        
      
      
      El primer número tiene 6 dígitos y luego un número de 3 dígitos:

      
        
        
                       X
\d+.......\d+
(123456)(789)z
        
      
      
      El primer número tiene 6 dígitos, y luego 2 números:

      
        
        
                         X
\d+.....\d+ \d+
(123456)(78)(9)z
        
      
      
      …Y así sucesivamente.


Hay muchas formas de dividir una secuencia de dígitos 123456789 en números. Para ser precisos, hay 2n-1, donde n es la longitud de la secuencia.

Para 123456789 tenemos n=9, lo que da 511 combinaciones.
Para una secuencia más larga con “n=20” hay alrededor de un millón (1048575) de combinaciones.
Para n=30 – mil veces más (1073741823 combinaciones).

Probar cada una de ellas es precisamente la razón por la que la búsqueda lleva tanto tiempo.
Volver a las palabras y cadenasLo mismo ocurre en nuestro primer ejemplo, cuando buscamos palabras por el patrón ^(\w+\s?)*$ en la cadena An input that hangs!.
La razón es que una palabra puede representarse como un \w+ o muchos:

      
        
        
          (input)
(inpu)(t)
(inp)(u)(t)
(in)(p)(ut)
...
        
      
      
      Para un humano es obvio que puede no haber coincidencia porque la cadena termina con un signo de exclamación ! pero la expresión regular espera un carácter denominativo \w o un espacio \s al final. Pero el motor no lo sabe.
El motor prueba todas las combinaciones de cómo la regexp (\w+\s?)* puede “consumir” la cadena, incluyendo las variantes con espacios (\w+\s)* y sin ellos (\w+)* (porque los espacios \s? son opcionales). Como hay muchas combinaciones de este tipo (lo hemos visto con dígitos), la búsqueda lleva muchísimo tiempo.
¿Qué hacer?
¿Debemos activar el lazy mode?
Desgraciadamente eso no ayudará: si sustituimos \w+ por \w+? la regexp seguirá colgada. El orden de las combinaciones cambiará, pero no su número total.
Algunos motores de expresiones regulares hacen análisis complicados y automatizaciones finitas que permiten evitar pasar por todas las combinaciones o hacerlo mucho más rápido, pero la mayoría de los motores no lo hacen. Además, eso no siempre ayuda.
¿Cómo solucionarlo?Hay dos enfoques principales para solucionar el problema.
El primero es reducir el número de combinaciones posibles.
Hagamos que el espacio no sea opcional reescribiendo la expresión regular como ^(\w+\s)*\w*$ buscaremos cualquier número de palabras seguidas de un espacio (\w+\s)*, y luego (opcionalmente) una palabra final \w*.
Esta regexp es equivalente a la anterior (coincide con lo mismo) y funciona bien:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /^(\w+\s)*\w*$/;
let str = "An input string that takes a long time or even makes this regex hang!";

alert( regexp.test(str) ); // false
        
      
      
      ¿Por qué ha desaparecido el problema?
Porque ahora el espacio es obligatorio.
La regexp anterior, si omitimos el espacio, se convierte en (\w+)*, dando lugar a muchas combinaciones de \w+ dentro de una misma palabra
Así, input podría coincidir con dos repeticiones de \w+ así:

      
        
        
          \w+  \w+
(inp)(ut)
        
      
      
      El nuevo patrón es diferente: (\w+\s)* especifica repeticiones de palabras seguidas de un espacio. La cadena input no puede coincidir con dos repeticiones de \w+\s, porque el espacio es obligatorio.
Ahora se ahorra el tiempo necesario para probar un montón de combinaciones (en realidad la mayoría).
Previniendo el backtrackingSin embargo no siempre es conveniente reescribir una regexp. En el ejemplo anterior era fácil pero no siempre es obvio cómo hacerlo.
Además una regexp reescrita suele ser más compleja y eso no es bueno. Las regexps son suficientemente complejas sin necesidad de esfuerzos adicionales.
Por suerte hay un enfoque alternativo. Podemos prohibir el retroceso para el cuantificador.
La raíz del problema es que el motor de regexp intenta muchas combinaciones que son obviamente erróneas para un humano.
Por ejemplo, en la regexp (\d+)*$ es obvio para un humano que patrón:+ no debería retroceder. Si sustituimos un patrón:\d+ por dos \d+\d+ separados nada cambia:

      
        
        
          \d+........
(123456789)!

\d+...\d+....
(1234)(56789)!
        
      
      
      Y en el ejemplo original ^(\w+\s?)*$ podemos querer prohibir el backtracking en \w+. Es decir: \w+ debe coincidir con una palabra entera, con la máxima longitud posible. No es necesario reducir el número de repeticiones en \w+ o dividirlo en dos palabras \w+\w+ y así sucesivamente.
Los motores de expresiones regulares modernos admiten cuantificadores posesivos para ello. Los cuantificadores regulares se convierten en posesivos si añadimos + después de ellos. Es decir, usamos \d++ en lugar de \d+ para evitar que + retroceda.
Los cuantificadores posesivos son de hecho más simples que los “regulares”. Simplemente coinciden con todos los que pueden sin ningún tipo de retroceso. El proceso de búsqueda sin retroceso es más sencillo.
También existen los llamados “grupos de captura atómicos”, una forma de desactivar el retroceso dentro de los paréntesis.
…Pero la mala noticia es que, por desgracia, en JavaScript no están soportados.
Sin embargo, podemos emularlos utilizando “lookahead transform”.
Lookahead al rescate!Así que hemos llegado a temas realmente avanzados. Nos gustaría que un cuantificador como + no retrocediera porque a veces retroceder no tiene sentido.
El patrón para tomar tantas repeticiones de \w como sea posible sin retroceder es: (?=(\w+))\1. Por supuesto, podríamos tomar otro patrón en lugar de \w.
Puede parecer extraño pero en realidad es una transformación muy sencilla.
Vamos a descifrarla:

Lookahead ?= busca la palabra más larga \w+ a partir de la posición actual.
El contenido de los paréntesis con ?=... no es memorizado por el motor así que envuelva \w+ en paréntesis. Entonces el motor memorizará su contenido
…y nos permitirá hacer referencia a él en el patrón como \1.

Es decir: miramos hacia adelante y si hay una palabra \w+, entonces la emparejamos como \1.
¿Por qué? Porque el lookahead encuentra una palabra \w+ como un todo y la capturamos en el patrón con \1. Así que esencialmente implementamos un cuantificador posesivo más +. Captura sólo la palabra entera patrón:\w+, no una parte de ella.
Por ejemplo, en la palabra JavaScript no sólo puede coincidir con Java sino que deja fuera Script para que coincida con el resto del patrón.
He aquí la comparación de dos patrones:

      
        
        
          
            
          
          
            
          
        
        
          alert( "JavaScript".match(/\w+Script/)); // JavaScript
alert( "JavaScript".match(/(?=(\w+))\1Script/)); // null
        
      
      
      
En la primera variante, \w+ captura primero la palabra completa JavaScript, pero luego + retrocede carácter por carácter, para intentar coincidir con el resto del patrón, hasta que finalmente tiene éxito (cuando \w+ coincide con Java).
En la segunda variante (?=(\w+)) mira hacia adelante y encuentra la palabra JavaScript, que está incluida en el patrón como un todo por \1, por lo que no hay manera de encontrar Script después de ella.

Podemos poner una expresión regular más compleja en (?=(\w+))\1 en lugar de \w, cuando necesitemos prohibir el retroceso para + después de ella.

            Por favor tome nota:
            Hay más (en inglés) acerca de la relación entre los cuantificadores posesivos y lookahead en los artículos Regex: Emulate Atomic Grouping (and Possessive Quantifiers) with LookAhead y Mimicking Atomic Groups.

Reescribamos el primer ejemplo utilizando lookahead para evitar el backtracking:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /^((?=(\w+))\2\s?)*$/;

alert( regexp.test("A good string") ); // true

let str = "An input string that takes a long time or even makes this regex hang!";

alert( regexp.test(str) ); // false, funciona, ¡y rápido!
        
      
      
      Aquí se utiliza \2 en lugar de \1 porque hay paréntesis exteriores adicionales. Para evitar enredarnos con los números, podríamos dar a los paréntesis un nombre, por ejemplo (?<word>\w+).

      
        
        
          
            
          
          
            
          
        
        
          // nombramos a los parentesis ?<word>, y los referenciamos como \k<word>
let regexp = /^((?=(?<word>\w+))\k<word>\s?)*$/;

let str = "An input string that takes a long time or even makes this regex hang!";

alert( regexp.test(str) ); // false

alert( regexp.test("A correct string") ); // true
        
      
      
      El problema descrito en este artículo se llama “backtracking catastrófico”.
Cubrimos dos formas de resolverlo:

Reescribir la regexp para reducir el número de combinaciones posibles.
Evitar el retroceso.

",
	"url": "https://es.javascript.info/regexp-catastrophic-backtracking" 
},
{
	"docs_id": "177",
	"name": "Indicador adhesivo “y”, buscando en una posición.",
	"description": "EL indicador y permite realizar la búsqueda en una posición dada en el string de origen.",
	"content": "EL indicador y permite realizar la búsqueda en una posición dada en el string de origen.
Para entender el caso de uso del indicador y exploremos un ejemplo práctico.
Una tarea común para regexps es el “Análisis léxico”: tomar un texto (como el de un lenguaje de programación), y analizar sus elementos estructurales. Por ejemplo, HTML tiene etiquetas y atributos, el código JavaScript tiene funciones, variables, etc.
Escribir analizadores léxicos es un área especial, con sus propias herramientas y algoritmos, así que no profundizaremos en ello; pero existe una tarea común: leer algo en una posición dada.
Por ej. tenemos una cadena de código let varName = "value", y necesitamos leer el nombre de su variable, que comienza en la posición 4.
Buscaremos el nombre de la variable usando regexp \w+. En realidad, el nombre de la variable de JavaScript necesita un regexp un poco más complejo para un emparejamiento más preciso, pero aquí eso no importa.
Una llamada a str.match(/\w+/) solo encontrará la primera palabra de la línea (let). No es la que queremos.
Podríamos añadir el indicador g, pero al llamar a str.match(/\w+/g) buscará todas las palabras del texto y solo necesitamos una y en la posición 4. De nuevo, no es lo que necesitamos.
Entonces, ¿cómo buscamos exactamente en un posición determinada?
Usemos el método regexp.exec(str).
Para un regexp sin los indicadores g y y, este método busca la primera coincidencia y funciona exactamente igual a str.match(regexp).
…Pero si existe el indicador g, realiza la búsqueda en str empezando desde la posición almacenada en su propiedad regexp.lastIndex. Y si encuentra una coincidencia, establece regexp.lastIndex en el index inmediatamente posterior a la coincidencia.
En otras palabras, regexp.lastIndex funciona como punto de partida para la búsqueda, cada llamada lo reestablece a un nuevo valor: el posterior a la última coincidencia.
Entonces, llamadas sucesivas a regexp.exec(str) devuelve coincidencias una después de la otra.
Un ejemplo (con el indicador g):

      
        
        
          
            
          
          
            
          
        
        
          let str = 'let varName'; // encontremos todas las palabras del string
let regexp = /\w+/g;

alert(regexp.lastIndex); // 0 (inicialmente lastIndex=0)

let word1 = regexp.exec(str);
alert(word1[0]); // let (primera palabra)
alert(regexp.lastIndex); // 3 (Posición posterior a la coincidencia)

let word2 = regexp.exec(str);
alert(word2[0]); // varName (2da palabra)
alert(regexp.lastIndex); // 11 (Posición posterior a la coincidencia)

let word3 = regexp.exec(str);
alert(word3); // null (no más coincidencias)
alert(regexp.lastIndex); // 0 (se reinicia al final de la búsqueda)
        
      
      
      Podemos conseguir todas las coincidencias en el loop:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'let varName';
let regexp = /\w+/g;

let result;

while (result = regexp.exec(str)) {
  alert( `Found ${result[0]} at position ${result.index}` );
  // Found let at position 0, then
  // Found varName at position 4
}
        
      
      
      Tal uso de regexp.exec es una alternativa al método str.match bAll, con más control sobre el proceso.
Volvamos a nuestra tarea.
Podemos establecer manualmente lastIndex a 4, para comenzar la búsqueda desde la posición dada.
Como aquí:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'let varName = "value"';

let regexp = /\w+/g; // Sin el indicador “g”, la propiedad lastindex es ignorada.

regexp.lastIndex = 4;

let word = regexp.exec(str);
alert(word); // varName
        
      
      
      ¡Problema resuelto!
Realizamos una búsqueda de \w+, comenzando desde la posición regexp.lastIndex = 4.
El resultado es correcto.
…Pero espera, no tan rápido.
Nota que la búsqueda comienza en la posición lastIndex y luego sigue adelante. Si no hay ninguna palabra en la posición lastIndex pero la hay en algún lugar posterior, entonces será encontrada:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'let varName = "value"';

let regexp = /\w+/g;

// comenzando desde la posición 3
regexp.lastIndex = 3;

let word = regexp.exec(str);
// encuentra coincidencia en la posición 4
alert(word[0]); // varName
alert(word.index); // 4
        
      
      
      Para algunas tareas, incluido el análisis léxico, esto está mal. Necesitamos la coincidencia en la posición exacta, y para ello es el flag y.
El indicador y hace que regexp.exec busque “exactamente en” la posición lastIndex, no “comenzando en” ella.
Aquí está la misma búsqueda con el indicador y:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'let varName = "value"';

let regexp = /\w+/y;

regexp.lastIndex = 3;
alert( regexp.exec(str) ); // null (Hay un espacio en la posición 3, no una palabra)

regexp.lastIndex = 4;
alert( regexp.exec(str) ); // varName (Una palabra en la posición 4)
        
      
      
      Como podemos ver, el /\w+/y de regexp no coincide en la posición 3 (a diferencia del indicador g), pero coincide en la posición 4.
No solamente es lo que necesitamos, el uso del indicador y mejora el rendimiento.
Imagina que tenemos un texto largo, y no hay coincidencias en él. Entonces la búsqueda con el indicador g irá hasta el final del texto, y esto tomará significativamente más tiempo que la búsqueda con el indicador y.
En tareas tales como el análisis léxico, normalmente hay muchas búsquedas en una posición exacta. Usar el indicador y es la clave para un buen desempeño.
",
	"url": "https://es.javascript.info/regexp-sticky" 
},
{
	"docs_id": "178",
	"name": "Métodos de RegExp y String",
	"description": "En este artículo vamos a abordar varios métodos que funcionan con expresiones regulares a fondo.",
	"content": "En este artículo vamos a abordar varios métodos que funcionan con expresiones regulares a fondo.
str.match(regexp)El método str.match(regexp) encuentra coincidencias para las expresiones regulares (regexp) en la cadena (str).
Tiene 3 modos:


Si la expresión regular (regexp) no tiene la bandera g, retorna un array con los grupos capturados y las propiedades index (posición de la coincidencia), input (cadena de entrada, igual a str):

      
        
        
          
            
          
          
            
          
        
        
          let str = "I love JavaScript";

let result = str.match(/Java(Script)/);

alert( result[0] );     // JavaScript (toda la coincidencia)
alert( result[1] );     // Script (primer grupo capturado)
alert( result.length ); // 2

// Additional information:
alert( result.index );  // 7 (match position)
alert( result.input );  // I love JavaScript (cadena de entrada)
        
      
      
      

Si la expresión regular (regexp) tiene la bandera g, retorna un array de todas las coincidencias como cadenas, sin capturar grupos y otros detalles.

      
        
        
          
            
          
          
            
          
        
        
          let str = "I love JavaScript";

let result = str.match(/Java(Script)/g);

alert( result[0] ); // JavaScript
alert( result.length ); // 1
        
      
      
      

Si no hay coincidencias, no importa si tiene la bandera g o no,  retorna null .
Esto es algo muy importante. Si no hay coincidencias, no vamos a obtener un array vacío, pero sí un null. Es fácil cometer un error olvidándolo, ej.:

      
        
        
          
            
          
          
            
          
        
        
          let str = "I love JavaScript";

let result = str.match(/HTML/);

alert(result); // null
alert(result.length); // Error: Cannot read property 'length' of null
        
      
      
      Si queremos que el resultado sea un array, podemos escribirlo así:

      
        
        
          let result = str.match(regexp) || [];
        
      
      
      

str.matchAll(regexp)
            Una adición reciente
            
            Esta es una adición reciente al lenguaje.
            Los navegadores antiguos pueden necesitar polyfills.
            
El método str.matchAll(regexp) es una variante (“nueva y mejorada”) de str.match.
Es usado principalmente para buscar por todas las coincidencias con todos los grupos.
Hay 3 diferencias con match:

Retorna un objeto iterable con las coincidencias en lugar de un array. Podemos convertirlo en un array usando el método Array.from.
Cada coincidencia es retornada como un array con los grupos capturados (el mismo formato de str.match sin la bandera g).
Si no hay resultados devuelve un objeto iterable vacío en lugar de null.

Ejemplo de uso:

      
        
        
          
            
          
          
            
          
        
        
          let str = '<h1>Hello, world!</h1>';
let regexp = /<(.*?)>/g;

let matchAll = str.matchAll(regexp);

alert(matchAll); // [object RegExp String Iterator], no es un array, pero sí un objeto iterable

matchAll = Array.from(matchAll); // ahora es un array

let firstMatch = matchAll[0];
alert( firstMatch[0] );  // <h1>
alert( firstMatch[1] );  // h1
alert( firstMatch.index );  // 0
alert( firstMatch.input );  // <h1>Hello, world!</h1>
        
      
      
      Si usamos for..of para iterar todas las coincidencias de matchAll, no necesitamos Array.from.
str.split(regexp|substr, limit)Divide la cadena usando la expresión regular (o una sub-cadena) como delimitador.
Podemos usar split con cadenas, así:

      
        
        
          
            
          
          
            
          
        
        
          alert('12-34-56'.split('-')) // array de ['12', '34', '56']
        
      
      
      O también dividir una cadena usando una expresión regular de la misma forma:

      
        
        
          
            
          
          
            
          
        
        
          alert('12, 34, 56'.split(/,\s*/)) // array de ['12', '34', '56']
        
      
      
      str.search(regexp)El método str.search(regexp) retorna la posición de la primera coincidencia o -1 si no encuentra nada:

      
        
        
          
            
          
          
            
          
        
        
          let str = "A drop of ink may make a million think";

alert( str.search( /ink/i ) ); // 10 (posición de la primera coincidencia)
        
      
      
      Limitación importante: search solamente encuentra la primera coincidencia.
Si necesitamos las posiciones de las demás coincidencias, deberíamos usar otros medios, como encontrar todos con str.matchAll(regexp).
str.replace(str|regexp, str|func)Este es un método genérico para buscar y reemplazar, uno de los más útiles. La navaja suiza para buscar y reemplazar.
Podemos usarlo sin expresiones regulares, para buscar y reemplazar una sub-cadena:

      
        
        
          
            
          
          
            
          
        
        
          // reemplazar guion por dos puntos
alert('12-34-56'.replace("-", ":")) // 12:34-56
        
      
      
      Sin embargo hay una trampa:
Cuando el primer argumento de replace es una cadena, solo reemplaza la primera coincidencia.
Puedes ver eso en el ejemplo anterior: solo el primer "-" es reemplazado por ":".
Para encontrar todos los guiones, no necesitamos usar un cadena "-" sino una expresión regular /-/g con la bandera g obligatoria:

      
        
        
          
            
          
          
            
          
        
        
          // reemplazar todos los guiones por dos puntos
alert( '12-34-56'.replace( /-/g, ":" ) )  // 12:34:56
        
      
      
      El segundo argumento es la cadena de reemplazo. Podemos usar caracteres especiales:



Símbolos
Acción en la cadena de reemplazo




$&
inserta toda la coincidencia


$`
inserta una parte de la cadena antes de la coincidencia


$'
inserta una parte de la cadena después de la coincidencia


$n
si n es un número, inserta el contenido del enésimo grupo capturado, para más detalles ver Grupos de captura


$<nombre>
inserta el contenido de los paréntesis con el nombre dado, para más detalles ver Grupos de captura


$$
inserta el carácter $



Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let str = "John Smith";

// intercambiar el nombre con el apellido
alert(str.replace(/(john) (smith)/i, '$2, $1')) // Smith, John
        
      
      
      Para situaciones que requieran reemplazos “inteligentes”, el segundo argumento puede ser una función.
Puede ser llamado por cada coincidencia y el valor retornado puede ser insertado como un reemplazo.
La función es llamada con los siguientes argumentos func(match, p1, p2, ..., pn, offset, input, groups):

match – la coincidencia,
p1, p2, ..., pn – contenido de los grupos capturados (si hay alguno),
offset – posición de la coincidencia,
input – la cadena de entrada,
groups – un objeto con los grupos nombrados.

Si hay paréntesis en la expresión regular, entonces solo son 3 argumentos: func(str, offset, input).
Por ejemplo, hacer mayúsculas todas las coincidencias:

      
        
        
          
            
          
          
            
          
        
        
          let str = "html and css";

let result = str.replace(/html|css/gi, str => str.toUpperCase());

alert(result); // HTML and CSS
        
      
      
      Reemplazar cada coincidencia por su posición en la cadena:

      
        
        
          
            
          
          
            
          
        
        
          alert("Ho-Ho-ho".replace(/ho/gi, (match, offset) => offset)); // 0-3-6
        
      
      
      En el ejemplo anterior hay dos paréntesis, entonces la función de reemplazo es llamada con 5 argumentos: el primero es toda la coincidencia, luego dos paréntesis, y después (no usado en el ejemplo) la posición de la coincidencia y la cadena de entrada:

      
        
        
          
            
          
          
            
          
        
        
          let str = "John Smith";

let result = str.replace(/(\w+) (\w+)/, (match, name, surname) => `${surname}, ${name}`);

alert(result); // Smith, John
        
      
      
      Si hay muchos grupos, es conveniente usar parámetros rest para acceder a ellos:

      
        
        
          
            
          
          
            
          
        
        
          let str = "John Smith";

let result = str.replace(/(\w+) (\w+)/, (...match) => `${match[2]}, ${match[1]}`);

alert(result); // Smith, John
        
      
      
      O, si estamos usando grupos nombrados, entonces el objeto groups con ellos es siempre el último, por lo que podemos obtenerlos así:

      
        
        
          
            
          
          
            
          
        
        
          let str = "John Smith";

let result = str.replace(/(?<name>\w+) (?<surname>\w+)/, (...match) => {
  let groups = match.pop();

  return `${groups.surname}, ${groups.name}`;
});

alert(result); // Smith, John
        
      
      
      Usando una función nos da todo el poder del reemplazo, porque obtiene toda la información de la coincidencia, ya que tiene acceso a las variables externas y se puede hacer de todo.
str.replaceAll(str|regexp, str|func)Este método es esencialmente el mismo que str.replace, con dos diferencias principales:

Si el primer argumento es un string, reemplaza todas las ocurrencias del string, mientras qye replace solamente reemplaza la primera ocurrencia.
Si el primer argumento es una expresión regular sin la bandera g, funciona igual que replace.

El caso de uso principal para replaceAll es el reemplazo de todas las ocurrencias de un string.
Como esto:

      
        
        
          
            
          
          
            
          
        
        
          // reemplaza todos los guiones por dos puntos
alert('12-34-56'.replaceAll("-", ":")) // 12:34:56
        
      
      
      regexp.exec(str)El método regexp.exec(str) retorna una coincidencia por expresión regular regexp en la cadena str. A diferencia de los métodos anteriores, se llama en una expresión regular en lugar de en una cadena.
Se comporta de manera diferente dependiendo de si la expresión regular tiene la bandera g o no.
Si no está la bandera g, entonces regexp.exec(str) retorna la primera coincidencia igual que str.match(regexp). Este comportamiento no trae nada nuevo.
Pero si está la bandera g, entonces:

Una llamada a regexp.exec(str) retorna la primera coincidencia y guarda la posición inmediatamente después en regexp.lastIndex.
La siguiente llamada de la búsqueda comienza desde la posición de regexp.lastIndex, retorna la siguiente coincidencia y guarda la posición inmediatamente después en regexp.lastIndex.
…y así sucesivamente.
Si no hay coincidencias, regexp.exec retorna null y resetea regexp.lastIndex a 0.

Entonces, repetidas llamadas retornan todas las coincidencias una tras otra, usando la propiedad regexp.lastIndex para realizar el rastreo de la posición actual de la búsqueda.
En el pasado, antes de que el método str.matchAll fuera agregado a JavaScript, se utilizaban llamadas de regexp.exec en el ciclo para obtener todas las coincidencias con sus grupos:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'More about JavaScript at https://javascript.info';
let regexp = /javascript/ig;

let result;

while (result = regexp.exec(str)) {
  alert( `Se encontró ${result[0]} en la posición ${result.index}` );
  // Se encontró JavaScript en la posición 11, luego
  // Se encontró javascript en la posición 33
}
        
      
      
      Esto también funciona, aunque para navegadores modernos str.matchAll usualmente es lo más conveniente.
Podemos usar regexp.exec para buscar desde una posición dada configurando manualmente el lastIndex.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Hello, world!';

let regexp = /\w+/g; // sin la bandera "g", la propiedad `lastIndex` es ignorada
regexp.lastIndex = 5; // buscar desde la 5ta posición (desde la coma)

alert( regexp.exec(str) ); // world
        
      
      
      Si la expresión regular tiene la bandera y, entonces la búsqueda se realizará exactamente en la posición del regexp.lastIndex, no más adelante.
Vamos a reemplazar la bandera g con y en el ejemplo anterior. No habrá coincidencias, ya que no hay palabra en la posición 5:

      
        
        
          
            
          
          
            
          
        
        
          let str = 'Hello, world!';

let regexp = /\w+/y;
regexp.lastIndex = 5; // buscar exactamente en la posición 5

alert( regexp.exec(str) ); // null
        
      
      
      Esto es conveniente cuando con una expresión regular necesitamos “leer” algo de la cadena en una posición exacta, no en otro lugar.
regexp.test(str)El método regexp.test(str) busca por una coincidencia y retorna true/false si existe.
Por ejemplo:

      
        
        
          
            
          
          
            
          
        
        
          let str = "I love JavaScript";

// estas dos pruebas hacen lo mismo
alert( /love/i.test(str) ); // true
alert( str.search(/love/i) != -1 ); // true
        
      
      
      Un ejemplo con respuesta negativa:

      
        
        
          
            
          
          
            
          
        
        
          let str = "Bla-bla-bla";

alert( /love/i.test(str) ); // false
alert( str.search(/love/i) != -1 ); // false
        
      
      
      Si la expresión regular tiene la bandera g, el método regexp.test busca la propiedad regexp.lastIndex y la actualiza, igual que regexp.exec.
Entonces podemos usarlo para buscar desde un posición dada:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /love/gi;

let str = "I love JavaScript";

// comienza la búsqueda desde la posición 10:
regexp.lastIndex = 10;
alert( regexp.test(str) ); // false (sin coincidencia)
        
      
      
      
            La misma expresión regular probada (de manera global) repetidamente en diferentes lugares puede fallar
            Si nosotros aplicamos la misma expresión regular (de manera global) a diferentes entradas, puede causar resultados incorrectos, porque regexp.test anticipa las llamadas usando la propiedad regexp.lastIndex, por lo que la búsqueda en otra cadena puede comenzar desde una posición distinta a cero.
Por ejemplo, aquí llamamos regexp.test dos veces en el mismo texto y en la segunda vez falla:

      
        
        
          
            
          
          
            
          
        
        
          let regexp = /javascript/g;  // (expresión regular creada: regexp.lastIndex=0)

alert( regexp.test("javascript") ); // true (ahora regexp.lastIndex es 10)
alert( regexp.test("javascript") ); // false
        
      
      
      Eso es porque regexp.lastIndex no es cero en la segunda prueba.
Para solucionarlo, podemos establecer regexp.lastIndex = 0 antes de cada búsqueda. O en lugar de llamar a los métodos en la expresión regular usar los métodos de cadena str.match/search/..., ellos no usan el lastIndex.

",
	"url": "https://es.javascript.info/regexp-methods" 
},
{
	"docs_id": "179",
	"name": "",
	"description": "Aquí aprenderemos JavaScript, empezando desde cero y llegaremos hasta conceptos avanzados como POO.",
	"content": "Parte 1El lenguaje JavaScriptParte 2El navegador: Documentos, Eventos e InterfacesParte 3Artículos adicionalesEl lenguaje JavaScriptAquí aprenderemos JavaScript, empezando desde cero y llegaremos hasta conceptos avanzados como POO.
Nos concentraremos en el lenguaje mismo con el mínimo de notas específicas del entorno.
Una introducciónUna introducción a JavaScriptManuales y especificacionesEditores de CódigoConsola de desarrolladorFundamentos de JavaScript¡Hola, mundo!Estructura del códigoEl modo moderno, "use strict"VariablesTipos de datosInteracción: alert, prompt, confirmConversiones de TiposOperadores básicos, matemáticasComparacionesEjecución condicional: if, '?'Operadores LógicosOperador Nullish Coalescing '??'Bucles: while y forLa sentencia "switch"FuncionesExpresiones de funciónFunciones Flecha, lo básicoEspeciales JavaScriptMás…Calidad del códigoDebugging en el navegadorEstilo de codificaciónComentariosCódigo ninjaTest automatizados con MochaPolyfills y transpiladoresObjetos: lo básicoObjetosReferencias de objetos y copiaRecolección de basuraMétodos del objeto, "this"Constructor, operador "new"Encadenamiento opcional '?.'Tipo SymbolConversión de objeto a valor primitivoTipos de datosMétodos en tipos primitivosNúmerosStringsArraysMétodos de arraysIterablesMap y SetWeakMap y WeakSetObject.keys, values, entriesAsignación desestructuranteFecha y HoraMétodos JSON, toJSONMás…Trabajo avanzado con funcionesRecursión y pilaParámetros Rest y operador SpreadÁmbito de Variable y el concepto "closure"La vieja "var"Objeto GlobalFunción como objeto, NFELa sintaxis "new Function"Planificación: setTimeout y setIntervalDecoradores y redirecciones, call/applyFunción bind: vinculación de funcionesFunciones de flecha revisadasMás…Configuración de las propiedades de objetosIndicadores y descriptores de propiedad"Getters" y "setters" de propiedadPrototipos y herenciaHerencia prototípicaF.prototypePrototipos nativosMétodos prototipo, objetos sin __proto__ClasesSintaxis básica de `class`Herencia de clasePropiedades y métodos estáticos.Propiedades y métodos privados y protegidos.Ampliación de clases integradasComprobación de clase: "instanceof"Los MixinsManejo de erroresManejo de errores, "try...catch"Errores personalizados, extendiendo ErrorPromesas y async/awaitIntroducción: callbacksPromesaEncadenamiento de promesasManejo de errores con promesasPromise APIPromisificaciónMicrotareas (Microtasks)Async/awaitGeneradores e iteración avanzadaGeneradoresIteradores y generadores asíncronosMódulosMódulos, introducciónExport e ImportImportaciones dinámicasTemas diversosProxy y ReflectEval: ejecutando una cadena de códigoCurrificaciónTipo de ReferenciaBigIntEl navegador: Documentos, Eventos e InterfacesAprenderemos a manejar la página del navegador: agregar elementos, manipular su tamaño y posición, crear interfaces dinámicamente e interactuar con el visitante.
DocumentoEntorno del navegador, especificacionesÁrbol del Modelo de Objetos del Documento (DOM)Recorriendo el DOMBuscar: getElement*, querySelector*Propiedades del nodo: tipo, etiqueta y contenidoAtributos y propiedadesModificando el documentoEstilos y clasesTamaño de elementos y desplazamientoTamaño de ventana y desplazamientoCoordenadasMás…Introducción a los eventosIntroducción a los eventos en el navegadorPropagación y capturaDelegación de eventosAcciones predeterminadas del navegadorEnvío de eventos personalizadosEventos en la UIEventos del MouseMoviendo el mouse: mouseover/out, mouseenter/leaveArrastrar y Soltar con eventos del ratónEventos de punteroTeclado: keydown y keyupDesplazamientoFormularios y controlesPropiedades y Métodos de FormulariosEnfocado: enfoque/desenfoqueEventos: change, input, cut, copy, pasteFormularios: evento y método submitEl documento y carga de recursosPágina: DOMContentLoaded, load, beforeunload, unloadScripts: async, deferCarga de recursos: onload y onerrorTemas diversosMutation observerSelection y RangeLoop de eventos: microtareas y macrotareasArtículos adicionalesLista de temas adicionales que supone que ha cubierto las dos primeras partes del tutorial. Aquí no hay una jerarquía clara, puede leer los artículos en el orden que desee.Marcos y ventanasVentanas emergentes y métodos de ventanaComunicación entre ventanasEl ataque de secuestro de clicsDatos binarios y archivosArrayBuffer, arrays binariosTextDecoder y TextEncoderBlobFile y FileReaderSolicitudes de redFetchFormDataFetch: Progreso de la descargaFetch: AbortFetch: Cross-Origin RequestsFetch APIObjetos URLXMLHttpRequestCarga de archivos reanudableSondeo largoWebSocketEventos enviados por el servidorMás…Almacenando datos en el navegadorCookies, document.cookieLocalStorage, sessionStorageIndexedDBAnimacionesCurva de BézierAnimaciones CSSAnimaciones JavaScriptComponentes WebDesde la altura orbitalElementos personalizadosShadow DOMElemento templateShadow DOM slots, composiciónEstilo Shadow DOMShadow DOM y eventosExpresiones RegularesPatrones y banderas (flags)Clases de caracteresUnicode: bandera "u" y clase \p{...}Anclas: inicio ^ y final $ de cadenaModo multilínea de anclas ^ $, bandera "m"Límite de palabra: \bEscapando, caracteres especialesConjuntos y rangos [...]Cuantificadores +, *, ? y {n}Cuantificadores codiciosos y perezososGrupos de capturaReferencias inversas en patrones: \N y \k<nombre>Alternancia (O) |Lookahead y lookbehind (revisar delante/detrás)Backtracking catastróficoIndicador adhesivo “y”, buscando en una posición.Métodos de RegExp y StringMás…{
  "@context": "http://schema.org",
  "@type": "WebSite",
  "url": "https://es.javascript.info/",
  "potentialAction": {
    "@type": "SearchAction",
    "target": "https://es.javascript.info/search?query={search_term_string}",
    "query-input": "required name=search_term_string"
  }
}",
	"url": "https://es.javascript.info#" 
},
